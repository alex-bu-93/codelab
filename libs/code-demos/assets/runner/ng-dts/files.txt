[
  {
    "paths": [
      "node_modules/@angular/core/index.d.ts",
      "node_modules/@angular/core/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { Observable } from 'rxjs';\nimport { Subject } from 'rxjs';\nimport { Subscribable } from 'rxjs';\nimport { Subscription } from 'rxjs';\n\n/**\n * @description\n *\n * Represents an abstract class `T`, if applied to a concrete class it would stop being\n * instantiable.\n *\n * @publicApi\n */\nexport declare interface AbstractType<T> extends Function {\n    prototype: T;\n}\n\n/**\n * @description\n * A lifecycle hook that is called after the default change detector has\n * completed checking all content of a directive.\n *\n * @see `AfterViewChecked`\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own after-check functionality.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}\n *\n * @publicApi\n */\nexport declare interface AfterContentChecked {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has completed checking all of the directive's\n     * content.\n     */\n    ngAfterContentChecked(): void;\n}\n\n/**\n * @description\n * A lifecycle hook that is called after Angular has fully initialized\n * all content of a directive.\n * Define an `ngAfterContentInit()` method to handle any additional initialization tasks.\n *\n * @see `OnInit`\n * @see `AfterViewInit`\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own content initialization method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}\n *\n * @publicApi\n */\nexport declare interface AfterContentInit {\n    /**\n     * A callback method that is invoked immediately after\n     * Angular has completed initialization of all of the directive's\n     * content.\n     * It is invoked only once when the directive is instantiated.\n     */\n    ngAfterContentInit(): void;\n}\n\n/**\n * @description\n * A lifecycle hook that is called after the default change detector has\n * completed checking a component's view for changes.\n *\n * @see `AfterContentChecked`\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own after-check functionality.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}\n *\n * @publicApi\n */\nexport declare interface AfterViewChecked {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has completed one change-check cycle\n     * for a component's view.\n     */\n    ngAfterViewChecked(): void;\n}\n\n/**\n * @description\n * A lifecycle hook that is called after Angular has fully initialized\n * a component's view.\n * Define an `ngAfterViewInit()` method to handle any additional initialization tasks.\n *\n * @see `OnInit`\n * @see `AfterContentInit`\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own view initialization method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}\n *\n * @publicApi\n */\nexport declare interface AfterViewInit {\n    /**\n     * A callback method that is invoked immediately after\n     * Angular has completed initialization of a component's view.\n     * It is invoked only once when the view is instantiated.\n     *\n     */\n    ngAfterViewInit(): void;\n}\n\n/**\n * A DI token that you can use to create a virtual [provider](guide/glossary#provider)\n * that will populate the `entryComponents` field of components and NgModules\n * based on its `useValue` property value.\n * All components that are referenced in the `useValue` value (either directly\n * or in a nested array or map) are added to the `entryComponents` property.\n *\n * @usageNotes\n *\n * The following example shows how the router can populate the `entryComponents`\n * field of an NgModule based on a router configuration that refers\n * to components.\n *\n * ```typescript\n * // helper function inside the router\n * function provideRoutes(routes) {\n *   return [\n *     {provide: ROUTES, useValue: routes},\n *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\n *   ];\n * }\n *\n * // user code\n * let routes = [\n *   {path: '/root', component: RootComp},\n *   {path: '/teams', component: TeamsComp}\n * ];\n *\n * @NgModule({\n *   providers: [provideRoutes(routes)]\n * })\n * class ModuleWithRoutes {}\n * ```\n *\n * @publicApi\n * @deprecated Since 9.0.0. With Ivy, this property is no longer necessary.\n */\nexport declare const ANALYZE_FOR_ENTRY_COMPONENTS: InjectionToken<any>;\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates which animations\n * module has been loaded.\n * @publicApi\n */\nexport declare const ANIMATION_MODULE_TYPE: InjectionToken<\"NoopAnimations\" | \"BrowserAnimations\">;\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that provides a set of callbacks to\n * be called for every component that is bootstrapped.\n *\n * Each callback must take a `ComponentRef` instance and return nothing.\n *\n * `(componentRef: ComponentRef) => void`\n *\n * @publicApi\n */\nexport declare const APP_BOOTSTRAP_LISTENER: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") representing a unique string ID, used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\n *\n * BY default, the value is randomly generated and assigned to the application by Angular.\n * To provide a custom ID value, use a DI provider <!-- TODO: provider --> to configure\n * the root {@link Injector} that uses this token.\n *\n * @publicApi\n */\nexport declare const APP_ID: InjectionToken<string>;\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that you can use to provide\n * one or more initialization functions.\n *\n * The provided functions are injected at application startup and executed during\n * app initialization. If any of these functions returns a Promise or an Observable, initialization\n * does not complete until the Promise is resolved or the Observable is completed.\n *\n * You can, for example, create a factory function that loads language data\n * or an external configuration, and provide that function to the `APP_INITIALIZER` token.\n * The function is executed during the application bootstrap process,\n * and the needed data is available on startup.\n *\n * @see `ApplicationInitStatus`\n *\n * @usageNotes\n *\n * The following example illustrates how to configure a multi-provider using `APP_INITIALIZER` token\n * and a function returning a promise.\n *\n * ```\n *  function initializeApp(): Promise<any> {\n *    return new Promise((resolve, reject) => {\n *      // Do some asynchronous stuff\n *      resolve();\n *    });\n *  }\n *\n *  @NgModule({\n *   imports: [BrowserModule],\n *   declarations: [AppComponent],\n *   bootstrap: [AppComponent],\n *   providers: [{\n *     provide: APP_INITIALIZER,\n *     useFactory: () => initializeApp,\n *     multi: true\n *    }]\n *   })\n *  export class AppModule {}\n * ```\n *\n * It's also possible to configure a multi-provider using `APP_INITIALIZER` token and a function\n * returning an observable, see an example below. Note: the `HttpClient` in this example is used for\n * demo purposes to illustrate how the factory function can work with other providers available\n * through DI.\n *\n * ```\n *  function initializeAppFactory(httpClient: HttpClient): () => Observable<any> {\n *   return () => httpClient.get(\"https://someUrl.com/api/user\")\n *     .pipe(\n *        tap(user => { ... })\n *     );\n *  }\n *\n *  @NgModule({\n *    imports: [BrowserModule, HttpClientModule],\n *    declarations: [AppComponent],\n *    bootstrap: [AppComponent],\n *    providers: [{\n *      provide: APP_INITIALIZER,\n *      useFactory: initializeAppFactory,\n *      deps: [HttpClient],\n *      multi: true\n *    }]\n *  })\n *  export class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare const APP_INITIALIZER: InjectionToken<readonly (() => Observable<unknown> | Promise<unknown> | void)[]>;\n\ndeclare function _appIdRandomProviderFactory(): string;\n\n/**\n * A class that reflects the state of running {@link APP_INITIALIZER} functions.\n *\n * @publicApi\n */\nexport declare class ApplicationInitStatus {\n    private readonly appInits;\n    private resolve;\n    private reject;\n    private initialized;\n    readonly donePromise: Promise<any>;\n    readonly done = false;\n    constructor(appInits: ReadonlyArray<() => Observable<unknown> | Promise<unknown> | void>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationInitStatus, [{ optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ApplicationInitStatus>;\n}\n\n/**\n * Re-exported by `BrowserModule`, which is included automatically in the root\n * `AppModule` when you create a new app with the CLI `new` command. Eagerly injects\n * `ApplicationRef` to instantiate it.\n *\n * @publicApi\n */\nexport declare class ApplicationModule {\n    constructor(appRef: ApplicationRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<ApplicationModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<ApplicationModule>;\n}\n\n/**\n * A reference to an Angular application running on a page.\n *\n * @usageNotes\n *\n * {@a is-stable-examples}\n * ### isStable examples and caveats\n *\n * Note two important points about `isStable`, demonstrated in the examples below:\n * - the application will never be stable if you start any kind\n * of recurrent asynchronous task when the application starts\n * (for example for a polling process, started with a `setInterval`, a `setTimeout`\n * or using RxJS operators like `interval`);\n * - the `isStable` Observable runs outside of the Angular zone.\n *\n * Let's imagine that you start a recurrent task\n * (here incrementing a counter, using RxJS `interval`),\n * and at the same time subscribe to `isStable`.\n *\n * ```\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *      filter(stable => stable)\n *   ).subscribe(() => console.log('App is stable now');\n *   interval(1000).subscribe(counter => console.log(counter));\n * }\n * ```\n * In this example, `isStable` will never emit `true`,\n * and the trace \"App is stable now\" will never get logged.\n *\n * If you want to execute something when the app is stable,\n * you have to wait for the application to be stable\n * before starting your polling process.\n *\n * ```\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     tap(stable => console.log('App is stable now')),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => console.log(counter));\n * }\n * ```\n * In this example, the trace \"App is stable now\" will be logged\n * and then the counter starts incrementing every second.\n *\n * Note also that this Observable runs outside of the Angular zone,\n * which means that the code in the subscription\n * to this Observable will not trigger the change detection.\n *\n * Let's imagine that instead of logging the counter value,\n * you update a field of your component\n * and display it in its template.\n *\n * ```\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => this.value = counter);\n * }\n * ```\n * As the `isStable` Observable runs outside the zone,\n * the `value` field will be updated properly,\n * but the template will not be refreshed!\n *\n * You'll have to manually trigger the change detection to update the template.\n *\n * ```\n * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => {\n *     this.value = counter;\n *     cd.detectChanges();\n *   });\n * }\n * ```\n *\n * Or make the subscription callback run inside the zone.\n *\n * ```\n * constructor(appRef: ApplicationRef, zone: NgZone) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => zone.run(() => this.value = counter));\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class ApplicationRef {\n    private _zone;\n    private _injector;\n    private _exceptionHandler;\n    private _views;\n    private _runningTick;\n    private _stable;\n    private _onMicrotaskEmptySubscription;\n    private _destroyed;\n    private _destroyListeners;\n    /**\n     * Indicates whether this instance was destroyed.\n     */\n    get destroyed(): boolean;\n    /**\n     * Get a list of component types registered to this application.\n     * This list is populated even before the component is created.\n     */\n    readonly componentTypes: Type<any>[];\n    /**\n     * Get a list of components registered to this application.\n     */\n    readonly components: ComponentRef<any>[];\n    /**\n     * Returns an Observable that indicates when the application is stable or unstable.\n     *\n     * @see  [Usage notes](#is-stable-examples) for examples and caveats when using this API.\n     */\n    readonly isStable: Observable<boolean>;\n    /**\n     * The `EnvironmentInjector` used to create this application.\n     */\n    get injector(): EnvironmentInjector;\n    /**\n     * Bootstrap a component onto the element identified by its selector or, optionally, to a\n     * specified element.\n     *\n     * @usageNotes\n     * ### Bootstrap process\n     *\n     * When bootstrapping a component, Angular mounts it onto a target DOM element\n     * and kicks off automatic change detection. The target DOM element can be\n     * provided using the `rootSelectorOrNode` argument.\n     *\n     * If the target DOM element is not provided, Angular tries to find one on a page\n     * using the `selector` of the component that is being bootstrapped\n     * (first matched element is used).\n     *\n     * ### Example\n     *\n     * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,\n     * but it requires us to know the component while writing the application code.\n     *\n     * Imagine a situation where we have to wait for an API call to decide about the component to\n     * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to\n     * dynamically bootstrap a component.\n     *\n     * {@example core/ts/platform/platform.ts region='componentSelector'}\n     *\n     * Optionally, a component can be mounted onto a DOM element that does not match the\n     * selector of the bootstrapped component.\n     *\n     * In the following example, we are providing a CSS selector to match the target element.\n     *\n     * {@example core/ts/platform/platform.ts region='cssSelector'}\n     *\n     * While in this example, we are providing reference to a DOM node.\n     *\n     * {@example core/ts/platform/platform.ts region='domNode'}\n     */\n    bootstrap<C>(component: Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;\n    /**\n     * Bootstrap a component onto the element identified by its selector or, optionally, to a\n     * specified element.\n     *\n     * @usageNotes\n     * ### Bootstrap process\n     *\n     * When bootstrapping a component, Angular mounts it onto a target DOM element\n     * and kicks off automatic change detection. The target DOM element can be\n     * provided using the `rootSelectorOrNode` argument.\n     *\n     * If the target DOM element is not provided, Angular tries to find one on a page\n     * using the `selector` of the component that is being bootstrapped\n     * (first matched element is used).\n     *\n     * ### Example\n     *\n     * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,\n     * but it requires us to know the component while writing the application code.\n     *\n     * Imagine a situation where we have to wait for an API call to decide about the component to\n     * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to\n     * dynamically bootstrap a component.\n     *\n     * {@example core/ts/platform/platform.ts region='componentSelector'}\n     *\n     * Optionally, a component can be mounted onto a DOM element that does not match the\n     * selector of the bootstrapped component.\n     *\n     * In the following example, we are providing a CSS selector to match the target element.\n     *\n     * {@example core/ts/platform/platform.ts region='cssSelector'}\n     *\n     * While in this example, we are providing reference to a DOM node.\n     *\n     * {@example core/ts/platform/platform.ts region='domNode'}\n     *\n     * @deprecated Passing Component factories as the `Application.bootstrap` function argument is\n     *     deprecated. Pass Component Types instead.\n     */\n    bootstrap<C>(componentFactory: ComponentFactory<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;\n    /**\n     * Invoke this method to explicitly process change detection and its side-effects.\n     *\n     * In development mode, `tick()` also performs a second change detection cycle to ensure that no\n     * further changes are detected. If additional changes are picked up during this second cycle,\n     * bindings in the app have side-effects that cannot be resolved in a single change detection\n     * pass.\n     * In this case, Angular throws an error, since an Angular application can only have one change\n     * detection pass during which all change detection must complete.\n     */\n    tick(): void;\n    /**\n     * Attaches a view so that it will be dirty checked.\n     * The view will be automatically detached when it is destroyed.\n     * This will throw if the view is already attached to a ViewContainer.\n     */\n    attachView(viewRef: ViewRef): void;\n    /**\n     * Detaches a view from dirty checking again.\n     */\n    detachView(viewRef: ViewRef): void;\n    private _loadComponent;\n    /**\n     * Destroys an Angular application represented by this `ApplicationRef`. Calling this function\n     * will destroy the associated environment injectors as well as all the bootstrapped components\n     * with their views.\n     */\n    destroy(): void;\n    /**\n     * Returns the number of attached views.\n     */\n    get viewCount(): number;\n    private warnIfDestroyed;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationRef, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ApplicationRef>;\n}\n\n/**\n * @publicApi\n */\nexport declare function asNativeElements(debugEls: DebugElement[]): any;\n\n/**\n * Checks that there is currently a platform that contains the given token as a provider.\n *\n * @publicApi\n */\nexport declare function assertPlatform(requiredToken: any): PlatformRef;\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport declare interface Attribute {\n    /**\n     * The name of the attribute whose value can be injected.\n     */\n    attributeName: string;\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Attribute: AttributeDecorator;\n\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface AttributeDecorator {\n    /**\n     * Parameter decorator for a directive constructor that designates\n     * a host-element attribute whose value is injected as a constant string literal.\n     *\n     * @usageNotes\n     *\n     * Suppose we have an `<input>` element and want to know its `type`.\n     *\n     * ```html\n     * <input type=\"text\">\n     * ```\n     *\n     * The following example uses the decorator to inject the string literal `text` in a directive.\n     *\n     * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n     *\n     * The following example uses the decorator in a component constructor.\n     *\n     * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n     *\n     */\n    (name: string): any;\n    new (name: string): Attribute;\n}\n\n/**\n * Provides additional options to the bootstrapping process.\n *\n * @publicApi\n */\nexport declare interface BootstrapOptions {\n    /**\n     * Optionally specify which `NgZone` should be used.\n     *\n     * - Provide your own `NgZone` instance.\n     * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\n     * - `noop` - Use `NoopNgZone` which does nothing.\n     */\n    ngZone?: NgZone | 'zone.js' | 'noop';\n    /**\n     * Optionally specify coalescing event change detections or not.\n     * Consider the following case.\n     *\n     * <div (click)=\"doSomething()\">\n     *   <button (click)=\"doSomethingElse()\"></button>\n     * </div>\n     *\n     * When button is clicked, because of the event bubbling, both\n     * event handlers will be called and 2 change detections will be\n     * triggered. We can coalesce such kind of events to only trigger\n     * change detection only once.\n     *\n     * By default, this option will be false. So the events will not be\n     * coalesced and the change detection will be triggered multiple times.\n     * And if this option be set to true, the change detection will be\n     * triggered async by scheduling a animation frame. So in the case above,\n     * the change detection will only be triggered once.\n     */\n    ngZoneEventCoalescing?: boolean;\n    /**\n     * Optionally specify if `NgZone#run()` method invocations should be coalesced\n     * into a single change detection.\n     *\n     * Consider the following case.\n     *\n     * for (let i = 0; i < 10; i ++) {\n     *   ngZone.run(() => {\n     *     // do something\n     *   });\n     * }\n     *\n     * This case triggers the change detection multiple times.\n     * With ngZoneRunCoalescing options, all change detections in an event loop trigger only once.\n     * In addition, the change detection executes in requestAnimation.\n     *\n     */\n    ngZoneRunCoalescing?: boolean;\n}\n\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nexport declare enum ChangeDetectionStrategy {\n    /**\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n     * Change detection can still be explicitly invoked.\n     * This strategy applies to all child directives and cannot be overridden.\n     */\n    OnPush = 0,\n    /**\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\n     * explicitly deactivated.\n     */\n    Default = 1\n}\n\ndeclare type ChangeDetectionStrategy_2 = number;\n\n/**\n * Base class that provides change detection functionality.\n * A change-detection tree collects all views that are to be checked for changes.\n * Use the methods to add and remove views from the tree, initiate change-detection,\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be re-rendered.\n *\n * @see [Using change detection hooks](guide/lifecycle-hooks#using-change-detection-hooks)\n * @see [Defining custom change detection](guide/lifecycle-hooks#defining-custom-change-detection)\n *\n * @usageNotes\n *\n * The following examples demonstrate how to modify default change-detection behavior\n * to perform explicit detection when needed.\n *\n * ### Use `markForCheck()` with `CheckOnce` strategy\n *\n * The following example sets the `OnPush` change-detection strategy for a component\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\n * after an interval. See [live demo](https://plnkr.co/edit/GC512b?p=preview).\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\"\n * region=\"mark-for-check\"></code-example>\n *\n * ### Detach change detector to limit how often check occurs\n *\n * The following example defines a component with a large list of read-only data\n * that is expected to change constantly, many times per second.\n * To improve performance, we want to check and update the list\n * less often than the changes actually occur. To do that, we detach\n * the component's change detector and perform an explicit local check every five seconds.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"detach\"></code-example>\n *\n *\n * ### Reattaching a detached component\n *\n * The following example creates a component displaying live data.\n * The component detaches its change detector from the main change detector tree\n * when the `live` property is set to false, and reattaches it when the property\n * becomes true.\n *\n * <code-example path=\"core/ts/change_detect/change-detection.ts\" region=\"reattach\"></code-example>\n *\n * @publicApi\n */\nexport declare abstract class ChangeDetectorRef {\n    /**\n     * When a view uses the {@link ChangeDetectionStrategy#OnPush OnPush} (checkOnce)\n     * change detection strategy, explicitly marks the view as changed so that\n     * it can be checked again.\n     *\n     * Components are normally marked as dirty (in need of rerendering) when inputs\n     * have changed or events have fired in the view. Call this method to ensure that\n     * a component is checked even if these triggers have not occurred.\n     *\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\n     *\n     */\n    abstract markForCheck(): void;\n    /**\n     * Detaches this view from the change-detection tree.\n     * A detached view is  not checked until it is reattached.\n     * Use in combination with `detectChanges()` to implement local change detection checks.\n     *\n     * Detached views are not checked during change detection runs until they are\n     * re-attached, even if they are marked as dirty.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     */\n    abstract detach(): void;\n    /**\n     * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach\n     * detach}\n     * to implement local change detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     */\n    abstract detectChanges(): void;\n    /**\n     * Checks the change detector and its children, and throws if any changes are detected.\n     *\n     * Use in development mode to verify that running change detection doesn't introduce\n     * other changes. Calling it in production mode is a noop.\n     */\n    abstract checkNoChanges(): void;\n    /**\n     * Re-attaches the previously detached view to the change detection tree.\n     * Views are attached to the tree by default.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     *\n     */\n    abstract reattach(): void;\n}\n\ndeclare const CHILD_HEAD = 13;\n\ndeclare const CHILD_TAIL = 14;\n\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='ClassProvider'}\n *\n * Note that following two providers are not equal:\n *\n * {@example core/di/ts/provider_spec.ts region='ClassProviderDifference'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport declare interface ClassProvider extends ClassSansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: any;\n    /**\n     * When true, injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return a value by invoking a `useClass` function.\n * Base for `ClassProvider` decorator.\n *\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @publicApi\n */\nexport declare interface ClassSansProvider {\n    /**\n     * Class to instantiate for the `token`.\n     */\n    useClass: Type<any>;\n}\n\ndeclare const CLEANUP = 7;\n\n/**\n * Low-level service for running the angular compiler during runtime\n * to create {@link ComponentFactory}s, which\n * can later be used to create and render a Component instance.\n *\n * Each `@NgModule` provides an own `Compiler` to its injector,\n * that will use the directives/pipes of the ng module for compilation\n * of components.\n *\n * @publicApi\n *\n * @deprecated\n * Ivy JIT mode doesn't require accessing this symbol.\n * See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes) for\n * additional context.\n */\nexport declare class Compiler {\n    /**\n     * Compiles the given NgModule and all of its components. All templates of the components listed\n     * in `entryComponents` have to be inlined.\n     */\n    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;\n    /**\n     * Compiles the given NgModule and all of its components\n     */\n    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;\n    /**\n     * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\n     */\n    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;\n    /**\n     * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\n     */\n    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;\n    /**\n     * Clears all caches.\n     */\n    clearCache(): void;\n    /**\n     * Clears the cache for the given component/ngModule.\n     */\n    clearCacheFor(type: Type<any>): void;\n    /**\n     * Returns the id for a given NgModule, if one is defined and known to the compiler.\n     */\n    getModuleId(moduleType: Type<any>): string | undefined;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Compiler, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Compiler>;\n}\n\n/**\n * Token to provide CompilerOptions in the platform injector.\n *\n * @publicApi\n */\nexport declare const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;\n\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n *\n * @deprecated\n * Ivy JIT mode doesn't require accessing this symbol.\n * See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes) for\n * additional context.\n */\nexport declare abstract class CompilerFactory {\n    abstract createCompiler(options?: CompilerOptions[]): Compiler;\n}\n\n/**\n * Options for creating a compiler.\n *\n * Note: the `useJit` and `missingTranslation` config options are not used in Ivy, passing them has\n * no effect. Those config options are deprecated since v13.\n *\n * @publicApi\n */\nexport declare type CompilerOptions = {\n    /**\n     * @deprecated not used at all in Ivy, providing this config option has no effect.\n     */\n    useJit?: boolean;\n    defaultEncapsulation?: ViewEncapsulation;\n    providers?: StaticProvider[];\n    /**\n     * @deprecated not used at all in Ivy, providing this config option has no effect.\n     */\n    missingTranslation?: MissingTranslationStrategy;\n    preserveWhitespaces?: boolean;\n};\n\n/**\n * Supplies configuration metadata for an Angular component.\n *\n * @publicApi\n */\nexport declare interface Component extends Directive {\n    /**\n     * The change-detection strategy to use for this component.\n     *\n     * When a component is instantiated, Angular creates a change detector,\n     * which is responsible for propagating the component's bindings.\n     * The strategy is one of:\n     * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n     * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n     */\n    changeDetection?: ChangeDetectionStrategy;\n    /**\n     * Defines the set of injectable objects that are visible to its view DOM children.\n     * See [example](#injecting-a-class-with-a-view-provider).\n     *\n     */\n    viewProviders?: Provider[];\n    /**\n     * The module ID of the module that contains the component.\n     * The component must be able to resolve relative URLs for templates and styles.\n     * SystemJS exposes the `__moduleName` variable within each module.\n     * In CommonJS, this can  be set to `module.id`.\n     *\n     */\n    moduleId?: string;\n    /**\n     * The relative path or absolute URL of a template file for an Angular component.\n     * If provided, do not supply an inline template using `template`.\n     *\n     */\n    templateUrl?: string;\n    /**\n     * An inline template for an Angular component. If provided,\n     * do not supply a template file using `templateUrl`.\n     *\n     */\n    template?: string;\n    /**\n     * One or more relative paths or absolute URLs for files containing CSS stylesheets to use\n     * in this component.\n     */\n    styleUrls?: string[];\n    /**\n     * One or more inline CSS stylesheets to use\n     * in this component.\n     */\n    styles?: string[];\n    /**\n     * One or more animation `trigger()` calls, containing\n     * [`state()`](api/animations/state) and `transition()` definitions.\n     * See the [Animations guide](/guide/animations) and animations API documentation.\n     *\n     */\n    animations?: any[];\n    /**\n     * An encapsulation policy for the component's styling.\n     * Possible values:\n     * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n     *                                 a native Shadow DOM CSS encapsulation behavior.\n     * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n     * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n     *\n     * If not supplied, the value is taken from the `CompilerOptions`\n     * which defaults to `ViewEncapsulation.Emulated`.\n     *\n     * If the policy is `ViewEncapsulation.Emulated` and the component has no\n     * {@link Component#styles styles} nor {@link Component#styleUrls styleUrls},\n     * the policy is automatically switched to `ViewEncapsulation.None`.\n     */\n    encapsulation?: ViewEncapsulation;\n    /**\n     * Overrides the default interpolation start and end delimiters (`{{` and `}}`).\n     */\n    interpolation?: [string, string];\n    /**\n     * A set of components that should be compiled along with\n     * this component. For each component listed here,\n     * Angular creates a {@link ComponentFactory} and stores it in the\n     * {@link ComponentFactoryResolver}.\n     * @deprecated Since 9.0.0. With Ivy, this property is no longer necessary.\n     */\n    entryComponents?: Array<Type<any> | any[]>;\n    /**\n     * True to preserve or false to remove potentially superfluous whitespace characters\n     * from the compiled template. Whitespace characters are those matching the `\\s`\n     * character class in JavaScript regular expressions. Default is false, unless\n     * overridden in compiler options.\n     */\n    preserveWhitespaces?: boolean;\n    /**\n     * Angular components marked as `standalone` do not need to be declared in an NgModule. Such\n     * components directly manage their own template dependencies (components, directives, and pipes\n     * used in a template) via the imports property.\n     *\n     * More information about standalone components, directives, and pipes can be found in [this\n     * guide](guide/standalone-components).\n     *\n     * @developerPreview\n     */\n    standalone?: boolean;\n    /**\n     * The imports property specifies the standalone component's template dependencies — those\n     * directives, components, and pipes that can be used within its template. Standalone components\n     * can import other standalone components, directives, and pipes as well as existing NgModules.\n     *\n     * This property is only available for standalone components - specifying it for components\n     * declared in an NgModule generates a compilation error.\n     *\n     * More information about standalone components, directives, and pipes can be found in [this\n     * guide](guide/standalone-components).\n     *\n     * @developerPreview\n     */\n    imports?: (Type<any> | any[])[];\n    /**\n     * The set of schemas that declare elements to be allowed in a standalone component. Elements and\n     * properties that are neither Angular components nor directives must be declared in a schema.\n     *\n     * This property is only available for standalone components - specifying it for components\n     * declared in an NgModule generates a compilation error.\n     *\n     * More information about standalone components, directives, and pipes can be found in [this\n     * guide](guide/standalone-components).\n     */\n    schemas?: SchemaMetadata[];\n}\n\n/**\n * Component decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Component: ComponentDecorator;\n\n/**\n * Component decorator interface\n *\n * @publicApi\n */\nexport declare interface ComponentDecorator {\n    /**\n     * Decorator that marks a class as an Angular component and provides configuration\n     * metadata that determines how the component should be processed,\n     * instantiated, and used at runtime.\n     *\n     * Components are the most basic UI building block of an Angular app.\n     * An Angular app contains a tree of Angular components.\n     *\n     * Angular components are a subset of directives, always associated with a template.\n     * Unlike other directives, only one component can be instantiated for a given element in a\n     * template.\n     *\n     * A component must belong to an NgModule in order for it to be available\n     * to another component or application. To make it a member of an NgModule,\n     * list it in the `declarations` field of the `NgModule` metadata.\n     *\n     * Note that, in addition to these options for configuring a directive,\n     * you can control a component's runtime behavior by implementing\n     * life-cycle hooks. For more information, see the\n     * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n     *\n     * @usageNotes\n     *\n     * ### Setting component inputs\n     *\n     * The following example creates a component with two data-bound properties,\n     * specified by the `inputs` value.\n     *\n     * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\"></code-example>\n     *\n     *\n     * ### Setting component outputs\n     *\n     * The following example shows two event emitters that emit on an interval. One\n     * emits an output every second, while the other emits every five seconds.\n     *\n     * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n     *\n     * ### Injecting a class with a view provider\n     *\n     * The following simple example injects a class into a component\n     * using the view provider specified in component metadata:\n     *\n     * ```ts\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Directive({\n     *   selector: 'needs-greeter'\n     * })\n     * class NeedsGreeter {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'greet',\n     *   viewProviders: [\n     *     Greeter\n     *   ],\n     *   template: `<needs-greeter></needs-greeter>`\n     * })\n     * class HelloWorld {\n     * }\n     *\n     * ```\n     *\n     * ### Preserving whitespace\n     *\n     * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.\n     * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).\n     * To change the default setting for all components in your application, set\n     * the `preserveWhitespaces` option of the AOT compiler.\n     *\n     * By default, the AOT compiler removes whitespace characters as follows:\n     * * Trims all whitespaces at the beginning and the end of a template.\n     * * Removes whitespace-only text nodes. For example,\n     *\n     * ```html\n     * <button>Action 1</button>  <button>Action 2</button>\n     * ```\n     *\n     * becomes:\n     *\n     * ```html\n     * <button>Action 1</button><button>Action 2</button>\n     * ```\n     *\n     * * Replaces a series of whitespace characters in text nodes with a single space.\n     * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n     * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n     * where whitespace characters are significant.\n     *\n     * Note that these transformations can influence DOM nodes layout, although impact\n     * should be minimal.\n     *\n     * You can override the default behavior to preserve whitespace characters\n     * in certain fragments of a template. For example, you can exclude an entire\n     * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n     *\n     * ```html\n     * <div ngPreserveWhitespaces>\n     *     whitespaces are preserved here\n     *     <span>    and here </span>\n     * </div>\n     * ```\n     *\n     * You can force a single space to be preserved in a text node by using `&ngsp;`,\n     * which is replaced with a space character by Angular's template\n     * compiler:\n     *\n     * ```html\n     * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n     * <!-- compiled to be equivalent to:\n     *  <a>Spaces</a> <a>between</a> <a>links.</a>  -->\n     * ```\n     *\n     * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n     * the `preserveWhitespaces` option is set to `false`.\n     *\n     * ```html\n     * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n     * <!-- compiled to be equivalent to:\n     *  <a>before</a> <a>after</a> -->\n     * ```\n     *\n     * To preserve sequences of whitespace characters, use the\n     * `ngPreserveWhitespaces` attribute.\n     *\n     * @Annotation\n     */\n    (obj: Component): TypeDecorator;\n    /**\n     * See the `Component` decorator.\n     */\n    new (obj: Component): Component;\n}\n\ndeclare interface ComponentDefFeature {\n    <T>(componentDef: ɵComponentDef<T>): void;\n    /**\n     * Marks a feature as something that {@link InheritDefinitionFeature} will execute\n     * during inheritance.\n     *\n     * NOTE: DO NOT SET IN ROOT OF MODULE! Doing so will result in tree-shakers/bundlers\n     * identifying the change as a side effect, and the feature will be included in\n     * every bundle.\n     */\n    ngInherit?: true;\n}\n\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\ndeclare abstract class ComponentFactory<C> {\n    /**\n     * The component's HTML selector.\n     */\n    abstract get selector(): string;\n    /**\n     * The type of component the factory will create.\n     */\n    abstract get componentType(): Type<any>;\n    /**\n     * Selector for all <ng-content> elements in the component.\n     */\n    abstract get ngContentSelectors(): string[];\n    /**\n     * The inputs of the component.\n     */\n    abstract get inputs(): {\n        propName: string;\n        templateName: string;\n    }[];\n    /**\n     * The outputs of the component.\n     */\n    abstract get outputs(): {\n        propName: string;\n        templateName: string;\n    }[];\n    /**\n     * Creates a new component.\n     */\n    abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, environmentInjector?: EnvironmentInjector | NgModuleRef<any>): ComponentRef<C>;\n}\nexport { ComponentFactory }\nexport { ComponentFactory as ɵComponentFactory }\n\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * Note: since v13, dynamic component creation via\n * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n * does **not** require resolving component factory: component class can be used directly.\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nexport declare abstract class ComponentFactoryResolver {\n    static NULL: ComponentFactoryResolver;\n    /**\n     * Retrieves the factory object that creates a component of the given type.\n     * @param component The component type.\n     */\n    abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n}\n\ndeclare class ComponentFactoryResolver_2 extends ComponentFactoryResolver {\n    private ngModule?;\n    /**\n     * @param ngModule The NgModuleRef to which all resolved factories are bound.\n     */\n    constructor(ngModule?: NgModuleRef<any> | undefined);\n    resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n}\n\n/**\n * An interface that describes the subset of component metadata\n * that can be retrieved using the `reflectComponentType` function.\n *\n * @publicApi\n */\nexport declare interface ComponentMirror<C> {\n    /**\n     * The component's HTML selector.\n     */\n    get selector(): string;\n    /**\n     * The type of component the factory will create.\n     */\n    get type(): Type<C>;\n    /**\n     * The inputs of the component.\n     */\n    get inputs(): ReadonlyArray<{\n        readonly propName: string;\n        readonly templateName: string;\n    }>;\n    /**\n     * The outputs of the component.\n     */\n    get outputs(): ReadonlyArray<{\n        readonly propName: string;\n        readonly templateName: string;\n    }>;\n    /**\n     * Selector for all <ng-content> elements in the component.\n     */\n    get ngContentSelectors(): ReadonlyArray<string>;\n    /**\n     * Whether this component is marked as standalone.\n     * Note: an extra flag, not present in `ComponentFactory`.\n     */\n    get isStandalone(): boolean;\n}\n\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nexport declare abstract class ComponentRef<C> {\n    /**\n     * Updates a specified input name to a new value. Using this method will properly mark for check\n     * component using the `OnPush` change detection strategy. It will also assure that the\n     * `OnChanges` lifecycle hook runs when a dynamically created component is change-detected.\n     *\n     * @param name The name of an input.\n     * @param value The new value of an input.\n     */\n    abstract setInput(name: string, value: unknown): void;\n    /**\n     * The host or anchor [element](guide/glossary#element) for this component instance.\n     */\n    abstract get location(): ElementRef;\n    /**\n     * The [dependency injector](guide/glossary#injector) for this component instance.\n     */\n    abstract get injector(): Injector;\n    /**\n     * This component instance.\n     */\n    abstract get instance(): C;\n    /**\n     * The [host view](guide/glossary#view-tree) defined by the template\n     * for this component instance.\n     */\n    abstract get hostView(): ViewRef;\n    /**\n     * The change detector for this component instance.\n     */\n    abstract get changeDetectorRef(): ChangeDetectorRef;\n    /**\n     * The type of this component (as created by a `ComponentFactory` class).\n     */\n    abstract get componentType(): Type<any>;\n    /**\n     * Destroys the component instance and all of the data structures associated with it.\n     */\n    abstract destroy(): void;\n    /**\n     * A lifecycle hook that provides additional developer-defined cleanup\n     * functionality for the component.\n     * @param callback A handler function that cleans up developer-defined data\n     * associated with this component. Called when the `destroy()` method is invoked.\n     */\n    abstract onDestroy(callback: Function): void;\n}\n\n/**\n * Definition of what a template rendering function should look like for a component.\n */\ndeclare type ComponentTemplate<T> = {\n    <U extends T>(rf: ɵRenderFlags, ctx: T | U): void;\n};\n\n/**\n * Configures the `Injector` to return an instance of a token.\n *\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport declare interface ConstructorProvider extends ConstructorSansProvider {\n    /**\n     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n     */\n    provide: Type<any>;\n    /**\n     * When true, injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return an instance of a token.\n *\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * ```ts\n * @Injectable(SomeModule, {deps: []})\n * class MyService {}\n * ```\n *\n * @publicApi\n */\nexport declare interface ConstructorSansProvider {\n    /**\n     * A list of `token`s to be resolved by the injector.\n     */\n    deps?: any[];\n}\n\n/**\n * Type of the ContentChild metadata.\n *\n * @publicApi\n */\nexport declare type ContentChild = Query;\n\n/**\n * ContentChild decorator and metadata.\n *\n *\n * @Annotation\n *\n * @publicApi\n */\nexport declare const ContentChild: ContentChildDecorator;\n\n/**\n * Type of the ContentChild decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface ContentChildDecorator {\n    /**\n     * @description\n     * Property decorator that configures a content query.\n     *\n     * Use to get the first element or the directive matching the selector from the content DOM.\n     * If the content DOM changes, and a new child matches the selector,\n     * the property will be updated.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     *\n     * Does not retrieve elements or directives that are in other components' templates,\n     * since a component's template is always a black box to its ancestors.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - The directive type or the name used for querying.\n     * * **descendants** - If `true` (default) include all descendants of the element. If `false` then\n     * only query direct children of the element.\n     * * **read** - Used to read a different token from the queried element.\n     * * **static** - True to resolve query results before change detection runs,\n     * false to resolve after change detection. Defaults to false.\n     *\n     * The following selectors are supported.\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * A template reference variable as a string (e.g. query `<my-component #cmp></my-component>`\n     * with `@ContentChild('cmp')`)\n     *   * Any provider defined in the child component tree of the current component (e.g.\n     * `@ContentChild(SomeService) someService: SomeService`)\n     *   * Any provider defined through a string token (e.g. `@ContentChild('someToken') someTokenVal:\n     * any`)\n     *   * A `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ContentChild(TemplateRef)\n     * template;`)\n     *\n     * The following values are supported by `read`:\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * Any provider defined on the injector of the component that is matched by the `selector` of\n     * this query\n     *   * Any provider defined through a string token (e.g. `{provide: 'token', useValue: 'val'}`)\n     *   * `TemplateRef`, `ElementRef`, and `ViewContainerRef`\n     *\n     * @usageNotes\n     *\n     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\n     *\n     * @Annotation\n     */\n    (selector: ProviderToken<unknown> | Function | string, opts?: {\n        descendants?: boolean;\n        read?: any;\n        static?: boolean;\n    }): any;\n    new (selector: ProviderToken<unknown> | Function | string, opts?: {\n        descendants?: boolean;\n        read?: any;\n        static?: boolean;\n    }): ContentChild;\n}\n\n/**\n * Type of the ContentChildren metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport declare type ContentChildren = Query;\n\n/**\n * ContentChildren decorator and metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nexport declare const ContentChildren: ContentChildrenDecorator;\n\n/**\n * Type of the ContentChildren decorator / constructor function.\n *\n * @see `ContentChildren`.\n * @publicApi\n */\nexport declare interface ContentChildrenDecorator {\n    /**\n     * @description\n     * Property decorator that configures a content query.\n     *\n     * Use to get the `QueryList` of elements or directives from the content DOM.\n     * Any time a child element is added, removed, or moved, the query list will be\n     * updated, and the changes observable of the query list will emit a new value.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     *\n     * Does not retrieve elements or directives that are in other components' templates,\n     * since a component's template is always a black box to its ancestors.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - The directive type or the name used for querying.\n     * * **descendants** - If `true` include all descendants of the element. If `false` then only\n     * query direct children of the element.\n     * * **emitDistinctChangesOnly** - The ` QueryList#changes` observable will emit new values only\n     *   if the QueryList result has changed. When `false` the `changes` observable might emit even\n     *   if the QueryList has not changed.\n     *   ** Note: *** This config option is **deprecated**, it will be permanently set to `true` and\n     *   removed in future versions of Angular.\n     * * **read** - Used to read a different token from the queried elements.\n     *\n     * The following selectors are supported.\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * A template reference variable as a string (e.g. query `<my-component #cmp></my-component>`\n     * with `@ContentChildren('cmp')`)\n     *   * Any provider defined in the child component tree of the current component (e.g.\n     * `@ContentChildren(SomeService) someService: SomeService`)\n     *   * Any provider defined through a string token (e.g. `@ContentChildren('someToken')\n     * someTokenVal: any`)\n     *   * A `TemplateRef` (e.g. query `<ng-template></ng-template>` with\n     * `@ContentChildren(TemplateRef) template;`)\n     *\n     * In addition, multiple string selectors can be separated with a comma (e.g.\n     * `@ContentChildren('cmp1,cmp2')`)\n     *\n     * The following values are supported by `read`:\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * Any provider defined on the injector of the component that is matched by the `selector` of\n     * this query\n     *   * Any provider defined through a string token (e.g. `{provide: 'token', useValue: 'val'}`)\n     *   * `TemplateRef`, `ElementRef`, and `ViewContainerRef`\n     *\n     * @usageNotes\n     *\n     * Here is a simple demonstration of how the `ContentChildren` decorator can be used.\n     *\n     * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}\n     *\n     * ### Tab-pane example\n     *\n     * Here is a slightly more realistic example that shows how `ContentChildren` decorators\n     * can be used to implement a tab pane component.\n     *\n     * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}\n     *\n     * @Annotation\n     */\n    (selector: ProviderToken<unknown> | Function | string, opts?: {\n        descendants?: boolean;\n        emitDistinctChangesOnly?: boolean;\n        read?: any;\n    }): any;\n    new (selector: ProviderToken<unknown> | Function | string, opts?: {\n        descendants?: boolean;\n        emitDistinctChangesOnly?: boolean;\n        read?: any;\n    }): Query;\n}\n\n/**\n * Definition of what a content queries function should look like.\n */\ndeclare type ContentQueriesFunction<T> = <U extends T>(rf: ɵRenderFlags, ctx: U, directiveIndex: number) => void;\n\ndeclare const CONTEXT = 8;\n\n/**\n * Creates a `ComponentRef` instance based on provided component type and a set of options.\n *\n * @usageNotes\n *\n * The example below demonstrates how the `createComponent` function can be used\n * to create an instance of a ComponentRef dynamically and attach it to an ApplicationRef,\n * so that it gets included into change detection cycles.\n *\n * Note: the example uses standalone components, but the function can also be used for\n * non-standalone components (declared in an NgModule) as well.\n *\n * ```typescript\n * @Component({\n *   standalone: true,\n *   template: `Hello {{ name }}!`\n * })\n * class HelloComponent {\n *   name = 'Angular';\n * }\n *\n * @Component({\n *   standalone: true,\n *   template: `<div id=\"hello-component-host\"></div>`\n * })\n * class RootComponent {}\n *\n * // Bootstrap an application.\n * const applicationRef = await bootstrapApplication(RootComponent);\n *\n * // Locate a DOM node that would be used as a host.\n * const host = document.getElementById('hello-component-host');\n *\n * // Get an `EnvironmentInjector` instance from the `ApplicationRef`.\n * const environmentInjector = applicationRef.injector;\n *\n * // We can now create a `ComponentRef` instance.\n * const componentRef = createComponent(HelloComponent, {host, environmentInjector});\n *\n * // Last step is to register the newly created ref using the `ApplicationRef` instance\n * // to include the component view into change detection cycles.\n * applicationRef.attachView(componentRef.hostView);\n * ```\n *\n * @param component Component class reference.\n * @param options Set of options to use:\n *  * `environmentInjector`: An `EnvironmentInjector` instance to be used for the component, see\n * additional info about it at https://angular.io/guide/standalone-components#environment-injectors.\n *  * `hostElement` (optional): A DOM node that should act as a host node for the component. If not\n * provided, Angular creates one based on the tag name used in the component selector (and falls\n * back to using `div` if selector doesn't have tag name info).\n *  * `elementInjector` (optional): An `ElementInjector` instance, see additional info about it at\n * https://angular.io/guide/hierarchical-dependency-injection#elementinjector.\n *  * `projectableNodes` (optional): A list of DOM nodes that should be projected through\n *                      [`<ng-content>`](api/core/ng-content) of the new component instance.\n * @returns ComponentRef instance that represents a given Component.\n *\n * @publicApi\n */\nexport declare function createComponent<C>(component: Type<C>, options: {\n    environmentInjector: EnvironmentInjector;\n    hostElement?: Element;\n    elementInjector?: Injector;\n    projectableNodes?: Node[][];\n}): ComponentRef<C>;\n\n/**\n * Create a new environment injector.\n *\n * Learn more about environment injectors in\n * [this guide](guide/standalone-components#environment-injectors).\n *\n * @param providers An array of providers.\n * @param parent A parent environment injector.\n * @param debugName An optional name for this injector instance, which will be used in error\n *     messages.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function createEnvironmentInjector(providers: Array<Provider | ImportedNgModuleProviders>, parent: EnvironmentInjector, debugName?: string | null): EnvironmentInjector;\n\n/**\n * Returns a new NgModuleRef instance based on the NgModule class and parent injector provided.\n *\n * @param ngModule NgModule class.\n * @param parentInjector Optional injector instance to use as a parent for the module injector. If\n *     not provided, `NullInjector` will be used instead.\n * @returns NgModuleRef that represents an NgModule instance.\n *\n * @publicApi\n */\nexport declare function createNgModule<T>(ngModule: Type<T>, parentInjector?: Injector): NgModuleRef<T>;\n\n/**\n * The `createNgModule` function alias for backwards-compatibility.\n * Please avoid using it directly and use `createNgModule` instead.\n *\n * @deprecated Use `createNgModule` instead.\n */\nexport declare const createNgModuleRef: typeof createNgModule;\n\n/**\n * Creates a platform.\n * Platforms must be created on launch using this function.\n *\n * @publicApi\n */\nexport declare function createPlatform(injector: Injector): PlatformRef;\n\n/**\n * Creates a factory for a platform. Can be used to provide or override `Providers` specific to\n * your application's runtime needs, such as `PLATFORM_INITIALIZER` and `PLATFORM_ID`.\n * @param parentPlatformFactory Another platform factory to modify. Allows you to compose factories\n * to build up configurations that might be required by different libraries or parts of the\n * application.\n * @param name Identifies the new platform factory.\n * @param providers A set of dependency providers for platforms created with the new factory.\n *\n * @publicApi\n */\nexport declare function createPlatformFactory(parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null, name: string, providers?: StaticProvider[]): (extraProviders?: StaticProvider[]) => PlatformRef;\n\n\n/**\n * Expresses a single CSS Selector.\n *\n * Beginning of array\n * - First index: element name\n * - Subsequent odd indices: attr keys\n * - Subsequent even indices: attr values\n *\n * After SelectorFlags.CLASS flag\n * - Class name values\n *\n * SelectorFlags.NOT flag\n * - Changes the mode to NOT\n * - Can be combined with other flags to set the element / attr / class mode\n *\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\n *\n * Example:\n * Original: `div.foo.bar[attr1=val1][attr2]`\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\n *\n * Original: 'div[attr1]:not(.foo[attr2])\n * Parsed: [\n *  'div', 'attr1', '',\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\n * ]\n *\n * See more examples in node_selector_matcher_spec.ts\n */\ndeclare type CssSelector = (string | SelectorFlags)[];\n\n/**\n * An object literal of this type is used to represent the metadata of a constructor dependency.\n * The type itself is never referred to from generated code.\n *\n * @publicApi\n */\ndeclare type CtorDependency = {\n    /**\n     * If an `@Attribute` decorator is used, this represents the injected attribute's name. If the\n     * attribute name is a dynamic expression instead of a string literal, this will be the unknown\n     * type.\n     */\n    attribute?: string | unknown;\n    /**\n     * If `@Optional()` is used, this key is set to true.\n     */\n    optional?: true;\n    /**\n     * If `@Host` is used, this key is set to true.\n     */\n    host?: true;\n    /**\n     * If `@Self` is used, this key is set to true.\n     */\n    self?: true;\n    /**\n     * If `@SkipSelf` is used, this key is set to true.\n     */\n    skipSelf?: true;\n} | null;\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nexport declare const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;\n\n/**\n * @publicApi\n *\n * @see [Component testing scenarios](guide/testing-components-scenarios)\n * @see [Basics of testing components](guide/testing-components-basics)\n * @see [Testing utility APIs](guide/testing-utility-apis)\n */\nexport declare class DebugElement extends DebugNode {\n    constructor(nativeNode: Element);\n    /**\n     * The underlying DOM element at the root of the component.\n     */\n    get nativeElement(): any;\n    /**\n     * The element tag name, if it is an element.\n     */\n    get name(): string;\n    /**\n     *  Gets a map of property names to property values for an element.\n     *\n     *  This map includes:\n     *  - Regular property bindings (e.g. `[id]=\"id\"`)\n     *  - Host property bindings (e.g. `host: { '[id]': \"id\" }`)\n     *  - Interpolated property bindings (e.g. `id=\"{{ value }}\")\n     *\n     *  It does not include:\n     *  - input property bindings (e.g. `[myCustomInput]=\"value\"`)\n     *  - attribute bindings (e.g. `[attr.role]=\"menu\"`)\n     */\n    get properties(): {\n        [key: string]: any;\n    };\n    /**\n     *  A map of attribute names to attribute values for an element.\n     */\n    get attributes(): {\n        [key: string]: string | null;\n    };\n    /**\n     * The inline styles of the DOM element.\n     *\n     * Will be `null` if there is no `style` property on the underlying DOM element.\n     *\n     * @see [ElementCSSInlineStyle](https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style)\n     */\n    get styles(): {\n        [key: string]: string | null;\n    };\n    /**\n     * A map containing the class names on the element as keys.\n     *\n     * This map is derived from the `className` property of the DOM element.\n     *\n     * Note: The values of this object will always be `true`. The class key will not appear in the KV\n     * object if it does not exist on the element.\n     *\n     * @see [Element.className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className)\n     */\n    get classes(): {\n        [key: string]: boolean;\n    };\n    /**\n     * The `childNodes` of the DOM element as a `DebugNode` array.\n     *\n     * @see [Node.childNodes](https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes)\n     */\n    get childNodes(): DebugNode[];\n    /**\n     * The immediate `DebugElement` children. Walk the tree by descending through `children`.\n     */\n    get children(): DebugElement[];\n    /**\n     * @returns the first `DebugElement` that matches the predicate at any depth in the subtree.\n     */\n    query(predicate: Predicate<DebugElement>): DebugElement;\n    /**\n     * @returns All `DebugElement` matches for the predicate at any depth in the subtree.\n     */\n    queryAll(predicate: Predicate<DebugElement>): DebugElement[];\n    /**\n     * @returns All `DebugNode` matches for the predicate at any depth in the subtree.\n     */\n    queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];\n    /**\n     * Triggers the event by its name if there is a corresponding listener in the element's\n     * `listeners` collection.\n     *\n     * If the event lacks a listener or there's some other problem, consider\n     * calling `nativeElement.dispatchEvent(eventObject)`.\n     *\n     * @param eventName The name of the event to trigger\n     * @param eventObj The _event object_ expected by the handler\n     *\n     * @see [Testing components scenarios](guide/testing-components-scenarios#trigger-event-handler)\n     */\n    triggerEventHandler(eventName: string, eventObj?: any): void;\n}\n\n/**\n * @publicApi\n */\nexport declare class DebugEventListener {\n    name: string;\n    callback: Function;\n    constructor(name: string, callback: Function);\n}\n\n/**\n * @publicApi\n */\nexport declare class DebugNode {\n    /**\n     * The underlying DOM node.\n     */\n    readonly nativeNode: any;\n    constructor(nativeNode: Node);\n    /**\n     * The `DebugElement` parent. Will be `null` if this is the root element.\n     */\n    get parent(): DebugElement | null;\n    /**\n     * The host dependency injector. For example, the root element's component instance injector.\n     */\n    get injector(): Injector;\n    /**\n     * The element's own component instance, if it has one.\n     */\n    get componentInstance(): any;\n    /**\n     * An object that provides parent context for this element. Often an ancestor component instance\n     * that governs this element.\n     *\n     * When an element is repeated within *ngFor, the context is an `NgForOf` whose `$implicit`\n     * property is the value of the row instance value. For example, the `hero` in `*ngFor=\"let hero\n     * of heroes\"`.\n     */\n    get context(): any;\n    /**\n     * The callbacks attached to the component's @Output properties and/or the element's event\n     * properties.\n     */\n    get listeners(): DebugEventListener[];\n    /**\n     * Dictionary of objects associated with template local variables (e.g. #foo), keyed by the local\n     * variable name.\n     */\n    get references(): {\n        [key: string]: any;\n    };\n    /**\n     * This component's injector lookup tokens. Includes the component itself plus the tokens that the\n     * component lists in its providers metadata.\n     */\n    get providerTokens(): any[];\n}\n\n/**\n * A logical node which comprise into `LView`s.\n *\n */\ndeclare interface DebugNode_2 {\n    /**\n     * HTML representation of the node.\n     */\n    html: string | null;\n    /**\n     * Associated `TNode`\n     */\n    tNode: TNode;\n    /**\n     * Human readable node type.\n     */\n    type: string;\n    /**\n     * DOM native node.\n     */\n    native: Node;\n    /**\n     * Child nodes\n     */\n    children: DebugNode_2[];\n    /**\n     * A list of Component/Directive types which need to be instantiated an this location.\n     */\n    factories: Type<unknown>[];\n    /**\n     * A list of Component/Directive instances which were instantiated an this location.\n     */\n    instances: unknown[];\n    /**\n     * NodeInjector information.\n     */\n    injector: NodeInjectorDebug;\n    /**\n     * Injector resolution path.\n     */\n    injectorResolutionPath: any;\n}\n\ndeclare const DECLARATION_COMPONENT_VIEW = 16;\n\ndeclare const DECLARATION_LCONTAINER = 17;\n\ndeclare const DECLARATION_VIEW = 15;\n\n/**\n * Provide this token to set the default currency code your application uses for\n * CurrencyPipe when there is no currency code passed into it. This is only used by\n * CurrencyPipe and has no relation to locale currency. Defaults to USD if not configured.\n *\n * See the [i18n guide](guide/i18n-common-locale-id) for more information.\n *\n * <div class=\"alert is-helpful\">\n *\n * **Deprecation notice:**\n *\n * The default currency code is currently always `USD` but this is deprecated from v9.\n *\n * **In v10 the default currency code will be taken from the current locale.**\n *\n * If you need the previous behavior then set it by creating a `DEFAULT_CURRENCY_CODE` provider in\n * your application `NgModule`:\n *\n * ```ts\n * {provide: DEFAULT_CURRENCY_CODE, useValue: 'USD'}\n * ```\n *\n * </div>\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: DEFAULT_CURRENCY_CODE, useValue: 'EUR' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport declare const DEFAULT_CURRENCY_CODE: InjectionToken<string>;\n\n/**\n * @deprecated v4.0.0 - Should not be part of public API.\n * @publicApi\n */\nexport declare class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {\n    readonly length: number;\n    readonly collection: V[] | Iterable<V> | null;\n    private _linkedRecords;\n    private _unlinkedRecords;\n    private _previousItHead;\n    private _itHead;\n    private _itTail;\n    private _additionsHead;\n    private _additionsTail;\n    private _movesHead;\n    private _movesTail;\n    private _removalsHead;\n    private _removalsTail;\n    private _identityChangesHead;\n    private _identityChangesTail;\n    private _trackByFn;\n    constructor(trackByFn?: TrackByFunction<V>);\n    forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;\n    forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;\n    forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;\n    diff(collection: NgIterable<V> | null | undefined): DefaultIterableDiffer<V> | null;\n    onDestroy(): void;\n    check(collection: NgIterable<V>): boolean;\n    get isDirty(): boolean;\n    private _addToRemovals;\n}\n\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\nexport declare const defineInjectable: typeof ɵɵdefineInjectable;\n\ndeclare type DependencyTypeList = (ɵDirectiveType<any> | ɵComponentType<any> | PipeType<any> | Type<any>)[];\n\n/**\n * Array of destroy hooks that should be executed for a view and their directive indices.\n *\n * The array is set up as a series of number/function or number/(number|function)[]:\n * - Even indices represent the context with which hooks should be called.\n * - Odd indices are the hook functions themselves. If a value at an odd index is an array,\n *   it represents the destroy hooks of a `multi` provider where:\n *     - Even indices represent the index of the provider for which we've registered a destroy hook,\n *       inside of the `multi` provider array.\n *     - Odd indices are the destroy hook functions.\n * For example:\n * LView: `[0, 1, 2, AService, 4, [BService, CService, DService]]`\n * destroyHooks: `[3, AService.ngOnDestroy, 5, [0, BService.ngOnDestroy, 2, DService.ngOnDestroy]]`\n *\n * In the example above `AService` is a type provider with an `ngOnDestroy`, whereas `BService`,\n * `CService` and `DService` are part of a `multi` provider where only `BService` and `DService`\n * have an `ngOnDestroy` hook.\n */\ndeclare type DestroyHookData = (HookEntry | HookData)[];\n\n/**\n * Destroys the current Angular platform and all Angular applications on the page.\n * Destroys all modules and listeners registered with the platform.\n *\n * @publicApi\n */\nexport declare function destroyPlatform(): void;\n\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare interface Directive {\n    /**\n     * The CSS selector that identifies this directive in a template\n     * and triggers instantiation of the directive.\n     *\n     * Declare as one of the following:\n     *\n     * - `element-name`: Select by element name.\n     * - `.class`: Select by class name.\n     * - `[attribute]`: Select by attribute name.\n     * - `[attribute=value]`: Select by attribute name and value.\n     * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n     * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n     *\n     * Angular only allows directives to apply on CSS selectors that do not cross\n     * element boundaries.\n     *\n     * For the following template HTML, a directive with an `input[type=text]` selector,\n     * would be instantiated only on the `<input type=\"text\">` element.\n     *\n     * ```html\n     * <form>\n     *   <input type=\"text\">\n     *   <input type=\"radio\">\n     * <form>\n     * ```\n     *\n     */\n    selector?: string;\n    /**\n     * Enumerates the set of data-bound input properties for a directive\n     *\n     * Angular automatically updates input properties during change detection.\n     * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\n     * configuration:\n     *\n     * - `directiveProperty` specifies the component property where the value is written.\n     * - `bindingProperty` specifies the DOM property where the value is read from.\n     *\n     * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\n     *\n     * @usageNotes\n     *\n     * The following example creates a component with two data-bound properties.\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'bank-account',\n     *   inputs: ['bankName', 'id: account-id'],\n     *   template: `\n     *     Bank Name: {{bankName}}\n     *     Account Id: {{id}}\n     *   `\n     * })\n     * class BankAccount {\n     *   bankName: string;\n     *   id: string;\n     * }\n     * ```\n     *\n     */\n    inputs?: string[];\n    /**\n     * Enumerates the set of event-bound output properties.\n     *\n     * When an output property emits an event, an event handler attached to that event\n     * in the template is invoked.\n     *\n     * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\n     * configuration:\n     *\n     * - `directiveProperty` specifies the component property that emits events.\n     * - `bindingProperty` specifies the DOM property the event handler is attached to.\n     *\n     * @usageNotes\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'child-dir',\n     *   outputs: [ 'bankNameChange' ]\n     *   template: `<input (input)=\"bankNameChange.emit($event.target.value)\" />`\n     * })\n     * class ChildDir {\n     *  bankNameChange: EventEmitter<string> = new EventEmitter<string>();\n     * }\n     *\n     * @Component({\n     *   selector: 'main',\n     *   template: `\n     *     {{ bankName }} <child-dir (bankNameChange)=\"onBankNameChange($event)\"></child-dir>\n     *   `\n     * })\n     * class MainComponent {\n     *  bankName: string;\n     *\n     *   onBankNameChange(bankName: string) {\n     *     this.bankName = bankName;\n     *   }\n     * }\n     * ```\n     *\n     */\n    outputs?: string[];\n    /**\n     * Configures the [injector](guide/glossary#injector) of this\n     * directive or component with a [token](guide/glossary#di-token)\n     * that maps to a [provider](guide/glossary#provider) of a dependency.\n     */\n    providers?: Provider[];\n    /**\n     * Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * @usageNotes\n     *\n     * ```ts\n     * @Directive({\n     *   selector: 'child-dir',\n     *   exportAs: 'child'\n     * })\n     * class ChildDir {\n     * }\n     *\n     * @Component({\n     *   selector: 'main',\n     *   template: `<child-dir #c=\"child\"></child-dir>`\n     * })\n     * class MainComponent {\n     * }\n     * ```\n     *\n     */\n    exportAs?: string;\n    /**\n     * Configures the queries that will be injected into the directive.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * @usageNotes\n     *\n     * The following example shows how queries are defined\n     * and when their results are available in lifecycle hooks:\n     *\n     * ```ts\n     * @Component({\n     *   selector: 'someDir',\n     *   queries: {\n     *     contentChildren: new ContentChildren(ChildDirective),\n     *     viewChildren: new ViewChildren(ChildDirective)\n     *   },\n     *   template: '<child-directive></child-directive>'\n     * })\n     * class SomeDir {\n     *   contentChildren: QueryList<ChildDirective>,\n     *   viewChildren: QueryList<ChildDirective>\n     *\n     *   ngAfterContentInit() {\n     *     // contentChildren is set\n     *   }\n     *\n     *   ngAfterViewInit() {\n     *     // viewChildren is set\n     *   }\n     * }\n     * ```\n     *\n     * @Annotation\n     */\n    queries?: {\n        [key: string]: any;\n    };\n    /**\n     * Maps class properties to host element bindings for properties,\n     * attributes, and events, using a set of key-value pairs.\n     *\n     * Angular automatically checks host property bindings during change detection.\n     * If a binding changes, Angular updates the directive's host element.\n     *\n     * When the key is a property of the host element, the property value is\n     * the propagated to the specified DOM property.\n     *\n     * When the key is a static attribute in the DOM, the attribute value\n     * is propagated to the specified property in the host element.\n     *\n     * For event handling:\n     * - The key is the DOM event that the directive listens to.\n     * To listen to global events, add the target to the event name.\n     * The target can be `window`, `document` or `body`.\n     * - The value is the statement to execute when the event occurs. If the\n     * statement evaluates to `false`, then `preventDefault` is applied on the DOM\n     * event. A handler method can refer to the `$event` local variable.\n     *\n     */\n    host?: {\n        [key: string]: string;\n    };\n    /**\n     * When present, this directive/component is ignored by the AOT compiler.\n     * It remains in distributed code, and the JIT compiler attempts to compile it\n     * at run time, in the browser.\n     * To ensure the correct behavior, the app must import `@angular/compiler`.\n     */\n    jit?: true;\n    /**\n     * Angular directives marked as `standalone` do not need to be declared in an NgModule. Such\n     * directives don't depend on any \"intermediate context\" of an NgModule (ex. configured\n     * providers).\n     *\n     * More information about standalone components, directives, and pipes can be found in [this\n     * guide](guide/standalone-components).\n     *\n     * @developerPreview\n     */\n    standalone?: boolean;\n}\n\n/**\n * Type of the Directive metadata.\n *\n * @publicApi\n */\nexport declare const Directive: DirectiveDecorator;\n\n/**\n * Type of the Directive decorator / constructor function.\n * @publicApi\n */\nexport declare interface DirectiveDecorator {\n    /**\n     * Decorator that marks a class as an Angular directive.\n     * You can define your own directives to attach custom behavior to elements in the DOM.\n     *\n     * The options provide configuration metadata that determines\n     * how the directive should be processed, instantiated and used at\n     * runtime.\n     *\n     * Directive classes, like component classes, can implement\n     * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\n     *\n     *\n     * @usageNotes\n     * To define a directive, mark the class with the decorator and provide metadata.\n     *\n     * ```ts\n     * import {Directive} from '@angular/core';\n     *\n     * @Directive({\n     *   selector: 'my-directive',\n     * })\n     * export class MyDirective {\n     * ...\n     * }\n     * ```\n     *\n     * ### Declaring directives\n     *\n     * In order to make a directive available to other components in your application, you should do\n     * one of the following:\n     *  - either mark the directive as [standalone](guide/standalone-components),\n     *  - or declare it in an NgModule by adding it to the `declarations` and `exports` fields.\n     *\n     * ** Marking a directive as standalone **\n     *\n     * You can add the `standalone: true` flag to the Directive decorator metadata to declare it as\n     * [standalone](guide/standalone-components):\n     *\n     * ```ts\n     * @Directive({\n     *   standalone: true,\n     *   selector: 'my-directive',\n     * })\n     * class MyDirective {}\n     * ```\n     *\n     * When marking a directive as standalone, please make sure that the directive is not already\n     * declared in an NgModule.\n     *\n     *\n     * ** Declaring a directive in an NgModule **\n     *\n     * Another approach is to declare a directive in an NgModule:\n     *\n     * ```ts\n     * @Directive({\n     *   selector: 'my-directive',\n     * })\n     * class MyDirective {}\n     *\n     * @NgModule({\n     *   declarations: [MyDirective, SomeComponent],\n     *   exports: [MyDirective], // making it available outside of this module\n     * })\n     * class SomeNgModule {}\n     * ```\n     *\n     * When declaring a directive in an NgModule, please make sure that:\n     *  - the directive is declared in exactly one NgModule.\n     *  - the directive is not standalone.\n     *  - you do not re-declare a directive imported from another module.\n     *  - the directive is included into the `exports` field as well if you want this directive to be\n     *    accessible for components outside of the NgModule.\n     *\n     *\n     * @Annotation\n     */\n    (obj?: Directive): TypeDecorator;\n    /**\n     * See the `Directive` decorator.\n     */\n    new (obj?: Directive): Directive;\n}\n\ndeclare interface DirectiveDefFeature {\n    <T>(directiveDef: ɵDirectiveDef<T>): void;\n    /**\n     * Marks a feature as something that {@link InheritDefinitionFeature} will execute\n     * during inheritance.\n     *\n     * NOTE: DO NOT SET IN ROOT OF MODULE! Doing so will result in tree-shakers/bundlers\n     * identifying the change as a side effect, and the feature will be included in\n     * every bundle.\n     */\n    ngInherit?: true;\n}\n\ndeclare type DirectiveDefList = (ɵDirectiveDef<any> | ɵComponentDef<any>)[];\n\n/**\n * Type used for directiveDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\ndeclare type DirectiveDefListOrFactory = (() => DirectiveDefList) | DirectiveDefList;\n\n/**\n * @description\n * Hook for manual bootstrapping of the application instead of using `bootstrap` array in @NgModule\n * annotation. This hook is invoked only when the `bootstrap` array is empty or not provided.\n *\n * Reference to the current application is provided as a parameter.\n *\n * See [\"Bootstrapping\"](guide/bootstrapping) and [\"Entry components\"](guide/entry-components).\n *\n * @usageNotes\n * The example below uses `ApplicationRef.bootstrap()` to render the\n * `AppComponent` on the page.\n *\n * ```typescript\n * class AppModule implements DoBootstrap {\n *   ngDoBootstrap(appRef: ApplicationRef) {\n *     appRef.bootstrap(AppComponent); // Or some other component\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare interface DoBootstrap {\n    ngDoBootstrap(appRef: ApplicationRef): void;\n}\n\n/**\n * A lifecycle hook that invokes a custom change-detection function for a directive,\n * in addition to the check performed by the default change-detector.\n *\n * The default change-detection algorithm looks for differences by comparing\n * bound-property values by reference across change detection runs. You can use this\n * hook to check for and respond to changes by some other means.\n *\n * When the default change detector detects changes, it invokes `ngOnChanges()` if supplied,\n * regardless of whether you perform additional change detection.\n * Typically, you should not use both `DoCheck` and `OnChanges` to respond to\n * changes on the same input.\n *\n * @see `OnChanges`\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface\n * to invoke it own change-detection cycle.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}\n *\n * For a more complete example and discussion, see\n * [Defining custom change detection](guide/lifecycle-hooks#defining-custom-change-detection).\n *\n * @publicApi\n */\nexport declare interface DoCheck {\n    /**\n     * A callback method that performs change-detection, invoked\n     * after the default change-detector runs.\n     * See `KeyValueDiffers` and `IterableDiffers` for implementing\n     * custom change checking for collections.\n     *\n     */\n    ngDoCheck(): void;\n}\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\ndeclare const ELEMENT_MARKER: ELEMENT_MARKER;\n\ndeclare interface ELEMENT_MARKER {\n    marker: 'element';\n}\n\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\nexport declare class ElementRef<T = any> {\n    /**\n     * The underlying native element or `null` if direct access to native elements is not supported\n     * (e.g. when the application runs in a web worker).\n     *\n     * <div class=\"callout is-critical\">\n     *   <header>Use with caution</header>\n     *   <p>\n     *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n     *    data-binding provided by Angular instead. Alternatively you can take a look at {@link\n     * Renderer2}\n     *    which provides API that can safely be used even when direct access to native elements is not\n     *    supported.\n     *   </p>\n     *   <p>\n     *    Relying on direct DOM access creates tight coupling between your application and rendering\n     *    layers which will make it impossible to separate the two and deploy your application into a\n     *    web worker.\n     *   </p>\n     * </div>\n     *\n     */\n    nativeElement: T;\n    constructor(nativeElement: T);\n}\n\ndeclare const EMBEDDED_VIEW_INJECTOR = 21;\n\n/**\n * Represents an Angular [view](guide/glossary#view) in a view container.\n * An [embedded view](guide/glossary#view-tree) can be referenced from a component\n * other than the hosting component whose template defines it, or it can be defined\n * independently by a `TemplateRef`.\n *\n * Properties of elements in a view can change, but the structure (number and order) of elements in\n * a view cannot. Change the structure of elements by inserting, moving, or\n * removing nested views in a view container.\n *\n * @see `ViewContainerRef`\n *\n * @usageNotes\n *\n * The following template breaks down into two separate `TemplateRef` instances,\n * an outer one and an inner one.\n *\n * ```\n * Count: {{items.length}}\n * <ul>\n *   <li *ngFor=\"let  item of items\">{{item}}</li>\n * </ul>\n * ```\n *\n * This is the outer `TemplateRef`:\n *\n * ```\n * Count: {{items.length}}\n * <ul>\n *   <ng-template ngFor let-item [ngForOf]=\"items\"></ng-template>\n * </ul>\n * ```\n *\n * This is the inner `TemplateRef`:\n *\n * ```\n *   <li>{{item}}</li>\n * ```\n *\n * The outer and inner `TemplateRef` instances are assembled into views as follows:\n *\n * ```\n * <!-- ViewRef: outer-0 -->\n * Count: 2\n * <ul>\n *   <ng-template view-container-ref></ng-template>\n *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n * </ul>\n * <!-- /ViewRef: outer-0 -->\n * ```\n * @publicApi\n */\nexport declare abstract class EmbeddedViewRef<C> extends ViewRef {\n    /**\n     * The context for this view, inherited from the anchor element.\n     */\n    abstract context: C;\n    /**\n     * The root nodes for this embedded view.\n     */\n    abstract get rootNodes(): any[];\n}\n\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n * @publicApi\n */\nexport declare function enableProdMode(): void;\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @publicApi\n */\nexport declare const ENVIRONMENT_INITIALIZER: InjectionToken<() => void>;\n\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @developerPreview\n */\nexport declare abstract class EnvironmentInjector implements Injector {\n    /**\n     * Retrieves an instance from the injector based on the provided token.\n     * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n     */\n    abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    /**\n     * @deprecated from v4.0.0 use ProviderToken<T>\n     * @suppress {duplicate}\n     */\n    abstract get(token: any, notFoundValue?: any): any;\n    /**\n     * Runs the given function in the context of this `EnvironmentInjector`.\n     *\n     * Within the function's stack frame, `inject` can be used to inject dependencies from this\n     * injector. Note that `inject` is only usable synchronously, and cannot be used in any\n     * asynchronous callbacks or after any `await` points.\n     *\n     * @param fn the closure to be run in the context of this injector\n     * @returns the return value of the function, if any\n     */\n    abstract runInContext<ReturnT>(fn: () => ReturnT): ReturnT;\n    abstract destroy(): void;\n}\n\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nexport declare class ErrorHandler {\n    handleError(error: any): void;\n}\n\n/**\n * Use in components with the `@Output` directive to emit custom events\n * synchronously or asynchronously, and register handlers for those events\n * by subscribing to an instance.\n *\n * @usageNotes\n *\n * Extends\n * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)\n * for Angular by adding the `emit()` method.\n *\n * In the following example, a component defines two output properties\n * that create event emitters. When the title is clicked, the emitter\n * emits an open or close event to toggle the current visibility state.\n *\n * ```html\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * Access the event object with the `$event` argument passed to the output event\n * handler:\n *\n * ```html\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * @see [Observables in Angular](guide/observables-in-angular)\n * @publicApi\n */\nexport declare interface EventEmitter<T> extends Subject<T> {\n    /**\n     * Creates an instance of this class that can\n     * deliver events synchronously or asynchronously.\n     *\n     * @param [isAsync=false] When true, deliver events asynchronously.\n     *\n     */\n    new (isAsync?: boolean): EventEmitter<T>;\n    /**\n     * Emits an event containing a given value.\n     * @param value The value to emit.\n     */\n    emit(value?: T): void;\n    /**\n     * Registers handlers for events emitted by this instance.\n     * @param next When supplied, a custom handler for emitted events.\n     * @param error When supplied, a custom handler for an error notification from this emitter.\n     * @param complete When supplied, a custom handler for a completion notification from this\n     *     emitter.\n     */\n    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n    /**\n     * Registers handlers for events emitted by this instance.\n     * @param observerOrNext When supplied, a custom handler for emitted events, or an observer\n     *     object.\n     * @param error When supplied, a custom handler for an error notification from this emitter.\n     * @param complete When supplied, a custom handler for a completion notification from this\n     *     emitter.\n     */\n    subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription;\n}\n\n/**\n * @publicApi\n */\nexport declare const EventEmitter: {\n    new (isAsync?: boolean): EventEmitter<any>;\n    new <T>(isAsync?: boolean): EventEmitter<T>;\n    readonly prototype: EventEmitter<any>;\n};\n\n/**\n * Configures the `Injector` to return a value of another `useExisting` token.\n *\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport declare interface ExistingProvider extends ExistingSansProvider {\n    /**\n     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n     */\n    provide: any;\n    /**\n     * When true, injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return a value of another `useExisting` token.\n *\n * @see `ExistingProvider`\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @publicApi\n */\nexport declare interface ExistingSansProvider {\n    /**\n     * Existing `token` to return. (Equivalent to `injector.get(useExisting)`)\n     */\n    useExisting: any;\n}\n\n/**\n * Definition of what a factory function should look like.\n */\ndeclare type FactoryFn<T> = {\n    /**\n     * Subclasses without an explicit constructor call through to the factory of their base\n     * definition, providing it with their own constructor to instantiate.\n     */\n    <U extends T>(t?: Type<U>): U;\n    /**\n     * If no constructor to instantiate is provided, an instance of type T itself is created.\n     */\n    (t?: undefined): T;\n};\n\n/**\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}\n *\n * Dependencies can also be marked as optional:\n *\n * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport declare interface FactoryProvider extends FactorySansProvider {\n    /**\n     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n     */\n    provide: any;\n    /**\n     * When true, injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\n *\n * @see `FactoryProvider`\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @publicApi\n */\nexport declare interface FactorySansProvider {\n    /**\n     * A function to invoke to create a value for this `token`. The function is invoked with\n     * resolved values of `token`s in the `deps` field.\n     */\n    useFactory: Function;\n    /**\n     * A list of `token`s to be resolved by the injector. The list of values is then\n     * used as arguments to the `useFactory` function.\n     */\n    deps?: any[];\n}\n\ndeclare const FLAGS = 2;\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nexport declare function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport declare interface ForwardRefFn {\n    (): any;\n}\n\n/**\n * @publicApi\n */\ndeclare function getDebugNode(nativeNode: any): DebugNode | null;\nexport { getDebugNode }\nexport { getDebugNode as ɵgetDebugNode }\n\n/**\n * Returns the NgModuleFactory with the given id (specified using [@NgModule.id\n * field](api/core/NgModule#id)), if it exists and has been loaded. Factories for NgModules that do\n * not specify an `id` cannot be retrieved. Throws if an NgModule cannot be found.\n * @publicApi\n * @deprecated Use `getNgModuleById` instead.\n */\nexport declare function getModuleFactory(id: string): NgModuleFactory<any>;\n\n/**\n * Returns the NgModule class with the given id (specified using [@NgModule.id\n * field](api/core/NgModule#id)), if it exists and has been loaded. Classes for NgModules that do\n * not specify an `id` cannot be retrieved. Throws if an NgModule cannot be found.\n * @publicApi\n */\nexport declare function getNgModuleById<T>(id: string): Type<T>;\n\n/**\n * Returns the current platform.\n *\n * @publicApi\n */\nexport declare function getPlatform(): PlatformRef | null;\n\n/**\n * Adapter interface for retrieving the `Testability` service associated for a\n * particular context.\n *\n * @publicApi\n */\nexport declare interface GetTestability {\n    addToWindow(registry: TestabilityRegistry): void;\n    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;\n}\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and then\n * use that at runtime for rendering.\n *\n * At runtime we can then use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\ndeclare type GlobalTargetName = 'document' | 'window' | 'body';\n\ndeclare type GlobalTargetResolver = (element: any) => EventTarget;\n\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\ndeclare const HAS_TRANSPLANTED_VIEWS = 2;\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * For each node of the view, the following data is stored:\n * 1) Node index (optional)\n * 2) A series of number/function pairs where:\n *  - even indices are directive indices\n *  - odd indices are hook functions\n *\n * Special cases:\n *  - a negative directive index flags an init hook (ngOnInit, ngAfterContentInit, ngAfterViewInit)\n */\ndeclare type HookData = HookEntry[];\n\n/**\n * Information necessary to call a hook. E.g. the callback that\n * needs to invoked and the index at which to find its context.\n */\ndeclare type HookEntry = number | HookFn;\n\n/** Single hook callback function. */\ndeclare type HookFn = () => void;\n\ndeclare const HOST = 0;\n\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport declare interface Host {\n}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Host: HostDecorator;\n\n/**\n * Type of the HostBinding metadata.\n *\n * @publicApi\n */\nexport declare interface HostBinding {\n    /**\n     * The DOM property that is bound to a data property.\n     */\n    hostPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const HostBinding: HostBindingDecorator;\n\n/**\n * Type of the HostBinding decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface HostBindingDecorator {\n    /**\n     * Decorator that marks a DOM property as a host-binding property and supplies configuration\n     * metadata.\n     * Angular automatically checks host property bindings during change detection, and\n     * if a binding changes it updates the host element of the directive.\n     *\n     * @usageNotes\n     *\n     * The following example creates a directive that sets the `valid` and `invalid`\n     * properties on the DOM element that has an `ngModel` directive on it.\n     *\n     * ```typescript\n     * @Directive({selector: '[ngModel]'})\n     * class NgModelStatus {\n     *   constructor(public control: NgModel) {}\n     *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n     *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   template: `<input [(ngModel)]=\"prop\">`,\n     * })\n     * class App {\n     *   prop;\n     * }\n     * ```\n     *\n     */\n    (hostPropertyName?: string): any;\n    new (hostPropertyName?: string): any;\n}\n\n/**\n * Stores a set of OpCodes to process `HostBindingsFunction` associated with a current view.\n *\n * In order to invoke `HostBindingsFunction` we need:\n * 1. 'elementIdx`: Index to the element associated with the `HostBindingsFunction`.\n * 2. 'directiveIdx`: Index to the directive associated with the `HostBindingsFunction`. (This will\n *    become the context for the `HostBindingsFunction` invocation.)\n * 3. `bindingRootIdx`: Location where the bindings for the `HostBindingsFunction` start. Internally\n *    `HostBindingsFunction` binding indexes start from `0` so we need to add `bindingRootIdx` to\n *    it.\n * 4. `HostBindingsFunction`: A host binding function to execute.\n *\n * The above information needs to be encoded into the `HostBindingOpCodes` in an efficient manner.\n *\n * 1. `elementIdx` is encoded into the `HostBindingOpCodes` as `~elementIdx` (so a negative number);\n * 2. `directiveIdx`\n * 3. `bindingRootIdx`\n * 4. `HostBindingsFunction` is passed in as is.\n *\n * The `HostBindingOpCodes` array contains:\n * - negative number to select the element index.\n * - followed by 1 or more of:\n *    - a number to select the directive index\n *    - a number to select the bindingRoot index\n *    - and a function to invoke.\n *\n * ## Example\n *\n * ```\n * const hostBindingOpCodes = [\n *   ~30,                               // Select element 30\n *   40, 45, MyDir.ɵdir.hostBindings    // Invoke host bindings on MyDir on element 30;\n *                                      // directiveIdx = 40; bindingRootIdx = 45;\n *   50, 55, OtherDir.ɵdir.hostBindings // Invoke host bindings on OtherDire on element 30\n *                                      // directiveIdx = 50; bindingRootIdx = 55;\n * ]\n * ```\n *\n * ## Pseudocode\n * ```\n * const hostBindingOpCodes = tView.hostBindingOpCodes;\n * if (hostBindingOpCodes === null) return;\n * for (let i = 0; i < hostBindingOpCodes.length; i++) {\n *   const opCode = hostBindingOpCodes[i] as number;\n *   if (opCode < 0) {\n *     // Negative numbers are element indexes.\n *     setSelectedIndex(~opCode);\n *   } else {\n *     // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n *     const directiveIdx = opCode;\n *     const bindingRootIndx = hostBindingOpCodes[++i] as number;\n *     const hostBindingFn = hostBindingOpCodes[++i] as HostBindingsFunction<any>;\n *     setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n *     const context = lView[directiveIdx];\n *     hostBindingFn(RenderFlags.Update, context);\n *   }\n * }\n * ```\n *\n */\ndeclare interface HostBindingOpCodes extends Array<number | HostBindingsFunction<any>> {\n    __brand__: 'HostBindingOpCodes';\n    debug?: string[];\n}\n\ndeclare type HostBindingsFunction<T> = <U extends T>(rf: ɵRenderFlags, ctx: U) => void;\n\n/**\n * Type of the `Host` decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface HostDecorator {\n    /**\n     * Parameter decorator on a view-provider parameter of a class constructor\n     * that tells the DI framework to resolve the view by checking injectors of child\n     * elements, and stop when reaching the host element of the current component.\n     *\n     * @usageNotes\n     *\n     * The following shows use with the `@Optional` decorator, and allows for a `null` result.\n     *\n     * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Host\">\n     * </code-example>\n     *\n     * For an extended example, see [\"Dependency Injection\n     * Guide\"](guide/dependency-injection-in-action#optional).\n     */\n    (): any;\n    new (): Host;\n}\n\n/**\n * Type of the HostListener metadata.\n *\n * @publicApi\n */\nexport declare interface HostListener {\n    /**\n     * The DOM event to listen for.\n     */\n    eventName?: string;\n    /**\n     * A set of arguments to pass to the handler method when the event occurs.\n     */\n    args?: string[];\n}\n\n/**\n * Decorator that binds a DOM event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n *\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```ts\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *   }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n *\n * ```\n *\n * The following example registers another DOM event handler that listens for `Enter` key-press\n * events on the global `window`.\n * ``` ts\n * import { HostListener, Component } from \"@angular/core\";\n *\n * @Component({\n *   selector: 'app',\n *   template: `<h1>Hello, you have pressed enter {{counter}} number of times!</h1> Press enter key\n * to increment the counter.\n *   <button (click)=\"resetCounter()\">Reset Counter</button>`\n * })\n * class AppComponent {\n *   counter = 0;\n *   @HostListener('window:keydown.enter', ['$event'])\n *   handleKeyDown(event: KeyboardEvent) {\n *     this.counter++;\n *   }\n *   resetCounter() {\n *     this.counter = 0;\n *   }\n * }\n * ```\n * The list of valid key names for `keydown` and `keyup` events\n * can be found here:\n * https://www.w3.org/TR/DOM-Level-3-Events-key/#named-key-attribute-values\n *\n * Note that keys can also be combined, e.g. `@HostListener('keydown.shift.a')`.\n *\n * The global target names that can be used to prefix an event name are\n * `document:`, `window:` and `body:`.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const HostListener: HostListenerDecorator;\n\n/**\n * Type of the HostListener decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface HostListenerDecorator {\n    /**\n     * Decorator that declares a DOM event to listen for,\n     * and provides a handler method to run when that event occurs.\n     *\n     * Angular invokes the supplied handler method when the host element emits the specified event,\n     * and updates the bound element with the result.\n     *\n     * If the handler method returns false, applies `preventDefault` on the bound element.\n     */\n    (eventName: string, args?: string[]): any;\n    new (eventName: string, args?: string[]): any;\n}\n\ndeclare namespace i0 {\n    export {\n        ɵɵinject,\n        ɵɵdefineInjectable,\n        ɵɵdefineInjector,\n        ɵɵInjectableDeclaration,\n        ɵNgModuleDef as NgModuleDef,\n        ɵɵdefineNgModule,\n        ɵɵFactoryDeclaration,\n        ɵɵInjectorDeclaration,\n        ɵɵNgModuleDeclaration,\n        ɵsetClassMetadata as setClassMetadata,\n        ɵNgModuleFactory as NgModuleFactory,\n        ɵnoSideEffects,\n        ITS_JUST_ANGULAR\n    }\n}\n\n/**\n * Array storing OpCode for dynamically creating `i18n` translation DOM elements.\n *\n * This array creates a sequence of `Text` and `Comment` (as ICU anchor) DOM elements. It consists\n * of a pair of `number` and `string` pairs which encode the operations for the creation of the\n * translated block.\n *\n * The number is shifted and encoded according to `I18nCreateOpCode`\n *\n * Pseudocode:\n * ```\n * const i18nCreateOpCodes = [\n *   10 << I18nCreateOpCode.SHIFT, \"Text Node add to DOM\",\n *   11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, \"Comment Node add to DOM\",\n *   12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_LATER, \"Text Node added later\"\n * ];\n *\n * for(var i=0; i<i18nCreateOpCodes.length; i++) {\n *   const opcode = i18NCreateOpCodes[i++];\n *   const index = opcode >> I18nCreateOpCode.SHIFT;\n *   const text = i18NCreateOpCodes[i];\n *   let node: Text|Comment;\n *   if (opcode & I18nCreateOpCode.COMMENT === I18nCreateOpCode.COMMENT) {\n *     node = lView[~index] = document.createComment(text);\n *   } else {\n *     node = lView[index] = document.createText(text);\n *   }\n *   if (opcode & I18nCreateOpCode.APPEND_EAGERLY !== I18nCreateOpCode.APPEND_EAGERLY) {\n *     parentNode.appendChild(node);\n *   }\n * }\n * ```\n */\ndeclare interface I18nCreateOpCodes extends Array<number | string>, I18nDebug {\n    __brand__: 'I18nCreateOpCodes';\n}\n\ndeclare interface I18nDebug {\n    /**\n     * Human readable representation of the OpCode arrays.\n     *\n     * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n     * production. Its presence is purely to help debug issue in development, and should not be relied\n     * on in production application.\n     */\n    debug?: string[];\n}\n\n/**\n * Stores a list of nodes which need to be removed.\n *\n * Numbers are indexes into the `LView`\n * - index > 0: `removeRNode(lView[0])`\n * - index < 0: `removeICU(~lView[0])`\n */\ndeclare interface I18nRemoveOpCodes extends Array<number> {\n    __brand__: 'I18nRemoveOpCodes';\n}\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * NOTE: 32nd bit is special as it says 32nd or higher. This way if we have more than 32 bindings\n * the code still works, but with lower efficiency. (it is unlikely that a translation would have\n * more than 32 bindings.)\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `8` values and start processing next OpCodes.\n *   0b11, 8,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `2` values and start processing next OpCodes.\n *   0b1000, 2,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\ndeclare interface I18nUpdateOpCodes extends Array<string | number | SanitizerFn | null>, I18nDebug {\n    __brand__: 'I18nUpdateOpCodes';\n}\n\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\ndeclare const ICU_MARKER: ICU_MARKER;\n\ndeclare interface ICU_MARKER {\n    marker: 'ICU';\n}\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createTextNode('xyz'));\n *   'xyz', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createElement('div'));\n *   ELEMENT_MARKER, 'div', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createComment(''));\n *   ICU_MARKER, '', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Attr, 'attr', 'value'\n * ];\n * ```\n */\ndeclare interface IcuCreateOpCodes extends Array<number | string | ELEMENT_MARKER | ICU_MARKER | null>, I18nDebug {\n    __brand__: 'I18nCreateOpCodes';\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\ndeclare const enum IcuType {\n    select = 0,\n    plural = 1\n}\n\ndeclare const ID = 20;\n\n/**\n * Providers that were imported from NgModules via the `importProvidersFrom` function.\n *\n * These providers are meant for use in an application injector (or other environment injectors) and\n * should not be used in component injectors.\n *\n * This type cannot be directly implemented. It's returned from the `importProvidersFrom` function\n * and serves to prevent the extracted NgModule providers from being used in the wrong contexts.\n *\n * @see `importProvidersFrom`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare interface ImportedNgModuleProviders {\n    ɵproviders: Provider[];\n}\n\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```typescript\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n * @developerPreview\n */\nexport declare function importProvidersFrom(...sources: ImportProvidersSource[]): ImportedNgModuleProviders;\n\n/**\n * A source of providers for the `importProvidersFrom` function.\n *\n * @developerPreview\n * @publicApi\n */\nexport declare type ImportProvidersSource = Type<unknown> | ModuleWithProviders<unknown> | Array<ImportProvidersSource>;\n\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'minified-input', 'button']]\n */\ndeclare type InitialInputData = (InitialInputs | null)[];\n\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * e.g. ['role-min', 'minified-input', 'button']\n */\ndeclare type InitialInputs = string[];\n\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport declare interface Inject {\n    /**\n     * A [DI token](guide/glossary#di-token) that maps to the dependency to be injected.\n     */\n    token: any;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Inject: InjectDecorator;\n\n/**\n * @param token A token that represents a dependency that should be injected.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @publicApi\n */\nexport declare function inject<T>(token: ProviderToken<T>): T;\n\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param flags Control how injection is executed. The flags correspond to injection strategies that\n *     can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @publicApi\n * @deprecated prefer an options object instead of `InjectFlags`\n */\nexport declare function inject<T>(token: ProviderToken<T>, flags?: InjectFlags): T | null;\n\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful.\n * @throws if called outside of a supported context, or if the token is not found.\n *\n * @publicApi\n */\nexport declare function inject<T>(token: ProviderToken<T>, options: InjectOptions & {\n    optional?: false;\n}): T;\n\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful,  `null` if the token is not\n *     found and optional injection has been requested.\n * @throws if called outside of a supported context, or if the token is not found and optional\n *     injection was not requested.\n *\n * @publicApi\n */\nexport declare function inject<T>(token: ProviderToken<T>, options: InjectOptions): T | null;\n\n/**\n * Type of the Injectable metadata.\n *\n * @publicApi\n */\nexport declare interface Injectable {\n    /**\n     * Determines which injectors will provide the injectable.\n     *\n     * - `Type<any>` - associates the injectable with an `@NgModule` or other `InjectorType`,\n     * - 'null' : Equivalent to `undefined`. The injectable is not provided in any scope automatically\n     * and must be added to a `providers` array of an [@NgModule](api/core/NgModule#providers),\n     * [@Component](api/core/Directive#providers) or [@Directive](api/core/Directive#providers).\n     *\n     * The following options specify that this injectable should be provided in one of the following\n     * injectors:\n     * - 'root' : The application-level injector in most apps.\n     * - 'platform' : A special singleton platform injector shared by all\n     * applications on the page.\n     * - 'any' : Provides a unique instance in each lazy loaded module while all eagerly loaded\n     * modules share one instance.\n     *\n     */\n    providedIn?: Type<any> | 'root' | 'platform' | 'any' | null;\n}\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Injectable: InjectableDecorator;\n\n/**\n * Type of the Injectable decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface InjectableDecorator {\n    /**\n     * Decorator that marks a class as available to be\n     * provided and injected as a dependency.\n     *\n     * @see [Introduction to Services and DI](guide/architecture-services)\n     * @see [Dependency Injection Guide](guide/dependency-injection)\n     *\n     * @usageNotes\n     *\n     * Marking a class with `@Injectable` ensures that the compiler\n     * will generate the necessary metadata to create the class's\n     * dependencies when the class is injected.\n     *\n     * The following example shows how a service class is properly\n     *  marked so that a supporting service can be injected upon creation.\n     *\n     * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Injectable\"></code-example>\n     *\n     */\n    (): TypeDecorator;\n    (options?: {\n        providedIn: Type<any> | 'root' | 'platform' | 'any' | null;\n    } & InjectableProvider): TypeDecorator;\n    new (): Injectable;\n    new (options?: {\n        providedIn: Type<any> | 'root' | 'platform' | 'any' | null;\n    } & InjectableProvider): Injectable;\n}\n\n/**\n * Injectable providers used in `@Injectable` decorator.\n *\n * @publicApi\n */\nexport declare type InjectableProvider = ValueSansProvider | ExistingSansProvider | StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;\n\n/**\n * A `Type` which has a `ɵprov: ɵɵInjectableDeclaration` static field.\n *\n * `InjectableType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector`.\n *\n * @publicApi\n */\nexport declare interface InjectableType<T> extends Type<T> {\n    /**\n     * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n     */\n    ɵprov: unknown;\n}\n\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface InjectDecorator {\n    /**\n     * Parameter decorator on a dependency parameter of a class constructor\n     * that specifies a custom provider of the dependency.\n     *\n     * @usageNotes\n     * The following example shows a class constructor that specifies a\n     * custom provider of a dependency using the parameter decorator.\n     *\n     * When `@Inject()` is not present, the injector uses the type annotation of the\n     * parameter as the provider.\n     *\n     * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"InjectWithoutDecorator\">\n     * </code-example>\n     *\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection)\n     *\n     */\n    (token: any): any;\n    new (token: any): Inject;\n}\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n * @deprecated use an options object for `inject` instead.\n */\nexport declare enum InjectFlags {\n    /** Check self and check parent injector if needed */\n    Default = 0,\n    /**\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\n     * host element of the current component. (Only used with Element Injector)\n     */\n    Host = 1,\n    /** Don't ascend to ancestors of the node requesting injection. */\n    Self = 2,\n    /** Skip the node that is requesting injection. */\n    SkipSelf = 4,\n    /** Inject `defaultValue` instead if token not found. */\n    Optional = 8\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * const myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nexport declare class InjectionToken<T> {\n    protected _desc: string;\n    readonly ɵprov: unknown;\n    /**\n     * @param _desc   Description for the token,\n     *                used only for debugging purposes,\n     *                it should but does not need to be unique\n     * @param options Options for the token's usage, as described above\n     */\n    constructor(_desc: string, options?: {\n        providedIn?: Type<any> | 'root' | 'platform' | 'any' | null;\n        factory: () => T;\n    });\n    toString(): string;\n}\n\n/**\n * Type of the options argument to `inject`.\n *\n * @publicApi\n */\nexport declare interface InjectOptions {\n    /**\n     * Use optional injection, and return `null` if the requested token is not found.\n     */\n    optional?: boolean;\n    /**\n     * Start injection at the parent of the current injector.\n     */\n    skipSelf?: boolean;\n    /**\n     * Only query the current injector for the token, and don't fall back to the parent injector if\n     * it's not found.\n     */\n    self?: boolean;\n    /**\n     * Stop injection at the host component's injector. Only relevant when injecting from an element\n     * injector, and a no-op for environment injectors.\n     */\n    host?: boolean;\n}\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport declare const INJECTOR: InjectionToken<Injector>;\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see `StaticProvider`\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport declare abstract class Injector {\n    static THROW_IF_NOT_FOUND: {};\n    static NULL: Injector;\n    /**\n     * Retrieves an instance from the injector based on the provided token.\n     * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n     */\n    abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    /**\n     * @deprecated from v4.0.0 use ProviderToken<T>\n     * @suppress {duplicate}\n     */\n    abstract get(token: any, notFoundValue?: any): any;\n    /**\n     * @deprecated from v5 use the new signature Injector.create(options)\n     */\n    static create(providers: StaticProvider[], parent?: Injector): Injector;\n    /**\n     * Creates a new injector instance that provides one or more dependencies,\n     * according to a given type or types of `StaticProvider`.\n     *\n     * @param options An object with the following properties:\n     * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).\n     * * `parent`: (optional) A parent injector.\n     * * `name`: (optional) A developer-defined identifying name for the new injector.\n     *\n     * @returns The new injector instance.\n     *\n     */\n    static create(options: {\n        providers: StaticProvider[];\n        parent?: Injector;\n        name?: string;\n    }): Injector;\n    /** @nocollapse */\n    static ɵprov: unknown;\n}\n\ndeclare const INJECTOR_2 = 9;\n\ndeclare type InjectorScope = 'root' | 'platform' | 'environment';\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorTypes` can be used to configure a `StaticInjector`.\n *\n * This is an opaque type whose structure is highly version dependent. Do not rely on any\n * properties.\n *\n * @publicApi\n */\nexport declare interface InjectorType<T> extends Type<T> {\n    ɵfac?: unknown;\n    ɵinj: unknown;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\ndeclare interface InjectorTypeWithProviders<T> {\n    ngModule: InjectorType<T>;\n    providers?: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];\n}\n\n/**\n * Type of metadata for an `Input` property.\n *\n * @publicApi\n */\nexport declare interface Input {\n    /**\n     * The name of the DOM property to which the input property is bound.\n     */\n    bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const Input: InputDecorator;\n\n/**\n * @publicApi\n */\nexport declare interface InputDecorator {\n    /**\n     * Decorator that marks a class field as an input property and supplies configuration metadata.\n     * The input property is bound to a DOM property in the template. During change detection,\n     * Angular automatically updates the data property with the DOM property's value.\n     *\n     * @usageNotes\n     *\n     * You can supply an optional name to use in templates when the\n     * component is instantiated, that maps to the\n     * name of the bound property. By default, the original\n     * name of the bound property is used for input binding.\n     *\n     * The following example creates a component with two input properties,\n     * one of which is given a special binding name.\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'bank-account',\n     *   template: `\n     *     Bank Name: {{bankName}}\n     *     Account Id: {{id}}\n     *   `\n     * })\n     * class BankAccount {\n     *   // This property is bound using its original name.\n     *   @Input() bankName: string;\n     *   // this property value is bound to a different property name\n     *   // when this component is instantiated in a template.\n     *   @Input('account-id') id: string;\n     *\n     *   // this property is not bound, and is not automatically updated by Angular\n     *   normalizedBankName: string;\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   template: `\n     *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\n     *   `\n     * })\n     * class App {}\n     * ```\n     *\n     * @see [Input and Output properties](guide/inputs-outputs)\n     */\n    (bindingPropertyName?: string): any;\n    new (bindingPropertyName?: string): any;\n}\n\n/**\n * See `TNode.insertBeforeIndex`\n */\ndeclare type InsertBeforeIndex = null | number | number[];\n\ndeclare interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n    _bootstrapComponents: Type<any>[];\n}\n\ndeclare interface InternalViewRef extends ViewRef {\n    detachFromAppRef(): void;\n    attachToAppRef(appRef: ViewRefTracker): void;\n}\n\n\n/**\n * Returns whether Angular is in development mode. After called once,\n * the value is locked and won't change any more.\n *\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\n *\n * @publicApi\n */\nexport declare function isDevMode(): boolean;\n\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport declare interface IterableChangeRecord<V> {\n    /** Current index of the item in `Iterable` or null if removed. */\n    readonly currentIndex: number | null;\n    /** Previous index of the item in `Iterable` or null if added. */\n    readonly previousIndex: number | null;\n    /** The item. */\n    readonly item: V;\n    /** Track by identity as computed by the `TrackByFunction`. */\n    readonly trackById: any;\n}\n\ndeclare class IterableChangeRecord_<V> implements IterableChangeRecord<V> {\n    item: V;\n    trackById: any;\n    currentIndex: number | null;\n    previousIndex: number | null;\n    constructor(item: V, trackById: any);\n}\n\n/**\n * An object describing the changes in the `Iterable` collection since last time\n * `IterableDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport declare interface IterableChanges<V> {\n    /**\n     * Iterate over all changes. `IterableChangeRecord` will contain information about changes\n     * to each item.\n     */\n    forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /**\n     * Iterate over a set of operations which when applied to the original `Iterable` will produce the\n     * new `Iterable`.\n     *\n     * NOTE: These are not necessarily the actual operations which were applied to the original\n     * `Iterable`, rather these are a set of computed operations which may not be the same as the\n     * ones applied.\n     *\n     * @param record A change which needs to be applied\n     * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the\n     *        original `Iterable` location, where as `previousIndex` refers to the transient location\n     *        of the item, after applying the operations up to this point.\n     * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the\n     *        original `Iterable` location, where as `currentIndex` refers to the transient location\n     *        of the item, after applying the operations up to this point.\n     */\n    forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;\n    /**\n     * Iterate over changes in the order of original `Iterable` showing where the original items\n     * have moved.\n     */\n    forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /** Iterate over all added items. */\n    forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /** Iterate over all moved items. */\n    forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /** Iterate over all removed items. */\n    forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n    /**\n     * Iterate over all items which had their identity (as computed by the `TrackByFunction`)\n     * changed.\n     */\n    forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;\n}\n\n/**\n * A strategy for tracking changes over time to an iterable. Used by {@link NgForOf} to\n * respond to changes in an iterable by effecting equivalent changes in the DOM.\n *\n * @publicApi\n */\nexport declare interface IterableDiffer<V> {\n    /**\n     * Compute a difference between the previous state and the new `object` state.\n     *\n     * @param object containing the new value.\n     * @returns an object describing the difference. The return value is only valid until the next\n     * `diff()` invocation.\n     */\n    diff(object: NgIterable<V> | undefined | null): IterableChanges<V> | null;\n}\n\n/**\n * Provides a factory for {@link IterableDiffer}.\n *\n * @publicApi\n */\nexport declare interface IterableDifferFactory {\n    supports(objects: any): boolean;\n    create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;\n}\n\n/**\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n *\n * @publicApi\n */\nexport declare class IterableDiffers {\n    /** @nocollapse */\n    static ɵprov: unknown;\n    /**\n     * @deprecated v4.0.0 - Should be private\n     */\n    factories: IterableDifferFactory[];\n    constructor(factories: IterableDifferFactory[]);\n    static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;\n    /**\n     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\n     * {@link IterableDiffers} instance.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link IterableDiffer} available.\n     *\n     * ```\n     * @Component({\n     *   viewProviders: [\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\n     *   ]\n     * })\n     * ```\n     */\n    static extend(factories: IterableDifferFactory[]): StaticProvider;\n    find(iterable: any): IterableDifferFactory;\n}\n\n/**\n * The existence of this constant (in this particular file) informs the Angular compiler that the\n * current program is actually @angular/core, which needs to be compiled specially.\n */\ndeclare const ITS_JUST_ANGULAR = true;\n\n/**\n * `KeyValueArray` is an array where even positions contain keys and odd positions contain values.\n *\n * `KeyValueArray` provides a very efficient way of iterating over its contents. For small\n * sets (~10) the cost of binary searching an `KeyValueArray` has about the same performance\n * characteristics that of a `Map` with significantly better memory footprint.\n *\n * If used as a `Map` the keys are stored in alphabetical order so that they can be binary searched\n * for retrieval.\n *\n * See: `keyValueArraySet`, `keyValueArrayGet`, `keyValueArrayIndexOf`, `keyValueArrayDelete`.\n */\ndeclare interface KeyValueArray<VALUE> extends Array<VALUE | string> {\n    __brand__: 'array-map';\n}\n\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport declare interface KeyValueChangeRecord<K, V> {\n    /**\n     * Current key in the Map.\n     */\n    readonly key: K;\n    /**\n     * Current value for the key or `null` if removed.\n     */\n    readonly currentValue: V | null;\n    /**\n     * Previous value for the key or `null` if added.\n     */\n    readonly previousValue: V | null;\n}\n\n/**\n * An object describing the changes in the `Map` or `{[k:string]: string}` since last time\n * `KeyValueDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport declare interface KeyValueChanges<K, V> {\n    /**\n     * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes\n     * to each item.\n     */\n    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over changes in the order of original Map showing where the original items\n     * have moved.\n     */\n    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over all keys for which values have changed.\n     */\n    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over all added items.\n     */\n    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n    /**\n     * Iterate over all removed items.\n     */\n    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n}\n\n/**\n * A differ that tracks changes made to an object over time.\n *\n * @publicApi\n */\nexport declare interface KeyValueDiffer<K, V> {\n    /**\n     * Compute a difference between the previous state and the new `object` state.\n     *\n     * @param object containing the new value.\n     * @returns an object describing the difference. The return value is only valid until the next\n     * `diff()` invocation.\n     */\n    diff(object: Map<K, V>): KeyValueChanges<K, V> | null;\n    /**\n     * Compute a difference between the previous state and the new `object` state.\n     *\n     * @param object containing the new value.\n     * @returns an object describing the difference. The return value is only valid until the next\n     * `diff()` invocation.\n     */\n    diff(object: {\n        [key: string]: V;\n    }): KeyValueChanges<string, V> | null;\n}\n\n/**\n * Provides a factory for {@link KeyValueDiffer}.\n *\n * @publicApi\n */\nexport declare interface KeyValueDifferFactory {\n    /**\n     * Test to see if the differ knows how to diff this kind of object.\n     */\n    supports(objects: any): boolean;\n    /**\n     * Create a `KeyValueDiffer`.\n     */\n    create<K, V>(): KeyValueDiffer<K, V>;\n}\n\n/**\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n *\n * @publicApi\n */\nexport declare class KeyValueDiffers {\n    /** @nocollapse */\n    static ɵprov: unknown;\n    /**\n     * @deprecated v4.0.0 - Should be private.\n     */\n    factories: KeyValueDifferFactory[];\n    constructor(factories: KeyValueDifferFactory[]);\n    static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;\n    /**\n     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n     * {@link KeyValueDiffers} instance.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link KeyValueDiffer} available.\n     *\n     * ```\n     * @Component({\n     *   viewProviders: [\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n     *   ]\n     * })\n     * ```\n     */\n    static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider;\n    find(kv: any): KeyValueDifferFactory;\n}\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\ndeclare interface LContainer extends Array<any> {\n    /**\n     * The host element of this LContainer.\n     *\n     * The host could be an LView if this container is on a component node.\n     * In that case, the component LView is its HOST.\n     */\n    readonly [HOST]: RElement | RComment | LView;\n    /**\n     * This is a type field which allows us to differentiate `LContainer` from `StylingContext` in an\n     * efficient way. The value is always set to `true`\n     */\n    [TYPE]: true;\n    /**\n     * Flag to signify that this `LContainer` may have transplanted views which need to be change\n     * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n     *\n     * This flag, once set, is never unset for the `LContainer`.\n     */\n    [HAS_TRANSPLANTED_VIEWS]: boolean;\n    /**\n     * Access to the parent view is necessary so we can propagate back\n     * up from inside a container to parent[NEXT].\n     */\n    [PARENT]: LView;\n    /**\n     * This allows us to jump from a container to a sibling container or component\n     * view with the same parent, so we can remove listeners efficiently.\n     */\n    [NEXT]: LView | LContainer | null;\n    /**\n     * The number of direct transplanted views which need a refresh or have descendants themselves\n     * that need a refresh but have not marked their ancestors as Dirty. This tells us that during\n     * change detection we should still descend to find those children to refresh, even if the parents\n     * are not `Dirty`/`CheckAlways`.\n     */\n    [TRANSPLANTED_VIEWS_TO_REFRESH]: number;\n    /**\n     * A collection of views created based on the underlying `<ng-template>` element but inserted into\n     * a different `LContainer`. We need to track views created from a given declaration point since\n     * queries collect matches from the embedded view declaration point and _not_ the insertion point.\n     */\n    [MOVED_VIEWS]: LView[] | null;\n    /**\n     * Pointer to the `TNode` which represents the host of the container.\n     */\n    [T_HOST]: TNode;\n    /** The comment element that serves as an anchor for this LContainer. */\n    readonly [NATIVE]: RComment;\n    /**\n     * Array of `ViewRef`s used by any `ViewContainerRef`s that point to this container.\n     *\n     * This is lazily initialized by `ViewContainerRef` when the first view is inserted.\n     *\n     * NOTE: This is stored as `any[]` because render3 should really not be aware of `ViewRef` and\n     * doing so creates circular dependency.\n     */\n    [VIEW_REFS]: unknown[] | null;\n}\n\n/**\n * Human readable version of the `LContainer`\n *\n * `LContainer` is a data structure used internally to keep track of child views. The `LContainer`\n * is designed for efficiency and so at times it is difficult to read or write tests which assert on\n * its values. For this reason when `ngDevMode` is true we patch a `LContainer.debug` property which\n * points to `LContainerDebug` for easier debugging and test writing. It is the intent of\n * `LContainerDebug` to be used in tests.\n */\ndeclare interface LContainerDebug {\n    readonly native: RComment;\n    /**\n     * Child `LView`s.\n     */\n    readonly views: LViewDebug[];\n    readonly parent: LViewDebug | null;\n    readonly movedViews: LView[] | null;\n    readonly host: RElement | RComment | LView;\n    readonly next: LViewDebug | LContainerDebug | null;\n    readonly hasTransplantedViews: boolean;\n}\n\n/**\n * Provide this token to set the locale of your application.\n * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,\n * DecimalPipe and PercentPipe) and by ICU expressions.\n *\n * See the [i18n guide](guide/i18n-common-locale-id) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { LOCALE_ID } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport declare const LOCALE_ID: InjectionToken<string>;\n\n/**\n * Type for a function that extracts a value for a local refs.\n * Example:\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\n */\ndeclare type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LView) => any;\n\n/**\n * lQueries represent a collection of individual LQuery objects tracked in a given view.\n */\ndeclare interface LQueries {\n    /**\n     * A collection of queries tracked in a given view.\n     */\n    queries: LQuery<any>[];\n    /**\n     * A method called when a new embedded view is created. As a result a set of LQueries applicable\n     * for a new embedded view is instantiated (cloned) from the declaration view.\n     * @param tView\n     */\n    createEmbeddedView(tView: TView): LQueries | null;\n    /**\n     * A method called when an embedded view is inserted into a container. As a result all impacted\n     * `LQuery` objects (and associated `QueryList`) are marked as dirty.\n     * @param tView\n     */\n    insertView(tView: TView): void;\n    /**\n     * A method called when an embedded view is detached from a container. As a result all impacted\n     * `LQuery` objects (and associated `QueryList`) are marked as dirty.\n     * @param tView\n     */\n    detachView(tView: TView): void;\n}\n\n/**\n * An interface that represents query-related information specific to a view instance. Most notably\n * it contains:\n * - materialized query matches;\n * - a pointer to a QueryList where materialized query results should be reported.\n */\ndeclare interface LQuery<T> {\n    /**\n     * Materialized query matches for a given view only (!). Results are initialized lazily so the\n     * array of matches is set to `null` initially.\n     */\n    matches: (T | null)[] | null;\n    /**\n     * A QueryList where materialized query results should be reported.\n     */\n    queryList: QueryList<T>;\n    /**\n     * Clones an LQuery for an embedded view. A cloned query shares the same `QueryList` but has a\n     * separate collection of materialized matches.\n     */\n    clone(): LQuery<T>;\n    /**\n     * Called when an embedded view, impacting results of this query, is inserted or removed.\n     */\n    setDirty(): void;\n}\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\ndeclare interface LView<T = unknown> extends Array<any> {\n    /**\n     * Human readable representation of the `LView`.\n     *\n     * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n     * production. Its presence is purely to help debug issue in development, and should not be relied\n     * on in production application.\n     */\n    debug?: LViewDebug;\n    /**\n     * The node into which this `LView` is inserted.\n     */\n    [HOST]: RElement | null;\n    /**\n     * The static data for this view. We need a reference to this so we can easily walk up the\n     * node tree in DI and get the TView.data array associated with a node (where the\n     * directive defs are stored).\n     */\n    readonly [TVIEW]: TView;\n    /** Flags for this view. See LViewFlags for more info. */\n    [FLAGS]: LViewFlags;\n    /**\n     * This may store an {@link LView} or {@link LContainer}.\n     *\n     * `LView` - The parent view. This is needed when we exit the view and must restore the previous\n     * LView. Without this, the render method would have to keep a stack of\n     * views as it is recursively rendering templates.\n     *\n     * `LContainer` - The current view is part of a container, and is an embedded view.\n     */\n    [PARENT]: LView | LContainer | null;\n    /**\n     *\n     * The next sibling LView or LContainer.\n     *\n     * Allows us to propagate between sibling view states that aren't in the same\n     * container. Embedded views already have a node.next, but it is only set for\n     * views in the same container. We need a way to link component views and views\n     * across containers as well.\n     */\n    [NEXT]: LView | LContainer | null;\n    /** Queries active for this view - nodes from a view are reported to those queries. */\n    [QUERIES]: LQueries | null;\n    /**\n     * Store the `TNode` of the location where the current `LView` is inserted into.\n     *\n     * Given:\n     * ```\n     * <div>\n     *   <ng-template><span></span></ng-template>\n     * </div>\n     * ```\n     *\n     * We end up with two `TView`s.\n     * - `parent` `TView` which contains `<div><!-- anchor --></div>`\n     * - `child` `TView` which contains `<span></span>`\n     *\n     * Typically the `child` is inserted into the declaration location of the `parent`, but it can be\n     * inserted anywhere. Because it can be inserted anywhere it is not possible to store the\n     * insertion information in the `TView` and instead we must store it in the `LView[T_HOST]`.\n     *\n     * So to determine where is our insertion parent we would execute:\n     * ```\n     * const parentLView = lView[PARENT];\n     * const parentTNode = lView[T_HOST];\n     * const insertionParent = parentLView[parentTNode.index];\n     * ```\n     *\n     *\n     * If `null`, this is the root view of an application (root component is in this view) and it has\n     * no parents.\n     */\n    [T_HOST]: TNode | null;\n    /**\n     * When a view is destroyed, listeners need to be released and outputs need to be\n     * unsubscribed. This context array stores both listener functions wrapped with\n     * their context and output subscription instances for a particular view.\n     *\n     * These change per LView instance, so they cannot be stored on TView. Instead,\n     * TView.cleanup saves an index to the necessary context in this array.\n     *\n     * After `LView` is created it is possible to attach additional instance specific functions at the\n     * end of the `lView[CLEANUP]` because we know that no more `T` level cleanup functions will be\n     * added here.\n     */\n    [CLEANUP]: any[] | null;\n    /**\n     * - For dynamic views, this is the context with which to render the template (e.g.\n     *   `NgForContext`), or `{}` if not defined explicitly.\n     * - For root view of the root component it's a reference to the component instance itself.\n     * - For components, the context is a reference to the component instance itself.\n     * - For inline views, the context is null.\n     */\n    [CONTEXT]: T;\n    /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n    readonly [INJECTOR_2]: Injector | null;\n    /** Factory to be used for creating Renderer. */\n    [RENDERER_FACTORY]: RendererFactory;\n    /** Renderer to be used for this view. */\n    [RENDERER]: Renderer;\n    /** An optional custom sanitizer. */\n    [SANITIZER]: Sanitizer | null;\n    /**\n     * Reference to the first LView or LContainer beneath this LView in\n     * the hierarchy.\n     *\n     * Necessary to store this so views can traverse through their nested views\n     * to remove listeners and call onDestroy callbacks.\n     */\n    [CHILD_HEAD]: LView | LContainer | null;\n    /**\n     * The last LView or LContainer beneath this LView in the hierarchy.\n     *\n     * The tail allows us to quickly add a new state to the end of the view list\n     * without having to propagate starting from the first child.\n     */\n    [CHILD_TAIL]: LView | LContainer | null;\n    /**\n     * View where this view's template was declared.\n     *\n     * The template for a dynamically created view may be declared in a different view than\n     * it is inserted. We already track the \"insertion view\" (view where the template was\n     * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n     * (view where the template was declared). Otherwise, we wouldn't be able to call the\n     * view's template function with the proper contexts. Context should be inherited from\n     * the declaration view tree, not the insertion view tree.\n     *\n     * Example (AppComponent template):\n     *\n     * <ng-template #foo></ng-template>       <-- declared here -->\n     * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n     *\n     * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n     * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n     * but the insertion view would be SomeComp. When we are removing views, we would want to\n     * traverse through the insertion view to clean up listeners. When we are calling the\n     * template function during change detection, we need the declaration view to get inherited\n     * context.\n     */\n    [DECLARATION_VIEW]: LView | null;\n    /**\n     * Points to the declaration component view, used to track transplanted `LView`s.\n     *\n     * See: `DECLARATION_VIEW` which points to the actual `LView` where it was declared, whereas\n     * `DECLARATION_COMPONENT_VIEW` points to the component which may not be same as\n     * `DECLARATION_VIEW`.\n     *\n     * Example:\n     * ```\n     * <#VIEW #myComp>\n     *  <div *ngIf=\"true\">\n     *   <ng-template #myTmpl>...</ng-template>\n     *  </div>\n     * </#VIEW>\n     * ```\n     * In the above case `DECLARATION_VIEW` for `myTmpl` points to the `LView` of `ngIf` whereas\n     * `DECLARATION_COMPONENT_VIEW` points to `LView` of the `myComp` which owns the template.\n     *\n     * The reason for this is that all embedded views are always check-always whereas the component\n     * view can be check-always or on-push. When we have a transplanted view it is important to\n     * determine if we have transplanted a view from check-always declaration to on-push insertion\n     * point. In such a case the transplanted view needs to be added to the `LContainer` in the\n     * declared `LView` and CD during the declared view CD (in addition to the CD at the insertion\n     * point.) (Any transplanted views which are intra Component are of no interest because the CD\n     * strategy of declaration and insertion will always be the same, because it is the same\n     * component.)\n     *\n     * Queries already track moved views in `LView[DECLARATION_LCONTAINER]` and\n     * `LContainer[MOVED_VIEWS]`. However the queries also track `LView`s which moved within the same\n     * component `LView`. Transplanted views are a subset of moved views, and we use\n     * `DECLARATION_COMPONENT_VIEW` to differentiate them. As in this example.\n     *\n     * Example showing intra component `LView` movement.\n     * ```\n     * <#VIEW #myComp>\n     *   <div *ngIf=\"condition; then thenBlock else elseBlock\"></div>\n     *   <ng-template #thenBlock>Content to render when condition is true.</ng-template>\n     *   <ng-template #elseBlock>Content to render when condition is false.</ng-template>\n     * </#VIEW>\n     * ```\n     * The `thenBlock` and `elseBlock` is moved but not transplanted.\n     *\n     * Example showing inter component `LView` movement (transplanted view).\n     * ```\n     * <#VIEW #myComp>\n     *   <ng-template #myTmpl>...</ng-template>\n     *   <insertion-component [template]=\"myTmpl\"></insertion-component>\n     * </#VIEW>\n     * ```\n     * In the above example `myTmpl` is passed into a different component. If `insertion-component`\n     * instantiates `myTmpl` and `insertion-component` is on-push then the `LContainer` needs to be\n     * marked as containing transplanted views and those views need to be CD as part of the\n     * declaration CD.\n     *\n     *\n     * When change detection runs, it iterates over `[MOVED_VIEWS]` and CDs any child `LView`s where\n     * the `DECLARATION_COMPONENT_VIEW` of the current component and the child `LView` does not match\n     * (it has been transplanted across components.)\n     *\n     * Note: `[DECLARATION_COMPONENT_VIEW]` points to itself if the LView is a component view (the\n     *       simplest / most common case).\n     *\n     * see also:\n     *   - https://hackmd.io/@mhevery/rJUJsvv9H write up of the problem\n     *   - `LContainer[HAS_TRANSPLANTED_VIEWS]` which marks which `LContainer` has transplanted views.\n     *   - `LContainer[TRANSPLANT_HEAD]` and `LContainer[TRANSPLANT_TAIL]` storage for transplanted\n     *   - `LView[DECLARATION_LCONTAINER]` similar problem for queries\n     *   - `LContainer[MOVED_VIEWS]` similar problem for queries\n     */\n    [DECLARATION_COMPONENT_VIEW]: LView;\n    /**\n     * A declaration point of embedded views (ones instantiated based on the content of a\n     * <ng-template>), null for other types of views.\n     *\n     * We need to track all embedded views created from a given declaration point so we can prepare\n     * query matches in a proper order (query matches are ordered based on their declaration point and\n     * _not_ the insertion point).\n     */\n    [DECLARATION_LCONTAINER]: LContainer | null;\n    /**\n     * More flags for this view. See PreOrderHookFlags for more info.\n     */\n    [PREORDER_HOOK_FLAGS]: PreOrderHookFlags;\n    /**\n     * The number of direct transplanted views which need a refresh or have descendants themselves\n     * that need a refresh but have not marked their ancestors as Dirty. This tells us that during\n     * change detection we should still descend to find those children to refresh, even if the parents\n     * are not `Dirty`/`CheckAlways`.\n     */\n    [TRANSPLANTED_VIEWS_TO_REFRESH]: number;\n    /** Unique ID of the view. Used for `__ngContext__` lookups in the `LView` registry. */\n    [ID]: number;\n    /**\n     * Optional injector assigned to embedded views that takes\n     * precedence over the element and module injectors.\n     */\n    readonly [EMBEDDED_VIEW_INJECTOR]: Injector | null;\n}\n\n/**\n * Human readable version of the `LView`.\n *\n * `LView` is a data structure used internally to keep track of views. The `LView` is designed for\n * efficiency and so at times it is difficult to read or write tests which assert on its values. For\n * this reason when `ngDevMode` is true we patch a `LView.debug` property which points to\n * `LViewDebug` for easier debugging and test writing. It is the intent of `LViewDebug` to be used\n * in tests.\n */\ndeclare interface LViewDebug<T = unknown> {\n    /**\n     * Flags associated with the `LView` unpacked into a more readable state.\n     *\n     * See `LViewFlags` for the flag meanings.\n     */\n    readonly flags: {\n        initPhaseState: number;\n        creationMode: boolean;\n        firstViewPass: boolean;\n        checkAlways: boolean;\n        dirty: boolean;\n        attached: boolean;\n        destroyed: boolean;\n        isRoot: boolean;\n        indexWithinInitPhase: number;\n    };\n    /**\n     * Associated TView\n     */\n    readonly tView: TView;\n    /**\n     * Parent view (or container)\n     */\n    readonly parent: LViewDebug | LContainerDebug | null;\n    /**\n     * Next sibling to the `LView`.\n     */\n    readonly next: LViewDebug | LContainerDebug | null;\n    /**\n     * The context used for evaluation of the `LView`\n     *\n     * (Usually the component)\n     */\n    readonly context: T;\n    /**\n     * Hierarchical tree of nodes.\n     */\n    readonly nodes: DebugNode_2[];\n    /**\n     * Template structure (no instance data).\n     * (Shows how TNodes are connected)\n     */\n    readonly template: string;\n    /**\n     * HTML representation of the `LView`.\n     *\n     * This is only approximate to actual HTML as child `LView`s are removed.\n     */\n    readonly html: string;\n    /**\n     * The host element to which this `LView` is attached.\n     */\n    readonly hostHTML: string | null;\n    /**\n     * Child `LView`s\n     */\n    readonly childViews: Array<LViewDebug | LContainerDebug>;\n    /**\n     * Sub range of `LView` containing decls (DOM elements).\n     */\n    readonly decls: LViewDebugRange;\n    /**\n     * Sub range of `LView` containing vars (bindings).\n     */\n    readonly vars: LViewDebugRange;\n    /**\n     * Sub range of `LView` containing expando (used by DI).\n     */\n    readonly expando: LViewDebugRange;\n}\n\n/**\n * `LView` is subdivided to ranges where the actual data is stored. Some of these ranges such as\n * `decls` and `vars` are known at compile time. Other such as `i18n` and `expando` are runtime only\n * concepts.\n */\ndeclare interface LViewDebugRange {\n    /**\n     * The starting index in `LView` where the range begins. (Inclusive)\n     */\n    start: number;\n    /**\n     * The ending index in `LView` where the range ends. (Exclusive)\n     */\n    end: number;\n    /**\n     * The length of the range\n     */\n    length: number;\n    /**\n     * The merged content of the range. `t` contains data from `TView.data` and `l` contains `LView`\n     * data at an index.\n     */\n    content: LViewDebugRangeContent[];\n}\n\n/**\n * For convenience the static and instance portions of `TView` and `LView` are merged into a single\n * object in `LViewRange`.\n */\ndeclare interface LViewDebugRangeContent {\n    /**\n     * Index into original `LView` or `TView.data`.\n     */\n    index: number;\n    /**\n     * Value from the `TView.data[index]` location.\n     */\n    t: any;\n    /**\n     * Value from the `LView[index]` location.\n     */\n    l: any;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\ndeclare const enum LViewFlags {\n    /** The state of the init phase on the first 2 bits */\n    InitPhaseStateIncrementer = 1,\n    InitPhaseStateMask = 3,\n    /**\n     * Whether or not the view is in creationMode.\n     *\n     * This must be stored in the view rather than using `data` as a marker so that\n     * we can properly support embedded views. Otherwise, when exiting a child view\n     * back into the parent view, `data` will be defined and `creationMode` will be\n     * improperly reported as false.\n     */\n    CreationMode = 4,\n    /**\n     * Whether or not this LView instance is on its first processing pass.\n     *\n     * An LView instance is considered to be on its \"first pass\" until it\n     * has completed one creation mode run and one update mode run. At this\n     * time, the flag is turned off.\n     */\n    FirstLViewPass = 8,\n    /** Whether this view has default change detection strategy (checks always) or onPush */\n    CheckAlways = 16,\n    /** Whether or not this view is currently dirty (needing check) */\n    Dirty = 32,\n    /** Whether or not this view is currently attached to change detection tree. */\n    Attached = 64,\n    /** Whether or not this view is destroyed. */\n    Destroyed = 128,\n    /** Whether or not this view is the root view */\n    IsRoot = 256,\n    /**\n     * Whether this moved LView was needs to be refreshed at the insertion location because the\n     * declaration was dirty.\n     */\n    RefreshTransplantedView = 512,\n    /** Indicates that the view **or any of its ancestors** have an embedded view injector. */\n    HasEmbeddedViewInjector = 1024,\n    /**\n     * Index of the current init phase on last 21 bits\n     */\n    IndexWithinInitPhaseIncrementer = 2048,\n    IndexWithinInitPhaseShift = 11,\n    IndexWithinInitPhaseReset = 2047\n}\n\n/**\n * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy\n * that the compiler should use in case of missing translations:\n * - Error: throw if you have missing translations.\n * - Warning (default): show a warning in the console and/or shell.\n * - Ignore: do nothing.\n *\n * See the [i18n guide](guide/i18n-common-merge#report-missing-translations) for more information.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * import { MissingTranslationStrategy } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   missingTranslation: MissingTranslationStrategy.Error\n * });\n * ```\n *\n * @publicApi\n */\nexport declare enum MissingTranslationStrategy {\n    Error = 0,\n    Warning = 1,\n    Ignore = 2\n}\n\n/**\n * Combination of NgModuleFactory and ComponentFactories.\n *\n * @publicApi\n *\n * @deprecated\n * Ivy JIT mode doesn't require accessing this symbol.\n * See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes) for\n * additional context.\n */\nexport declare class ModuleWithComponentFactories<T> {\n    ngModuleFactory: NgModuleFactory<T>;\n    componentFactories: ComponentFactory<any>[];\n    constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);\n}\n\n/**\n * A wrapper around an NgModule that associates it with [providers](guide/glossary#provider\n * \"Definition\"). Usage without a generic type is deprecated.\n *\n * @see [Deprecations](guide/deprecations#modulewithproviders-type-without-a-generic)\n *\n * @publicApi\n */\nexport declare interface ModuleWithProviders<T> {\n    ngModule: Type<T>;\n    providers?: Provider[];\n}\n\ndeclare const MOVED_VIEWS = 9;\n\ndeclare const NATIVE = 7;\n\ndeclare const NEXT = 4;\n\n/**\n * A type describing supported iterable types.\n *\n * @publicApi\n */\nexport declare type NgIterable<T> = Array<T> | Iterable<T>;\n\n/**\n * Type of the NgModule metadata.\n *\n * @publicApi\n */\nexport declare interface NgModule {\n    /**\n     * The set of injectable objects that are available in the injector\n     * of this module.\n     *\n     * @see [Dependency Injection guide](guide/dependency-injection)\n     * @see [NgModule guide](guide/providers)\n     *\n     * @usageNotes\n     *\n     * Dependencies whose providers are listed here become available for injection\n     * into any component, directive, pipe or service that is a child of this injector.\n     * The NgModule used for bootstrapping uses the root injector, and can provide dependencies\n     * to any part of the app.\n     *\n     * A lazy-loaded module has its own injector, typically a child of the app root injector.\n     * Lazy-loaded services are scoped to the lazy-loaded module's injector.\n     * If a lazy-loaded module also provides the `UserService`, any component created\n     * within that module's context (such as by router navigation) gets the local instance\n     * of the service, not the instance in the root injector.\n     * Components in external modules continue to receive the instance provided by their injectors.\n     *\n     * ### Example\n     *\n     * The following example defines a class that is injected in\n     * the HelloWorld NgModule:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @NgModule({\n     *   providers: [\n     *     Greeter\n     *   ]\n     * })\n     * class HelloWorld {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     * ```\n     */\n    providers?: Provider[];\n    /**\n     * The set of components, directives, and pipes ([declarables](guide/glossary#declarable))\n     * that belong to this module.\n     *\n     * @usageNotes\n     *\n     * The set of selectors that are available to a template include those declared here, and\n     * those that are exported from imported NgModules.\n     *\n     * Declarables must belong to exactly one module.\n     * The compiler emits an error if you try to declare the same class in more than one module.\n     * Be careful not to declare a class that is imported from another module.\n     *\n     * ### Example\n     *\n     * The following example allows the CommonModule to use the `NgFor`\n     * directive.\n     *\n     * ```javascript\n     * @NgModule({\n     *   declarations: [NgFor]\n     * })\n     * class CommonModule {\n     * }\n     * ```\n     */\n    declarations?: Array<Type<any> | any[]>;\n    /**\n     * The set of NgModules whose exported [declarables](guide/glossary#declarable)\n     * are available to templates in this module.\n     *\n     * @usageNotes\n     *\n     * A template can use exported declarables from any\n     * imported module, including those from modules that are imported indirectly\n     * and re-exported.\n     * For example, `ModuleA` imports `ModuleB`, and also exports\n     * it, which makes the declarables from `ModuleB` available\n     * wherever `ModuleA` is imported.\n     *\n     * ### Example\n     *\n     * The following example allows MainModule to use anything exported by\n     * `CommonModule`:\n     *\n     * ```javascript\n     * @NgModule({\n     *   imports: [CommonModule]\n     * })\n     * class MainModule {\n     * }\n     * ```\n     *\n     */\n    imports?: Array<Type<any> | ModuleWithProviders<{}> | any[]>;\n    /**\n     * The set of components, directives, and pipes declared in this\n     * NgModule that can be used in the template of any component that is part of an\n     * NgModule that imports this NgModule. Exported declarations are the module's public API.\n     *\n     * A declarable belongs to one and only one NgModule.\n     * A module can list another module among its exports, in which case all of that module's\n     * public declaration are exported.\n     *\n     * @usageNotes\n     *\n     * Declarations are private by default.\n     * If this ModuleA does not export UserComponent, then only the components within this\n     * ModuleA can use UserComponent.\n     *\n     * ModuleA can import ModuleB and also export it, making exports from ModuleB\n     * available to an NgModule that imports ModuleA.\n     *\n     * ### Example\n     *\n     * The following example exports the `NgFor` directive from CommonModule.\n     *\n     * ```javascript\n     * @NgModule({\n     *   exports: [NgFor]\n     * })\n     * class CommonModule {\n     * }\n     * ```\n     */\n    exports?: Array<Type<any> | any[]>;\n    /**\n     * The set of components to compile when this NgModule is defined,\n     * so that they can be dynamically loaded into the view.\n     *\n     * For each component listed here, Angular creates a `ComponentFactory`\n     * and stores it in the `ComponentFactoryResolver`.\n     *\n     * Angular automatically adds components in the module's bootstrap\n     * and route definitions into the `entryComponents` list. Use this\n     * option to add components that are bootstrapped\n     * using one of the imperative techniques, such as `ViewContainerRef.createComponent()`.\n     *\n     * @see [Entry Components](guide/entry-components)\n     * @deprecated\n     * Since 9.0.0. With Ivy, this property is no longer necessary.\n     * (You may need to keep these if building a library that will be consumed by a View Engine\n     * application.)\n     */\n    entryComponents?: Array<Type<any> | any[]>;\n    /**\n     * The set of components that are bootstrapped when\n     * this module is bootstrapped. The components listed here\n     * are automatically added to `entryComponents`.\n     */\n    bootstrap?: Array<Type<any> | any[]>;\n    /**\n     * The set of schemas that declare elements to be allowed in the NgModule.\n     * Elements and properties that are neither Angular components nor directives\n     * must be declared in a schema.\n     *\n     * Allowed value are `NO_ERRORS_SCHEMA` and `CUSTOM_ELEMENTS_SCHEMA`.\n     *\n     * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA`\n     * you must ensure that allowed elements and properties securely escape inputs.\n     */\n    schemas?: Array<SchemaMetadata | any[]>;\n    /**\n     * A name or path that uniquely identifies this NgModule in `getNgModuleById`.\n     * If left `undefined`, the NgModule is not registered with `getNgModuleById`.\n     */\n    id?: string;\n    /**\n     * When present, this module is ignored by the AOT compiler.\n     * It remains in distributed code, and the JIT compiler attempts to compile it\n     * at run time, in the browser.\n     * To ensure the correct behavior, the app must import `@angular/compiler`.\n     */\n    jit?: true;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const NgModule: NgModuleDecorator;\n\n/**\n * Type of the NgModule decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface NgModuleDecorator {\n    /**\n     * Decorator that marks a class as an NgModule and supplies configuration metadata.\n     */\n    (obj?: NgModule): TypeDecorator;\n    new (obj?: NgModule): NgModule;\n}\n\n/**\n * @publicApi\n *\n * @deprecated\n * This class was mostly used as a part of ViewEngine-based JIT API and is no longer needed in Ivy\n * JIT mode. See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes)\n * for additional context. Angular provides APIs that accept NgModule classes directly (such as\n * [PlatformRef.bootstrapModule](api/core/PlatformRef#bootstrapModule) and\n * [createNgModule](api/core/createNgModule)), consider switching to those APIs instead of\n * using factory-based ones.\n */\nexport declare abstract class NgModuleFactory<T> {\n    abstract get moduleType(): Type<T>;\n    abstract create(parentInjector: Injector | null): NgModuleRef<T>;\n}\n\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\nexport declare abstract class NgModuleRef<T> {\n    /**\n     * The injector that contains all of the providers of the `NgModule`.\n     */\n    abstract get injector(): EnvironmentInjector;\n    /**\n     * The resolver that can retrieve component factories in a context of this module.\n     *\n     * Note: since v13, dynamic component creation via\n     * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n     * does **not** require resolving component factory: component class can be used directly.\n     *\n     * @deprecated Angular no longer requires Component factories. Please use other APIs where\n     *     Component class can be used directly.\n     */\n    abstract get componentFactoryResolver(): ComponentFactoryResolver;\n    /**\n     * The `NgModule` instance.\n     */\n    abstract get instance(): T;\n    /**\n     * Destroys the module instance and all of the data structures associated with it.\n     */\n    abstract destroy(): void;\n    /**\n     * Registers a callback to be executed when the module is destroyed.\n     */\n    abstract onDestroy(callback: () => void): void;\n}\n\n/**\n * A token for third-party components that can register themselves with NgProbe.\n *\n * @publicApi\n */\nexport declare class NgProbeToken {\n    name: string;\n    token: any;\n    constructor(name: string, token: any);\n}\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class NgZone {\n    readonly hasPendingMacrotasks: boolean;\n    readonly hasPendingMicrotasks: boolean;\n    /**\n     * Whether there are no outstanding microtasks or macrotasks.\n     */\n    readonly isStable: boolean;\n    /**\n     * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n     */\n    readonly onUnstable: EventEmitter<any>;\n    /**\n     * Notifies when there is no more microtasks enqueued in the current VM Turn.\n     * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n     * For this reason this event can fire multiple times per VM Turn.\n     */\n    readonly onMicrotaskEmpty: EventEmitter<any>;\n    /**\n     * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n     * implies we are about to relinquish VM turn.\n     * This event gets called just once.\n     */\n    readonly onStable: EventEmitter<any>;\n    /**\n     * Notifies that an error has been delivered.\n     */\n    readonly onError: EventEmitter<any>;\n    constructor({ enableLongStackTrace, shouldCoalesceEventChangeDetection, shouldCoalesceRunChangeDetection }: {\n        enableLongStackTrace?: boolean | undefined;\n        shouldCoalesceEventChangeDetection?: boolean | undefined;\n        shouldCoalesceRunChangeDetection?: boolean | undefined;\n    });\n    static isInAngularZone(): boolean;\n    static assertInAngularZone(): void;\n    static assertNotInAngularZone(): void;\n    /**\n     * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n     * the function.\n     *\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * within the Angular zone.\n     *\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\n     */\n    run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;\n    /**\n     * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n     * returned by the function.\n     *\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * within the Angular zone.\n     *\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\n     */\n    runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T;\n    /**\n     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n     * rethrown.\n     */\n    runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;\n    /**\n     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n     * the function.\n     *\n     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n     * work that\n     * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * outside of the Angular zone.\n     *\n     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n     */\n    runOutsideAngular<T>(fn: (...args: any[]) => T): T;\n}\n\n/**\n * Defines a schema that allows any property on any element.\n *\n * This schema allows you to ignore the errors related to any unknown elements or properties in a\n * template. The usage of this schema is generally discouraged because it prevents useful validation\n * and may hide real errors in your template. Consider using the `CUSTOM_ELEMENTS_SCHEMA` instead.\n *\n * @publicApi\n */\nexport declare const NO_ERRORS_SCHEMA: SchemaMetadata;\n\ndeclare interface NodeInjectorDebug {\n    /**\n     * Instance bloom. Does the current injector have a provider with a given bloom mask.\n     */\n    bloom: string;\n    /**\n     * Cumulative bloom. Do any of the above injectors have a provider with a given bloom mask.\n     */\n    cumulativeBloom: string;\n    /**\n     * A list of providers associated with this injector.\n     */\n    providers: (Type<unknown> | ɵDirectiveDef<unknown> | ɵComponentDef<unknown>)[];\n    /**\n     * A list of providers associated with this injector visible to the view of the component only.\n     */\n    viewProviders: Type<unknown>[];\n    /**\n     * Location of the parent `TNode`.\n     */\n    parentInjectorIndex: number;\n}\n\n/**\n * @description\n * A lifecycle hook that is called when any data-bound property of a directive changes.\n * Define an `ngOnChanges()` method to handle the changes.\n *\n * @see `DoCheck`\n * @see `OnInit`\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define an on-changes handler for an input property.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}\n *\n * @publicApi\n */\nexport declare interface OnChanges {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has checked data-bound properties\n     * if at least one has changed, and before the view and content\n     * children are checked.\n     * @param changes The changed properties.\n     */\n    ngOnChanges(changes: SimpleChanges): void;\n}\n\n/**\n * A lifecycle hook that is called when a directive, pipe, or service is destroyed.\n * Use for any custom cleanup that needs to occur when the\n * instance is destroyed.\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface\n * to define its own custom clean-up method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}\n *\n * @publicApi\n */\nexport declare interface OnDestroy {\n    /**\n     * A callback method that performs custom clean-up, invoked immediately\n     * before a directive, pipe, or service instance is destroyed.\n     */\n    ngOnDestroy(): void;\n}\n\n/**\n * @description\n * A lifecycle hook that is called after Angular has initialized\n * all data-bound properties of a directive.\n * Define an `ngOnInit()` method to handle any additional initialization tasks.\n *\n * @see `AfterContentInit`\n * @see [Lifecycle hooks guide](guide/lifecycle-hooks)\n *\n * @usageNotes\n * The following snippet shows how a component can implement this interface to\n * define its own initialization method.\n *\n * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}\n *\n * @publicApi\n */\nexport declare interface OnInit {\n    /**\n     * A callback method that is invoked immediately after the\n     * default change detector has checked the directive's\n     * data-bound properties for the first time,\n     * and before any of the view or content children have been checked.\n     * It is invoked only once when the directive is instantiated.\n     */\n    ngOnInit(): void;\n}\n\ndeclare type OpaqueValue = unknown;\n\ndeclare interface OpaqueViewState {\n    '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport declare interface Optional {\n}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Optional: OptionalDecorator;\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface OptionalDecorator {\n    /**\n     * Parameter decorator to be used on constructor parameters,\n     * which marks the parameter as being an optional dependency.\n     * The DI framework provides `null` if the dependency is not found.\n     *\n     * Can be used together with other parameter decorators\n     * that modify how dependency injection operates.\n     *\n     * @usageNotes\n     *\n     * The following code allows the possibility of a `null` result:\n     *\n     * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Optional\">\n     * </code-example>\n     *\n     * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n     */\n    (): any;\n    new (): Optional;\n}\n\n/**\n * Type of the Output metadata.\n *\n * @publicApi\n */\nexport declare interface Output {\n    /**\n     * The name of the DOM property to which the output property is bound.\n     */\n    bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const Output: OutputDecorator;\n\n/**\n * Type of the Output decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface OutputDecorator {\n    /**\n     * Decorator that marks a class field as an output property and supplies configuration metadata.\n     * The DOM property bound to the output property is automatically updated during change detection.\n     *\n     * @usageNotes\n     *\n     * You can supply an optional name to use in templates when the\n     * component is instantiated, that maps to the\n     * name of the bound property. By default, the original\n     * name of the bound property is used for output binding.\n     *\n     * See `Input` decorator for an example of providing a binding name.\n     *\n     * @see [Input and Output properties](guide/inputs-outputs)\n     *\n     */\n    (bindingPropertyName?: string): any;\n    new (bindingPropertyName?: string): any;\n}\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates the root directory of\n * the application\n * @publicApi\n */\nexport declare const PACKAGE_ROOT_URL: InjectionToken<string>;\n\ndeclare const PARENT = 3;\n\n/**\n * Type of the Pipe metadata.\n *\n * @publicApi\n */\nexport declare interface Pipe {\n    /**\n     * The pipe name to use in template bindings.\n     * Typically uses [lowerCamelCase](guide/glossary#case-types)\n     * because the name cannot contain hyphens.\n     */\n    name: string;\n    /**\n     * When true, the pipe is pure, meaning that the\n     * `transform()` method is invoked only when its input arguments\n     * change. Pipes are pure by default.\n     *\n     * If the pipe has internal state (that is, the result\n     * depends on state other than its arguments), set `pure` to false.\n     * In this case, the pipe is invoked on each change-detection cycle,\n     * even if the arguments have not changed.\n     */\n    pure?: boolean;\n    /**\n     * Angular pipes marked as `standalone` do not need to be declared in an NgModule. Such\n     * pipes don't depend on any \"intermediate context\" of an NgModule (ex. configured providers).\n     *\n     * More information about standalone components, directives, and pipes can be found in [this\n     * guide](guide/standalone-components).\n     */\n    standalone?: boolean;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport declare const Pipe: PipeDecorator;\n\n/**\n * Type of the Pipe decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface PipeDecorator {\n    /**\n     *\n     * Decorator that marks a class as pipe and supplies configuration metadata.\n     *\n     * A pipe class must implement the `PipeTransform` interface.\n     * For example, if the name is \"myPipe\", use a template binding expression\n     * such as the following:\n     *\n     * ```\n     * {{ exp | myPipe }}\n     * ```\n     *\n     * The result of the expression is passed to the pipe's `transform()` method.\n     *\n     * A pipe must belong to an NgModule in order for it to be available\n     * to a template. To make it a member of an NgModule,\n     * list it in the `declarations` field of the `NgModule` metadata.\n     *\n     * @see [Style Guide: Pipe Names](guide/styleguide#02-09)\n     *\n     */\n    (obj: Pipe): TypeDecorator;\n    /**\n     * See the `Pipe` decorator.\n     */\n    new (obj: Pipe): Pipe;\n}\n\ndeclare type PipeDefList = ɵPipeDef<any>[];\n\n/**\n * Type used for PipeDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\ndeclare type PipeDefListOrFactory = (() => PipeDefList) | PipeDefList;\n\n\n/**\n * An interface that is implemented by pipes in order to perform a transformation.\n * Angular invokes the `transform` method with the value of a binding\n * as the first argument, and any parameters as the second argument in list form.\n *\n * @usageNotes\n *\n * In the following example, `TruncatePipe` returns the shortened value with an added ellipses.\n *\n * <code-example path=\"core/ts/pipes/simple_truncate.ts\" header=\"simple_truncate.ts\"></code-example>\n *\n * Invoking `{{ 'It was the best of times' | truncate }}` in a template will produce `It was...`.\n *\n * In the following example, `TruncatePipe` takes parameters that sets the truncated length and the\n * string to append with.\n *\n * <code-example path=\"core/ts/pipes/truncate.ts\" header=\"truncate.ts\"></code-example>\n *\n * Invoking `{{ 'It was the best of times' | truncate:4:'....' }}` in a template will produce `It\n * was the best....`.\n *\n * @publicApi\n */\nexport declare interface PipeTransform {\n    transform(value: any, ...args: any[]): any;\n}\n\n/**\n * A subclass of `Type` which has a static `ɵpipe`:`PipeDef` field making it\n * consumable for rendering.\n */\ndeclare interface PipeType<T> extends Type<T> {\n    ɵpipe: unknown;\n}\n\n/**\n * A token that indicates an opaque platform ID.\n * @publicApi\n */\nexport declare const PLATFORM_ID: InjectionToken<Object>;\n\n/**\n * A function that is executed when a platform is initialized.\n * @publicApi\n */\nexport declare const PLATFORM_INITIALIZER: InjectionToken<(() => void)[]>;\n\n/**\n * This platform has to be included in any other platform\n *\n * @publicApi\n */\nexport declare const platformCore: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;\n\n/**\n * The Angular platform is the entry point for Angular on a web page.\n * Each page has exactly one platform. Services (such as reflection) which are common\n * to every Angular application running on the page are bound in its scope.\n * A page's platform is initialized implicitly when a platform is created using a platform\n * factory such as `PlatformBrowser`, or explicitly by calling the `createPlatform()` function.\n *\n * @publicApi\n */\nexport declare class PlatformRef {\n    private _injector;\n    private _modules;\n    private _destroyListeners;\n    private _destroyed;\n    /**\n     * Creates an instance of an `@NgModule` for the given platform.\n     *\n     * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function\n     *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.\n     */\n    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions): Promise<NgModuleRef<M>>;\n    /**\n     * Creates an instance of an `@NgModule` for a given platform.\n     *\n     * @usageNotes\n     * ### Simple Example\n     *\n     * ```typescript\n     * @NgModule({\n     *   imports: [BrowserModule]\n     * })\n     * class MyModule {}\n     *\n     * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n     * ```\n     *\n     */\n    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: (CompilerOptions & BootstrapOptions) | Array<CompilerOptions & BootstrapOptions>): Promise<NgModuleRef<M>>;\n    private _moduleDoBootstrap;\n    /**\n     * Registers a listener to be called when the platform is destroyed.\n     */\n    onDestroy(callback: () => void): void;\n    /**\n     * Retrieves the platform {@link Injector}, which is the parent injector for\n     * every Angular application on the page and provides singleton providers.\n     */\n    get injector(): Injector;\n    /**\n     * Destroys the current Angular platform and all Angular applications on the page.\n     * Destroys all modules and listeners registered with the platform.\n     */\n    destroy(): void;\n    /**\n     * Indicates whether this instance was destroyed.\n     */\n    get destroyed(): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<PlatformRef, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<PlatformRef>;\n}\n\ndeclare interface PlatformReflectionCapabilities {\n    factory(type: Type<any>): Function;\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\n    /**\n     * Return a list of annotations/types for constructor parameters\n     */\n    parameters(type: Type<any>): any[][];\n    /**\n     * Return a list of annotations declared on the class\n     */\n    annotations(type: Type<any>): any[];\n    /**\n     * Return a object literal which describes the annotations on Class fields/properties.\n     */\n    propMetadata(typeOrFunc: Type<any>): {\n        [key: string]: any[];\n    };\n}\n\n/**\n * A boolean-valued function over a value, possibly including context information\n * regarding that value's position in an array.\n *\n * @publicApi\n */\nexport declare interface Predicate<T> {\n    (value: T): boolean;\n}\n\ndeclare const PREORDER_HOOK_FLAGS = 18;\n\n/** More flags associated with an LView (saved in LView[PREORDER_HOOK_FLAGS]) */\ndeclare const enum PreOrderHookFlags {\n    /**\n     The index of the next pre-order hook to be called in the hooks array, on the first 16\n     bits\n     */\n    IndexOfTheNextPreOrderHookMaskMask = 65535,\n    /**\n     * The number of init hooks that have already been called, on the last 16 bits\n     */\n    NumberOfInitHooksCalledIncrementer = 65536,\n    NumberOfInitHooksCalledShift = 16,\n    NumberOfInitHooksCalledMask = 4294901760\n}\n\n/**\n * Describes a function that is used to process provider lists (such as provider\n * overrides).\n */\ndeclare type ProcessProvidersFunction = (providers: Provider[]) => Provider[];\n\n/**\n * List of slots for a projection. A slot can be either based on a parsed CSS selector\n * which will be used to determine nodes which are projected into that slot.\n *\n * When set to \"*\", the slot is reserved and can be used for multi-slot projection\n * using {@link ViewContainerRef#createComponent}. The last slot that specifies the\n * wildcard selector will retrieve all projectable nodes which do not match any selector.\n */\ndeclare type ProjectionSlots = (ɵCssSelectorList | '*')[];\n\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\ndeclare type PropertyAliases = {\n    [key: string]: PropertyAliasValue;\n};\n\n/**\n * Store the runtime input or output names for all the directives.\n *\n * i+0: directive instance index\n * i+1: privateName\n *\n * e.g. [0, 'change-minified']\n */\ndeclare type PropertyAliasValue = (number | string)[];\n\n/**\n * Describes how the `Injector` should be configured.\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @see `StaticProvider`\n *\n * @publicApi\n */\nexport declare type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];\n\n/**\n * @description\n *\n * Token that can be used to retrieve an instance from an injector or through a query.\n *\n * @publicApi\n */\nexport declare type ProviderToken<T> = Type<T> | AbstractType<T> | InjectionToken<T>;\n\n/**\n * Testability API.\n * `declare` keyword causes tsickle to generate externs, so these methods are\n * not renamed by Closure Compiler.\n * @publicApi\n */\ndeclare interface PublicTestability {\n    isStable(): boolean;\n    whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;\n    findProviders(using: any, provider: string, exactMatch: boolean): any[];\n}\n\ndeclare const QUERIES = 19;\n\n/**\n * Type of the Query metadata.\n *\n * @publicApi\n */\nexport declare interface Query {\n    descendants: boolean;\n    emitDistinctChangesOnly: boolean;\n    first: boolean;\n    read: any;\n    isViewQuery: boolean;\n    selector: any;\n    static?: boolean;\n}\n\n/**\n * Base class for query metadata.\n *\n * @see `ContentChildren`.\n * @see `ContentChild`.\n * @see `ViewChildren`.\n * @see `ViewChild`.\n *\n * @publicApi\n */\nexport declare abstract class Query {\n}\n\n/**\n * A set of flags to be used with Queries.\n *\n * NOTE: Ensure changes here are reflected in `packages/compiler/src/render3/view/compiler.ts`\n */\ndeclare const enum QueryFlags {\n    /**\n     * No flags\n     */\n    none = 0,\n    /**\n     * Whether or not the query should descend into children.\n     */\n    descendants = 1,\n    /**\n     * The query can be computed statically and hence can be assigned eagerly.\n     *\n     * NOTE: Backwards compatibility with ViewEngine.\n     */\n    isStatic = 2,\n    /**\n     * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n     * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n     * query resulted in the same list.)\n     */\n    emitDistinctChangesOnly = 4\n}\n\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class QueryList<T> implements Iterable<T> {\n    private _emitDistinctChangesOnly;\n    readonly dirty = true;\n    private _results;\n    private _changesDetected;\n    private _changes;\n    readonly length: number;\n    readonly first: T;\n    readonly last: T;\n    /**\n     * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n     */\n    get changes(): Observable<any>;\n    /**\n     * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n     *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n     *     the same result)\n     */\n    constructor(_emitDistinctChangesOnly?: boolean);\n    /**\n     * Returns the QueryList entry at `index`.\n     */\n    get(index: number): T | undefined;\n    /**\n     * See\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n     */\n    map<U>(fn: (item: T, index: number, array: T[]) => U): U[];\n    /**\n     * See\n     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n     */\n    filter(fn: (item: T, index: number, array: T[]) => boolean): T[];\n    /**\n     * See\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n     */\n    find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;\n    /**\n     * See\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n     */\n    reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;\n    /**\n     * See\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n     */\n    forEach(fn: (item: T, index: number, array: T[]) => void): void;\n    /**\n     * See\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n     */\n    some(fn: (value: T, index: number, array: T[]) => boolean): boolean;\n    /**\n     * Returns a copy of the internal results list as an Array.\n     */\n    toArray(): T[];\n    toString(): string;\n    /**\n     * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n     * on change detection, it will not notify of changes to the queries, unless a new change\n     * occurs.\n     *\n     * @param resultsTree The query results to store\n     * @param identityAccessor Optional function for extracting stable object identity from a value\n     *    in the array. This function is executed for each element of the query result list while\n     *    comparing current query list with the new one (provided as a first argument of the `reset`\n     *    function) to detect if the lists are different. If the function is not provided, elements\n     *    are compared as is (without any pre-processing).\n     */\n    reset(resultsTree: Array<T | any[]>, identityAccessor?: (value: T) => unknown): void;\n    /**\n     * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n     */\n    notifyOnChanges(): void;\n    /** internal */\n    setDirty(): void;\n    /** internal */\n    destroy(): void;\n    [Symbol.iterator]: () => Iterator<T>;\n}\n\ndeclare interface R3DeclareComponentFacade extends R3DeclareDirectiveFacade {\n    template: string;\n    isInline?: boolean;\n    styles?: string[];\n    dependencies?: R3DeclareTemplateDependencyFacade[];\n    components?: R3DeclareDirectiveDependencyFacade[];\n    directives?: R3DeclareDirectiveDependencyFacade[];\n    pipes?: {\n        [pipeName: string]: OpaqueValue | (() => OpaqueValue);\n    };\n    viewProviders?: OpaqueValue;\n    animations?: OpaqueValue;\n    changeDetection?: ChangeDetectionStrategy_2;\n    encapsulation?: ViewEncapsulation_2;\n    interpolation?: [string, string];\n    preserveWhitespaces?: boolean;\n}\n\ndeclare interface R3DeclareDependencyMetadataFacade {\n    token: OpaqueValue;\n    attribute?: boolean;\n    host?: boolean;\n    optional?: boolean;\n    self?: boolean;\n    skipSelf?: boolean;\n}\n\ndeclare interface R3DeclareDirectiveDependencyFacade {\n    kind?: 'directive' | 'component';\n    selector: string;\n    type: OpaqueValue | (() => OpaqueValue);\n    inputs?: string[];\n    outputs?: string[];\n    exportAs?: string[];\n}\n\ndeclare interface R3DeclareDirectiveFacade {\n    selector?: string;\n    type: Type_2;\n    inputs?: {\n        [classPropertyName: string]: string | [string, string];\n    };\n    outputs?: {\n        [classPropertyName: string]: string;\n    };\n    host?: {\n        attributes?: {\n            [key: string]: OpaqueValue;\n        };\n        listeners?: {\n            [key: string]: string;\n        };\n        properties?: {\n            [key: string]: string;\n        };\n        classAttribute?: string;\n        styleAttribute?: string;\n    };\n    queries?: R3DeclareQueryMetadataFacade[];\n    viewQueries?: R3DeclareQueryMetadataFacade[];\n    providers?: OpaqueValue;\n    exportAs?: string[];\n    usesInheritance?: boolean;\n    usesOnChanges?: boolean;\n    isStandalone?: boolean;\n}\n\ndeclare interface R3DeclareFactoryFacade {\n    type: Type_2;\n    deps: R3DeclareDependencyMetadataFacade[] | 'invalid' | null;\n    target: ɵɵFactoryTarget;\n}\n\ndeclare interface R3DeclareInjectableFacade {\n    type: Type_2;\n    providedIn?: Type_2 | 'root' | 'platform' | 'any' | null;\n    useClass?: OpaqueValue;\n    useFactory?: OpaqueValue;\n    useExisting?: OpaqueValue;\n    useValue?: OpaqueValue;\n    deps?: R3DeclareDependencyMetadataFacade[];\n}\n\ndeclare interface R3DeclareInjectorFacade {\n    type: Type_2;\n    imports?: OpaqueValue[];\n    providers?: OpaqueValue[];\n}\n\ndeclare interface R3DeclareNgModuleDependencyFacade {\n    kind: 'ngmodule';\n    type: OpaqueValue | (() => OpaqueValue);\n}\n\ndeclare interface R3DeclareNgModuleFacade {\n    type: Type_2;\n    bootstrap?: OpaqueValue[] | (() => OpaqueValue[]);\n    declarations?: OpaqueValue[] | (() => OpaqueValue[]);\n    imports?: OpaqueValue[] | (() => OpaqueValue[]);\n    exports?: OpaqueValue[] | (() => OpaqueValue[]);\n    schemas?: OpaqueValue[];\n    id?: OpaqueValue;\n}\n\ndeclare interface R3DeclarePipeDependencyFacade {\n    kind?: 'pipe';\n    name: string;\n    type: OpaqueValue | (() => OpaqueValue);\n}\n\ndeclare interface R3DeclarePipeFacade {\n    type: Type_2;\n    name: string;\n    pure?: boolean;\n    isStandalone?: boolean;\n}\n\ndeclare interface R3DeclareQueryMetadataFacade {\n    propertyName: string;\n    first?: boolean;\n    predicate: OpaqueValue | string[];\n    descendants?: boolean;\n    read?: OpaqueValue;\n    static?: boolean;\n    emitDistinctChangesOnly?: boolean;\n}\n\ndeclare type R3DeclareTemplateDependencyFacade = {\n    kind: string;\n} & (R3DeclareDirectiveDependencyFacade | R3DeclarePipeDependencyFacade | R3DeclareNgModuleDependencyFacade);\n\ndeclare class R3Injector extends EnvironmentInjector {\n    readonly parent: Injector;\n    readonly source: string | null;\n    readonly scopes: Set<InjectorScope>;\n    /**\n     * Map of tokens to records which contain the instances of those tokens.\n     * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n     * to prevent further searches.\n     */\n    private records;\n    /**\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n     */\n    private _ngOnDestroyHooks;\n    private _onDestroyHooks;\n    /**\n     * Flag indicating that this injector was previously destroyed.\n     */\n    get destroyed(): boolean;\n    private _destroyed;\n    private injectorDefTypes;\n    constructor(providers: Array<Provider | ImportedNgModuleProviders>, parent: Injector, source: string | null, scopes: Set<InjectorScope>);\n    /**\n     * Destroy the injector and release references to every instance or provider associated with it.\n     *\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n     * hook was found.\n     */\n    destroy(): void;\n    onDestroy(callback: () => void): void;\n    runInContext<ReturnT>(fn: () => ReturnT): ReturnT;\n    get<T>(token: ProviderToken<T>, notFoundValue?: any, flags?: InjectFlags): T;\n    toString(): string;\n    private assertNotDestroyed;\n    /**\n     * Process a `SingleProvider` and add it.\n     */\n    private processProvider;\n    private hydrate;\n    private injectableDefInScope;\n}\n\ndeclare interface RComment extends RNode {\n    textContent: string | null;\n}\n\ndeclare interface RCssStyleDeclaration {\n    removeProperty(propertyName: string): string;\n    setProperty(propertyName: string, value: string | null, priority?: string): void;\n}\n\ndeclare interface RDomTokenList {\n    add(token: string): void;\n    remove(token: string): void;\n}\n\n/**\n * Creates an object that allows to retrieve component metadata.\n *\n * @usageNotes\n *\n * The example below demonstrates how to use the function and how the fields\n * of the returned object map to the component metadata.\n *\n * ```typescript\n * @Component({\n *   standalone: true,\n *   selector: 'foo-component',\n *   template: `\n *     <ng-content></ng-content>\n *     <ng-content select=\"content-selector-a\"></ng-content>\n *   `,\n * })\n * class FooComponent {\n *   @Input('inputName') inputPropName: string;\n *   @Output('outputName') outputPropName = new EventEmitter<void>();\n * }\n *\n * const mirror = reflectComponentType(FooComponent);\n * expect(mirror.type).toBe(FooComponent);\n * expect(mirror.selector).toBe('foo-component');\n * expect(mirror.isStandalone).toBe(true);\n * expect(mirror.inputs).toEqual([{propName: 'inputName', templateName: 'inputPropName'}]);\n * expect(mirror.outputs).toEqual([{propName: 'outputName', templateName: 'outputPropName'}]);\n * expect(mirror.ngContentSelectors).toEqual([\n *   '*',                 // first `<ng-content>` in a template, the selector defaults to `*`\n *   'content-selector-a' // second `<ng-content>` in a template\n * ]);\n * ```\n *\n * @param component Component class reference.\n * @returns An object that allows to retrieve component metadata.\n *\n * @publicApi\n */\nexport declare function reflectComponentType<C>(component: Type<C>): ComponentMirror<C> | null;\n\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\ndeclare class ReflectiveDependency {\n    key: ReflectiveKey;\n    optional: boolean;\n    visibility: Self | SkipSelf | null;\n    constructor(key: ReflectiveKey, optional: boolean, visibility: Self | SkipSelf | null);\n    static fromKey(key: ReflectiveKey): ReflectiveDependency;\n}\n\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * TODO: delete in v14.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\nexport declare abstract class ReflectiveInjector implements Injector {\n    /**\n     * Turns an array of provider definitions into an array of resolved providers.\n     *\n     * A resolution is a process of flattening multiple nested arrays and converting individual\n     * providers into an array of `ResolvedReflectiveProvider`s.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n     *\n     * expect(providers.length).toEqual(2);\n     *\n     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n     * expect(providers[0].key.displayName).toBe(\"Car\");\n     * expect(providers[0].dependencies.length).toEqual(1);\n     * expect(providers[0].factory).toBeDefined();\n     *\n     * expect(providers[1].key.displayName).toBe(\"Engine\");\n     * });\n     * ```\n     *\n     */\n    static resolve(providers: Provider[]): ResolvedReflectiveProvider[];\n    /**\n     * Resolves an array of providers and creates an injector from those providers.\n     *\n     * The passed-in providers can be an array of `Type`, `Provider`,\n     * or a recursive array of more providers.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector;\n    /**\n     * Creates an injector from previously resolved providers.\n     *\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, Engine]);\n     * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector): ReflectiveInjector;\n    /**\n     * Parent of this injector.\n     *\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n     * -->\n     */\n    abstract get parent(): Injector | null;\n    /**\n     * Resolves an array of providers and creates a child injector from those providers.\n     *\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n     * -->\n     *\n     * The passed-in providers can be an array of `Type`, `Provider`,\n     * or a recursive array of more providers.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * class ParentProvider {}\n     * class ChildProvider {}\n     *\n     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n     * var child = parent.resolveAndCreateChild([ChildProvider]);\n     *\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n     * ```\n     */\n    abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n    /**\n     * Creates a child injector from previously resolved providers.\n     *\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n     * -->\n     *\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * class ParentProvider {}\n     * class ChildProvider {}\n     *\n     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n     *\n     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n     * var child = parent.createChildFromResolved(childProviders);\n     *\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n     * ```\n     */\n    abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n    /**\n     * Resolves a provider and instantiates an object in the context of the injector.\n     *\n     * The created object does not get cached by the injector.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n     *\n     * var car = injector.resolveAndInstantiate(Car);\n     * expect(car.engine).toBe(injector.get(Engine));\n     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n     * ```\n     */\n    abstract resolveAndInstantiate(provider: Provider): any;\n    /**\n     * Instantiates an object using a resolved provider in the context of the injector.\n     *\n     * The created object does not get cached by the injector.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n     * var carProvider = ReflectiveInjector.resolve([Car])[0];\n     * var car = injector.instantiateResolved(carProvider);\n     * expect(car.engine).toBe(injector.get(Engine));\n     * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n     * ```\n     */\n    abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n    abstract get(token: any, notFoundValue?: any): any;\n}\n\n\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\nexport declare class ReflectiveKey {\n    token: Object;\n    id: number;\n    readonly displayName: string;\n    /**\n     * Private\n     */\n    constructor(token: Object, id: number);\n    /**\n     * Retrieves a `Key` for a token.\n     */\n    static get(token: Object): ReflectiveKey;\n    /**\n     * @returns the number of keys registered in the system.\n     */\n    static get numberOfKeys(): number;\n}\n\n/**\n * Subset of API needed for writing attributes, properties, and setting up\n * listeners on Element.\n */\ndeclare interface RElement extends RNode {\n    style: RCssStyleDeclaration;\n    classList: RDomTokenList;\n    className: string;\n    tagName: string;\n    textContent: string | null;\n    setAttribute(name: string, value: string | TrustedHTML | TrustedScript | TrustedScriptURL): void;\n    removeAttribute(name: string): void;\n    setAttributeNS(namespaceURI: string, qualifiedName: string, value: string | TrustedHTML | TrustedScript | TrustedScriptURL): void;\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\n    removeEventListener(type: string, listener?: EventListener, options?: boolean): void;\n    setProperty?(name: string, value: any): void;\n}\n\ndeclare const RENDERER = 11;\n\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. In practice, this is implemented by `Renderer2`.\n */\ndeclare interface Renderer {\n    destroy(): void;\n    createComment(value: string): RComment;\n    createElement(name: string, namespace?: string | null): RElement;\n    createText(value: string): RText;\n    /**\n     * This property is allowed to be null / undefined,\n     * in which case the view engine won't call it.\n     * This is used as a performance optimization for production mode.\n     */\n    destroyNode?: ((node: RNode) => void) | null;\n    appendChild(parent: RElement, newChild: RNode): void;\n    insertBefore(parent: RNode, newChild: RNode, refChild: RNode | null, isMove?: boolean): void;\n    removeChild(parent: RElement, oldChild: RNode, isHostElement?: boolean): void;\n    selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): RElement;\n    parentNode(node: RNode): RElement | null;\n    nextSibling(node: RNode): RNode | null;\n    setAttribute(el: RElement, name: string, value: string | TrustedHTML | TrustedScript | TrustedScriptURL, namespace?: string | null): void;\n    removeAttribute(el: RElement, name: string, namespace?: string | null): void;\n    addClass(el: RElement, name: string): void;\n    removeClass(el: RElement, name: string): void;\n    setStyle(el: RElement, style: string, value: any, flags?: RendererStyleFlags2): void;\n    removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2): void;\n    setProperty(el: RElement, name: string, value: any): void;\n    setValue(node: RText | RComment, value: string): void;\n    listen(target: GlobalTargetName | RNode, eventName: string, callback: (event: any) => boolean | void): () => void;\n}\n\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nexport declare abstract class Renderer2 {\n    /**\n     * Use to store arbitrary developer-defined data on a renderer instance,\n     * as an object containing key-value pairs.\n     * This is useful for renderers that delegate to other renderers.\n     */\n    abstract get data(): {\n        [key: string]: any;\n    };\n    /**\n     * Implement this callback to destroy the renderer or the host element.\n     */\n    abstract destroy(): void;\n    /**\n     * Implement this callback to create an instance of the host element.\n     * @param name An identifying name for the new element, unique within the namespace.\n     * @param namespace The namespace for the new element.\n     * @returns The new element.\n     */\n    abstract createElement(name: string, namespace?: string | null): any;\n    /**\n     * Implement this callback to add a comment to the DOM of the host element.\n     * @param value The comment text.\n     * @returns The modified element.\n     */\n    abstract createComment(value: string): any;\n    /**\n     * Implement this callback to add text to the DOM of the host element.\n     * @param value The text string.\n     * @returns The modified element.\n     */\n    abstract createText(value: string): any;\n    /**\n     * If null or undefined, the view engine won't call it.\n     * This is used as a performance optimization for production mode.\n     */\n    destroyNode: ((node: any) => void) | null;\n    /**\n     * Appends a child to a given parent node in the host element DOM.\n     * @param parent The parent node.\n     * @param newChild The new child node.\n     */\n    abstract appendChild(parent: any, newChild: any): void;\n    /**\n     * Implement this callback to insert a child node at a given position in a parent node\n     * in the host element DOM.\n     * @param parent The parent node.\n     * @param newChild The new child nodes.\n     * @param refChild The existing child node before which `newChild` is inserted.\n     * @param isMove Optional argument which signifies if the current `insertBefore` is a result of a\n     *     move. Animation uses this information to trigger move animations. In the past the Animation\n     *     would always assume that any `insertBefore` is a move. This is not strictly true because\n     *     with runtime i18n it is possible to invoke `insertBefore` as a result of i18n and it should\n     *     not trigger an animation move.\n     */\n    abstract insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void;\n    /**\n     * Implement this callback to remove a child node from the host element's DOM.\n     * @param parent The parent node.\n     * @param oldChild The child node to remove.\n     * @param isHostElement Optionally signal to the renderer whether this element is a host element\n     * or not\n     */\n    abstract removeChild(parent: any, oldChild: any, isHostElement?: boolean): void;\n    /**\n     * Implement this callback to prepare an element to be bootstrapped\n     * as a root element, and return the element instance.\n     * @param selectorOrNode The DOM element.\n     * @param preserveContent Whether the contents of the root element\n     * should be preserved, or cleared upon bootstrap (default behavior).\n     * Use with `ViewEncapsulation.ShadowDom` to allow simple native\n     * content projection via `<slot>` elements.\n     * @returns The root element.\n     */\n    abstract selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;\n    /**\n     * Implement this callback to get the parent of a given node\n     * in the host element's DOM.\n     * @param node The child node to query.\n     * @returns The parent node, or null if there is no parent.\n     * For WebWorkers, always returns true.\n     * This is because the check is synchronous,\n     * and the caller can't rely on checking for null.\n     */\n    abstract parentNode(node: any): any;\n    /**\n     * Implement this callback to get the next sibling node of a given node\n     * in the host element's DOM.\n     * @returns The sibling node, or null if there is no sibling.\n     * For WebWorkers, always returns a value.\n     * This is because the check is synchronous,\n     * and the caller can't rely on checking for null.\n     */\n    abstract nextSibling(node: any): any;\n    /**\n     * Implement this callback to set an attribute value for an element in the DOM.\n     * @param el The element.\n     * @param name The attribute name.\n     * @param value The new value.\n     * @param namespace The namespace.\n     */\n    abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;\n    /**\n     * Implement this callback to remove an attribute from an element in the DOM.\n     * @param el The element.\n     * @param name The attribute name.\n     * @param namespace The namespace.\n     */\n    abstract removeAttribute(el: any, name: string, namespace?: string | null): void;\n    /**\n     * Implement this callback to add a class to an element in the DOM.\n     * @param el The element.\n     * @param name The class name.\n     */\n    abstract addClass(el: any, name: string): void;\n    /**\n     * Implement this callback to remove a class from an element in the DOM.\n     * @param el The element.\n     * @param name The class name.\n     */\n    abstract removeClass(el: any, name: string): void;\n    /**\n     * Implement this callback to set a CSS style for an element in the DOM.\n     * @param el The element.\n     * @param style The name of the style.\n     * @param value The new value.\n     * @param flags Flags for style variations. No flags are set by default.\n     */\n    abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;\n    /**\n     * Implement this callback to remove the value from a CSS style for an element in the DOM.\n     * @param el The element.\n     * @param style The name of the style.\n     * @param flags Flags for style variations to remove, if set. ???\n     */\n    abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;\n    /**\n     * Implement this callback to set the value of a property of an element in the DOM.\n     * @param el The element.\n     * @param name The property name.\n     * @param value The new value.\n     */\n    abstract setProperty(el: any, name: string, value: any): void;\n    /**\n     * Implement this callback to set the value of a node in the host element.\n     * @param node The node.\n     * @param value The new value.\n     */\n    abstract setValue(node: any, value: string): void;\n    /**\n     * Implement this callback to start an event listener.\n     * @param target The context in which to listen for events. Can be\n     * the entire window or document, the body of the document, or a specific\n     * DOM element.\n     * @param eventName The event to listen for.\n     * @param callback A handler function to invoke when the event occurs.\n     * @returns An \"unlisten\" function for disposing of this handler.\n     */\n    abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;\n}\n\ndeclare const RENDERER_FACTORY = 10;\n\ndeclare interface RendererFactory {\n    createRenderer(hostElement: RElement | null, rendererType: RendererType2 | null): Renderer;\n    begin?(): void;\n    end?(): void;\n}\n\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nexport declare abstract class RendererFactory2 {\n    /**\n     * Creates and initializes a custom renderer for a host DOM element.\n     * @param hostElement The element to render.\n     * @param type The base class to implement.\n     * @returns The new custom renderer instance.\n     */\n    abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;\n    /**\n     * A callback invoked when rendering has begun.\n     */\n    abstract begin?(): void;\n    /**\n     * A callback invoked when rendering has completed.\n     */\n    abstract end?(): void;\n    /**\n     * Use with animations test-only mode. Notifies the test when rendering has completed.\n     * @returns The asynchronous result of the developer-defined function.\n     */\n    abstract whenRenderingDone?(): Promise<any>;\n}\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nexport declare enum RendererStyleFlags2 {\n    /**\n     * Marks a style as important.\n     */\n    Important = 1,\n    /**\n     * Marks a style as using dash case naming (this-is-dash-case).\n     */\n    DashCase = 2\n}\n\n/**\n * Used by `RendererFactory2` to associate custom rendering data and styles\n * with a rendering implementation.\n *  @publicApi\n */\nexport declare interface RendererType2 {\n    /**\n     * A unique identifying string for the new renderer, used when creating\n     * unique styles for encapsulation.\n     */\n    id: string;\n    /**\n     * The view encapsulation type, which determines how styles are applied to\n     * DOM elements. One of\n     * - `Emulated` (default): Emulate native scoping of styles.\n     * - `Native`: Use the native encapsulation mechanism of the renderer.\n     * - `ShadowDom`: Use modern [Shadow\n     * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n     * create a ShadowRoot for component's host element.\n     * - `None`: Do not provide any template or style encapsulation.\n     */\n    encapsulation: ViewEncapsulation;\n    /**\n     * Defines CSS styles to be stored on a renderer instance.\n     */\n    styles: (string | any[])[];\n    /**\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\n     * This is useful for renderers that delegate to other renderers.\n     */\n    data: {\n        [kind: string]: any;\n    };\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @publicApi\n */\nexport declare class ResolvedReflectiveFactory {\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    factory: Function;\n    /**\n     * Arguments (dependencies) to the `factory` function.\n     */\n    dependencies: ReflectiveDependency[];\n    constructor(\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    factory: Function, \n    /**\n     * Arguments (dependencies) to the `factory` function.\n     */\n    dependencies: ReflectiveDependency[]);\n}\n\n/**\n * An internal resolved representation of a `Provider` used by the `Injector`.\n *\n * @usageNotes\n * This is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @publicApi\n */\nexport declare interface ResolvedReflectiveProvider {\n    /**\n     * A key, usually a `Type<any>`.\n     */\n    key: ReflectiveKey;\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    resolvedFactories: ResolvedReflectiveFactory[];\n    /**\n     * Indicates if the provider is a multi-provider or a regular provider.\n     */\n    multiProvider: boolean;\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nexport declare function resolveForwardRef<T>(type: T): T;\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and then\n * use that at runtime for rendering.\n *\n * At runtime we can then use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\n/** Subset of API needed for appending elements and text nodes. */\ndeclare interface RNode {\n    /**\n     * Returns the parent Element, Document, or DocumentFragment\n     */\n    parentNode: RNode | null;\n    /**\n     * Returns the parent Element if there is one\n     */\n    parentElement: RElement | null;\n    /**\n     * Gets the Node immediately following this one in the parent's childNodes\n     */\n    nextSibling: RNode | null;\n    /**\n     * Removes a child from the current node and returns the removed node\n     * @param oldChild the child node to remove\n     */\n    removeChild(oldChild: RNode): RNode;\n    /**\n     * Insert a child node.\n     *\n     * Used exclusively for adding View root nodes into ViewAnchor location.\n     */\n    insertBefore(newChild: RNode, refChild: RNode | null, isViewRoot: boolean): void;\n    /**\n     * Append a child node.\n     *\n     * Used exclusively for building up DOM which are static (ie not View roots)\n     */\n    appendChild(newChild: RNode): RNode;\n}\n\ndeclare interface RText extends RNode {\n    textContent: string | null;\n}\n\n\n/**\n * The list of error codes used in runtime code of the `core` package.\n * Reserved error code range: 100-999.\n *\n * Note: the minus sign denotes the fact that a particular code has a detailed guide on\n * angular.io. This extra annotation is needed to avoid introducing a separate set to store\n * error codes which have guides, which might leak into runtime code.\n *\n * Full list of available error guides can be found at https://angular.io/errors.\n */\ndeclare const enum RuntimeErrorCode {\n    EXPRESSION_CHANGED_AFTER_CHECKED = -100,\n    RECURSIVE_APPLICATION_REF_TICK = 101,\n    CYCLIC_DI_DEPENDENCY = -200,\n    PROVIDER_NOT_FOUND = -201,\n    INVALID_FACTORY_DEPENDENCY = 202,\n    MISSING_INJECTION_CONTEXT = -203,\n    INVALID_INJECTION_TOKEN = 204,\n    INJECTOR_ALREADY_DESTROYED = 205,\n    PROVIDER_IN_WRONG_CONTEXT = 207,\n    MISSING_INJECTION_TOKEN = 208,\n    INVALID_MULTI_PROVIDER = 209,\n    MULTIPLE_COMPONENTS_MATCH = -300,\n    EXPORT_NOT_FOUND = -301,\n    PIPE_NOT_FOUND = -302,\n    UNKNOWN_BINDING = 303,\n    UNKNOWN_ELEMENT = 304,\n    TEMPLATE_STRUCTURE_ERROR = 305,\n    INVALID_EVENT_BINDING = 306,\n    MULTIPLE_PLATFORMS = 400,\n    PLATFORM_NOT_FOUND = 401,\n    ERROR_HANDLER_NOT_FOUND = 402,\n    BOOTSTRAP_COMPONENTS_NOT_FOUND = 403,\n    PLATFORM_ALREADY_DESTROYED = 404,\n    ASYNC_INITIALIZERS_STILL_RUNNING = 405,\n    APPLICATION_REF_ALREADY_DESTROYED = 406,\n    RENDERER_NOT_FOUND = 407,\n    INVALID_I18N_STRUCTURE = 700,\n    MISSING_LOCALE_DATA = 701,\n    IMPORT_PROVIDERS_FROM_STANDALONE = 800,\n    INVALID_DIFFER_INPUT = 900,\n    NO_SUPPORTING_DIFFER_FACTORY = 901,\n    VIEW_ALREADY_ATTACHED = 902,\n    INVALID_INHERITANCE = 903,\n    UNSAFE_VALUE_IN_RESOURCE_URL = 904,\n    UNSAFE_VALUE_IN_SCRIPT = 905,\n    MISSING_GENERATED_DEF = 906,\n    TYPE_IS_NOT_STANDALONE = 907,\n    MISSING_ZONEJS = 908,\n    UNEXPECTED_ZONE_STATE = 909\n}\n\ndeclare const SANITIZER = 12;\n\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nexport declare abstract class Sanitizer {\n    abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;\n    /** @nocollapse */\n    static ɵprov: unknown;\n}\n\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\ndeclare type SanitizerFn = (value: any, tagName?: string, propName?: string) => string | TrustedHTML | TrustedScript | TrustedScriptURL;\n\n\n/**\n * A schema definition associated with an NgModule.\n *\n * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`\n *\n * @param name The name of a defined schema.\n *\n * @publicApi\n */\nexport declare interface SchemaMetadata {\n    name: string;\n}\n\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nexport declare enum SecurityContext {\n    NONE = 0,\n    HTML = 1,\n    STYLE = 2,\n    SCRIPT = 3,\n    URL = 4,\n    RESOURCE_URL = 5\n}\n\n/** Flags used to build up CssSelectors */\ndeclare const enum SelectorFlags {\n    /** Indicates this is the beginning of a new negative selector */\n    NOT = 1,\n    /** Mode for matching attributes */\n    ATTRIBUTE = 2,\n    /** Mode for matching tag names */\n    ELEMENT = 4,\n    /** Mode for matching class names */\n    CLASS = 8\n}\n\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport declare interface Self {\n}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const Self: SelfDecorator;\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface SelfDecorator {\n    /**\n     * Parameter decorator to be used on constructor parameters,\n     * which tells the DI framework to start dependency resolution from the local injector.\n     *\n     * Resolution works upward through the injector hierarchy, so the children\n     * of this class must configure their own providers or be prepared for a `null` result.\n     *\n     * @usageNotes\n     *\n     * In the following example, the dependency can be resolved\n     * by the local injector when instantiating the class itself, but not\n     * when instantiating a child.\n     *\n     * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Self\">\n     * </code-example>\n     *\n     * @see `SkipSelf`\n     * @see `Optional`\n     *\n     */\n    (): any;\n    new (): Self;\n}\n\n/**\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\n * @publicApi\n */\nexport declare function setTestabilityGetter(getter: GetTestability): void;\n\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport declare class SimpleChange {\n    previousValue: any;\n    currentValue: any;\n    firstChange: boolean;\n    constructor(previousValue: any, currentValue: any, firstChange: boolean);\n    /**\n     * Check whether the new value is the first value assigned.\n     */\n    isFirstChange(): boolean;\n}\n\n/**\n * A hashtable of changes represented by {@link SimpleChange} objects stored\n * at the declared property name they belong to on a Directive or Component. This is\n * the type passed to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport declare interface SimpleChanges {\n    [propName: string]: SimpleChange;\n}\n\n/**\n * Type of the `SkipSelf` metadata.\n *\n * @publicApi\n */\nexport declare interface SkipSelf {\n}\n\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const SkipSelf: SkipSelfDecorator;\n\n/**\n * Type of the `SkipSelf` decorator / constructor function.\n *\n * @publicApi\n */\nexport declare interface SkipSelfDecorator {\n    /**\n     * Parameter decorator to be used on constructor parameters,\n     * which tells the DI framework to start dependency resolution from the parent injector.\n     * Resolution works upward through the injector hierarchy, so the local injector\n     * is not checked for a provider.\n     *\n     * @usageNotes\n     *\n     * In the following example, the dependency can be resolved when\n     * instantiating a child, but not when instantiating the class itself.\n     *\n     * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"SkipSelf\">\n     * </code-example>\n     *\n     * @see [Dependency Injection guide](guide/dependency-injection-in-action#skip).\n     * @see `Self`\n     * @see `Optional`\n     *\n     */\n    (): any;\n    new (): SkipSelf;\n}\n\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='StaticClassProvider'}\n *\n * Note that following two providers are not equal:\n *\n * {@example core/di/ts/provider_spec.ts region='StaticClassProviderDifference'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport declare interface StaticClassProvider extends StaticClassSansProvider {\n    /**\n     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n     */\n    provide: any;\n    /**\n     * When true, injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n * Base for `StaticClassProvider` decorator.\n *\n * @publicApi\n */\nexport declare interface StaticClassSansProvider {\n    /**\n     * An optional class to instantiate for the `token`. By default, the `provide`\n     * class is instantiated.\n     */\n    useClass: Type<any>;\n    /**\n     * A list of `token`s to be resolved by the injector. The list of values is then\n     * used as arguments to the `useClass` constructor.\n     */\n    deps: any[];\n}\n\n/**\n * Describes how an `Injector` should be configured as static (that is, without reflection).\n * A static provider provides tokens to an injector for various types of dependencies.\n *\n * @see `Injector.create()`.\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection-providers).\n *\n * @publicApi\n */\nexport declare type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];\n\ndeclare const T_HOST = 6;\n\n/**\n * A combination of:\n * - Attribute names and values.\n * - Special markers acting as flags to alter attributes processing.\n * - Parsed ngProjectAs selectors.\n */\ndeclare type TAttributes = (string | ɵAttributeMarker | CssSelector)[];\n\n/**\n * Constants that are associated with a view. Includes:\n * - Attribute arrays.\n * - Local definition arrays.\n * - Translated messages (i18n).\n */\ndeclare type TConstants = (TAttributes | string)[];\n\n/**\n * Factory function that returns an array of consts. Consts can be represented as a function in\n * case any additional statements are required to define consts in the list. An example is i18n\n * where additional i18n calls are generated, which should be executed when consts are requested\n * for the first time.\n */\ndeclare type TConstantsFactory = () => TConstants;\n\n/**\n * TConstants type that describes how the `consts` field is generated on ComponentDef: it can be\n * either an array or a factory function that returns that array.\n */\ndeclare type TConstantsOrFactory = TConstants | TConstantsFactory;\n\n/** Static data for an LContainer */\ndeclare interface TContainerNode extends TNode {\n    /**\n     * Index in the data[] array.\n     *\n     * If it's -1, this is a dynamically created container node that isn't stored in\n     * data[] (e.g. when you inject ViewContainerRef) .\n     */\n    index: number;\n    child: null;\n    /**\n     * Container nodes will have parents unless:\n     *\n     * - They are the first node of a component or embedded view\n     * - They are dynamically created\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: TView | TView[] | null;\n    projection: null;\n    value: null;\n}\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Each host property's name is stored here at the same index as its value in the\n * data array.\n *\n * Each property binding name is stored here at the same index as its value in\n * the data array. If the binding is an interpolation, the static string values\n * are stored parallel to the dynamic values. Example:\n *\n * id=\"prefix {{ v0 }} a {{ v1 }} b {{ v2 }} suffix\"\n *\n * LView       |   TView.data\n *------------------------\n *  v0 value   |   'a'\n *  v1 value   |   'b'\n *  v2 value   |   id � prefix � suffix\n *\n * Injector bloom filters are also stored here.\n */\ndeclare type TData = (TNode | ɵPipeDef<any> | ɵDirectiveDef<any> | ɵComponentDef<any> | number | TStylingRange | TStylingKey | ProviderToken<any> | TI18n | I18nUpdateOpCodes | TIcu | null | string)[];\n\n/** Static data for an <ng-container> */\ndeclare interface TElementContainerNode extends TNode {\n    /** Index in the LView[] array. */\n    index: number;\n    child: TElementNode | TTextNode | TContainerNode | TElementContainerNode | TProjectionNode | null;\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    projection: null;\n}\n\n/** Static data for an element  */\ndeclare interface TElementNode extends TNode {\n    /** Index in the data[] array */\n    index: number;\n    child: TElementNode | TTextNode | TElementContainerNode | TContainerNode | TProjectionNode | null;\n    /**\n     * Element nodes will have parents unless they are the first node of a component or\n     * embedded view (which means their parent is in a different view and must be\n     * retrieved using viewData[HOST_NODE]).\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    /**\n     * If this is a component TNode with projection, this will be an array of projected\n     * TNodes or native nodes (see TNode.projection for more info). If it's a regular element node\n     * or a component without projection, it will be null.\n     */\n    projection: (TNode | RNode[])[] | null;\n    /**\n     * Stores TagName\n     */\n    value: string;\n}\n\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nexport declare abstract class TemplateRef<C> {\n    /**\n     * The anchor element in the parent view for this embedded view.\n     *\n     * The data-binding and injection contexts of embedded views created from this `TemplateRef`\n     * inherit from the contexts of this location.\n     *\n     * Typically new embedded views are attached to the view container of this location, but in\n     * advanced use-cases, the view can be attached to a different container while keeping the\n     * data-binding and injection context from the original location.\n     *\n     */\n    abstract readonly elementRef: ElementRef;\n    /**\n     * Instantiates an unattached embedded view based on this template.\n     * @param context The data-binding context of the embedded view, as declared\n     * in the `<ng-template>` usage.\n     * @param injector Injector to be used within the embedded view.\n     * @returns The new embedded view object.\n     */\n    abstract createEmbeddedView(context: C, injector?: Injector): EmbeddedViewRef<C>;\n}\n\n/**\n * The Testability service provides testing hooks that can be accessed from\n * the browser.\n *\n * Angular applications bootstrapped using an NgModule (via `@NgModule.bootstrap` field) will also\n * instantiate Testability by default (in both development and production modes).\n *\n * For applications bootstrapped using the `bootstrapApplication` function, Testability is not\n * included by default. You can include it into your applications by getting the list of necessary\n * providers using the `provideProtractorTestingSupport()` function and adding them into the\n * `options.providers` array. Example:\n *\n * ```typescript\n * import {provideProtractorTestingSupport} from '@angular/platform-browser';\n *\n * await bootstrapApplication(RootComponent, providers: [provideProtractorTestingSupport()]);\n * ```\n *\n * @publicApi\n */\nexport declare class Testability implements PublicTestability {\n    private _ngZone;\n    private registry;\n    private _pendingCount;\n    private _isZoneStable;\n    private _callbacks;\n    private taskTrackingZone;\n    constructor(_ngZone: NgZone, registry: TestabilityRegistry, testabilityGetter: GetTestability);\n    private _watchAngularEvents;\n    /**\n     * Increases the number of pending request\n     * @deprecated pending requests are now tracked with zones.\n     */\n    increasePendingRequestCount(): number;\n    /**\n     * Decreases the number of pending request\n     * @deprecated pending requests are now tracked with zones\n     */\n    decreasePendingRequestCount(): number;\n    /**\n     * Whether an associated application is stable\n     */\n    isStable(): boolean;\n    private _runCallbacksIfReady;\n    private getPendingTasks;\n    private addCallback;\n    /**\n     * Wait for the application to be stable with a timeout. If the timeout is reached before that\n     * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\n     *\n     * @param doneCb The callback to invoke when Angular is stable or the timeout expires\n     *    whichever comes first.\n     * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\n     *    specified, whenStable() will wait forever.\n     * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\n     *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\n     *    and no further updates will be issued.\n     */\n    whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void;\n    /**\n     * Get the number of pending requests\n     * @deprecated pending requests are now tracked with zones\n     */\n    getPendingRequestCount(): number;\n    /**\n     * Find providers by name\n     * @param using The root element to search from\n     * @param provider The name of binding variable\n     * @param exactMatch Whether using exactMatch\n     */\n    findProviders(using: any, provider: string, exactMatch: boolean): any[];\n    static ɵfac: i0.ɵɵFactoryDeclaration<Testability, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Testability>;\n}\n\n/**\n * A global registry of {@link Testability} instances for specific elements.\n * @publicApi\n */\nexport declare class TestabilityRegistry {\n    /**\n     * Registers an application with a testability hook so that it can be tracked\n     * @param token token of application, root element\n     * @param testability Testability hook\n     */\n    registerApplication(token: any, testability: Testability): void;\n    /**\n     * Unregisters an application.\n     * @param token token of application, root element\n     */\n    unregisterApplication(token: any): void;\n    /**\n     * Unregisters all applications\n     */\n    unregisterAllApplications(): void;\n    /**\n     * Get a testability hook associated with the application\n     * @param elem root element\n     */\n    getTestability(elem: any): Testability | null;\n    /**\n     * Get all registered testabilities\n     */\n    getAllTestabilities(): Testability[];\n    /**\n     * Get all registered applications(root elements)\n     */\n    getAllRootElements(): any[];\n    /**\n     * Find testability of a node in the Tree\n     * @param elem node\n     * @param findInAncestors whether finding testability in ancestors if testability was not found in\n     * current node\n     */\n    findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<TestabilityRegistry, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<TestabilityRegistry>;\n}\n\n/**\n * Store information for the i18n translation block.\n */\ndeclare interface TI18n {\n    /**\n     * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n     *\n     * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n     */\n    create: I18nCreateOpCodes;\n    /**\n     * A set of OpCodes which will be executed on each change detection to determine if any changes to\n     * DOM are required.\n     */\n    update: I18nUpdateOpCodes;\n}\n\ndeclare interface TIcu {\n    /**\n     * Defines the ICU type of `select` or `plural`\n     */\n    type: IcuType;\n    /**\n     * Index in `LView` where the anchor node is stored. `<!-- ICU 0:0 -->`\n     */\n    anchorIdx: number;\n    /**\n     * Currently selected ICU case pointer.\n     *\n     * `lView[currentCaseLViewIndex]` stores the currently selected case. This is needed to know how\n     * to clean up the current case when transitioning no the new case.\n     *\n     * If the value stored is:\n     * `null`: No current case selected.\n     *   `<0`: A flag which means that the ICU just switched and that `icuUpdate` must be executed\n     *         regardless of the `mask`. (After the execution the flag is cleared)\n     *   `>=0` A currently selected case index.\n     */\n    currentCaseLViewIndex: number;\n    /**\n     * A list of case values which the current ICU will try to match.\n     *\n     * The last value is `other`\n     */\n    cases: any[];\n    /**\n     * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n     */\n    create: IcuCreateOpCodes[];\n    /**\n     * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n     */\n    remove: I18nRemoveOpCodes[];\n    /**\n     * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n     */\n    update: I18nUpdateOpCodes[];\n}\n\n/**\n * Binding data (flyweight) for a particular node that is shared between all templates\n * of a specific type.\n *\n * If a property is:\n *    - PropertyAliases: that property's data was generated and this is it\n *    - Null: that property's data was already generated and nothing was found.\n *    - Undefined: that property's data has not yet been generated\n *\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\n */\ndeclare interface TNode {\n    /** The type of the TNode. See TNodeType. */\n    type: TNodeType;\n    /**\n     * Index of the TNode in TView.data and corresponding native element in LView.\n     *\n     * This is necessary to get from any TNode to its corresponding native element when\n     * traversing the node tree.\n     *\n     * If index is -1, this is a dynamically created container node or embedded view node.\n     */\n    index: number;\n    /**\n     * Insert before existing DOM node index.\n     *\n     * When DOM nodes are being inserted, normally they are being appended as they are created.\n     * Under i18n case, the translated text nodes are created ahead of time as part of the\n     * `ɵɵi18nStart` instruction which means that this `TNode` can't just be appended and instead\n     * needs to be inserted using `insertBeforeIndex` semantics.\n     *\n     * Additionally sometimes it is necessary to insert new text nodes as a child of this `TNode`. In\n     * such a case the value stores an array of text nodes to insert.\n     *\n     * Example:\n     * ```\n     * <div i18n>\n     *   Hello <span>World</span>!\n     * </div>\n     * ```\n     * In the above example the `ɵɵi18nStart` instruction can create `Hello `, `World` and `!` text\n     * nodes. It can also insert `Hello ` and `!` text node as a child of `<div>`, but it can't\n     * insert `World` because the `<span>` node has not yet been created. In such a case the\n     * `<span>` `TNode` will have an array which will direct the `<span>` to not only insert\n     * itself in front of `!` but also to insert the `World` (created by `ɵɵi18nStart`) into\n     * `<span>` itself.\n     *\n     * Pseudo code:\n     * ```\n     *   if (insertBeforeIndex === null) {\n     *     // append as normal\n     *   } else if (Array.isArray(insertBeforeIndex)) {\n     *     // First insert current `TNode` at correct location\n     *     const currentNode = lView[this.index];\n     *     parentNode.insertBefore(currentNode, lView[this.insertBeforeIndex[0]]);\n     *     // Now append all of the children\n     *     for(let i=1; i<this.insertBeforeIndex; i++) {\n     *       currentNode.appendChild(lView[this.insertBeforeIndex[i]]);\n     *     }\n     *   } else {\n     *     parentNode.insertBefore(lView[this.index], lView[this.insertBeforeIndex])\n     *   }\n     * ```\n     * - null: Append as normal using `parentNode.appendChild`\n     * - `number`: Append using\n     *      `parentNode.insertBefore(lView[this.index], lView[this.insertBeforeIndex])`\n     *\n     * *Initialization*\n     *\n     * Because `ɵɵi18nStart` executes before nodes are created, on `TView.firstCreatePass` it is not\n     * possible for `ɵɵi18nStart` to set the `insertBeforeIndex` value as the corresponding `TNode`\n     * has not yet been created. For this reason the `ɵɵi18nStart` creates a `TNodeType.Placeholder`\n     * `TNode` at that location. See `TNodeType.Placeholder` for more information.\n     */\n    insertBeforeIndex: InsertBeforeIndex;\n    /**\n     * The index of the closest injector in this node's LView.\n     *\n     * If the index === -1, there is no injector on this node or any ancestor node in this view.\n     *\n     * If the index !== -1, it is the index of this node's injector OR the index of a parent\n     * injector in the same view. We pass the parent injector index down the node tree of a view so\n     * it's possible to find the parent injector without walking a potentially deep node tree.\n     * Injector indices are not set across view boundaries because there could be multiple component\n     * hosts.\n     *\n     * If tNode.injectorIndex === tNode.parent.injectorIndex, then the index belongs to a parent\n     * injector.\n     */\n    injectorIndex: number;\n    /**\n     * Stores starting index of the directives.\n     *\n     * NOTE: The first directive is always component (if present).\n     */\n    directiveStart: number;\n    /**\n     * Stores final exclusive index of the directives.\n     *\n     * The area right behind the `directiveStart-directiveEnd` range is used to allocate the\n     * `HostBindingFunction` `vars` (or null if no bindings.) Therefore `directiveEnd` is used to set\n     * `LFrame.bindingRootIndex` before `HostBindingFunction` is executed.\n     */\n    directiveEnd: number;\n    /**\n     * Stores the last directive which had a styling instruction.\n     *\n     * Initial value of this is `-1` which means that no `hostBindings` styling instruction has\n     * executed. As `hostBindings` instructions execute they set the value to the index of the\n     * `DirectiveDef` which contained the last `hostBindings` styling instruction.\n     *\n     * Valid values are:\n     * - `-1` No `hostBindings` instruction has executed.\n     * - `directiveStart <= directiveStylingLast < directiveEnd`: Points to the `DirectiveDef` of\n     * the last styling instruction which executed in the `hostBindings`.\n     *\n     * This data is needed so that styling instructions know which static styling data needs to be\n     * collected from the `DirectiveDef.hostAttrs`. A styling instruction needs to collect all data\n     * since last styling instruction.\n     */\n    directiveStylingLast: number;\n    /**\n     * Stores indexes of property bindings. This field is only set in the ngDevMode and holds\n     * indexes of property bindings so TestBed can get bound property metadata for a given node.\n     */\n    propertyBindings: number[] | null;\n    /**\n     * Stores if Node isComponent, isProjected, hasContentQuery, hasClassInput and hasStyleInput\n     * etc.\n     */\n    flags: TNodeFlags;\n    /**\n     * This number stores two values using its bits:\n     *\n     * - the index of the first provider on that node (first 16 bits)\n     * - the count of view providers from the component on this node (last 16 bits)\n     */\n    providerIndexes: TNodeProviderIndexes;\n    /**\n     * The value name associated with this node.\n     * if type:\n     *   `TNodeType.Text`: text value\n     *   `TNodeType.Element`: tag name\n     *   `TNodeType.ICUContainer`: `TIcu`\n     */\n    value: any;\n    /**\n     * Attributes associated with an element. We need to store attributes to support various\n     * use-cases (attribute injection, content projection with selectors, directives matching).\n     * Attributes are stored statically because reading them from the DOM would be way too slow for\n     * content projection and queries.\n     *\n     * Since attrs will always be calculated first, they will never need to be marked undefined by\n     * other instructions.\n     *\n     * For regular attributes a name of an attribute and its value alternate in the array.\n     * e.g. ['role', 'checkbox']\n     * This array can contain flags that will indicate \"special attributes\" (attributes with\n     * namespaces, attributes extracted from bindings and outputs).\n     */\n    attrs: TAttributes | null;\n    /**\n     * Same as `TNode.attrs` but contains merged data across all directive host bindings.\n     *\n     * We need to keep `attrs` as unmerged so that it can be used for attribute selectors.\n     * We merge attrs here so that it can be used in a performant way for initial rendering.\n     *\n     * The `attrs` are merged in first pass in following order:\n     * - Component's `hostAttrs`\n     * - Directives' `hostAttrs`\n     * - Template `TNode.attrs` associated with the current `TNode`.\n     */\n    mergedAttrs: TAttributes | null;\n    /**\n     * A set of local names under which a given element is exported in a template and\n     * visible to queries. An entry in this array can be created for different reasons:\n     * - an element itself is referenced, ex.: `<div #foo>`\n     * - a component is referenced, ex.: `<my-cmpt #foo>`\n     * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\n     *\n     * A given element might have different local names and those names can be associated\n     * with a directive. We store local names at even indexes while odd indexes are reserved\n     * for directive index in a view (or `-1` if there is no associated directive).\n     *\n     * Some examples:\n     * - `<div #foo>` => `[\"foo\", -1]`\n     * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\n     * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\n     * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\n     */\n    localNames: (string | number)[] | null;\n    /** Information about input properties that need to be set once from attribute data. */\n    initialInputs: InitialInputData | null | undefined;\n    /**\n     * Input data for all directives on this node. `null` means that there are no directives with\n     * inputs on this node.\n     */\n    inputs: PropertyAliases | null;\n    /**\n     * Output data for all directives on this node. `null` means that there are no directives with\n     * outputs on this node.\n     */\n    outputs: PropertyAliases | null;\n    /**\n     * The TView or TViews attached to this node.\n     *\n     * If this TNode corresponds to an LContainer with inline views, the container will\n     * need to store separate static data for each of its view blocks (TView[]). Otherwise,\n     * nodes in inline views with the same index as nodes in their parent views will overwrite\n     * each other, as they are in the same template.\n     *\n     * Each index in this array corresponds to the static data for a certain\n     * view. So if you had V(0) and V(1) in a container, you might have:\n     *\n     * [\n     *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\n     *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\n     *\n     * If this TNode corresponds to an LContainer with a template (e.g. structural\n     * directive), the template's TView will be stored here.\n     *\n     * If this TNode corresponds to an element, tViews will be null .\n     */\n    tViews: TView | TView[] | null;\n    /**\n     * The next sibling node. Necessary so we can propagate through the root nodes of a view\n     * to insert them or remove them from the DOM.\n     */\n    next: TNode | null;\n    /**\n     * The next projected sibling. Since in Angular content projection works on the node-by-node\n     * basis the act of projecting nodes might change nodes relationship at the insertion point\n     * (target view). At the same time we need to keep initial relationship between nodes as\n     * expressed in content view.\n     */\n    projectionNext: TNode | null;\n    /**\n     * First child of the current node.\n     *\n     * For component nodes, the child will always be a ContentChild (in same view).\n     * For embedded view nodes, the child will be in their child view.\n     */\n    child: TNode | null;\n    /**\n     * Parent node (in the same view only).\n     *\n     * We need a reference to a node's parent so we can append the node to its parent's native\n     * element at the appropriate time.\n     *\n     * If the parent would be in a different view (e.g. component host), this property will be null.\n     * It's important that we don't try to cross component boundaries when retrieving the parent\n     * because the parent will change (e.g. index, attrs) depending on where the component was\n     * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through\n     * LView.node instead (which will be instance-specific).\n     *\n     * If this is an inline view node (V), the parent will be its container.\n     */\n    parent: TElementNode | TContainerNode | null;\n    /**\n     * List of projected TNodes for a given component host element OR index into the said nodes.\n     *\n     * For easier discussion assume this example:\n     * `<parent>`'s view definition:\n     * ```\n     * <child id=\"c1\">content1</child>\n     * <child id=\"c2\"><span>content2</span></child>\n     * ```\n     * `<child>`'s view definition:\n     * ```\n     * <ng-content id=\"cont1\"></ng-content>\n     * ```\n     *\n     * If `Array.isArray(projection)` then `TNode` is a host element:\n     * - `projection` stores the content nodes which are to be projected.\n     *    - The nodes represent categories defined by the selector: For example:\n     *      `<ng-content/><ng-content select=\"abc\"/>` would represent the heads for `<ng-content/>`\n     *      and `<ng-content select=\"abc\"/>` respectively.\n     *    - The nodes we store in `projection` are heads only, we used `.next` to get their\n     *      siblings.\n     *    - The nodes `.next` is sorted/rewritten as part of the projection setup.\n     *    - `projection` size is equal to the number of projections `<ng-content>`. The size of\n     *      `c1` will be `1` because `<child>` has only one `<ng-content>`.\n     * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)\n     *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and\n     * as a result have different set of nodes to project.\n     * - without `projection` it would be difficult to efficiently traverse nodes to be projected.\n     *\n     * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:\n     * - `projection` is an index of the host's `projection`Nodes.\n     *   - This would return the first head node to project:\n     *     `getHost(currentTNode).projection[currentTNode.projection]`.\n     * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case\n     *   the process is recursive in nature.\n     *\n     * If `projection` is of type `RNode[][]` than we have a collection of native nodes passed as\n     * projectable nodes during dynamic component creation.\n     */\n    projection: (TNode | RNode[])[] | number | null;\n    /**\n     * A collection of all `style` static values for an element (including from host).\n     *\n     * This field will be populated if and when:\n     *\n     * - There are one or more initial `style`s on an element (e.g. `<div style=\"width:200px;\">`)\n     * - There are one or more initial `style`s on a directive/component host\n     *   (e.g. `@Directive({host: {style: \"width:200px;\" } }`)\n     */\n    styles: string | null;\n    /**\n     * A collection of all `style` static values for an element excluding host sources.\n     *\n     * Populated when there are one or more initial `style`s on an element\n     * (e.g. `<div style=\"width:200px;\">`)\n     * Must be stored separately from `tNode.styles` to facilitate setting directive\n     * inputs that shadow the `style` property. If we used `tNode.styles` as is for shadowed inputs,\n     * we would feed host styles back into directives as \"inputs\". If we used `tNode.attrs`, we\n     * would have to concatenate the attributes on every template pass. Instead, we process once on\n     * first create pass and store here.\n     */\n    stylesWithoutHost: string | null;\n    /**\n     * A `KeyValueArray` version of residual `styles`.\n     *\n     * When there are styling instructions than each instruction stores the static styling\n     * which is of lower priority than itself. This means that there may be a higher priority\n     * styling than the instruction.\n     *\n     * Imagine:\n     * ```\n     * <div style=\"color: highest;\" my-dir>\n     *\n     * @Directive({\n     *   host: {\n     *     style: 'color: lowest; ',\n     *     '[styles.color]': 'exp' // ɵɵstyleProp('color', ctx.exp);\n     *   }\n     * })\n     * ```\n     *\n     * In the above case:\n     * - `color: lowest` is stored with `ɵɵstyleProp('color', ctx.exp);` instruction\n     * -  `color: highest` is the residual and is stored here.\n     *\n     * - `undefined': not initialized.\n     * - `null`: initialized but `styles` is `null`\n     * - `KeyValueArray`: parsed version of `styles`.\n     */\n    residualStyles: KeyValueArray<any> | undefined | null;\n    /**\n     * A collection of all class static values for an element (including from host).\n     *\n     * This field will be populated if and when:\n     *\n     * - There are one or more initial classes on an element (e.g. `<div class=\"one two three\">`)\n     * - There are one or more initial classes on an directive/component host\n     *   (e.g. `@Directive({host: {class: \"SOME_CLASS\" } }`)\n     */\n    classes: string | null;\n    /**\n     * A collection of all class static values for an element excluding host sources.\n     *\n     * Populated when there are one or more initial classes on an element\n     * (e.g. `<div class=\"SOME_CLASS\">`)\n     * Must be stored separately from `tNode.classes` to facilitate setting directive\n     * inputs that shadow the `class` property. If we used `tNode.classes` as is for shadowed\n     * inputs, we would feed host classes back into directives as \"inputs\". If we used\n     * `tNode.attrs`, we would have to concatenate the attributes on every template pass. Instead,\n     * we process once on first create pass and store here.\n     */\n    classesWithoutHost: string | null;\n    /**\n     * A `KeyValueArray` version of residual `classes`.\n     *\n     * Same as `TNode.residualStyles` but for classes.\n     *\n     * - `undefined': not initialized.\n     * - `null`: initialized but `classes` is `null`\n     * - `KeyValueArray`: parsed version of `classes`.\n     */\n    residualClasses: KeyValueArray<any> | undefined | null;\n    /**\n     * Stores the head/tail index of the class bindings.\n     *\n     * - If no bindings, the head and tail will both be 0.\n     * - If there are template bindings, stores the head/tail of the class bindings in the template.\n     * - If no template bindings but there are host bindings, the head value will point to the last\n     *   host binding for \"class\" (not the head of the linked list), tail will be 0.\n     *\n     * See: `style_binding_list.ts` for details.\n     *\n     * This is used by `insertTStylingBinding` to know where the next styling binding should be\n     * inserted so that they can be sorted in priority order.\n     */\n    classBindings: TStylingRange;\n    /**\n     * Stores the head/tail index of the class bindings.\n     *\n     * - If no bindings, the head and tail will both be 0.\n     * - If there are template bindings, stores the head/tail of the style bindings in the template.\n     * - If no template bindings but there are host bindings, the head value will point to the last\n     *   host binding for \"style\" (not the head of the linked list), tail will be 0.\n     *\n     * See: `style_binding_list.ts` for details.\n     *\n     * This is used by `insertTStylingBinding` to know where the next styling binding should be\n     * inserted so that they can be sorted in priority order.\n     */\n    styleBindings: TStylingRange;\n}\n\n/**\n * Corresponds to the TNode.flags property.\n */\ndeclare const enum TNodeFlags {\n    /** Bit #1 - This bit is set if the node is a host for any directive (including a component) */\n    isDirectiveHost = 1,\n    /**\n     * Bit #2 - This bit is set if the node is a host for a component.\n     *\n     * Setting this bit implies that the `isDirectiveHost` bit is set as well.\n     * */\n    isComponentHost = 2,\n    /** Bit #3 - This bit is set if the node has been projected */\n    isProjected = 4,\n    /** Bit #4 - This bit is set if any directive on this node has content queries */\n    hasContentQuery = 8,\n    /** Bit #5 - This bit is set if the node has any \"class\" inputs */\n    hasClassInput = 16,\n    /** Bit #6 - This bit is set if the node has any \"style\" inputs */\n    hasStyleInput = 32,\n    /** Bit #7 This bit is set if the node has been detached by i18n */\n    isDetached = 64,\n    /**\n     * Bit #8 - This bit is set if the node has directives with host bindings.\n     *\n     * This flags allows us to guard host-binding logic and invoke it only on nodes\n     * that actually have directives with host bindings.\n     */\n    hasHostBindings = 128\n}\n\n/**\n * Corresponds to the TNode.providerIndexes property.\n */\ndeclare const enum TNodeProviderIndexes {\n    /** The index of the first provider on this node is encoded on the least significant bits. */\n    ProvidersStartIndexMask = 1048575,\n    /**\n     * The count of view providers from the component on this node is\n     * encoded on the 20 most significant bits.\n     */\n    CptViewProvidersCountShift = 20,\n    CptViewProvidersCountShifter = 1048576\n}\n\n/**\n * TNodeType corresponds to the {@link TNode} `type` property.\n *\n * NOTE: type IDs are such that we use each bit to denote a type. This is done so that we can easily\n * check if the `TNode` is of more than one type.\n *\n * `if (tNode.type === TNodeType.Text || tNode.type === TNode.Element)`\n * can be written as:\n * `if (tNode.type & (TNodeType.Text | TNodeType.Element))`\n *\n * However any given `TNode` can only be of one type.\n */\ndeclare const enum TNodeType {\n    /**\n     * The TNode contains information about a DOM element aka {@link RText}.\n     */\n    Text = 1,\n    /**\n     * The TNode contains information about a DOM element aka {@link RElement}.\n     */\n    Element = 2,\n    /**\n     * The TNode contains information about an {@link LContainer} for embedded views.\n     */\n    Container = 4,\n    /**\n     * The TNode contains information about an `<ng-container>` element {@link RNode}.\n     */\n    ElementContainer = 8,\n    /**\n     * The TNode contains information about an `<ng-content>` projection\n     */\n    Projection = 16,\n    /**\n     * The TNode contains information about an ICU comment used in `i18n`.\n     */\n    Icu = 32,\n    /**\n     * Special node type representing a placeholder for future `TNode` at this location.\n     *\n     * I18n translation blocks are created before the element nodes which they contain. (I18n blocks\n     * can span over many elements.) Because i18n `TNode`s (representing text) are created first they\n     * often may need to point to element `TNode`s which are not yet created. In such a case we create\n     * a `Placeholder` `TNode`. This allows the i18n to structurally link the `TNode`s together\n     * without knowing any information about the future nodes which will be at that location.\n     *\n     * On `firstCreatePass` When element instruction executes it will try to create a `TNode` at that\n     * location. Seeing a `Placeholder` `TNode` already there tells the system that it should reuse\n     * existing `TNode` (rather than create a new one) and just update the missing information.\n     */\n    Placeholder = 64,\n    AnyRNode = 3,\n    AnyContainer = 12\n}\n\n/**\n * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.\n */\ndeclare type TNodeWithLocalRefs = TContainerNode | TElementNode | TElementContainerNode;\n\n/** Static data for an LProjectionNode  */\ndeclare interface TProjectionNode extends TNode {\n    /** Index in the data[] array */\n    child: null;\n    /**\n     * Projection nodes will have parents unless they are the first node of a component\n     * or embedded view (which means their parent is in a different view and must be\n     * retrieved using LView.node).\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    /** Index of the projection node. (See TNode.projection for more info.) */\n    projection: number;\n    value: null;\n}\n\n/**\n * TQueries represent a collection of individual TQuery objects tracked in a given view. Most of the\n * methods on this interface are simple proxy methods to the corresponding functionality on TQuery.\n */\ndeclare interface TQueries {\n    /**\n     * Adds a new TQuery to a collection of queries tracked in a given view.\n     * @param tQuery\n     */\n    track(tQuery: TQuery): void;\n    /**\n     * Returns a TQuery instance for at the given index  in the queries array.\n     * @param index\n     */\n    getByIndex(index: number): TQuery;\n    /**\n     * Returns the number of queries tracked in a given view.\n     */\n    length: number;\n    /**\n     * A proxy method that iterates over all the TQueries in a given TView and calls the corresponding\n     * `elementStart` on each and every TQuery.\n     * @param tView\n     * @param tNode\n     */\n    elementStart(tView: TView, tNode: TNode): void;\n    /**\n     * A proxy method that iterates over all the TQueries in a given TView and calls the corresponding\n     * `elementEnd` on each and every TQuery.\n     * @param tNode\n     */\n    elementEnd(tNode: TNode): void;\n    /**\n     * A proxy method that iterates over all the TQueries in a given TView and calls the corresponding\n     * `template` on each and every TQuery.\n     * @param tView\n     * @param tNode\n     */\n    template(tView: TView, tNode: TNode): void;\n    /**\n     * A proxy method that iterates over all the TQueries in a given TView and calls the corresponding\n     * `embeddedTView` on each and every TQuery.\n     * @param tNode\n     */\n    embeddedTView(tNode: TNode): TQueries | null;\n}\n\n/**\n * TQuery objects represent all the query-related data that remain the same from one view instance\n * to another and can be determined on the very first template pass. Most notably TQuery holds all\n * the matches for a given view.\n */\ndeclare interface TQuery {\n    /**\n     * Query metadata extracted from query annotations.\n     */\n    metadata: TQueryMetadata;\n    /**\n     * Index of a query in a declaration view in case of queries propagated to en embedded view, -1\n     * for queries declared in a given view. We are storing this index so we can find a parent query\n     * to clone for an embedded view (when an embedded view is created).\n     */\n    indexInDeclarationView: number;\n    /**\n     * Matches collected on the first template pass. Each match is a pair of:\n     * - TNode index;\n     * - match index;\n     *\n     * A TNode index can be either:\n     * - a positive number (the most common case) to indicate a matching TNode;\n     * - a negative number to indicate that a given query is crossing a <ng-template> element and\n     * results from views created based on TemplateRef should be inserted at this place.\n     *\n     * A match index is a number used to find an actual value (for a given node) when query results\n     * are materialized. This index can have one of the following values:\n     * - -2 - indicates that we need to read a special token (TemplateRef, ViewContainerRef etc.);\n     * - -1 - indicates that we need to read a default value based on the node type (TemplateRef for\n     * ng-template and ElementRef for other elements);\n     * - a positive number - index of an injectable to be read from the element injector.\n     */\n    matches: number[] | null;\n    /**\n     * A flag indicating if a given query crosses an <ng-template> element. This flag exists for\n     * performance reasons: we can notice that queries not crossing any <ng-template> elements will\n     * have matches from a given view only (and adapt processing accordingly).\n     */\n    crossesNgTemplate: boolean;\n    /**\n     * A method call when a given query is crossing an element (or element container). This is where a\n     * given TNode is matched against a query predicate.\n     * @param tView\n     * @param tNode\n     */\n    elementStart(tView: TView, tNode: TNode): void;\n    /**\n     * A method called when processing the elementEnd instruction - this is mostly useful to determine\n     * if a given content query should match any nodes past this point.\n     * @param tNode\n     */\n    elementEnd(tNode: TNode): void;\n    /**\n     * A method called when processing the template instruction. This is where a\n     * given TContainerNode is matched against a query predicate.\n     * @param tView\n     * @param tNode\n     */\n    template(tView: TView, tNode: TNode): void;\n    /**\n     * A query-related method called when an embedded TView is created based on the content of a\n     * <ng-template> element. We call this method to determine if a given query should be propagated\n     * to the embedded view and if so - return a cloned TQuery for this embedded view.\n     * @param tNode\n     * @param childQueryIndex\n     */\n    embeddedTView(tNode: TNode, childQueryIndex: number): TQuery | null;\n}\n\n/**\n * An object representing query metadata extracted from query annotations.\n */\ndeclare interface TQueryMetadata {\n    predicate: ProviderToken<unknown> | string[];\n    read: any;\n    flags: QueryFlags;\n}\n\n/**\n * A function optionally passed into the `NgForOf` directive to customize how `NgForOf` uniquely\n * identifies items in an iterable.\n *\n * `NgForOf` needs to uniquely identify items in the iterable to correctly perform DOM updates\n * when items in the iterable are reordered, new items are added, or existing items are removed.\n *\n *\n * In all of these scenarios it is usually desirable to only update the DOM elements associated\n * with the items affected by the change. This behavior is important to:\n *\n * - preserve any DOM-specific UI state (like cursor position, focus, text selection) when the\n *   iterable is modified\n * - enable animation of item addition, removal, and iterable reordering\n * - preserve the value of the `<select>` element when nested `<option>` elements are dynamically\n *   populated using `NgForOf` and the bound iterable is updated\n *\n * A common use for custom `trackBy` functions is when the model that `NgForOf` iterates over\n * contains a property with a unique identifier. For example, given a model:\n *\n * ```ts\n * class User {\n *   id: number;\n *   name: string;\n *   ...\n * }\n * ```\n * a custom `trackBy` function could look like the following:\n * ```ts\n * function userTrackBy(index, user) {\n *   return user.id;\n * }\n * ```\n *\n * A custom `trackBy` function must have several properties:\n *\n * - be [idempotent](https://en.wikipedia.org/wiki/Idempotence) (be without side effects, and always\n * return the same value for a given input)\n * - return unique value for all unique inputs\n * - be fast\n *\n * @see [`NgForOf#ngForTrackBy`](api/common/NgForOf#ngForTrackBy)\n * @publicApi\n */\nexport declare interface TrackByFunction<T> {\n    /**\n     * @param index The index of the item within the iterable.\n     * @param item The item in the iterable.\n     */\n    <U extends T>(index: number, item: T & U): any;\n}\n\n/**\n * Use this token at bootstrap to provide the content of your translation file (`xtb`,\n * `xlf` or `xlf2`) when you want to translate your application in another language.\n *\n * See the [i18n guide](guide/i18n-common-merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * // content of your translation file\n * const translations = '....';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS, useValue: translations }]\n * });\n * ```\n *\n * @publicApi\n */\nexport declare const TRANSLATIONS: InjectionToken<string>;\n\n/**\n * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,\n * `xlf` or `xlf2`.\n *\n * See the [i18n guide](guide/i18n-common-merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS_FORMAT } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport declare const TRANSLATIONS_FORMAT: InjectionToken<string>;\n\ndeclare const TRANSPLANTED_VIEWS_TO_REFRESH = 5;\n\n\n/**\n * @fileoverview\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\ndeclare interface TrustedHTML {\n    __brand__: 'TrustedHTML';\n}\n\ndeclare interface TrustedScript {\n    __brand__: 'TrustedScript';\n}\n\ndeclare interface TrustedScriptURL {\n    __brand__: 'TrustedScriptURL';\n}\n\n/**\n * Value stored in the `TData` which is needed to re-concatenate the styling.\n *\n * See: `TStylingKeyPrimitive` and `TStylingStatic`\n */\ndeclare type TStylingKey = TStylingKeyPrimitive | TStylingStatic;\n\n/**\n * The primitive portion (`TStylingStatic` removed) of the value stored in the `TData` which is\n * needed to re-concatenate the styling.\n *\n * - `string`: Stores the property name. Used with `ɵɵstyleProp`/`ɵɵclassProp` instruction.\n * - `null`: Represents map, so there is no name. Used with `ɵɵstyleMap`/`ɵɵclassMap`.\n * - `false`: Represents an ignore case. This happens when `ɵɵstyleProp`/`ɵɵclassProp` instruction\n *   is combined with directive which shadows its input `@Input('class')`. That way the binding\n *   should not participate in the styling resolution.\n */\ndeclare type TStylingKeyPrimitive = string | null | false;\n\n/**\n * This is a branded number which contains previous and next index.\n *\n * When we come across styling instructions we need to store the `TStylingKey` in the correct\n * order so that we can re-concatenate the styling value in the desired priority.\n *\n * The insertion can happen either at the:\n * - end of template as in the case of coming across additional styling instruction in the template\n * - in front of the template in the case of coming across additional instruction in the\n *   `hostBindings`.\n *\n * We use `TStylingRange` to store the previous and next index into the `TData` where the template\n * bindings can be found.\n *\n * - bit 0 is used to mark that the previous index has a duplicate for current value.\n * - bit 1 is used to mark that the next index has a duplicate for the current value.\n * - bits 2-16 are used to encode the next/tail of the template.\n * - bits 17-32 are used to encode the previous/head of template.\n *\n * NODE: *duplicate* false implies that it is statically known that this binding will not collide\n * with other bindings and therefore there is no need to check other bindings. For example the\n * bindings in `<div [style.color]=\"exp\" [style.width]=\"exp\">` will never collide and will have\n * their bits set accordingly. Previous duplicate means that we may need to check previous if the\n * current binding is `null`. Next duplicate means that we may need to check next bindings if the\n * current binding is not `null`.\n *\n * NOTE: `0` has special significance and represents `null` as in no additional pointer.\n */\ndeclare interface TStylingRange {\n    __brand__: 'TStylingRange';\n}\n\n/**\n * Store the static values for the styling binding.\n *\n * The `TStylingStatic` is just `KeyValueArray` where key `\"\"` (stored at location 0) contains the\n * `TStylingKey` (stored at location 1). In other words this wraps the `TStylingKey` such that the\n * `\"\"` contains the wrapped value.\n *\n * When instructions are resolving styling they may need to look forward or backwards in the linked\n * list to resolve the value. For this reason we have to make sure that he linked list also contains\n * the static values. However the list only has space for one item per styling instruction. For this\n * reason we store the static values here as part of the `TStylingKey`. This means that the\n * resolution function when looking for a value needs to first look at the binding value, and than\n * at `TStylingKey` (if it exists).\n *\n * Imagine we have:\n *\n * ```\n * <div class=\"TEMPLATE\" my-dir>\n *\n * @Directive({\n *   host: {\n *     class: 'DIR',\n *     '[class.dynamic]': 'exp' // ɵɵclassProp('dynamic', ctx.exp);\n *   }\n * })\n * ```\n *\n * In the above case the linked list will contain one item:\n *\n * ```\n *   // assume binding location: 10 for `ɵɵclassProp('dynamic', ctx.exp);`\n *   tData[10] = <TStylingStatic>[\n *     '': 'dynamic', // This is the wrapped value of `TStylingKey`\n *     'DIR': true,   // This is the default static value of directive binding.\n *   ];\n *   tData[10 + 1] = 0; // We don't have prev/next.\n *\n *   lView[10] = undefined;     // assume `ctx.exp` is `undefined`\n *   lView[10 + 1] = undefined; // Just normalized `lView[10]`\n * ```\n *\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into the static `TStylingStatic` too see if there is a default value for\n * `dynamic` (there is not). Therefore it is safe to remove it.\n *\n * If setting `true` case:\n * ```\n *   lView[10] = true;     // assume `ctx.exp` is `true`\n *   lView[10 + 1] = true; // Just normalized `lView[10]`\n * ```\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into `TNode.residualClass` (TNode.residualStyle) which contains\n * ```\n *   tNode.residualClass = [\n *     'TEMPLATE': true,\n *   ];\n * ```\n *\n * This means that it is safe to add class.\n */\ndeclare interface TStylingStatic extends KeyValueArray<any> {\n}\n\n/** Static data for a text node */\ndeclare interface TTextNode extends TNode {\n    /** Index in the data[] array */\n    index: number;\n    child: null;\n    /**\n     * Text nodes will have parents unless they are the first node of a component or\n     * embedded view (which means their parent is in a different view and must be\n     * retrieved using LView.node).\n     */\n    parent: TElementNode | TElementContainerNode | null;\n    tViews: null;\n    projection: null;\n}\n\ndeclare const TVIEW = 1;\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the `ComponentDef.tView`.\n */\ndeclare interface TView {\n    /**\n     * Type of `TView` (`Root`|`Component`|`Embedded`).\n     */\n    type: TViewType;\n    /**\n     * This is a blueprint used to generate LView instances for this TView. Copying this\n     * blueprint is faster than creating a new LView from scratch.\n     */\n    blueprint: LView;\n    /**\n     * The template function used to refresh the view of dynamically created views\n     * and components. Will be null for inline views.\n     */\n    template: ComponentTemplate<{}> | null;\n    /**\n     * A function containing query-related instructions.\n     */\n    viewQuery: ViewQueriesFunction<{}> | null;\n    /**\n     * A `TNode` representing the declaration location of this `TView` (not part of this TView).\n     */\n    declTNode: TNode | null;\n    /** Whether or not this template has been processed in creation mode. */\n    firstCreatePass: boolean;\n    /**\n     *  Whether or not this template has been processed in update mode (e.g. change detected)\n     *\n     * `firstUpdatePass` is used by styling to set up `TData` to contain metadata about the styling\n     * instructions. (Mainly to build up a linked list of styling priority order.)\n     *\n     * Typically this function gets cleared after first execution. If exception is thrown then this\n     * flag can remain turned un until there is first successful (no exception) pass. This means that\n     * individual styling instructions keep track of if they have already been added to the linked\n     * list to prevent double adding.\n     */\n    firstUpdatePass: boolean;\n    /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n    data: TData;\n    /**\n     * The binding start index is the index at which the data array\n     * starts to store bindings only. Saving this value ensures that we\n     * will begin reading bindings at the correct point in the array when\n     * we are in update mode.\n     *\n     * -1 means that it has not been initialized.\n     */\n    bindingStartIndex: number;\n    /**\n     * The index where the \"expando\" section of `LView` begins. The expando\n     * section contains injectors, directive instances, and host binding values.\n     * Unlike the \"decls\" and \"vars\" sections of `LView`, the length of this\n     * section cannot be calculated at compile-time because directives are matched\n     * at runtime to preserve locality.\n     *\n     * We store this start index so we know where to start checking host bindings\n     * in `setHostBindings`.\n     */\n    expandoStartIndex: number;\n    /**\n     * Whether or not there are any static view queries tracked on this view.\n     *\n     * We store this so we know whether or not we should do a view query\n     * refresh after creation mode to collect static query results.\n     */\n    staticViewQueries: boolean;\n    /**\n     * Whether or not there are any static content queries tracked on this view.\n     *\n     * We store this so we know whether or not we should do a content query\n     * refresh after creation mode to collect static query results.\n     */\n    staticContentQueries: boolean;\n    /**\n     * A reference to the first child node located in the view.\n     */\n    firstChild: TNode | null;\n    /**\n     * Stores the OpCodes to be replayed during change-detection to process the `HostBindings`\n     *\n     * See `HostBindingOpCodes` for encoding details.\n     */\n    hostBindingOpCodes: HostBindingOpCodes | null;\n    /**\n     * Full registry of directives and components that may be found in this view.\n     *\n     * It's necessary to keep a copy of the full def list on the TView so it's possible\n     * to render template functions without a host component.\n     */\n    directiveRegistry: DirectiveDefList | null;\n    /**\n     * Full registry of pipes that may be found in this view.\n     *\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n     *\n     * It's necessary to keep a copy of the full def list on the TView so it's possible\n     * to render template functions without a host component.\n     */\n    pipeRegistry: PipeDefList | null;\n    /**\n     * Array of ngOnInit, ngOnChanges and ngDoCheck hooks that should be executed for this view in\n     * creation mode.\n     *\n     * This array has a flat structure and contains TNode indices, directive indices (where an\n     * instance can be found in `LView`) and hook functions. TNode index is followed by the directive\n     * index and a hook function. If there are multiple hooks for a given TNode, the TNode index is\n     * not repeated and the next lifecycle hook information is stored right after the previous hook\n     * function. This is done so that at runtime the system can efficiently iterate over all of the\n     * functions to invoke without having to make any decisions/lookups.\n     */\n    preOrderHooks: HookData | null;\n    /**\n     * Array of ngOnChanges and ngDoCheck hooks that should be executed for this view in update mode.\n     *\n     * This array has the same structure as the `preOrderHooks` one.\n     */\n    preOrderCheckHooks: HookData | null;\n    /**\n     * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n     * for this view in creation mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    contentHooks: HookData | null;\n    /**\n     * Array of ngAfterContentChecked hooks that should be executed for this view in update\n     * mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    contentCheckHooks: HookData | null;\n    /**\n     * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n     * this view in creation mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    viewHooks: HookData | null;\n    /**\n     * Array of ngAfterViewChecked hooks that should be executed for this view in\n     * update mode.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    viewCheckHooks: HookData | null;\n    /**\n     * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n     *\n     * Even indices: Directive index\n     * Odd indices: Hook function\n     */\n    destroyHooks: DestroyHookData | null;\n    /**\n     * When a view is destroyed, listeners need to be released and outputs need to be\n     * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n     * and output data (in chunks of 2) for a particular view. Combining the arrays\n     * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n     * separate for loops).\n     *\n     * If it's a native DOM listener or output subscription being stored:\n     * 1st index is: event name  `name = tView.cleanup[i+0]`\n     * 2nd index is: index of native element or a function that retrieves global target (window,\n     *               document or body) reference based on the native element:\n     *    `typeof idxOrTargetGetter === 'function'`: global target getter function\n     *    `typeof idxOrTargetGetter === 'number'`: index of native element\n     *\n     * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n     * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n     *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n     *    `typeof useCaptureOrIndx == 'number':\n     *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n     *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n     *\n     * If it's an output subscription or query list destroy hook:\n     * 1st index is: output unsubscribe function / query list destroy function\n     * 2nd index is: index of function context in LView.cleanupInstances[]\n     *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n     */\n    cleanup: any[] | null;\n    /**\n     * A list of element indices for child components that will need to be\n     * refreshed when the current view has finished its check. These indices have\n     * already been adjusted for the HEADER_OFFSET.\n     *\n     */\n    components: number[] | null;\n    /**\n     * A collection of queries tracked in a given view.\n     */\n    queries: TQueries | null;\n    /**\n     * An array of indices pointing to directives with content queries alongside with the\n     * corresponding query index. Each entry in this array is a tuple of:\n     * - index of the first content query index declared by a given directive;\n     * - index of a directive.\n     *\n     * We are storing those indexes so we can refresh content queries as part of a view refresh\n     * process.\n     */\n    contentQueries: number[] | null;\n    /**\n     * Set of schemas that declare elements to be allowed inside the view.\n     */\n    schemas: SchemaMetadata[] | null;\n    /**\n     * Array of constants for the view. Includes attribute arrays, local definition arrays etc.\n     * Used for directive matching, attribute bindings, local definitions and more.\n     */\n    consts: TConstants | null;\n    /**\n     * Indicates that there was an error before we managed to complete the first create pass of the\n     * view. This means that the view is likely corrupted and we should try to recover it.\n     */\n    incompleteFirstPass: boolean;\n}\n\n/**\n * Explicitly marks `TView` as a specific type in `ngDevMode`\n *\n * It is useful to know conceptually what time of `TView` we are dealing with when\n * debugging an application (even if the runtime does not need it.) For this reason\n * we store this information in the `ngDevMode` `TView` and than use it for\n * better debugging experience.\n */\ndeclare const enum TViewType {\n    /**\n     * Root `TView` is the used to bootstrap components into. It is used in conjunction with\n     * `LView` which takes an existing DOM node not owned by Angular and wraps it in `TView`/`LView`\n     * so that other components can be loaded into it.\n     */\n    Root = 0,\n    /**\n     * `TView` associated with a Component. This would be the `TView` directly associated with the\n     * component view (as opposed an `Embedded` `TView` which would be a child of `Component` `TView`)\n     */\n    Component = 1,\n    /**\n     * `TView` associated with a template. Such as `*ngIf`, `<ng-template>` etc... A `Component`\n     * can have zero or more `Embedded` `TView`s.\n     */\n    Embedded = 2\n}\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\ndeclare const TYPE = 1;\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nexport declare const Type: FunctionConstructor;\n\nexport declare interface Type<T> extends Function {\n    new (...args: any[]): T;\n}\n\ndeclare type Type_2 = Function;\n\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as\n * decorators as well as Angular syntax.\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n * @publicApi\n */\nexport declare interface TypeDecorator {\n    /**\n     * Invoke as decorator.\n     */\n    <T extends Type<any>>(type: T): T;\n    (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;\n}\n\ndeclare type TypeOrFactory<T> = T | (() => T);\n\n/**\n * Configures the `Injector` to return an instance of `Type` when `Type' is used as the token.\n *\n * Create an instance by invoking the `new` operator and supplying additional arguments.\n * This form is a short form of `TypeProvider`;\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='TypeProvider'}\n *\n * @publicApi\n */\nexport declare interface TypeProvider extends Type<any> {\n}\n\n/**\n * Configures the `Injector` to return a value for a token.\n * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ValueProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport declare interface ValueProvider extends ValueSansProvider {\n    /**\n     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n     */\n    provide: any;\n    /**\n     * When true, injector returns an array of instances. This is useful to allow multiple\n     * providers spread across many files to provide configuration information to a common token.\n     */\n    multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return a value for a token.\n * Base for `ValueProvider` decorator.\n *\n * @publicApi\n */\nexport declare interface ValueSansProvider {\n    /**\n     * The value to inject.\n     */\n    useValue: any;\n}\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nexport declare class Version {\n    full: string;\n    readonly major: string;\n    readonly minor: string;\n    readonly patch: string;\n    constructor(full: string);\n}\n\ndeclare const VIEW_REFS = 8;\n\n/**\n * Type of the ViewChild metadata.\n *\n * @publicApi\n */\nexport declare type ViewChild = Query;\n\n/**\n * ViewChild decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const ViewChild: ViewChildDecorator;\n\n/**\n * Type of the ViewChild decorator / constructor function.\n *\n * @see `ViewChild`.\n * @publicApi\n */\nexport declare interface ViewChildDecorator {\n    /**\n     * @description\n     * Property decorator that configures a view query.\n     * The change detector looks for the first element or the directive matching the selector\n     * in the view DOM. If the view DOM changes, and a new child matches the selector,\n     * the property is updated.\n     *\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - The directive type or the name used for querying.\n     * * **read** - Used to read a different token from the queried elements.\n     * * **static** - True to resolve query results before change detection runs,\n     * false to resolve after change detection. Defaults to false.\n     *\n     *\n     * The following selectors are supported.\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * A template reference variable as a string (e.g. query `<my-component #cmp></my-component>`\n     * with `@ViewChild('cmp')`)\n     *   * Any provider defined in the child component tree of the current component (e.g.\n     * `@ViewChild(SomeService) someService: SomeService`)\n     *   * Any provider defined through a string token (e.g. `@ViewChild('someToken') someTokenVal:\n     * any`)\n     *   * A `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ViewChild(TemplateRef)\n     * template;`)\n     *\n     * The following values are supported by `read`:\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * Any provider defined on the injector of the component that is matched by the `selector` of\n     * this query\n     *   * Any provider defined through a string token (e.g. `{provide: 'token', useValue: 'val'}`)\n     *   * `TemplateRef`, `ElementRef`, and `ViewContainerRef`\n     *\n     * @usageNotes\n     *\n     * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\n     *\n     * ### Example 2\n     *\n     * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}\n     *\n     * @Annotation\n     */\n    (selector: ProviderToken<unknown> | Function | string, opts?: {\n        read?: any;\n        static?: boolean;\n    }): any;\n    new (selector: ProviderToken<unknown> | Function | string, opts?: {\n        read?: any;\n        static?: boolean;\n    }): ViewChild;\n}\n\n/**\n * Type of the ViewChildren metadata.\n *\n * @publicApi\n */\nexport declare type ViewChildren = Query;\n\n/**\n * ViewChildren decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport declare const ViewChildren: ViewChildrenDecorator;\n\n/**\n * Type of the ViewChildren decorator / constructor function.\n *\n * @see `ViewChildren`.\n *\n * @publicApi\n */\nexport declare interface ViewChildrenDecorator {\n    /**\n     * @description\n     * Property decorator that configures a view query.\n     *\n     * Use to get the `QueryList` of elements or directives from the view DOM.\n     * Any time a child element is added, removed, or moved, the query list will be updated,\n     * and the changes observable of the query list will emit a new value.\n     *\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - The directive type or the name used for querying.\n     * * **read** - Used to read a different token from the queried elements.\n     * * **emitDistinctChangesOnly** - The ` QueryList#changes` observable will emit new values only\n     *   if the QueryList result has changed. When `false` the `changes` observable might emit even\n     *   if the QueryList has not changed.\n     *   ** Note: *** This config option is **deprecated**, it will be permanently set to `true` and\n     * removed in future versions of Angular.\n     *\n     * The following selectors are supported.\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * A template reference variable as a string (e.g. query `<my-component #cmp></my-component>`\n     * with `@ViewChildren('cmp')`)\n     *   * Any provider defined in the child component tree of the current component (e.g.\n     * `@ViewChildren(SomeService) someService!: SomeService`)\n     *   * Any provider defined through a string token (e.g. `@ViewChildren('someToken')\n     * someTokenVal!: any`)\n     *   * A `TemplateRef` (e.g. query `<ng-template></ng-template>` with `@ViewChildren(TemplateRef)\n     * template;`)\n     *\n     * In addition, multiple string selectors can be separated with a comma (e.g.\n     * `@ViewChildren('cmp1,cmp2')`)\n     *\n     * The following values are supported by `read`:\n     *   * Any class with the `@Component` or `@Directive` decorator\n     *   * Any provider defined on the injector of the component that is matched by the `selector` of\n     * this query\n     *   * Any provider defined through a string token (e.g. `{provide: 'token', useValue: 'val'}`)\n     *   * `TemplateRef`, `ElementRef`, and `ViewContainerRef`\n     *\n     * @usageNotes\n     *\n     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\n     *\n     * ### Another example\n     *\n     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\n     *\n     * @Annotation\n     */\n    (selector: ProviderToken<unknown> | Function | string, opts?: {\n        read?: any;\n        emitDistinctChangesOnly?: boolean;\n    }): any;\n    new (selector: ProviderToken<unknown> | Function | string, opts?: {\n        read?: any;\n        emitDistinctChangesOnly?: boolean;\n    }): ViewChildren;\n}\n\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nexport declare abstract class ViewContainerRef {\n    /**\n     * Anchor element that specifies the location of this container in the containing view.\n     * Each view container can have only one anchor element, and each anchor element\n     * can have only a single view container.\n     *\n     * Root elements of views attached to this container become siblings of the anchor element in\n     * the rendered view.\n     *\n     * Access the `ViewContainerRef` of an element by placing a `Directive` injected\n     * with `ViewContainerRef` on the element, or use a `ViewChild` query.\n     *\n     * <!-- TODO: rename to anchorElement -->\n     */\n    abstract get element(): ElementRef;\n    /**\n     * The [dependency injector](guide/glossary#injector) for this view container.\n     */\n    abstract get injector(): Injector;\n    /** @deprecated No replacement */\n    abstract get parentInjector(): Injector;\n    /**\n     * Destroys all views in this container.\n     */\n    abstract clear(): void;\n    /**\n     * Retrieves a view from this container.\n     * @param index The 0-based index of the view to retrieve.\n     * @returns The `ViewRef` instance, or null if the index is out of range.\n     */\n    abstract get(index: number): ViewRef | null;\n    /**\n     * Reports how many views are currently attached to this container.\n     * @returns The number of views.\n     */\n    abstract get length(): number;\n    /**\n     * Instantiates an embedded view and inserts it\n     * into this container.\n     * @param templateRef The HTML template that defines the view.\n     * @param context The data-binding context of the embedded view, as declared\n     * in the `<ng-template>` usage.\n     * @param options Extra configuration for the created view. Includes:\n     *  * index: The 0-based index at which to insert the new view into this container.\n     *           If not specified, appends the new view as the last entry.\n     *  * injector: Injector to be used within the embedded view.\n     *\n     * @returns The `ViewRef` instance for the newly created view.\n     */\n    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, options?: {\n        index?: number;\n        injector?: Injector;\n    }): EmbeddedViewRef<C>;\n    /**\n     * Instantiates an embedded view and inserts it\n     * into this container.\n     * @param templateRef The HTML template that defines the view.\n     * @param context The data-binding context of the embedded view, as declared\n     * in the `<ng-template>` usage.\n     * @param index The 0-based index at which to insert the new view into this container.\n     * If not specified, appends the new view as the last entry.\n     *\n     * @returns The `ViewRef` instance for the newly created view.\n     */\n    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;\n    /**\n     * Instantiates a single component and inserts its host view into this container.\n     *\n     * @param componentType Component Type to use.\n     * @param options An object that contains extra parameters:\n     *  * index: the index at which to insert the new component's host view into this container.\n     *           If not specified, appends the new view as the last entry.\n     *  * injector: the injector to use as the parent for the new component.\n     *  * ngModuleRef: an NgModuleRef of the component's NgModule, you should almost always provide\n     *                 this to ensure that all expected providers are available for the component\n     *                 instantiation.\n     *  * environmentInjector: an EnvironmentInjector which will provide the component's environment.\n     *                 you should almost always provide this to ensure that all expected providers\n     *                 are available for the component instantiation. This option is intended to\n     *                 replace the `ngModuleRef` parameter.\n     *  * projectableNodes: list of DOM nodes that should be projected through\n     *                      [`<ng-content>`](api/core/ng-content) of the new component instance.\n     *\n     * @returns The new `ComponentRef` which contains the component instance and the host view.\n     */\n    abstract createComponent<C>(componentType: Type<C>, options?: {\n        index?: number;\n        injector?: Injector;\n        ngModuleRef?: NgModuleRef<unknown>;\n        environmentInjector?: EnvironmentInjector | NgModuleRef<unknown>;\n        projectableNodes?: Node[][];\n    }): ComponentRef<C>;\n    /**\n     * Instantiates a single component and inserts its host view into this container.\n     *\n     * @param componentFactory Component factory to use.\n     * @param index The index at which to insert the new component's host view into this container.\n     * If not specified, appends the new view as the last entry.\n     * @param injector The injector to use as the parent for the new component.\n     * @param projectableNodes List of DOM nodes that should be projected through\n     *     [`<ng-content>`](api/core/ng-content) of the new component instance.\n     * @param ngModuleRef An instance of the NgModuleRef that represent an NgModule.\n     * This information is used to retrieve corresponding NgModule injector.\n     *\n     * @returns The new `ComponentRef` which contains the component instance and the host view.\n     *\n     * @deprecated Angular no longer requires component factories to dynamically create components.\n     *     Use different signature of the `createComponent` method, which allows passing\n     *     Component class directly.\n     */\n    abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], environmentInjector?: EnvironmentInjector | NgModuleRef<any>): ComponentRef<C>;\n    /**\n     * Inserts a view into this container.\n     * @param viewRef The view to insert.\n     * @param index The 0-based index at which to insert the view.\n     * If not specified, appends the new view as the last entry.\n     * @returns The inserted `ViewRef` instance.\n     *\n     */\n    abstract insert(viewRef: ViewRef, index?: number): ViewRef;\n    /**\n     * Moves a view to a new location in this container.\n     * @param viewRef The view to move.\n     * @param index The 0-based index of the new location.\n     * @returns The moved `ViewRef` instance.\n     */\n    abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;\n    /**\n     * Returns the index of a view within the current container.\n     * @param viewRef The view to query.\n     * @returns The 0-based index of the view's position in this container,\n     * or `-1` if this container doesn't contain the view.\n     */\n    abstract indexOf(viewRef: ViewRef): number;\n    /**\n     * Destroys a view attached to this container\n     * @param index The 0-based index of the view to destroy.\n     * If not specified, the last view in the container is removed.\n     */\n    abstract remove(index?: number): void;\n    /**\n     * Detaches a view from this container without destroying it.\n     * Use along with `insert()` to move a view within the current container.\n     * @param index The 0-based index of the view to detach.\n     * If not specified, the last view in the container is detached.\n     */\n    abstract detach(index?: number): ViewRef | null;\n}\n\n\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nexport declare enum ViewEncapsulation {\n    /**\n     * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n     * component's host element and applying the same attribute to all the CSS selectors provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n     *\n     * This is the default option.\n     */\n    Emulated = 0,\n    /**\n     * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n     * to any HTML element of the application regardless of their host Component.\n     */\n    None = 2,\n    /**\n     * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n     * a ShadowRoot for the component's host element which is then used to encapsulate\n     * all the Component's styling.\n     */\n    ShadowDom = 3\n}\n\ndeclare enum ViewEncapsulation_2 {\n    Emulated = 0,\n    None = 2,\n    ShadowDom = 3\n}\n\ndeclare interface viewEngine_ChangeDetectorRef_interface extends ChangeDetectorRef {\n}\n\n/**\n * Definition of what a view queries function should look like.\n */\ndeclare type ViewQueriesFunction<T> = <U extends T>(rf: ɵRenderFlags, ctx: U) => void;\n\n/**\n * Represents an Angular [view](guide/glossary#view \"Definition\").\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nexport declare abstract class ViewRef extends ChangeDetectorRef {\n    /**\n     * Destroys this view and all of the data structures associated with it.\n     */\n    abstract destroy(): void;\n    /**\n     * Reports whether this view has been destroyed.\n     * @returns True after the `destroy()` method has been called, false otherwise.\n     */\n    abstract get destroyed(): boolean;\n    /**\n     * A lifecycle hook that provides additional developer-defined cleanup\n     * functionality for views.\n     * @param callback A handler function that cleans up developer-defined data\n     * associated with a view. Called when the `destroy()` method is invoked.\n     */\n    abstract onDestroy(callback: Function): any /** TODO #9100 */;\n}\n\n/**\n * Interface for tracking root `ViewRef`s in `ApplicationRef`.\n *\n * NOTE: Importing `ApplicationRef` here directly creates circular dependency, which is why we have\n * a subset of the `ApplicationRef` interface `ViewRefTracker` here.\n */\ndeclare interface ViewRefTracker {\n    detachView(viewRef: ViewRef): void;\n}\n\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nexport declare function ɵ_sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): TrustedHTML | string;\n\n\nexport declare function ɵ_sanitizeUrl(url: string): string;\n\n/**\n * Internal token to indicate whether having multiple bootstrapped platform should be allowed (only\n * one bootstrapped platform is allowed by default). This token helps to support SSR scenarios.\n */\nexport declare const ɵALLOW_MULTIPLE_PLATFORMS: InjectionToken<boolean>;\n\nexport declare function ɵallowSanitizationBypassAndThrow(value: any, type: ɵBypassType.Html): value is ɵSafeHtml;\n\nexport declare function ɵallowSanitizationBypassAndThrow(value: any, type: ɵBypassType.ResourceUrl): value is ɵSafeResourceUrl;\n\nexport declare function ɵallowSanitizationBypassAndThrow(value: any, type: ɵBypassType.Script): value is ɵSafeScript;\n\nexport declare function ɵallowSanitizationBypassAndThrow(value: any, type: ɵBypassType.Style): value is ɵSafeStyle;\n\nexport declare function ɵallowSanitizationBypassAndThrow(value: any, type: ɵBypassType.Url): value is ɵSafeUrl;\n\nexport declare function ɵallowSanitizationBypassAndThrow(value: any, type: ɵBypassType): boolean;\n\n/**\n * Providers that generate a random `APP_ID_TOKEN`.\n * @publicApi\n */\nexport declare const ɵAPP_ID_RANDOM_PROVIDER: {\n    provide: InjectionToken<string>;\n    useFactory: typeof _appIdRandomProviderFactory;\n    deps: any[];\n};\n\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport declare const enum ɵAttributeMarker {\n    /**\n     * An implicit marker which indicates that the value in the array are of `attributeKey`,\n     * `attributeValue` format.\n     *\n     * NOTE: This is implicit as it is the type when no marker is present in array. We indicate that\n     * it should not be present at runtime by the negative number.\n     */\n    ImplicitAttributes = -1,\n    /**\n     * Marker indicates that the following 3 values in the attributes array are:\n     * namespaceUri, attributeName, attributeValue\n     * in that order.\n     */\n    NamespaceURI = 0,\n    /**\n     * Signals class declaration.\n     *\n     * Each value following `Classes` designates a class name to include on the element.\n     * ## Example:\n     *\n     * Given:\n     * ```\n     * <div class=\"foo bar baz\">...<d/vi>\n     * ```\n     *\n     * the generated code is:\n     * ```\n     * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n     * ```\n     */\n    Classes = 1,\n    /**\n     * Signals style declaration.\n     *\n     * Each pair of values following `Styles` designates a style name and value to include on the\n     * element.\n     * ## Example:\n     *\n     * Given:\n     * ```\n     * <div style=\"width:100px; height:200px; color:red\">...</div>\n     * ```\n     *\n     * the generated code is:\n     * ```\n     * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n     * ```\n     */\n    Styles = 2,\n    /**\n     * Signals that the following attribute names were extracted from input or output bindings.\n     *\n     * For example, given the following HTML:\n     *\n     * ```\n     * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n     * ```\n     *\n     * the generated code is:\n     *\n     * ```\n     * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n     * ```\n     */\n    Bindings = 3,\n    /**\n     * Signals that the following attribute names were hoisted from an inline-template declaration.\n     *\n     * For example, given the following HTML:\n     *\n     * ```\n     * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n     * ```\n     *\n     * the generated code for the `template()` instruction would include:\n     *\n     * ```\n     * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n     * 'ngForTrackBy', 'let-value']\n     * ```\n     *\n     * while the generated code for the `element()` instruction inside the template function would\n     * include:\n     *\n     * ```\n     * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n     * ```\n     */\n    Template = 4,\n    /**\n     * Signals that the following attribute is `ngProjectAs` and its value is a parsed\n     * `CssSelector`.\n     *\n     * For example, given the following HTML:\n     *\n     * ```\n     * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n     * ```\n     *\n     * the generated code for the `element()` instruction would include:\n     *\n     * ```\n     * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n     * ```\n     */\n    ProjectAs = 5,\n    /**\n     * Signals that the following attribute will be translated by runtime i18n\n     *\n     * For example, given the following HTML:\n     *\n     * ```\n     * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n     * ```\n     *\n     * the generated code is:\n     *\n     * ```\n     * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n     */\n    I18n = 6\n}\n\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nexport declare function ɵbypassSanitizationTrustHtml(trustedHtml: string): ɵSafeHtml;\n\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nexport declare function ɵbypassSanitizationTrustResourceUrl(trustedResourceUrl: string): ɵSafeResourceUrl;\n\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nexport declare function ɵbypassSanitizationTrustScript(trustedScript: string): ɵSafeScript;\n\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nexport declare function ɵbypassSanitizationTrustStyle(trustedStyle: string): ɵSafeStyle;\n\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nexport declare function ɵbypassSanitizationTrustUrl(trustedUrl: string): ɵSafeUrl;\n\n\nexport declare const enum ɵBypassType {\n    Url = \"URL\",\n    Html = \"HTML\",\n    ResourceUrl = \"ResourceURL\",\n    Script = \"Script\",\n    Style = \"Style\"\n}\n\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nexport declare enum ɵChangeDetectorStatus {\n    /**\n     * A state in which, after calling `detectChanges()`, the change detector\n     * state becomes `Checked`, and must be explicitly invoked or reactivated.\n     */\n    CheckOnce = 0,\n    /**\n     * A state in which change detection is skipped until the change detector mode\n     * becomes `CheckOnce`.\n     */\n    Checked = 1,\n    /**\n     * A state in which change detection continues automatically until explicitly\n     * deactivated.\n     */\n    CheckAlways = 2,\n    /**\n     * A state in which a change detector sub tree is not a part of the main tree and\n     * should be skipped.\n     */\n    Detached = 3,\n    /**\n     * Indicates that the change detector encountered an error checking a binding\n     * or calling a directive lifecycle method and is now in an inconsistent state. Change\n     * detectors in this state do not detect changes.\n     */\n    Errored = 4,\n    /**\n     * Indicates that the change detector has been destroyed.\n     */\n    Destroyed = 5\n}\n\nexport declare function ɵclearResolutionOfComponentResourcesQueue(): Map<Type<any>, Component>;\n\n\n/** Coerces a value (typically a string) to a boolean. */\nexport declare function ɵcoerceToBoolean(value: unknown): boolean;\n\n/**\n * Compile an Angular component according to its decorator metadata, and patch the resulting\n * component def (ɵcmp) onto the component type.\n *\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\n * will enqueue resource resolution into a global queue and will fail to return the `ɵcmp`\n * until the global queue has been resolved with a call to `resolveComponentResources`.\n */\nexport declare function ɵcompileComponent(type: Type<any>, metadata: Component): void;\n\n/**\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\n * directive def onto the component type.\n *\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\n * will resolve when compilation completes and the directive becomes usable.\n */\nexport declare function ɵcompileDirective(type: Type<any>, directive: Directive | null): void;\n\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nexport declare function ɵcompileNgModule(moduleType: Type<any>, ngModule?: NgModule): void;\n\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nexport declare function ɵcompileNgModuleDefs(moduleType: ɵNgModuleType, ngModule: NgModule, allowDuplicateDeclarationsInRoot?: boolean): void;\n\nexport declare function ɵcompileNgModuleFactory<M>(injector: Injector, options: CompilerOptions, moduleType: Type<M>): Promise<NgModuleFactory<M>>;\n\nexport declare function ɵcompilePipe(type: Type<any>, meta: Pipe): void;\n\n/**\n * Runtime link information for Components.\n *\n * This is an internal data structure used by the render to link\n * components into templates.\n *\n * NOTE: Always use `defineComponent` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineComponent}\n */\nexport declare interface ɵComponentDef<T> extends ɵDirectiveDef<T> {\n    /**\n     * Unique ID for the component. Used in view encapsulation and\n     * to keep track of the injector in standalone components.\n     */\n    readonly id: string;\n    /**\n     * The View template of the component.\n     */\n    readonly template: ComponentTemplate<T>;\n    /** Constants associated with the component's view. */\n    readonly consts: TConstantsOrFactory | null;\n    /**\n     * An array of `ngContent[selector]` values that were found in the template.\n     */\n    readonly ngContentSelectors?: string[];\n    /**\n     * A set of styles that the component needs to be present for component to render correctly.\n     */\n    readonly styles: string[];\n    /**\n     * The number of nodes, local refs, and pipes in this component template.\n     *\n     * Used to calculate the length of the component's LView array, so we\n     * can pre-fill the array and set the binding start index.\n     */\n    readonly decls: number;\n    /**\n     * The number of bindings in this component template (including pure fn bindings).\n     *\n     * Used to calculate the length of the component's LView array, so we\n     * can pre-fill the array and set the host binding start index.\n     */\n    readonly vars: number;\n    /**\n     * Query-related instructions for a component.\n     */\n    viewQuery: ViewQueriesFunction<T> | null;\n    /**\n     * The view encapsulation type, which determines how styles are applied to\n     * DOM elements. One of\n     * - `Emulated` (default): Emulate native scoping of styles.\n     * - `Native`: Use the native encapsulation mechanism of the renderer.\n     * - `ShadowDom`: Use modern [ShadowDOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n     *   create a ShadowRoot for component's host element.\n     * - `None`: Do not provide any template or style encapsulation.\n     */\n    readonly encapsulation: ViewEncapsulation;\n    /**\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\n     * This is useful for renderers that delegate to other renderers.\n     */\n    readonly data: {\n        [kind: string]: any;\n    };\n    /** Whether or not this component's ChangeDetectionStrategy is OnPush */\n    readonly onPush: boolean;\n    /**\n     * Registry of directives and components that may be found in this view.\n     *\n     * The property is either an array of `DirectiveDef`s or a function which returns the array of\n     * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n     */\n    directiveDefs: DirectiveDefListOrFactory | null;\n    /**\n     * Registry of pipes that may be found in this view.\n     *\n     * The property is either an array of `PipeDefs`s or a function which returns the array of\n     * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n     */\n    pipeDefs: PipeDefListOrFactory | null;\n    /**\n     * Unfiltered list of all dependencies of a component, or `null` if none.\n     */\n    dependencies: TypeOrFactory<DependencyTypeList> | null;\n    /**\n     * The set of schemas that declare elements to be allowed in the component's template.\n     */\n    schemas: SchemaMetadata[] | null;\n    /**\n     * Ivy runtime uses this place to store the computed tView for the component. This gets filled on\n     * the first run of component.\n     */\n    tView: TView | null;\n    /**\n     * A function added by the {@link ɵɵStandaloneFeature} and used by the framework to create\n     * standalone injectors.\n     */\n    getStandaloneInjector: ((parentInjector: EnvironmentInjector) => EnvironmentInjector | null) | null;\n    /**\n     * Used to store the result of `noSideEffects` function so that it is not removed by closure\n     * compiler. The property should never be read.\n     */\n    readonly _?: unknown;\n}\n\n/**\n * A subclass of `Type` which has a static `ɵcmp`:`ComponentDef` field making it\n * consumable for rendering.\n */\nexport declare interface ɵComponentType<T> extends Type<T> {\n    ɵcmp: unknown;\n}\n\nexport declare class ɵConsole {\n    log(message: string): void;\n    warn(message: string): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵConsole, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵConsole>;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nexport declare function ɵcreateInjector(defType: any, parent?: Injector | null, additionalProviders?: StaticProvider[] | null, name?: string): Injector;\n\n/**\n * A list of CssSelectors.\n *\n * A directive or component can have multiple selectors. This type is used for\n * directive defs so any of the selectors in the list will match that directive.\n *\n * Original: 'form, [ngForm]'\n * Parsed: [['form'], ['', 'ngForm', '']]\n */\nexport declare type ɵCssSelectorList = CssSelector[];\n\n/**\n * Index of each value in currency data (used to describe CURRENCIES_EN in currencies.ts)\n */\nexport declare const enum ɵCurrencyIndex {\n    Symbol = 0,\n    SymbolNarrow = 1,\n    NbOfDigits = 2\n}\n\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\nexport declare const ɵDEFAULT_LOCALE_ID = \"en-US\";\n\nexport declare const ɵdefaultIterableDiffers: IterableDiffers;\n\nexport declare const ɵdefaultKeyValueDiffers: KeyValueDiffers;\n\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\nexport declare function ɵdetectChanges(component: {}): void;\n\n\nexport declare function ɵdevModeEqual(a: any, b: any): boolean;\n\n/**\n * Runtime link information for Directives.\n *\n * This is an internal data structure used by the render to link\n * directives into templates.\n *\n * NOTE: Always use `defineDirective` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * @param Selector type metadata specifying the selector of the directive or component\n *\n * See: {@link defineDirective}\n */\nexport declare interface ɵDirectiveDef<T> {\n    /**\n     * A dictionary mapping the inputs' minified property names to their public API names, which\n     * are their aliases if any, or their original unminified property names\n     * (as in `@Input('alias') propertyName: any;`).\n     */\n    readonly inputs: {\n        [P in keyof T]: string;\n    };\n    /**\n     * @deprecated This is only here because `NgOnChanges` incorrectly uses declared name instead of\n     * public or minified name.\n     */\n    readonly declaredInputs: {\n        [P in keyof T]: string;\n    };\n    /**\n     * A dictionary mapping the outputs' minified property names to their public API names, which\n     * are their aliases if any, or their original unminified property names\n     * (as in `@Output('alias') propertyName: any;`).\n     */\n    readonly outputs: {\n        [P in keyof T]: string;\n    };\n    /**\n     * Function to create and refresh content queries associated with a given directive.\n     */\n    contentQueries: ContentQueriesFunction<T> | null;\n    /**\n     * Query-related instructions for a directive. Note that while directives don't have a\n     * view and as such view queries won't necessarily do anything, there might be\n     * components that extend the directive.\n     */\n    viewQuery: ViewQueriesFunction<T> | null;\n    /**\n     * Refreshes host bindings on the associated directive.\n     */\n    readonly hostBindings: HostBindingsFunction<T> | null;\n    /**\n     * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n     *\n     * Used to calculate the length of the component's LView array, so we\n     * can pre-fill the array and set the host binding start index.\n     */\n    readonly hostVars: number;\n    /**\n     * Assign static attribute values to a host element.\n     *\n     * This property will assign static attribute values as well as class and style\n     * values to a host element. Since attribute values can consist of different types of values, the\n     * `hostAttrs` array must include the values in the following format:\n     *\n     * attrs = [\n     *   // static attributes (like `title`, `name`, `id`...)\n     *   attr1, value1, attr2, value,\n     *\n     *   // a single namespace value (like `x:id`)\n     *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n     *\n     *   // another single namespace value (like `x:name`)\n     *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n     *\n     *   // a series of CSS classes that will be applied to the element (no spaces)\n     *   CLASSES_MARKER, class1, class2, class3,\n     *\n     *   // a series of CSS styles (property + value) that will be applied to the element\n     *   STYLES_MARKER, prop1, value1, prop2, value2\n     * ]\n     *\n     * All non-class and non-style attributes must be defined at the start of the list\n     * first before all class and style values are set. When there is a change in value\n     * type (like when classes and styles are introduced) a marker must be used to separate\n     * the entries. The marker values themselves are set via entries found in the\n     * [AttributeMarker] enum.\n     */\n    readonly hostAttrs: TAttributes | null;\n    /** Token representing the directive. Used by DI. */\n    readonly type: Type<T>;\n    /** Function that resolves providers and publishes them into the DI system. */\n    providersResolver: (<U extends T>(def: ɵDirectiveDef<U>, processProvidersFn?: ProcessProvidersFunction) => void) | null;\n    /** The selectors that will be used to match nodes to this directive. */\n    readonly selectors: ɵCssSelectorList;\n    /**\n     * Name under which the directive is exported (for use with local references in template)\n     */\n    readonly exportAs: string[] | null;\n    /**\n     * Whether this directive (or component) is standalone.\n     */\n    readonly standalone: boolean;\n    /**\n     * Factory function used to create a new directive instance. Will be null initially.\n     * Populated when the factory is first requested by directive instantiation logic.\n     */\n    readonly factory: FactoryFn<T> | null;\n    /**\n     * The features applied to this directive\n     */\n    readonly features: DirectiveDefFeature[] | null;\n    setInput: (<U extends T>(this: ɵDirectiveDef<U>, instance: U, value: any, publicName: string, privateName: string) => void) | null;\n}\n\n/**\n * A subclass of `Type` which has a static `ɵdir`:`DirectiveDef` field making it\n * consumable for rendering.\n */\nexport declare interface ɵDirectiveType<T> extends Type<T> {\n    ɵdir: unknown;\n    ɵfac: unknown;\n}\n\n/**\n * Index of each type of locale data from the extra locale data array\n */\nexport declare const enum ɵExtraLocaleDataIndex {\n    ExtraDayPeriodFormats = 0,\n    ExtraDayPeriodStandalone = 1,\n    ExtraDayPeriodsRules = 2\n}\n\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nexport declare function ɵfindLocaleData(locale: string): any;\n\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nexport declare function ɵflushModuleScopingQueueAsMuchAsPossible(): void;\n\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nexport declare function ɵformatRuntimeError<T extends number = RuntimeErrorCode>(code: T, message: null | false | string): string;\n\nexport declare function ɵgetDebugNodeR2(_nativeNode: any): DebugNode | null;\n\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n * @globalApi ng\n */\nexport declare function ɵgetDirectives(node: Node): {}[];\n\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n * @globalApi ng\n */\nexport declare function ɵgetHostElement(componentOrDirective: {}): Element;\n\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nexport declare function ɵgetInjectableDef<T>(type: any): ɵɵInjectableDeclaration<T> | null;\n\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport declare function ɵgetLContext(target: any): ɵLContext | null;\n\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\nexport declare function ɵgetLocaleCurrencyCode(locale: string): string | null;\n\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see `NgPlural`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nexport declare function ɵgetLocalePluralCase(locale: string): (value: number) => number;\n\nexport declare function ɵgetSanitizationBypassType(value: any): ɵBypassType | null;\n\n/**\n * Gets the current value of the strict mode.\n */\nexport declare function ɵgetUnknownElementStrictMode(): boolean;\n\n/**\n * Gets the current value of the strict mode.\n */\nexport declare function ɵgetUnknownPropertyStrictMode(): boolean;\n\n\nexport declare const ɵglobal: any;\n\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport declare function ɵinjectChangeDetectorRef(flags: InjectFlags): ChangeDetectorRef;\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport declare const ɵINJECTOR_SCOPE: InjectionToken<InjectorScope | null>;\n\n/**\n * Internal create application API that implements the core application creation logic and optional\n * bootstrap logic.\n *\n * Platforms (such as `platform-browser`) may require different set of application and platform\n * providers for an application to function correctly. As a result, platforms may use this function\n * internally and supply the necessary providers during the bootstrap, while exposing\n * platform-specific APIs as a part of their public API.\n *\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n */\nexport declare function ɵinternalCreateApplication(config: {\n    rootComponent?: Type<unknown>;\n    appProviders?: Array<Provider | ImportedNgModuleProviders>;\n    platformProviders?: Provider[];\n}): Promise<ApplicationRef>;\n\nexport declare function ɵisBoundToModule<C>(cf: ComponentFactory<C>): boolean;\n\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nexport declare function ɵisDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean;\n\nexport declare function ɵisInjectable(type: any): boolean;\n\nexport declare function ɵisListLikeIterable(obj: any): boolean;\n\n/**\n * Determine if the argument is an Observable\n *\n * Strictly this tests that the `obj` is `Subscribable`, since `Observable`\n * types need additional methods, such as `lift()`. But it is adequate for our\n * needs since within the Angular framework code we only ever need to use the\n * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects\n * into `Observable` as needed.\n */\nexport declare const ɵisObservable: (obj: any | Observable<any>) => obj is Observable<any>;\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport declare function ɵisPromise<T = any>(obj: any): obj is Promise<T>;\n\nexport declare function ɵisStandalone<T>(type: Type<T>): boolean;\n\n/**\n * Determine if the argument is a Subscribable\n */\nexport declare function ɵisSubscribable(obj: any | Subscribable<any>): obj is Subscribable<any>;\n\nexport declare const ɵivyEnabled = true;\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nexport declare class ɵLContext {\n    /**\n     * ID of the component's parent view data.\n     */\n    private lViewId;\n    /**\n     * The index instance of the node.\n     */\n    nodeIndex: number;\n    /**\n     * The instance of the DOM node that is attached to the lNode.\n     */\n    native: RNode;\n    /**\n     * The instance of the Component node.\n     */\n    component: {} | null | undefined;\n    /**\n     * The list of active directives that exist on this element.\n     */\n    directives: any[] | null | undefined;\n    /**\n     * The map of local references (local reference name => element or directive instance) that\n     * exist on this element.\n     */\n    localRefs: {\n        [key: string]: any;\n    } | null | undefined;\n    /** Component's parent view data. */\n    get lView(): LView | null;\n    constructor(\n    /**\n     * ID of the component's parent view data.\n     */\n    lViewId: number, \n    /**\n     * The index instance of the node.\n     */\n    nodeIndex: number, \n    /**\n     * The instance of the DOM node that is attached to the lNode.\n     */\n    native: RNode);\n}\n\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nexport declare function ɵLifecycleHooksFeature(): void;\n\n/**\n * Index of each type of locale data from the locale data array\n */\nexport declare enum ɵLocaleDataIndex {\n    LocaleId = 0,\n    DayPeriodsFormat = 1,\n    DayPeriodsStandalone = 2,\n    DaysFormat = 3,\n    DaysStandalone = 4,\n    MonthsFormat = 5,\n    MonthsStandalone = 6,\n    Eras = 7,\n    FirstDayOfWeek = 8,\n    WeekendRange = 9,\n    DateFormat = 10,\n    TimeFormat = 11,\n    DateTimeFormat = 12,\n    NumberSymbols = 13,\n    NumberFormats = 14,\n    CurrencyCode = 15,\n    CurrencySymbol = 16,\n    CurrencyName = 17,\n    Currencies = 18,\n    Directionality = 19,\n    PluralCase = 20,\n    ExtraData = 21\n}\n\n/**\n * @suppress {globalThis}\n */\nexport declare function ɵmakeDecorator<T>(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (type: Type<T>) => void, typeFn?: (type: Type<T>, ...args: any[]) => void): {\n    new (...args: any[]): any;\n    (...args: any[]): any;\n    (...args: any[]): (cls: any) => any;\n};\n\n\nexport declare const ɵNG_COMP_DEF: string;\n\nexport declare const ɵNG_DIR_DEF: string;\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\nexport declare const ɵNG_ELEMENT_ID: string;\n\nexport declare const ɵNG_INJ_DEF: string;\n\nexport declare const ɵNG_MOD_DEF: string;\n\nexport declare const ɵNG_PIPE_DEF: string;\n\nexport declare const ɵNG_PROV_DEF: string;\n\n/**\n * Runtime link information for NgModules.\n *\n * This is the internal data structure used by the runtime to assemble components, directives,\n * pipes, and injectors.\n *\n * NOTE: Always use `ɵɵdefineNgModule` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n */\nexport declare interface ɵNgModuleDef<T> {\n    /** Token representing the module. Used by DI. */\n    type: T;\n    /** List of components to bootstrap. */\n    bootstrap: Type<any>[] | (() => Type<any>[]);\n    /** List of components, directives, and pipes declared by this module. */\n    declarations: Type<any>[] | (() => Type<any>[]);\n    /** List of modules or `ModuleWithProviders` imported by this module. */\n    imports: Type<any>[] | (() => Type<any>[]);\n    /**\n     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n     * module.\n     */\n    exports: Type<any>[] | (() => Type<any>[]);\n    /**\n     * Cached value of computed `transitiveCompileScopes` for this module.\n     *\n     * This should never be read directly, but accessed via `transitiveScopesFor`.\n     */\n    transitiveCompileScopes: ɵNgModuleTransitiveScopes | null;\n    /** The set of schemas that declare elements to be allowed in the NgModule. */\n    schemas: SchemaMetadata[] | null;\n    /** Unique ID for the module with which it should be registered.  */\n    id: string | null;\n}\n\nexport declare class ɵNgModuleFactory<T> extends NgModuleFactory<T> {\n    moduleType: Type<T>;\n    constructor(moduleType: Type<T>);\n    create(parentInjector: Injector | null): NgModuleRef<T>;\n}\n\n/**\n * Represents the expansion of an `NgModule` into its scopes.\n *\n * A scope is a set of directives and pipes that are visible in a particular context. Each\n * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will\n * be recognized in the templates of components declared by the module. The `exported` scope is the\n * set of directives and pipes exported by a module (that is, module B's exported scope gets added\n * to module A's compilation scope when module A imports B).\n */\nexport declare interface ɵNgModuleTransitiveScopes {\n    compilation: {\n        directives: Set<any>;\n        pipes: Set<any>;\n    };\n    exported: {\n        directives: Set<any>;\n        pipes: Set<any>;\n    };\n    schemas: SchemaMetadata[] | null;\n}\n\nexport declare interface ɵNgModuleType<T = any> extends Type<T> {\n    ɵmod: ɵNgModuleDef<T>;\n}\n\n\nexport declare interface ɵNO_CHANGE {\n    __brand__: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport declare const ɵNO_CHANGE: ɵNO_CHANGE;\n\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport declare class ɵNoopNgZone implements NgZone {\n    readonly hasPendingMicrotasks: boolean;\n    readonly hasPendingMacrotasks: boolean;\n    readonly isStable: boolean;\n    readonly onUnstable: EventEmitter<any>;\n    readonly onMicrotaskEmpty: EventEmitter<any>;\n    readonly onStable: EventEmitter<any>;\n    readonly onError: EventEmitter<any>;\n    run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any): T;\n    runGuarded<T>(fn: (...args: any[]) => any, applyThis?: any, applyArgs?: any): T;\n    runOutsideAngular<T>(fn: (...args: any[]) => T): T;\n    runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any, name?: string): T;\n}\n\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport declare function ɵnoSideEffects<T>(fn: () => T): T;\n\n\nexport declare const ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: {};\n\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport declare function ɵpatchComponentDefWithScope<C>(componentDef: ɵComponentDef<C>, transitiveScopes: ɵNgModuleTransitiveScopes): void;\n\n/**\n * Runtime link information for Pipes.\n *\n * This is an internal data structure used by the renderer to link\n * pipes into templates.\n *\n * NOTE: Always use `definePipe` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link definePipe}\n */\nexport declare interface ɵPipeDef<T> {\n    /** Token representing the pipe. */\n    type: Type<T>;\n    /**\n     * Pipe name.\n     *\n     * Used to resolve pipe in templates.\n     */\n    readonly name: string;\n    /**\n     * Factory function used to create a new pipe instance. Will be null initially.\n     * Populated when the factory is first requested by pipe instantiation logic.\n     */\n    factory: FactoryFn<T> | null;\n    /**\n     * Whether or not the pipe is pure.\n     *\n     * Pure pipes result only depends on the pipe input and not on internal\n     * state of the pipe.\n     */\n    readonly pure: boolean;\n    /**\n     * Whether this pipe is standalone.\n     */\n    readonly standalone: boolean;\n    onDestroy: (() => void) | null;\n}\n\n/**\n * Profiler function which the runtime will invoke before and after user code.\n */\nexport declare interface ɵProfiler {\n    (event: ɵProfilerEvent, instance: {} | null, hookOrListener?: (e?: any) => any): void;\n}\n\n\n/**\n * Profiler events is an enum used by the profiler to distinguish between different calls of user\n * code invoked throughout the application lifecycle.\n */\nexport declare const enum ɵProfilerEvent {\n    /**\n     * Corresponds to the point in time before the runtime has called the template function of a\n     * component with `RenderFlags.Create`.\n     */\n    TemplateCreateStart = 0,\n    /**\n     * Corresponds to the point in time after the runtime has called the template function of a\n     * component with `RenderFlags.Create`.\n     */\n    TemplateCreateEnd = 1,\n    /**\n     * Corresponds to the point in time before the runtime has called the template function of a\n     * component with `RenderFlags.Update`.\n     */\n    TemplateUpdateStart = 2,\n    /**\n     * Corresponds to the point in time after the runtime has called the template function of a\n     * component with `RenderFlags.Update`.\n     */\n    TemplateUpdateEnd = 3,\n    /**\n     * Corresponds to the point in time before the runtime has called a lifecycle hook of a component\n     * or directive.\n     */\n    LifecycleHookStart = 4,\n    /**\n     * Corresponds to the point in time after the runtime has called a lifecycle hook of a component\n     * or directive.\n     */\n    LifecycleHookEnd = 5,\n    /**\n     * Corresponds to the point in time before the runtime has evaluated an expression associated with\n     * an event or an output.\n     */\n    OutputStart = 6,\n    /**\n     * Corresponds to the point in time after the runtime has evaluated an expression associated with\n     * an event or an output.\n     */\n    OutputEnd = 7\n}\n\n/**\n * Publishes a collection of default debug tools onto`window.ng`.\n *\n * These functions are available globally when Angular is in development\n * mode and are automatically stripped away from prod mode is on.\n */\nexport declare function ɵpublishDefaultGlobalUtils(): void;\n\n/**\n * Publishes the given function to `window.ng` so that it can be\n * used from the browser console when an application is not in production.\n */\nexport declare function ɵpublishGlobalUtil(name: string, fn: Function): void;\n\nexport declare class ɵReflectionCapabilities implements PlatformReflectionCapabilities {\n    private _reflect;\n    constructor(reflect?: any);\n    factory<T>(t: Type<T>): (args: any[]) => T;\n    private _ownParameters;\n    parameters(type: Type<any>): any[][];\n    private _ownAnnotations;\n    annotations(typeOrFunc: Type<any>): any[];\n    private _ownPropMetadata;\n    propMetadata(typeOrFunc: any): {\n        [key: string]: any[];\n    };\n    ownPropMetadata(typeOrFunc: any): {\n        [key: string]: any[];\n    };\n    hasLifecycleHook(type: any, lcProperty: string): boolean;\n}\n\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n-common-format-data-locale) to know how to import additional locale\n * data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\nexport declare function ɵregisterLocaleData(data: any, localeId?: string | any, extraData?: any): void;\n\n/**\n * ComponentFactory interface implementation.\n */\nexport declare class ɵRender3ComponentFactory<T> extends ComponentFactory<T> {\n    private componentDef;\n    private ngModule?;\n    selector: string;\n    componentType: Type<any>;\n    ngContentSelectors: string[];\n    isBoundToModule: boolean;\n    get inputs(): {\n        propName: string;\n        templateName: string;\n    }[];\n    get outputs(): {\n        propName: string;\n        templateName: string;\n    }[];\n    /**\n     * @param componentDef The component definition.\n     * @param ngModule The NgModuleRef to which the factory is bound.\n     */\n    constructor(componentDef: ɵComponentDef<any>, ngModule?: NgModuleRef<any> | undefined);\n    create(injector: Injector, projectableNodes?: any[][] | undefined, rootSelectorOrNode?: any, environmentInjector?: NgModuleRef<any> | EnvironmentInjector | undefined): ComponentRef<T>;\n}\n\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nexport declare class ɵRender3ComponentRef<T> extends ComponentRef<T> {\n    location: ElementRef;\n    private _rootLView;\n    private _tNode;\n    instance: T;\n    hostView: ɵViewRef<T>;\n    changeDetectorRef: ChangeDetectorRef;\n    componentType: Type<T>;\n    constructor(componentType: Type<T>, instance: T, location: ElementRef, _rootLView: LView, _tNode: TElementNode | TContainerNode | TElementContainerNode);\n    setInput(name: string, value: unknown): void;\n    get injector(): Injector;\n    destroy(): void;\n    onDestroy(callback: () => void): void;\n}\n\nexport declare class ɵRender3NgModuleRef<T> extends NgModuleRef<T> implements InternalNgModuleRef<T> {\n    _parent: Injector | null;\n    _bootstrapComponents: Type<any>[];\n    _r3Injector: R3Injector;\n    instance: T;\n    destroyCbs: (() => void)[] | null;\n    readonly componentFactoryResolver: ComponentFactoryResolver_2;\n    constructor(ngModuleType: Type<T>, _parent: Injector | null);\n    get injector(): EnvironmentInjector;\n    destroy(): void;\n    onDestroy(callback: () => void): void;\n}\n\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport declare const enum ɵRenderFlags {\n    Create = 1,\n    Update = 2\n}\n\nexport declare function ɵresetCompiledComponents(): void;\n\nexport declare function ɵresetJitOptions(): void;\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nexport declare function ɵresolveComponentResources(resourceResolver: (url: string) => (Promise<string | {\n    text(): Promise<string>;\n}>)): Promise<void>;\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime logic.\n */\nexport declare class ɵRuntimeError<T extends number = RuntimeErrorCode> extends Error {\n    code: T;\n    constructor(code: T, message: null | false | string);\n}\n\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * @publicApi\n */\nexport declare interface ɵSafeHtml extends ɵSafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * @publicApi\n */\nexport declare interface ɵSafeResourceUrl extends ɵSafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * @publicApi\n */\nexport declare interface ɵSafeScript extends ɵSafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * @publicApi\n */\nexport declare interface ɵSafeStyle extends ɵSafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * @publicApi\n */\nexport declare interface ɵSafeUrl extends ɵSafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * @publicApi\n */\nexport declare interface ɵSafeValue {\n}\n\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nexport declare function ɵsetAllowDuplicateNgModuleIdsForTest(allowDuplicates: boolean): void;\n\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\nexport declare function ɵsetClassMetadata(type: Type<any>, decorators: any[] | null, ctorParameters: (() => any[]) | null, propDecorators: {\n    [field: string]: any;\n} | null): void;\n\nexport declare function ɵsetCurrentInjector(injector: Injector | null | undefined): Injector | undefined | null;\n\n\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nexport declare function ɵsetDocument(document: Document | undefined): void;\n\n\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\nexport declare function ɵsetLocaleId(localeId: string): void;\n\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nexport declare function ɵsetUnknownElementStrictMode(shouldThrow: boolean): void;\n\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nexport declare function ɵsetUnknownPropertyStrictMode(shouldThrow: boolean): void;\n\n/** Store a value in the `data` at a given `index`. */\nexport declare function ɵstore<T>(tView: TView, lView: LView, index: number, value: T): void;\n\n\nexport declare function ɵstringify(token: any): string;\n\n/**\n * Internal injection token that can used to access an instance of a Testability class.\n *\n * This token acts as a bridge between the core bootstrap code and the `Testability` class. This is\n * needed to ensure that there are no direct references to the `Testability` class, so it can be\n * tree-shaken away (if not referenced). For the environments/setups when the `Testability` class\n * should be available, this token is used to add a provider that references the `Testability`\n * class. Otherwise, only this token is retained in a bundle, but the `Testability` class is not.\n */\nexport declare const ɵTESTABILITY: InjectionToken<Testability>;\n\n/**\n * Internal injection token to retrieve Testability getter class instance.\n */\nexport declare const ɵTESTABILITY_GETTER: InjectionToken<GetTestability>;\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nexport declare function ɵtransitiveScopesFor<T>(type: Type<T>): ɵNgModuleTransitiveScopes;\n\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\nexport declare function ɵunregisterLocaleData(): void;\n\nexport declare function ɵunwrapSafeValue(value: ɵSafeValue): string;\n\nexport declare function ɵunwrapSafeValue<T>(value: T): T;\n\nexport declare class ɵViewRef<T> implements EmbeddedViewRef<T>, InternalViewRef, viewEngine_ChangeDetectorRef_interface {\n    /**\n     * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n     * requested.\n     *\n     * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n     */\n    private _cdRefInjectingView?;\n    private _appRef;\n    private _attachedToViewContainer;\n    get rootNodes(): any[];\n    constructor(\n    /**\n     * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n     *\n     * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n     * component.\n     *\n     * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n     * view.\n     *\n     * @internal\n     */\n    _lView: LView, \n    /**\n     * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n     * requested.\n     *\n     * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n     */\n    _cdRefInjectingView?: LView<unknown> | undefined);\n    get context(): T;\n    set context(value: T);\n    get destroyed(): boolean;\n    destroy(): void;\n    onDestroy(callback: Function): void;\n    /**\n     * Marks a view and all of its ancestors dirty.\n     *\n     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n     * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n     * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n     *\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'app-root',\n     *   template: `Number of ticks: {{numberOfTicks}}`\n     *   changeDetection: ChangeDetectionStrategy.OnPush,\n     * })\n     * class AppComponent {\n     *   numberOfTicks = 0;\n     *\n     *   constructor(private ref: ChangeDetectorRef) {\n     *     setInterval(() => {\n     *       this.numberOfTicks++;\n     *       // the following is required, otherwise the view will not be updated\n     *       this.ref.markForCheck();\n     *     }, 1000);\n     *   }\n     * }\n     * ```\n     */\n    markForCheck(): void;\n    /**\n     * Detaches the view from the change detection tree.\n     *\n     * Detached views will not be checked during change detection runs until they are\n     * re-attached, even if they are dirty. `detach` can be used in combination with\n     * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n     * detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds. We can do that by detaching\n     * the component's change detector and doing a local check every five seconds.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   // in a real application the returned data will be different every time\n     *   get data() {\n     *     return [1,2,3,4,5];\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'giant-list',\n     *   template: `\n     *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n     *   `,\n     * })\n     * class GiantList {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n     *     ref.detach();\n     *     setInterval(() => {\n     *       this.ref.detectChanges();\n     *     }, 5000);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   providers: [DataProvider],\n     *   template: `\n     *     <giant-list><giant-list>\n     *   `,\n     * })\n     * class App {\n     * }\n     * ```\n     */\n    detach(): void;\n    /**\n     * Re-attaches a view to the change detection tree.\n     *\n     * This can be used to re-attach views that were previously detached from the tree\n     * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example creates a component displaying `live` data. The component will detach\n     * its change detector from the main change detector tree when the component's live property\n     * is set to false.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   data = 1;\n     *\n     *   constructor() {\n     *     setInterval(() => {\n     *       this.data = this.data * 2;\n     *     }, 500);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'live-data',\n     *   inputs: ['live'],\n     *   template: 'Data: {{dataProvider.data}}'\n     * })\n     * class LiveData {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n     *\n     *   set live(value) {\n     *     if (value) {\n     *       this.ref.reattach();\n     *     } else {\n     *       this.ref.detach();\n     *     }\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app-root',\n     *   providers: [DataProvider],\n     *   template: `\n     *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n     *     <live-data [live]=\"live\"><live-data>\n     *   `,\n     * })\n     * class AppComponent {\n     *   live = true;\n     * }\n     * ```\n     */\n    reattach(): void;\n    /**\n     * Checks the view and its children.\n     *\n     * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n     * local change detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine, the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds.\n     *\n     * We can do that by detaching the component's change detector and doing a local change detection\n     * check every five seconds.\n     *\n     * See {@link ChangeDetectorRef#detach detach} for more information.\n     */\n    detectChanges(): void;\n    /**\n     * Checks the change detector and its children, and throws if any changes are detected.\n     *\n     * This is used in development mode to verify that running change detection doesn't\n     * introduce other changes.\n     */\n    checkNoChanges(): void;\n    attachToViewContainerRef(): void;\n    detachFromAppRef(): void;\n    attachToAppRef(appRef: ViewRefTracker): void;\n}\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nexport declare function ɵɵadvance(delta: number): void;\n\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\nexport declare function ɵɵattribute(name: string, value: any, sanitizer?: SanitizerFn | null, namespace?: string): typeof ɵɵattribute;\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate1(attrName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate1;\n\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate2(attrName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate2;\n\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate3(attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate3;\n\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate4(attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate4;\n\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate5(attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate5;\n\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate6(attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate6;\n\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate7(attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate7;\n\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolate8(attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate8;\n\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵattributeInterpolateV(attrName: string, values: any[], sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolateV;\n\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nexport declare function ɵɵclassMap(classes: {\n    [className: string]: boolean | undefined | null;\n} | string | undefined | null): void;\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate1(prefix: string, v0: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate2(prefix: string, v0: any, i0: string, v1: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate3(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate4(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate5(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate6(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate7(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolate8(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string): void;\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport declare function ɵɵclassMapInterpolateV(values: any[]): void;\n\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nexport declare function ɵɵclassProp(className: string, value: boolean | undefined | null): typeof ɵɵclassProp;\n\n/**\n * @publicApi\n */\nexport declare type ɵɵComponentDeclaration<T, Selector extends String, ExportAs extends string[], InputMap extends {\n    [key: string]: string;\n}, OutputMap extends {\n    [key: string]: string;\n}, QueryFields extends string[], NgContentSelectors extends string[], IsStandalone extends boolean = false> = unknown;\n\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n *\n * @param directiveIndex Current directive index\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n * @returns QueryList<T>\n *\n * @codeGenApi\n */\nexport declare function ɵɵcontentQuery<T>(directiveIndex: number, predicate: ProviderToken<unknown> | string[], flags: QueryFlags, read?: any): void;\n\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport declare function ɵɵCopyDefinitionFeature(definition: ɵDirectiveDef<any> | ɵComponentDef<any>): void;\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nexport declare function ɵɵdefineComponent<T>(componentDefinition: {\n    /**\n     * Directive type, needed to configure the injector.\n     */\n    type: Type<T>;\n    /** The selectors that will be used to match nodes to this component. */\n    selectors?: ɵCssSelectorList;\n    /**\n     * The number of nodes, local refs, and pipes in this component template.\n     *\n     * Used to calculate the length of this component's LView array, so we\n     * can pre-fill the array and set the binding start index.\n     */\n    decls: number;\n    /**\n     * The number of bindings in this component template (including pure fn bindings).\n     *\n     * Used to calculate the length of this component's LView array, so we\n     * can pre-fill the array and set the host binding start index.\n     */\n    vars: number;\n    /**\n     * A map of input names.\n     *\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n     *\n     * Given:\n     * ```\n     * class MyComponent {\n     *   @Input()\n     *   publicInput1: string;\n     *\n     *   @Input('publicInput2')\n     *   declaredInput2: string;\n     * }\n     * ```\n     *\n     * is described as:\n     * ```\n     * {\n     *   publicInput1: 'publicInput1',\n     *   declaredInput2: ['publicInput2', 'declaredInput2'],\n     * }\n     * ```\n     *\n     * Which the minifier may translate to:\n     * ```\n     * {\n     *   minifiedPublicInput1: 'publicInput1',\n     *   minifiedDeclaredInput2: ['publicInput2', 'declaredInput2'],\n     * }\n     * ```\n     *\n     * This allows the render to re-construct the minified, public, and declared names\n     * of properties.\n     *\n     * NOTE:\n     *  - Because declared and public name are usually same we only generate the array\n     *    `['public', 'declared']` format when they differ.\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n     *    API will be simplified to be consistent with `output`.\n     */\n    inputs?: {\n        [P in keyof T]?: string | [string, string];\n    };\n    /**\n     * A map of output names.\n     *\n     * The format is in: `{[actualPropertyName: string]:string}`.\n     *\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n     *\n     * This allows the render to re-construct the minified and non-minified names\n     * of properties.\n     */\n    outputs?: {\n        [P in keyof T]?: string;\n    };\n    /**\n     * Function executed by the parent template to allow child directive to apply host bindings.\n     */\n    hostBindings?: HostBindingsFunction<T>;\n    /**\n     * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n     *\n     * Used to calculate the length of the component's LView array, so we\n     * can pre-fill the array and set the host binding start index.\n     */\n    hostVars?: number;\n    /**\n     * Assign static attribute values to a host element.\n     *\n     * This property will assign static attribute values as well as class and style\n     * values to a host element. Since attribute values can consist of different types of values, the\n     * `hostAttrs` array must include the values in the following format:\n     *\n     * attrs = [\n     *   // static attributes (like `title`, `name`, `id`...)\n     *   attr1, value1, attr2, value,\n     *\n     *   // a single namespace value (like `x:id`)\n     *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n     *\n     *   // another single namespace value (like `x:name`)\n     *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n     *\n     *   // a series of CSS classes that will be applied to the element (no spaces)\n     *   CLASSES_MARKER, class1, class2, class3,\n     *\n     *   // a series of CSS styles (property + value) that will be applied to the element\n     *   STYLES_MARKER, prop1, value1, prop2, value2\n     * ]\n     *\n     * All non-class and non-style attributes must be defined at the start of the list\n     * first before all class and style values are set. When there is a change in value\n     * type (like when classes and styles are introduced) a marker must be used to separate\n     * the entries. The marker values themselves are set via entries found in the\n     * [AttributeMarker] enum.\n     */\n    hostAttrs?: TAttributes;\n    /**\n     * Function to create instances of content queries associated with a given directive.\n     */\n    contentQueries?: ContentQueriesFunction<T>;\n    /**\n     * Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * See: {@link Directive.exportAs}\n     */\n    exportAs?: string[];\n    /**\n     * Template function use for rendering DOM.\n     *\n     * This function has following structure.\n     *\n     * ```\n     * function Template<T>(ctx:T, creationMode: boolean) {\n     *   if (creationMode) {\n     *     // Contains creation mode instructions.\n     *   }\n     *   // Contains binding update instructions\n     * }\n     * ```\n     *\n     * Common instructions are:\n     * Creation mode instructions:\n     *  - `elementStart`, `elementEnd`\n     *  - `text`\n     *  - `container`\n     *  - `listener`\n     *\n     * Binding update instructions:\n     * - `bind`\n     * - `elementAttribute`\n     * - `elementProperty`\n     * - `elementClass`\n     * - `elementStyle`\n     *\n     */\n    template: ComponentTemplate<T>;\n    /**\n     * Constants for the nodes in the component's view.\n     * Includes attribute arrays, local definition arrays etc.\n     */\n    consts?: TConstantsOrFactory;\n    /**\n     * An array of `ngContent[selector]` values that were found in the template.\n     */\n    ngContentSelectors?: string[];\n    /**\n     * Additional set of instructions specific to view query processing. This could be seen as a\n     * set of instruction to be inserted into the template function.\n     *\n     * Query-related instructions need to be pulled out to a specific function as a timing of\n     * execution is different as compared to all other instructions (after change detection hooks but\n     * before view hooks).\n     */\n    viewQuery?: ViewQueriesFunction<T> | null;\n    /**\n     * A list of optional features to apply.\n     *\n     * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n     */\n    features?: ComponentDefFeature[];\n    /**\n     * Defines template and style encapsulation options available for Component's {@link Component}.\n     */\n    encapsulation?: ViewEncapsulation;\n    /**\n     * Defines arbitrary developer-defined data to be stored on a renderer instance.\n     * This is useful for renderers that delegate to other renderers.\n     *\n     * see: animation\n     */\n    data?: {\n        [kind: string]: any;\n    };\n    /**\n     * A set of styles that the component needs to be present for component to render correctly.\n     */\n    styles?: string[];\n    /**\n     * The strategy that the default change detector uses to detect changes.\n     * When set, takes effect the next time change detection is triggered.\n     */\n    changeDetection?: ChangeDetectionStrategy;\n    /**\n     * Registry of directives, components, and pipes that may be found in this component's view.\n     *\n     * This property is either an array of types or a function that returns the array of types. This\n     * function may be necessary to support forward declarations.\n     */\n    dependencies?: TypeOrFactory<DependencyTypeList>;\n    /**\n     * The set of schemas that declare elements to be allowed in the component's template.\n     */\n    schemas?: SchemaMetadata[] | null;\n    /**\n     * Whether this directive/component is standalone.\n     */\n    standalone?: boolean;\n}): unknown;\n\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport declare const ɵɵdefineDirective: <T>(directiveDefinition: {\n    /**\n     * Directive type, needed to configure the injector.\n     */\n    type: Type<T>;\n    /** The selectors that will be used to match nodes to this directive. */\n    selectors?: ɵCssSelectorList | undefined;\n    /**\n     * A map of input names.\n     *\n     * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n     *\n     * Given:\n     * ```\n     * class MyComponent {\n     *   @Input()\n     *   publicInput1: string;\n     *\n     *   @Input('publicInput2')\n     *   declaredInput2: string;\n     * }\n     * ```\n     *\n     * is described as:\n     * ```\n     * {\n     *   publicInput1: 'publicInput1',\n     *   declaredInput2: ['declaredInput2', 'publicInput2'],\n     * }\n     * ```\n     *\n     * Which the minifier may translate to:\n     * ```\n     * {\n     *   minifiedPublicInput1: 'publicInput1',\n     *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n     * }\n     * ```\n     *\n     * This allows the render to re-construct the minified, public, and declared names\n     * of properties.\n     *\n     * NOTE:\n     *  - Because declared and public name are usually same we only generate the array\n     *    `['declared', 'public']` format when they differ.\n     *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n     *    inconsistent behavior in that it uses declared names rather than minified or public. For\n     *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n     *    API will be simplified to be consistent with `output`.\n     */\n    inputs?: { [P in keyof T]?: string | [string, string] | undefined; } | undefined;\n    /**\n     * A map of output names.\n     *\n     * The format is in: `{[actualPropertyName: string]:string}`.\n     *\n     * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n     *\n     * This allows the render to re-construct the minified and non-minified names\n     * of properties.\n     */\n    outputs?: { [P_1 in keyof T]?: string | undefined; } | undefined;\n    /**\n     * A list of optional features to apply.\n     *\n     * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n     */\n    features?: DirectiveDefFeature[] | undefined;\n    /**\n     * Function executed by the parent template to allow child directive to apply host bindings.\n     */\n    hostBindings?: HostBindingsFunction<T> | undefined;\n    /**\n     * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n     *\n     * Used to calculate the length of the component's LView array, so we\n     * can pre-fill the array and set the host binding start index.\n     */\n    hostVars?: number | undefined;\n    /**\n     * Assign static attribute values to a host element.\n     *\n     * This property will assign static attribute values as well as class and style\n     * values to a host element. Since attribute values can consist of different types of values,\n     * the `hostAttrs` array must include the values in the following format:\n     *\n     * attrs = [\n     *   // static attributes (like `title`, `name`, `id`...)\n     *   attr1, value1, attr2, value,\n     *\n     *   // a single namespace value (like `x:id`)\n     *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n     *\n     *   // another single namespace value (like `x:name`)\n     *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n     *\n     *   // a series of CSS classes that will be applied to the element (no spaces)\n     *   CLASSES_MARKER, class1, class2, class3,\n     *\n     *   // a series of CSS styles (property + value) that will be applied to the element\n     *   STYLES_MARKER, prop1, value1, prop2, value2\n     * ]\n     *\n     * All non-class and non-style attributes must be defined at the start of the list\n     * first before all class and style values are set. When there is a change in value\n     * type (like when classes and styles are introduced) a marker must be used to separate\n     * the entries. The marker values themselves are set via entries found in the\n     * [AttributeMarker] enum.\n     */\n    hostAttrs?: TAttributes | undefined;\n    /**\n     * Function to create instances of content queries associated with a given directive.\n     */\n    contentQueries?: ContentQueriesFunction<T> | undefined;\n    /**\n     * Additional set of instructions specific to view query processing. This could be seen as a\n     * set of instructions to be inserted into the template function.\n     */\n    viewQuery?: ViewQueriesFunction<T> | null | undefined;\n    /**\n     * Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * See: {@link Directive.exportAs}\n     */\n    exportAs?: string[] | undefined;\n}) => never;\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport declare function ɵɵdefineInjectable<T>(opts: {\n    token: unknown;\n    providedIn?: Type<any> | 'root' | 'platform' | 'any' | 'environment' | null;\n    factory: () => T;\n}): unknown;\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nexport declare function ɵɵdefineInjector(options: {\n    providers?: any[];\n    imports?: any[];\n}): unknown;\n\n/**\n * @codeGenApi\n */\nexport declare function ɵɵdefineNgModule<T>(def: {\n    /** Token representing the module. Used by DI. */\n    type: T;\n    /** List of components to bootstrap. */\n    bootstrap?: Type<any>[] | (() => Type<any>[]);\n    /** List of components, directives, and pipes declared by this module. */\n    declarations?: Type<any>[] | (() => Type<any>[]);\n    /** List of modules or `ModuleWithProviders` imported by this module. */\n    imports?: Type<any>[] | (() => Type<any>[]);\n    /**\n     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n     * module.\n     */\n    exports?: Type<any>[] | (() => Type<any>[]);\n    /** The set of schemas that declare elements to be allowed in the NgModule. */\n    schemas?: SchemaMetadata[] | null;\n    /** Unique ID for the module that is used with `getModuleFactory`. */\n    id?: string | null;\n}): unknown;\n\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nexport declare function ɵɵdefinePipe<T>(pipeDef: {\n    /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n    name: string;\n    /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n    type: Type<T>;\n    /** Whether the pipe is pure. */\n    pure?: boolean;\n    /**\n     * Whether the pipe is standalone.\n     */\n    standalone?: boolean;\n}): unknown;\n\n\n/**\n * @publicApi\n */\nexport declare type ɵɵDirectiveDeclaration<T, Selector extends string, ExportAs extends string[], InputMap extends {\n    [key: string]: string;\n}, OutputMap extends {\n    [key: string]: string;\n}, QueryFields extends string[], NgContentSelectors extends never = never, IsStandalone extends boolean = false> = unknown;\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * ```ts\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ɵdir = ɵɵdefineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(ɵɵdirectiveInject(DirectiveA))\n *   });\n * }\n * ```\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n *\n * @codeGenApi\n */\nexport declare function ɵɵdirectiveInject<T>(token: ProviderToken<T>): T;\n\nexport declare function ɵɵdirectiveInject<T>(token: ProviderToken<T>, flags: InjectFlags): T;\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport declare function ɵɵdisableBindings(): void;\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport declare function ɵɵelement(index: number, name: string, attrsIndex?: number | null, localRefsIndex?: number): typeof ɵɵelement;\n\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport declare function ɵɵelementContainer(index: number, attrsIndex?: number | null, localRefsIndex?: number): typeof ɵɵelementContainer;\n\n/**\n * Mark the end of the <ng-container>.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport declare function ɵɵelementContainerEnd(): typeof ɵɵelementContainerEnd;\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\nexport declare function ɵɵelementContainerStart(index: number, attrsIndex?: number | null, localRefsIndex?: number): typeof ɵɵelementContainerStart;\n\n/**\n * Mark the end of the element.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport declare function ɵɵelementEnd(): typeof ɵɵelementEnd;\n\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nexport declare function ɵɵelementStart(index: number, name: string, attrsIndex?: number | null, localRefsIndex?: number): typeof ɵɵelementStart;\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport declare function ɵɵenableBindings(): void;\n\n/**\n * @publicApi\n */\nexport declare type ɵɵFactoryDeclaration<T, CtorDependencies extends CtorDependency[]> = unknown;\n\nexport declare enum ɵɵFactoryTarget {\n    Directive = 0,\n    Component = 1,\n    Injectable = 2,\n    Pipe = 3,\n    NgModule = 4\n}\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nexport declare function ɵɵgetCurrentView(): OpaqueViewState;\n\n/**\n * @codeGenApi\n */\nexport declare function ɵɵgetInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T;\n\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport declare function ɵɵhostProperty<T>(propName: string, value: T, sanitizer?: SanitizerFn | null): typeof ɵɵhostProperty;\n\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport declare function ɵɵi18n(index: number, messageIndex: number, subTemplateIndex?: number): void;\n\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nexport declare function ɵɵi18nApply(index: number): void;\n\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nexport declare function ɵɵi18nAttributes(index: number, attrsIndex: number): void;\n\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nexport declare function ɵɵi18nEnd(): void;\n\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nexport declare function ɵɵi18nExp<T>(value: T): typeof ɵɵi18nExp;\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport declare function ɵɵi18nPostprocess(message: string, replacements?: {\n    [key: string]: (string | string[]);\n}): string;\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport declare function ɵɵi18nStart(index: number, messageIndex: number, subTemplateIndex?: number): void;\n\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nexport declare function ɵɵInheritDefinitionFeature(definition: ɵDirectiveDef<any> | ɵComponentDef<any>): void;\n\n/**\n * Generated instruction: injects a token from the currently active injector.\n *\n * (Additional documentation moved to `inject`, as it is the public API, and an alias for this\n * instruction)\n *\n * @see inject\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport declare function ɵɵinject<T>(token: ProviderToken<T>): T;\n\nexport declare function ɵɵinject<T>(token: ProviderToken<T>, flags?: InjectFlags): T | null;\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `Injector`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * @codeGenApi\n * @publicApi The ViewEngine compiler emits code with this type for injectables. This code is\n *   deployed to npm, and should be treated as public api.\n\n */\nexport declare interface ɵɵInjectableDeclaration<T> {\n    /**\n     * Specifies that the given type belongs to a particular injector:\n     * - `InjectorType` such as `NgModule`,\n     * - `'root'` the root injector\n     * - `'any'` all injectors.\n     * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n     *   `providers`.\n     */\n    providedIn: InjectorType<any> | 'root' | 'platform' | 'any' | 'environment' | null;\n    /**\n     * The token to which this definition belongs.\n     *\n     * Note that this may not be the same as the type that the `factory` will create.\n     */\n    token: unknown;\n    /**\n     * Factory method to execute to create an instance of the injectable.\n     */\n    factory: (t?: Type<any>) => T;\n    /**\n     * In a case of no explicit injector, a location where the instance of the injectable is stored.\n     */\n    value: T | undefined;\n}\n\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nexport declare function ɵɵinjectAttribute(attrNameToInject: string): string | null;\n\n/**\n * @publicApi\n */\nexport declare type ɵɵInjectorDeclaration<T> = unknown;\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n *\n * @codeGenApi\n */\nexport declare interface ɵɵInjectorDef<T> {\n    providers: (Type<any> | ValueProvider | ExistingProvider | FactoryProvider | ConstructorProvider | StaticClassProvider | ClassProvider | any[])[];\n    imports: (InjectorType<any> | InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport declare function ɵɵinvalidFactory(): never;\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport declare function ɵɵinvalidFactoryDep(index: number): never;\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nexport declare function ɵɵlistener(eventName: string, listenerFn: (e?: any) => any, useCapture?: boolean, eventTargetResolver?: GlobalTargetResolver): typeof ɵɵlistener;\n\n/**\n * Loads a QueryList corresponding to the current view or content query.\n *\n * @codeGenApi\n */\nexport declare function ɵɵloadQuery<T>(): QueryList<T>;\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nexport declare function ɵɵnamespaceHTML(): void;\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nexport declare function ɵɵnamespaceMathML(): void;\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nexport declare function ɵɵnamespaceSVG(): void;\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nexport declare function ɵɵnextContext<T = any>(level?: number): T;\n\n/**\n * Evaluates the class metadata declaration.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclareClassMetadata(decl: {\n    type: Type<any>;\n    decorators: any[];\n    ctorParameters?: () => any[];\n    propDecorators?: {\n        [field: string]: any;\n    };\n}): void;\n\n/**\n * Compiles a partial component declaration object into a full component definition object.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclareComponent(decl: R3DeclareComponentFacade): unknown;\n\n/**\n * Compiles a partial directive declaration object into a full directive definition object.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclareDirective(decl: R3DeclareDirectiveFacade): unknown;\n\n/**\n * Compiles a partial pipe declaration object into a full pipe definition object.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclareFactory(decl: R3DeclareFactoryFacade): unknown;\n\n/**\n * Compiles a partial injectable declaration object into a full injectable definition object.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclareInjectable(decl: R3DeclareInjectableFacade): unknown;\n\n/**\n * Compiles a partial injector declaration object into a full injector definition object.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclareInjector(decl: R3DeclareInjectorFacade): unknown;\n\n/**\n * Compiles a partial NgModule declaration object into a full NgModule definition object.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclareNgModule(decl: R3DeclareNgModuleFacade): unknown;\n\n/**\n * Compiles a partial pipe declaration object into a full pipe definition object.\n *\n * @codeGenApi\n */\nexport declare function ɵɵngDeclarePipe(decl: R3DeclarePipeFacade): unknown;\n\n/**\n * @publicApi\n */\nexport declare type ɵɵNgModuleDeclaration<T, Declarations, Imports, Exports> = unknown;\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nexport declare function ɵɵNgOnChangesFeature<T>(): DirectiveDefFeature;\n\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\nexport declare function ɵɵpipe(index: number, pipeName: string): any;\n\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport declare function ɵɵpipeBind1(index: number, slotOffset: number, v1: any): any;\n\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport declare function ɵɵpipeBind2(index: number, slotOffset: number, v1: any, v2: any): any;\n\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport declare function ɵɵpipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any;\n\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport declare function ɵɵpipeBind4(index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any;\n\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\nexport declare function ɵɵpipeBindV(index: number, slotOffset: number, values: [any, ...any[]]): any;\n\n/**\n * @publicApi\n */\nexport declare type ɵɵPipeDeclaration<T, Name extends string, IsStandalone extends boolean = false> = unknown;\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n */\nexport declare function ɵɵprojection(nodeIndex: number, selectorIndex?: number, attrs?: TAttributes): void;\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nexport declare function ɵɵprojectionDef(projectionSlots?: ProjectionSlots): void;\n\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport declare function ɵɵproperty<T>(propName: string, value: T, sanitizer?: SanitizerFn | null): typeof ɵɵproperty;\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate(propName: string, v0: any, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate;\n\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate1(propName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate1;\n\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate2(propName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate2;\n\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate3(propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate3;\n\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate4(propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate4;\n\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate5(propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate5;\n\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate6(propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate6;\n\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate7(propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate7;\n\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolate8(propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate8;\n\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵpropertyInterpolateV(propName: string, values: any[], sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolateV;\n\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * ```ts\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static ɵcmp = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    decls: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        ɵɵtext(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        ɵɵtextInterpolate(ctx.greeter.greet());\n *      }\n *    },\n *    features: [ɵɵProvidersFeature([GreeterDE])]\n *  });\n * }\n * ```\n *\n * @param definition\n *\n * @codeGenApi\n */\nexport declare function ɵɵProvidersFeature<T>(providers: Provider[], viewProviders?: Provider[]): (definition: ɵDirectiveDef<T>) => void;\n\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction0<T>(slotOffset: number, pureFn: () => T, thisArg?: any): T;\n\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction1(slotOffset: number, pureFn: (v: any) => any, exp: any, thisArg?: any): any;\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction2(slotOffset: number, pureFn: (v1: any, v2: any) => any, exp1: any, exp2: any, thisArg?: any): any;\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction3(slotOffset: number, pureFn: (v1: any, v2: any, v3: any) => any, exp1: any, exp2: any, exp3: any, thisArg?: any): any;\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction4(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, thisArg?: any): any;\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction5(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, thisArg?: any): any;\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction6(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, thisArg?: any): any;\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction7(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, thisArg?: any): any;\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunction8(slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any) => any, exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, exp8: any, thisArg?: any): any;\n\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport declare function ɵɵpureFunctionV(slotOffset: number, pureFn: (...v: any[]) => any, exps: any[], thisArg?: any): any;\n\n/**\n * Refreshes a query by combining matches from all active views and removing matches from deleted\n * views.\n *\n * @returns `true` if a query got dirty during change detection or if this is a static query\n * resolving in creation mode, `false` otherwise.\n *\n * @codeGenApi\n */\nexport declare function ɵɵqueryRefresh(queryList: QueryList<any>): boolean;\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\nexport declare function ɵɵreference<T>(index: number): T;\n\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nexport declare function ɵɵregisterNgModuleType(ngModuleType: ɵNgModuleType, id: string): void;\n\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nexport declare function ɵɵresetView<T>(value?: T): T | undefined;\n\n/**\n *\n * @codeGenApi\n */\nexport declare function ɵɵresolveBody(element: RElement & {\n    ownerDocument: Document;\n}): HTMLElement;\n\n/**\n *\n * @codeGenApi\n */\nexport declare function ɵɵresolveDocument(element: RElement & {\n    ownerDocument: Document;\n}): Document;\n\n/**\n *\n * @codeGenApi\n */\nexport declare function ɵɵresolveWindow(element: RElement & {\n    ownerDocument: Document;\n}): (Window & typeof globalThis) | null;\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nexport declare function ɵɵrestoreView<T = any>(viewToRestore: OpaqueViewState): T;\n\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsanitizeHtml(unsafeHtml: any): TrustedHTML | string;\n\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsanitizeResourceUrl(unsafeResourceUrl: any): TrustedScriptURL | string;\n\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsanitizeScript(unsafeScript: any): TrustedScript | string;\n\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsanitizeStyle(unsafeStyle: any): string;\n\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsanitizeUrl(unsafeUrl: any): string;\n\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl: any, tag: string, prop: string): any;\n\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsetComponentScope(type: ɵComponentType<any>, directives: Type<any>[] | (() => Type<any>[]), pipes: Type<any>[] | (() => Type<any>[])): void;\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsetNgModuleScope(type: any, scope: {\n    /** List of components, directives, and pipes declared by this module. */\n    declarations?: Type<any>[] | (() => Type<any>[]);\n    /** List of modules or `ModuleWithProviders` imported by this module. */\n    imports?: Type<any>[] | (() => Type<any>[]);\n    /**\n     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n     * module.\n     */\n    exports?: Type<any>[] | (() => Type<any>[]);\n}): unknown;\n\n/**\n * A feature that acts as a setup code for the {@link StandaloneService}.\n *\n * The most important responsibility of this feature is to expose the \"getStandaloneInjector\"\n * function (an entry points to a standalone injector creation) on a component definition object. We\n * go through the features infrastructure to make sure that the standalone injector creation logic\n * is tree-shakable and not included in applications that don't use standalone components.\n *\n * @codeGenApi\n */\nexport declare function ɵɵStandaloneFeature(definition: ɵComponentDef<unknown>): void;\n\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nexport declare function ɵɵstyleMap(styles: {\n    [styleName: string]: any;\n} | string | undefined | null): void;\n\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate1(prefix: string, v0: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate2(prefix: string, v0: any, i0: string, v1: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate3(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate4(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate5(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate6(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate7(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void;\n\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolate8(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string): void;\n\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport declare function ɵɵstyleMapInterpolateV(values: any[]): void;\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nexport declare function ɵɵstyleProp(prop: string, value: string | number | ɵSafeValue | undefined | null, suffix?: string | null): typeof ɵɵstyleProp;\n\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate1(prop: string, prefix: string, v0: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate1;\n\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate2(prop: string, prefix: string, v0: any, i0: string, v1: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate2;\n\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate3(prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate3;\n\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate4(prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate4;\n\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate5(prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate5;\n\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate6(prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate6;\n\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate7(prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate7;\n\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolate8(prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string, valueSuffix?: string | null): typeof ɵɵstylePropInterpolate8;\n\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵstylePropInterpolateV(prop: string, values: any[], valueSuffix?: string | null): typeof ɵɵstylePropInterpolateV;\n\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nexport declare function ɵɵsyntheticHostListener(eventName: string, listenerFn: (e?: any) => any): typeof ɵɵsyntheticHostListener;\n\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\nexport declare function ɵɵsyntheticHostProperty<T>(propName: string, value: T | ɵNO_CHANGE, sanitizer?: SanitizerFn | null): typeof ɵɵsyntheticHostProperty;\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nexport declare function ɵɵtemplate(index: number, templateFn: ComponentTemplate<any> | null, decls: number, vars: number, tagName?: string | null, attrsIndex?: number | null, localRefsIndex?: number | null, localRefExtractor?: LocalRefExtractor): void;\n\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n *\n * @codeGenApi\n */\nexport declare function ɵɵtemplateRefExtractor(tNode: TNode, lView: LView): TemplateRef<any> | null;\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nexport declare function ɵɵtext(index: number, value?: string): void;\n\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate(v0: any): typeof ɵɵtextInterpolate;\n\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate1(prefix: string, v0: any, suffix: string): typeof ɵɵtextInterpolate1;\n\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate2(prefix: string, v0: any, i0: string, v1: any, suffix: string): typeof ɵɵtextInterpolate2;\n\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate3(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): typeof ɵɵtextInterpolate3;\n\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ɵɵtextInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate4(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, suffix: string): typeof ɵɵtextInterpolate4;\n\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate5(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, suffix: string): typeof ɵɵtextInterpolate5;\n\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate6(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): typeof ɵɵtextInterpolate6;\n\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate7(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): typeof ɵɵtextInterpolate7;\n\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolate8(prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any, suffix: string): typeof ɵɵtextInterpolate8;\n\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport declare function ɵɵtextInterpolateV(values: any[]): typeof ɵɵtextInterpolateV;\n\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedHTML. Interpolation is explicitly not allowed.\n *\n * @param html constant template literal containing trusted HTML.\n * @returns TrustedHTML wrapping `html`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedHTML.\n *\n * @codeGenApi\n */\nexport declare function ɵɵtrustConstantHtml(html: TemplateStringsArray): TrustedHTML | string;\n\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedScriptURL. Interpolation is explicitly not allowed.\n *\n * @param url constant template literal containing a trusted script URL.\n * @returns TrustedScriptURL wrapping `url`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedScriptURL.\n *\n * @codeGenApi\n */\nexport declare function ɵɵtrustConstantResourceUrl(url: TemplateStringsArray): TrustedScriptURL | string;\n\n/**\n * Creates new QueryList, stores the reference in LView and returns QueryList.\n *\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n *\n * @codeGenApi\n */\nexport declare function ɵɵviewQuery<T>(predicate: ProviderToken<unknown> | string[], flags: QueryFlags, read?: any): void;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/entry-components/index.d.ts",
      "node_modules/@angular/core/schematics/migrations/entry-components/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/entry-components\" />\nimport { Rule } from '@angular-devkit/schematics';\n/** Migration that removes `entryComponents` usages. */\nexport default function (): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/entry-components/util.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/entry-components/util\" />\nimport ts from 'typescript';\n/** Finds and migrates all Angular decorators that pass in `entryComponents`. */\nexport declare function migrateEntryComponentsUsages(typeChecker: ts.TypeChecker, printer: ts.Printer, sourceFile: ts.SourceFile): {\n    start: number;\n    length: number;\n    end: number;\n    replacement: string;\n}[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/path-match-type/index.d.ts",
      "node_modules/@angular/core/schematics/migrations/path-match-type/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/path-match-type\" />\nimport { Rule } from '@angular-devkit/schematics';\n/** Migration that adds explicit type to `Route`/`Routes` which use `patchMatch` */\nexport default function (): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/path-match-type/transform.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/path-match-type/transform\" />\nimport ts from 'typescript';\nimport { UpdateRecorder } from './update_recorder';\nexport declare class PathMatchTypeTransform {\n    private getUpdateRecorder;\n    private printer;\n    private importManager;\n    constructor(getUpdateRecorder: (sf: ts.SourceFile) => UpdateRecorder);\n    migrate(sourceFiles: ts.SourceFile[]): void;\n    /** Records all changes that were made in the import manager. */\n    recordChanges(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/path-match-type/update_recorder.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/path-match-type/update_recorder\" />\nimport ts from 'typescript';\nimport { ImportManagerUpdateRecorder } from '../../utils/import_manager';\n/**\n * Update recorder interface that is used to transform source files\n * in a non-colliding way.\n */\nexport interface UpdateRecorder extends ImportManagerUpdateRecorder {\n    updateNode(oldNode: ts.VariableDeclaration, newNode: ts.VariableDeclaration, sourceFile: ts.SourceFile): void;\n    commitUpdate(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/path-match-type/util.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/path-match-type/util\" />\nimport ts from 'typescript';\nimport { ImportManager } from '../../utils/import_manager';\nexport declare function findExpressionsToMigrate(sourceFile: ts.SourceFile, importManager: ImportManager): Map<ts.VariableDeclaration, ts.VariableDeclaration>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/typed-forms/index.d.ts",
      "node_modules/@angular/core/schematics/migrations/typed-forms/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/typed-forms\" />\nimport { Rule } from '@angular-devkit/schematics';\nexport default function (): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/migrations/typed-forms/util.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/migrations/typed-forms/util\" />\nimport ts from 'typescript';\nexport declare const classes: Set<string>;\nexport declare const formControl = \"FormControl\";\nexport declare const untypedPrefix = \"Untyped\";\nexport declare const forms = \"@angular/forms\";\nexport interface MigratableNode {\n    node: ts.Node;\n    importName: string;\n}\nexport declare type rewriteFn = (startPos: number, origLength: number, text: string) => void;\nexport declare function migrateFile(sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker, rewrite: rewriteFn): void;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/import_manager.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/import_manager\" />\nimport ts from 'typescript';\n/** Update recorder for managing imports. */\nexport interface ImportManagerUpdateRecorder {\n    addNewImport(start: number, importText: string): void;\n    updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string): void;\n}\n/**\n * Import manager that can be used to add TypeScript imports to given source\n * files. The manager ensures that multiple transformations are applied properly\n * without shifted offsets and that similar existing import declarations are re-used.\n */\nexport declare class ImportManager {\n    private getUpdateRecorder;\n    private printer;\n    /** Map of import declarations that need to be updated to include the given symbols. */\n    private updatedImports;\n    /** Map of source-files and their previously used identifier names. */\n    private usedIdentifierNames;\n    /**\n     * Array of previously resolved symbol imports. Cache can be re-used to return\n     * the same identifier without checking the source-file again.\n     */\n    private importCache;\n    constructor(getUpdateRecorder: (sf: ts.SourceFile) => ImportManagerUpdateRecorder, printer: ts.Printer);\n    /**\n     * Adds an import to the given source-file and returns the TypeScript\n     * identifier that can be used to access the newly imported symbol.\n     */\n    addImportToSourceFile(sourceFile: ts.SourceFile, symbolName: string | null, moduleName: string, typeImport?: boolean): ts.Expression;\n    /**\n     * Stores the collected import changes within the appropriate update recorders. The\n     * updated imports can only be updated *once* per source-file because previous updates\n     * could otherwise shift the source-file offsets.\n     */\n    recordChanges(): void;\n    /** Gets an unique identifier with a base name for the given source file. */\n    private _getUniqueIdentifier;\n    /**\n     * Checks whether the specified identifier name is used within the given\n     * source file.\n     */\n    private isUniqueIdentifierName;\n    private _recordUsedIdentifier;\n    /**\n     * Determines the full end of a given node. By default the end position of a node is\n     * before all trailing comments. This could mean that generated imports shift comments.\n     */\n    private _getEndPositionOfNode;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/line_mappings.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/line_mappings\" />\n/** Gets the line and character for the given position from the line starts map. */\nexport declare function getLineAndCharacterFromPosition(lineStartsMap: number[], position: number): {\n    character: number;\n    line: number;\n};\n/**\n * Computes the line start map of the given text. This can be used in order to\n * retrieve the line and character of a given text position index.\n */\nexport declare function computeLineStartsMap(text: string): number[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/load_esm.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/load_esm\" />\n/// <reference types=\"node\" />\nimport { URL } from 'url';\n/**\n * This uses a dynamic import to load a module which may be ESM.\n * CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript\n * will currently, unconditionally downlevel dynamic import into a require call.\n * require calls cannot load ESM code and will result in a runtime error. To workaround\n * this, a Function constructor is used to prevent TypeScript from changing the dynamic import.\n * Once TypeScript provides support for keeping the dynamic import this workaround can\n * be dropped.\n * This is only intended to be used with Angular framework packages.\n *\n * @param modulePath The path of the module to load.\n * @returns A Promise that resolves to the dynamically imported module.\n */\nexport declare function loadEsmModule<T>(modulePath: string | URL): Promise<T>;\n/**\n * Attempt to load the new `@angular/compiler-cli/private/migrations` entry. If not yet present\n * the previous deep imports are used to constructor an equivalent object.\n *\n * @returns A Promise that resolves to the dynamically imported compiler-cli private migrations\n * entry or an equivalent object if not available.\n */\nexport declare function loadCompilerCliMigrationsModule(): Promise<typeof import('@angular/compiler-cli/private/migrations')>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/ng_component_template.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/ng_component_template\" />\nimport { Tree } from '@angular-devkit/schematics';\nimport ts from 'typescript';\nexport interface ResolvedTemplate {\n    /** Class declaration that contains this template. */\n    container: ts.ClassDeclaration;\n    /** File content of the given template. */\n    content: string;\n    /** Start offset of the template content (e.g. in the inline source file) */\n    start: number;\n    /** Whether the given template is inline or not. */\n    inline: boolean;\n    /** Path to the file that contains this template. */\n    filePath: string;\n    /**\n     * Gets the character and line of a given position index in the template.\n     * If the template is declared inline within a TypeScript source file, the line and\n     * character are based on the full source file content.\n     */\n    getCharacterAndLineOfPosition: (pos: number) => {\n        character: number;\n        line: number;\n    };\n}\n/**\n * Visitor that can be used to determine Angular templates referenced within given\n * TypeScript source files (inline templates or external referenced templates)\n */\nexport declare class NgComponentTemplateVisitor {\n    typeChecker: ts.TypeChecker;\n    private _basePath;\n    private _tree;\n    resolvedTemplates: ResolvedTemplate[];\n    constructor(typeChecker: ts.TypeChecker, _basePath: string, _tree: Tree);\n    visitNode(node: ts.Node): void;\n    private visitClassDeclaration;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/ng_decorators.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/ng_decorators\" />\nimport ts from 'typescript';\nexport declare type CallExpressionDecorator = ts.Decorator & {\n    expression: ts.CallExpression;\n};\nexport interface NgDecorator {\n    name: string;\n    moduleName: string;\n    node: CallExpressionDecorator;\n    importNode: ts.ImportDeclaration;\n}\n/**\n * Gets all decorators which are imported from an Angular package (e.g. \"@angular/core\")\n * from a list of decorators.\n */\nexport declare function getAngularDecorators(typeChecker: ts.TypeChecker, decorators: ReadonlyArray<ts.Decorator>): NgDecorator[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/parse_html.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/parse_html\" />\nimport type { TmplAstNode } from '@angular/compiler';\n/**\n * Parses the given HTML content using the Angular compiler. In case the parsing\n * fails, null is being returned.\n */\nexport declare function parseHtmlGracefully(htmlContent: string, filePath: string, compilerModule: typeof import('@angular/compiler')): TmplAstNode[] | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/project_tsconfig_paths.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/project_tsconfig_paths\" />\nimport { Tree } from '@angular-devkit/schematics';\n/**\n * Gets all tsconfig paths from a CLI project by reading the workspace configuration\n * and looking for common tsconfig locations.\n */\nexport declare function getProjectTsConfigPaths(tree: Tree): Promise<{\n    buildPaths: string[];\n    testPaths: string[];\n}>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/template_ast_visitor.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/template_ast_visitor\" />\nimport type { TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstContent, TmplAstElement, TmplAstIcu, TmplAstNode, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable } from '@angular/compiler';\n/**\n * A base class that can be used to implement a Render3 Template AST visitor.\n * This class is used instead of the `NullVisitor` found within the `@angular/compiler` because\n * the `NullVisitor` requires a deep import which is no longer supported with the ESM bundled\n * packages as of v13.\n * Schematics are also currently required to be CommonJS to support execution within the Angular\n * CLI. As a result, the ESM `@angular/compiler` package must be loaded via a native dynamic import.\n * Using a dynamic import makes classes extending from classes present in `@angular/compiler`\n * complicated due to the class not being present at module evaluation time. The classes using a\n * base class found within `@angular/compiler` must be wrapped in a factory to allow the class value\n * to be accessible at runtime after the dynamic import has completed. This class implements the\n * interface of the `TmplAstRecursiveVisitor` class (but does not extend) as the\n * `TmplAstRecursiveVisitor` as an interface provides the required set of visit methods. The base\n * interface `Visitor<T>` is not exported.\n */\nexport declare class TemplateAstVisitor implements TmplAstRecursiveVisitor {\n    protected readonly compilerModule: typeof import('@angular/compiler');\n    /**\n     * Creates a new Render3 Template AST visitor using an instance of the `@angular/compiler`\n     * package. Passing in the compiler is required due to the need to dynamically import the\n     * ESM `@angular/compiler` into a CommonJS schematic.\n     *\n     * @param compilerModule The compiler instance that should be used within the visitor.\n     */\n    constructor(compilerModule: typeof import('@angular/compiler'));\n    visitElement(element: TmplAstElement): void;\n    visitTemplate(template: TmplAstTemplate): void;\n    visitContent(content: TmplAstContent): void;\n    visitVariable(variable: TmplAstVariable): void;\n    visitReference(reference: TmplAstReference): void;\n    visitTextAttribute(attribute: TmplAstTextAttribute): void;\n    visitBoundAttribute(attribute: TmplAstBoundAttribute): void;\n    visitBoundEvent(attribute: TmplAstBoundEvent): void;\n    visitText(text: TmplAstText): void;\n    visitBoundText(text: TmplAstBoundText): void;\n    visitIcu(icu: TmplAstIcu): void;\n    /**\n     * Visits all the provided nodes in order using this Visitor's visit methods.\n     * This is a simplified variant of the `visitAll` function found inside of (but not\n     * exported from) the `@angular/compiler` that does not support returning a value\n     * since the migrations do not directly transform the nodes.\n     *\n     * @param nodes An iterable of nodes to visit using this visitor.\n     */\n    visitAll(nodes: Iterable<TmplAstNode>): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/class_declaration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/class_declaration\" />\nimport ts from 'typescript';\n/** Determines the base type identifiers of a specified class declaration. */\nexport declare function getBaseTypeIdentifiers(node: ts.ClassDeclaration): ts.Identifier[] | null;\n/** Gets the first found parent class declaration of a given node. */\nexport declare function findParentClassDeclaration(node: ts.Node): ts.ClassDeclaration | null;\n/** Checks whether the given class declaration has an explicit constructor or not. */\nexport declare function hasExplicitConstructor(node: ts.ClassDeclaration): boolean;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/compiler_host.d.ts"
    ],
    "content": "/// <amd-module name=\"@angular/core/schematics/utils/typescript/compiler_host\" />\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\nimport ts from 'typescript';\nexport declare type FakeReadFileFn = (fileName: string) => string | undefined;\n/**\n * Creates a TypeScript program instance for a TypeScript project within\n * the virtual file system tree.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n */\nexport declare function createMigrationProgram(tree: Tree, tsconfigPath: string, basePath: string, fakeFileRead?: FakeReadFileFn, additionalFiles?: string[]): {\n    parsed: ts.ParsedCommandLine;\n    host: ts.CompilerHost;\n    program: ts.Program;\n};\nexport declare function createMigrationCompilerHost(tree: Tree, options: ts.CompilerOptions, basePath: string, fakeRead?: FakeReadFileFn): ts.CompilerHost;\n/**\n * Checks whether a file can be migrate by our automated migrations.\n * @param basePath Absolute path to the project.\n * @param sourceFile File being checked.\n * @param program Program that includes the source file.\n */\nexport declare function canMigrateFile(basePath: string, sourceFile: ts.SourceFile, program: ts.Program): boolean;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/decorators.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/decorators\" />\nimport ts from 'typescript';\nimport { Import } from './imports';\nexport declare function getCallDecoratorImport(typeChecker: ts.TypeChecker, decorator: ts.Decorator): Import | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/find_base_classes.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/find_base_classes\" />\nimport ts from 'typescript';\n/** Gets all base class declarations of the specified class declaration. */\nexport declare function findBaseClassDeclarations(node: ts.ClassDeclaration, typeChecker: ts.TypeChecker): {\n    identifier: ts.Identifier;\n    node: ts.ClassDeclaration;\n}[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/functions.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/functions\" />\nimport ts from 'typescript';\n/** Checks whether a given node is a function like declaration. */\nexport declare function isFunctionLikeDeclaration(node: ts.Node): node is ts.FunctionLikeDeclaration;\n/**\n * Unwraps a given expression TypeScript node. Expressions can be wrapped within multiple\n * parentheses or as expression. e.g. \"(((({exp}))))()\". The function should return the\n * TypeScript node referring to the inner expression. e.g \"exp\".\n */\nexport declare function unwrapExpression(node: ts.Expression | ts.ParenthesizedExpression): ts.Expression;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/imports.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/imports\" />\nimport ts from 'typescript';\nexport declare type Import = {\n    name: string;\n    importModule: string;\n    node: ts.ImportDeclaration;\n};\n/** Gets import information about the specified identifier by using the Type checker. */\nexport declare function getImportOfIdentifier(typeChecker: ts.TypeChecker, node: ts.Identifier): Import | null;\n/**\n * Gets a top-level import specifier with a specific name that is imported from a particular module.\n * E.g. given a file that looks like:\n *\n * ```\n * import { Component, Directive } from '@angular/core';\n * import { Foo } from './foo';\n * ```\n *\n * Calling `getImportSpecifier(sourceFile, '@angular/core', 'Directive')` will yield the node\n * referring to `Directive` in the top import.\n *\n * @param sourceFile File in which to look for imports.\n * @param moduleName Name of the import's module.\n * @param specifierName Original name of the specifier to look for. Aliases will be resolved to\n *    their original name.\n */\nexport declare function getImportSpecifier(sourceFile: ts.SourceFile, moduleName: string, specifierName: string): ts.ImportSpecifier | null;\n/**\n * Replaces an import inside a named imports node with a different one.\n * @param node Node that contains the imports.\n * @param existingImport Import that should be replaced.\n * @param newImportName Import that should be inserted.\n */\nexport declare function replaceImport(node: ts.NamedImports, existingImport: string, newImportName: string): ts.NamedImports;\n/** Finds an import specifier with a particular name. */\nexport declare function findImportSpecifier(nodes: ts.NodeArray<ts.ImportSpecifier>, specifierName: string): ts.ImportSpecifier | undefined;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/nodes.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/nodes\" />\nimport ts from 'typescript';\n/** Checks whether the given TypeScript node has the specified modifier set. */\nexport declare function hasModifier(node: ts.Node, modifierKind: ts.SyntaxKind): boolean;\n/** Find the closest parent node of a particular kind. */\nexport declare function closestNode<T extends ts.Node>(node: ts.Node, kind: ts.SyntaxKind): T | null;\n/**\n * Checks whether a particular node is part of a null check. E.g. given:\n * `foo.bar ? foo.bar.value : null` the null check would be `foo.bar`.\n */\nexport declare function isNullCheck(node: ts.Node): boolean;\n/** Checks whether a property access is safe (e.g. `foo.parent?.value`). */\nexport declare function isSafeAccess(node: ts.Node): boolean;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/parse_tsconfig.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/parse_tsconfig\" />\nimport ts from 'typescript';\nexport declare function parseTsconfigFile(tsconfigPath: string, basePath: string): ts.ParsedCommandLine;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/property_name.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/property_name\" />\nimport ts from 'typescript';\n/** Type that describes a property name with an obtainable text. */\ndeclare type PropertyNameWithText = Exclude<ts.PropertyName, ts.ComputedPropertyName>;\n/**\n * Gets the text of the given property name. Returns null if the property\n * name couldn't be determined statically.\n */\nexport declare function getPropertyNameText(node: ts.PropertyName): string | null;\n/** Checks whether the given property name has a text. */\nexport declare function hasPropertyNameText(node: ts.PropertyName): node is PropertyNameWithText;\nexport {};\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/schematics/utils/typescript/symbol.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"@angular/core/schematics/utils/typescript/symbol\" />\nimport ts from 'typescript';\nexport declare function getValueSymbolOfDeclaration(node: ts.Node, typeChecker: ts.TypeChecker): ts.Symbol | undefined;\n/** Checks whether a node is referring to a specific import specifier. */\nexport declare function isReferenceToImport(typeChecker: ts.TypeChecker, node: ts.Node, importSpecifier: ts.ImportSpecifier): boolean;\n/** Checks whether a node's type is nullable (`null`, `undefined` or `void`). */\nexport declare function isNullableType(typeChecker: ts.TypeChecker, node: ts.Node): boolean;\n/**\n * Walks through the types and sub-types of a node, looking for a\n * type that has the same name as one of the passed-in ones.\n */\nexport declare function hasOneOfTypes(typeChecker: ts.TypeChecker, node: ts.Node, types: string[]): boolean;\n"
  },
  {
    "paths": [
      "node_modules/@angular/core/testing/index.d.ts",
      "node_modules/@angular/core/testing/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Component } from '@angular/core';\nimport { ComponentRef } from '@angular/core';\nimport { DebugElement } from '@angular/core';\nimport { Directive } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { InjectFlags } from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { Pipe } from '@angular/core';\nimport { PlatformRef } from '@angular/core';\nimport { ProviderToken } from '@angular/core';\nimport { SchemaMetadata } from '@angular/core';\nimport { Type } from '@angular/core';\n\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\nexport declare const __core_private_testing_placeholder__ = \"\";\n\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nexport declare function async(fn: Function): (done: any) => any;\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nexport declare class ComponentFixture<T> {\n    componentRef: ComponentRef<T>;\n    ngZone: NgZone | null;\n    private _autoDetect;\n    /**\n     * The DebugElement associated with the root element of this component.\n     */\n    debugElement: DebugElement;\n    /**\n     * The instance of the root component class.\n     */\n    componentInstance: T;\n    /**\n     * The native element at the root of the component.\n     */\n    nativeElement: any;\n    /**\n     * The ElementRef for the element at the root of the component.\n     */\n    elementRef: ElementRef;\n    /**\n     * The ChangeDetectorRef for the component\n     */\n    changeDetectorRef: ChangeDetectorRef;\n    private _renderer;\n    private _isStable;\n    private _isDestroyed;\n    private _resolve;\n    private _promise;\n    private _onUnstableSubscription;\n    private _onStableSubscription;\n    private _onMicrotaskEmptySubscription;\n    private _onErrorSubscription;\n    constructor(componentRef: ComponentRef<T>, ngZone: NgZone | null, _autoDetect: boolean);\n    private _tick;\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges?: boolean): void;\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges(): void;\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect?: boolean): void;\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable(): boolean;\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable(): Promise<any>;\n    private _getRenderer;\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone(): Promise<any>;\n    /**\n     * Trigger component destruction.\n     */\n    destroy(): void;\n}\n\n/**\n * @publicApi\n */\nexport declare const ComponentFixtureAutoDetect: InjectionToken<boolean[]>;\n\n/**\n * @publicApi\n */\nexport declare const ComponentFixtureNoNgZone: InjectionToken<boolean[]>;\n\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nexport declare function discardPeriodicTasks(): void;\n\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nexport declare function fakeAsync(fn: Function): (...args: any[]) => any;\n\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nexport declare function flush(maxTurns?: number): number;\n\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nexport declare function flushMicrotasks(): void;\n\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nexport declare function getTestBed(): TestBed;\n\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nexport declare function inject(tokens: any[], fn: Function): () => any;\n\n/**\n * @publicApi\n */\nexport declare class InjectSetupWrapper {\n    private _moduleDef;\n    constructor(_moduleDef: () => TestModuleMetadata);\n    private _addModule;\n    inject(tokens: any[], fn: Function): () => any;\n}\n\n\n/**\n * Type used for modifications to metadata\n *\n * @publicApi\n */\nexport declare type MetadataOverride<T> = {\n    add?: Partial<T>;\n    remove?: Partial<T>;\n    set?: Partial<T>;\n};\n\n/**\n * Configures the test module teardown behavior in `TestBed`.\n * @publicApi\n */\nexport declare interface ModuleTeardownOptions {\n    /** Whether the test module should be destroyed after every test. Defaults to `true`. */\n    destroyAfterEach: boolean;\n    /** Whether errors during test module destruction should be re-thrown. Defaults to `true`. */\n    rethrowErrors?: boolean;\n}\n\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nexport declare function resetFakeAsyncZone(): void;\n\n/**\n * @publicApi\n */\nexport declare interface TestBed {\n    get platform(): PlatformRef;\n    get ngModule(): Type<any> | Type<any>[];\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, options?: TestEnvironmentOptions): void;\n    /**\n     * Reset the providers for the test injector.\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): TestBed;\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): void;\n    configureTestingModule(moduleDef: TestModuleMetadata): TestBed;\n    compileComponents(): Promise<any>;\n    inject<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    inject<T>(token: ProviderToken<T>, notFoundValue: null, flags?: InjectFlags): T | null;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token: any, notFoundValue?: any): any;\n    execute(tokens: any[], fn: Function, context?: any): any;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBed;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBed;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBed;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBed;\n    overrideTemplate(component: Type<any>, template: string): TestBed;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): TestBed;\n    overrideProvider(token: any, provider: {\n        useValue: any;\n    }): TestBed;\n    overrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): TestBed;\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBed;\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nexport declare const TestBed: TestBedStatic;\n\n/**\n * Static methods implemented by the `TestBed`.\n *\n * @publicApi\n */\nexport declare interface TestBedStatic extends TestBed {\n    new (...args: any[]): TestBed;\n}\n\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nexport declare class TestComponentRenderer {\n    insertRootElement(rootElementId: string): void;\n    removeAllRootElements?(): void;\n}\n\n/**\n * @publicApi\n */\nexport declare interface TestEnvironmentOptions {\n    /**\n     * Configures the test module teardown behavior in `TestBed`.\n     */\n    teardown?: ModuleTeardownOptions;\n    /**\n     * Whether errors should be thrown when unknown elements are present in component's template.\n     * Defaults to `false`, where the error is simply logged.\n     * If set to `true`, the error is thrown.\n     * @see https://angular.io/errors/NG8001 for the description of the error and how to fix it\n     */\n    errorOnUnknownElements?: boolean;\n    /**\n     * Whether errors should be thrown when unknown properties are present in component's template.\n     * Defaults to `false`, where the error is simply logged.\n     * If set to `true`, the error is thrown.\n     * @see https://angular.io/errors/NG8002 for the description of the error and how to fix it\n     */\n    errorOnUnknownProperties?: boolean;\n}\n\n/**\n * @publicApi\n */\nexport declare interface TestModuleMetadata {\n    providers?: any[];\n    declarations?: any[];\n    imports?: any[];\n    schemas?: Array<SchemaMetadata | any[]>;\n    teardown?: ModuleTeardownOptions;\n    /**\n     * Whether NG0304 runtime errors should be thrown when unknown elements are present in component's\n     * template. Defaults to `false`, where the error is simply logged. If set to `true`, the error is\n     * thrown.\n     * @see https://angular.io/errors/NG8001 for the description of the problem and how to fix it\n     */\n    errorOnUnknownElements?: boolean;\n    /**\n     * Whether errors should be thrown when unknown properties are present in component's template.\n     * Defaults to `false`, where the error is simply logged.\n     * If set to `true`, the error is thrown.\n     * @see https://angular.io/errors/NG8002 for the description of the error and how to fix it\n     */\n    errorOnUnknownProperties?: boolean;\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nexport declare function tick(millis?: number, tickOptions?: {\n    processNewMacroTasksSynchronously: boolean;\n}): void;\n\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nexport declare function waitForAsync(fn: Function): (done: any) => any;\n\n/**\n * @publicApi\n */\nexport declare function withModule(moduleDef: TestModuleMetadata): InjectSetupWrapper;\n\nexport declare function withModule(moduleDef: TestModuleMetadata, fn: Function): () => any;\n\nexport declare class ɵMetadataOverrider {\n    private _references;\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata<C extends T, T>(metadataClass: {\n        new (options: T): C;\n    }, oldMetadata: C, override: MetadataOverride<T>): C;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/platform-browser/animations/index.d.ts",
      "node_modules/@angular/platform-browser/animations/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { ANIMATION_MODULE_TYPE } from '@angular/core';\nimport { AnimationBuilder } from '@angular/animations';\nimport { AnimationDriver } from '@angular/animations/browser';\nimport { AnimationFactory } from '@angular/animations';\nimport { AnimationMetadata } from '@angular/animations';\nimport { AnimationOptions } from '@angular/animations';\nimport { AnimationPlayer } from '@angular/animations';\nimport { ApplicationRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i1 from '@angular/platform-browser';\nimport { ModuleWithProviders } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { Provider } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { RendererFactory2 } from '@angular/core';\nimport { RendererStyleFlags2 } from '@angular/core';\nimport { RendererType2 } from '@angular/core';\nimport { ɵAnimationEngine } from '@angular/animations/browser';\nimport { ɵAnimationStyleNormalizer } from '@angular/animations/browser';\n\nexport { ANIMATION_MODULE_TYPE }\n\ndeclare class BaseAnimationRenderer implements Renderer2 {\n    protected namespaceId: string;\n    delegate: Renderer2;\n    engine: ɵAnimationEngine;\n    constructor(namespaceId: string, delegate: Renderer2, engine: ɵAnimationEngine);\n    get data(): {\n        [key: string]: any;\n    };\n    destroyNode: ((n: any) => void) | null;\n    destroy(): void;\n    createElement(name: string, namespace?: string | null | undefined): any;\n    createComment(value: string): any;\n    createText(value: string): any;\n    appendChild(parent: any, newChild: any): void;\n    insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void;\n    removeChild(parent: any, oldChild: any, isHostElement: boolean): void;\n    selectRootElement(selectorOrNode: any, preserveContent?: boolean): any;\n    parentNode(node: any): any;\n    nextSibling(node: any): any;\n    setAttribute(el: any, name: string, value: string, namespace?: string | null | undefined): void;\n    removeAttribute(el: any, name: string, namespace?: string | null | undefined): void;\n    addClass(el: any, name: string): void;\n    removeClass(el: any, name: string): void;\n    setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2 | undefined): void;\n    removeStyle(el: any, style: string, flags?: RendererStyleFlags2 | undefined): void;\n    setProperty(el: any, name: string, value: any): void;\n    setValue(node: any, value: string): void;\n    listen(target: any, eventName: string, callback: (event: any) => boolean | void): () => void;\n    protected disableAnimations(element: any, value: boolean): void;\n}\n\n/**\n * Exports `BrowserModule` with additional [dependency-injection providers](guide/glossary#provider)\n * for use with animations. See [Animations](guide/animations).\n * @publicApi\n */\nexport declare class BrowserAnimationsModule {\n    /**\n     * Configures the module based on the specified object.\n     *\n     * @param config Object used to configure the behavior of the `BrowserAnimationsModule`.\n     * @see `BrowserAnimationsModuleConfig`\n     *\n     * @usageNotes\n     * When registering the `BrowserAnimationsModule`, you can use the `withConfig`\n     * function as follows:\n     * ```\n     * @NgModule({\n     *   imports: [BrowserAnimationsModule.withConfig(config)]\n     * })\n     * class MyNgModule {}\n     * ```\n     */\n    static withConfig(config: BrowserAnimationsModuleConfig): ModuleWithProviders<BrowserAnimationsModule>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<BrowserAnimationsModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<BrowserAnimationsModule, never, never, [typeof i1.BrowserModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<BrowserAnimationsModule>;\n}\n\n/**\n * Object used to configure the behavior of {@link BrowserAnimationsModule}\n * @publicApi\n */\nexport declare interface BrowserAnimationsModuleConfig {\n    /**\n     *  Whether animations should be disabled. Passing this is identical to providing the\n     * `NoopAnimationsModule`, but it can be controlled based on a runtime value.\n     */\n    disableAnimations?: boolean;\n}\n\n/**\n * A null player that must be imported to allow disabling of animations.\n * @publicApi\n */\nexport declare class NoopAnimationsModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<NoopAnimationsModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<NoopAnimationsModule, never, never, [typeof i1.BrowserModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<NoopAnimationsModule>;\n}\n\n/**\n * Returns the set of [dependency-injection providers](guide/glossary#provider)\n * to enable animations in an application. See [animations guide](guide/animations)\n * to learn more about animations in Angular.\n *\n * @usageNotes\n *\n * The function is useful when you want to enable animations in an application\n * bootstrapped using the `bootstrapApplication` function. In this scenario there\n * is no need to import the `BrowserAnimationsModule` NgModule at all, just add\n * providers returned by this function to the `providers` list as show below.\n *\n * ```typescript\n * bootstrapApplication(RootComponent, {\n *   providers: [\n *     provideAnimations()\n *   ]\n * });\n * ```\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function provideAnimations(): Provider[];\n\n/**\n * Returns the set of [dependency-injection providers](guide/glossary#provider)\n * to disable animations in an application. See [animations guide](guide/animations)\n * to learn more about animations in Angular.\n *\n * @usageNotes\n *\n * The function is useful when you want to bootstrap an application using\n * the `bootstrapApplication` function, but you need to disable animations\n * (for example, when running tests).\n *\n * ```typescript\n * bootstrapApplication(RootComponent, {\n *   providers: [\n *     provideNoopAnimations()\n *   ]\n * });\n * ```\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function provideNoopAnimations(): Provider[];\n\nexport declare class ɵAnimationRenderer extends BaseAnimationRenderer implements Renderer2 {\n    factory: ɵAnimationRendererFactory;\n    constructor(factory: ɵAnimationRendererFactory, namespaceId: string, delegate: Renderer2, engine: ɵAnimationEngine);\n    setProperty(el: any, name: string, value: any): void;\n    listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => any): () => void;\n}\n\nexport declare class ɵAnimationRendererFactory implements RendererFactory2 {\n    private delegate;\n    private engine;\n    private _zone;\n    private _currentId;\n    private _microtaskId;\n    private _animationCallbacksBuffer;\n    private _rendererCache;\n    private _cdRecurDepth;\n    private promise;\n    constructor(delegate: RendererFactory2, engine: ɵAnimationEngine, _zone: NgZone);\n    createRenderer(hostElement: any, type: RendererType2): Renderer2;\n    begin(): void;\n    private _scheduleCountTask;\n    end(): void;\n    whenRenderingDone(): Promise<any>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵAnimationRendererFactory, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵAnimationRendererFactory>;\n}\n\nexport declare class ɵBrowserAnimationBuilder extends AnimationBuilder {\n    private _nextAnimationId;\n    private _renderer;\n    constructor(rootRenderer: RendererFactory2, doc: any);\n    build(animation: AnimationMetadata | AnimationMetadata[]): AnimationFactory;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵBrowserAnimationBuilder, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵBrowserAnimationBuilder>;\n}\n\nexport declare class ɵBrowserAnimationFactory extends AnimationFactory {\n    private _id;\n    private _renderer;\n    constructor(_id: string, _renderer: ɵAnimationRenderer);\n    create(element: any, options?: AnimationOptions): AnimationPlayer;\n}\n\nexport declare class ɵInjectableAnimationEngine extends ɵAnimationEngine implements OnDestroy {\n    constructor(doc: any, driver: AnimationDriver, normalizer: ɵAnimationStyleNormalizer, appRef: ApplicationRef);\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵInjectableAnimationEngine, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵInjectableAnimationEngine>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/platform-browser/index.d.ts",
      "node_modules/@angular/platform-browser/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { ApplicationRef } from '@angular/core';\nimport { ComponentRef } from '@angular/core';\nimport { DebugElement } from '@angular/core';\nimport { DebugNode } from '@angular/core';\nimport { GetTestability } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { ImportedNgModuleProviders } from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { ModuleWithProviders } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { PlatformRef } from '@angular/core';\nimport { Predicate } from '@angular/core';\nimport { Provider } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { RendererFactory2 } from '@angular/core';\nimport { RendererType2 } from '@angular/core';\nimport { Sanitizer } from '@angular/core';\nimport { SecurityContext } from '@angular/core';\nimport { StaticProvider } from '@angular/core';\nimport { Testability } from '@angular/core';\nimport { TestabilityRegistry } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { Version } from '@angular/core';\nimport { ɵConsole } from '@angular/core';\nimport { ɵDomAdapter } from '@angular/common';\nimport { ɵgetDOM } from '@angular/common';\n\n/**\n * Set of config options available during the application bootstrap operation.\n *\n * @developerPreview\n * @publicApi\n */\nexport declare interface ApplicationConfig {\n    /**\n     * List of providers that should be available to the root component and all its children.\n     */\n    providers: Array<Provider | ImportedNgModuleProviders>;\n}\n\n/**\n * Bootstraps an instance of an Angular application and renders a standalone component as the\n * application's root component. More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The root component passed into this function *must* be a standalone one (should have the\n * `standalone: true` flag in the `@Component` decorator config).\n *\n * ```typescript\n * @Component({\n *   standalone: true,\n *   template: 'Hello world!'\n * })\n * class RootComponent {}\n *\n * const appRef: ApplicationRef = await bootstrapApplication(RootComponent);\n * ```\n *\n * You can add the list of providers that should be available in the application injector by\n * specifying the `providers` field in an object passed as the second argument:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     {provide: BACKEND_URL, useValue: 'https://yourdomain.com/api'}\n *   ]\n * });\n * ```\n *\n * The `importProvidersFrom` helper method can be used to collect all providers from any\n * existing NgModule (and transitively from all NgModules that it imports):\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(SomeNgModule)\n *   ]\n * });\n * ```\n *\n * Note: the `bootstrapApplication` method doesn't include [Testability](api/core/Testability) by\n * default. You can add [Testability](api/core/Testability) by getting the list of necessary\n * providers using `provideProtractorTestingSupport()` function and adding them into the `providers`\n * array, for example:\n *\n * ```typescript\n * import {provideProtractorTestingSupport} from '@angular/platform-browser';\n *\n * await bootstrapApplication(RootComponent, {providers: [provideProtractorTestingSupport()]});\n * ```\n *\n * @param rootComponent A reference to a standalone component that should be rendered.\n * @param options Extra configuration for the bootstrap operation, see `ApplicationConfig` for\n *     additional info.\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function bootstrapApplication(rootComponent: Type<unknown>, options?: ApplicationConfig): Promise<ApplicationRef>;\n\n/**\n * Exports required infrastructure for all Angular apps.\n * Included by default in all Angular apps created with the CLI\n * `new` command.\n * Re-exports `CommonModule` and `ApplicationModule`, making their\n * exports and providers available to all apps.\n *\n * @publicApi\n */\nexport declare class BrowserModule {\n    constructor(providersAlreadyPresent: boolean | null);\n    /**\n     * Configures a browser-based app to transition from a server-rendered app, if\n     * one is present on the page.\n     *\n     * @param params An object containing an identifier for the app to transition.\n     * The ID must match between the client and server versions of the app.\n     * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.\n     */\n    static withServerTransition(params: {\n        appId: string;\n    }): ModuleWithProviders<BrowserModule>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<BrowserModule, [{ optional: true; skipSelf: true; }]>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<BrowserModule, never, never, [typeof i1.CommonModule, typeof i0.ApplicationModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<BrowserModule>;\n}\n\n/**\n * NgModule to install on the client side while using the `TransferState` to transfer state from\n * server to client.\n *\n * @publicApi\n * @deprecated no longer needed, you can inject the `TransferState` in an app without providing\n *     this module.\n */\nexport declare class BrowserTransferStateModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<BrowserTransferStateModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<BrowserTransferStateModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<BrowserTransferStateModule>;\n}\n\n/**\n * Predicates for use with {@link DebugElement}'s query functions.\n *\n * @publicApi\n */\nexport declare class By {\n    /**\n     * Match all nodes.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n     */\n    static all(): Predicate<DebugNode>;\n    /**\n     * Match elements by the given CSS selector.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n     */\n    static css(selector: string): Predicate<DebugElement>;\n    /**\n     * Match nodes that have the given directive present.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n     */\n    static directive(type: Type<any>): Predicate<DebugNode>;\n}\n\n/**\n * Create an instance of an Angular application without bootstrapping any components. This is useful\n * for the situation where one wants to decouple application environment creation (a platform and\n * associated injectors) from rendering components on a screen. Components can be subsequently\n * bootstrapped on the returned `ApplicationRef`.\n *\n * @param options Extra configuration for the application environment, see `ApplicationConfig` for\n *     additional info.\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function createApplication(options?: ApplicationConfig): Promise<ApplicationRef>;\n\n/**\n * Disables Angular tools.\n *\n * @publicApi\n */\nexport declare function disableDebugTools(): void;\n\n/**\n * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n * values to be safe to use in the different DOM contexts.\n *\n * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n * the website.\n *\n * In specific situations, it might be necessary to disable sanitization, for example if the\n * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n * methods, and then binding to that value from the template.\n *\n * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n * Cross Site Scripting (XSS) security bug!\n *\n * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n * close as possible to the source of the value, to make it easy to verify no security bug is\n * created by its use.\n *\n * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n * code. The sanitizer leaves safe values intact.\n *\n * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n * sanitization for the value passed in. Carefully check and audit all values and code paths going\n * into this call. Make sure any user data is appropriately escaped for this security context.\n * For more detail, see the [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\nexport declare abstract class DomSanitizer implements Sanitizer {\n    /**\n     * Sanitizes a value for use in the given SecurityContext.\n     *\n     * If value is trusted for the context, this method will unwrap the contained safe value and use\n     * it directly. Otherwise, value will be sanitized to be safe in the given context, for example\n     * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation\n     * is responsible to make sure that the value can definitely be safely used in the given context.\n     */\n    abstract sanitize(context: SecurityContext, value: SafeValue | string | null): string | null;\n    /**\n     * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML\n     * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will\n     * leave safe HTML intact, so in most situations this method should not be used.\n     *\n     * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n     * security risks!\n     */\n    abstract bypassSecurityTrustHtml(value: string): SafeHtml;\n    /**\n     * Bypass security and trust the given value to be safe style value (CSS).\n     *\n     * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n     * security risks!\n     */\n    abstract bypassSecurityTrustStyle(value: string): SafeStyle;\n    /**\n     * Bypass security and trust the given value to be safe JavaScript.\n     *\n     * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n     * security risks!\n     */\n    abstract bypassSecurityTrustScript(value: string): SafeScript;\n    /**\n     * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used\n     * in hyperlinks or `<img src>`.\n     *\n     * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n     * security risks!\n     */\n    abstract bypassSecurityTrustUrl(value: string): SafeUrl;\n    /**\n     * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may\n     * be used to load executable code from, like `<script src>`, or `<iframe src>`.\n     *\n     * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n     * security risks!\n     */\n    abstract bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl;\n    static ɵfac: i0.ɵɵFactoryDeclaration<DomSanitizer, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<DomSanitizer>;\n}\n\n/**\n * Enabled Angular debug tools that are accessible via your browser's\n * developer console.\n *\n * Usage:\n *\n * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n *    then hit Enter.\n *\n * @publicApi\n */\nexport declare function enableDebugTools<T>(ref: ComponentRef<T>): ComponentRef<T>;\n\n/**\n * The injection token for the event-manager plug-in service.\n *\n * @publicApi\n */\nexport declare const EVENT_MANAGER_PLUGINS: InjectionToken<EventManagerPlugin[]>;\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\nexport declare class EventManager {\n    private _zone;\n    private _plugins;\n    private _eventNameToPlugin;\n    /**\n     * Initializes an instance of the event-manager service.\n     */\n    constructor(plugins: EventManagerPlugin[], _zone: NgZone);\n    /**\n     * Registers a handler for a specific element and event.\n     *\n     * @param element The HTML element to receive event notifications.\n     * @param eventName The name of the event to listen for.\n     * @param handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @returns  A callback function that can be used to remove the handler.\n     */\n    addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n    /**\n     * Registers a global handler for an event in a target view.\n     *\n     * @param target A target for global event notifications. One of \"window\", \"document\", or \"body\".\n     * @param eventName The name of the event to listen for.\n     * @param handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @returns A callback function that can be used to remove the handler.\n     * @deprecated No longer being used in Ivy code. To be removed in version 14.\n     */\n    addGlobalEventListener(target: string, eventName: string, handler: Function): Function;\n    /**\n     * Retrieves the compilation zone in which event listeners are registered.\n     */\n    getZone(): NgZone;\n    static ɵfac: i0.ɵɵFactoryDeclaration<EventManager, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<EventManager>;\n}\n\ndeclare abstract class EventManagerPlugin {\n    private _doc;\n    constructor(_doc: any);\n    manager: EventManager;\n    abstract supports(eventName: string): boolean;\n    abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n    addGlobalEventListener(element: string, eventName: string, handler: Function): Function;\n}\n\n/**\n * Provides DOM operations in any browser environment.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\ndeclare abstract class GenericBrowserDomAdapter extends ɵDomAdapter {\n    readonly supportsDOMEvents: boolean;\n}\n\n/**\n * DI token for providing [HammerJS](https://hammerjs.github.io/) support to Angular.\n * @see `HammerGestureConfig`\n *\n * @ngModule HammerModule\n * @publicApi\n */\nexport declare const HAMMER_GESTURE_CONFIG: InjectionToken<HammerGestureConfig>;\n\n/**\n * Injection token used to provide a {@link HammerLoader} to Angular.\n *\n * @publicApi\n */\nexport declare const HAMMER_LOADER: InjectionToken<HammerLoader>;\n\n/**\n * An injectable [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n * for gesture recognition. Configures specific event recognition.\n * @publicApi\n */\nexport declare class HammerGestureConfig {\n    /**\n     * A set of supported event names for gestures to be used in Angular.\n     * Angular supports all built-in recognizers, as listed in\n     * [HammerJS documentation](https://hammerjs.github.io/).\n     */\n    events: string[];\n    /**\n     * Maps gesture event names to a set of configuration options\n     * that specify overrides to the default values for specific properties.\n     *\n     * The key is a supported event name to be configured,\n     * and the options object contains a set of properties, with override values\n     * to be applied to the named recognizer event.\n     * For example, to disable recognition of the rotate event, specify\n     *  `{\"rotate\": {\"enable\": false}}`.\n     *\n     * Properties that are not present take the HammerJS default values.\n     * For information about which properties are supported for which events,\n     * and their allowed and default values, see\n     * [HammerJS documentation](https://hammerjs.github.io/).\n     *\n     */\n    overrides: {\n        [key: string]: Object;\n    };\n    /**\n     * Properties whose default values can be overridden for a given event.\n     * Different sets of properties apply to different events.\n     * For information about which properties are supported for which events,\n     * and their allowed and default values, see\n     * [HammerJS documentation](https://hammerjs.github.io/).\n     */\n    options?: {\n        cssProps?: any;\n        domEvents?: boolean;\n        enable?: boolean | ((manager: any) => boolean);\n        preset?: any[];\n        touchAction?: string;\n        recognizers?: any[];\n        inputClass?: any;\n        inputTarget?: EventTarget;\n    };\n    /**\n     * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n     * and attaches it to a given HTML element.\n     * @param element The element that will recognize gestures.\n     * @returns A HammerJS event-manager object.\n     */\n    buildHammer(element: HTMLElement): HammerInstance;\n    static ɵfac: i0.ɵɵFactoryDeclaration<HammerGestureConfig, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<HammerGestureConfig>;\n}\n\ndeclare interface HammerInstance {\n    on(eventName: string, callback?: Function): void;\n    off(eventName: string, callback?: Function): void;\n    destroy?(): void;\n}\n\n/**\n * Function that loads HammerJS, returning a promise that is resolved once HammerJs is loaded.\n *\n * @publicApi\n */\nexport declare type HammerLoader = () => Promise<void>;\n\n/**\n * Adds support for HammerJS.\n *\n * Import this module at the root of your application so that Angular can work with\n * HammerJS to detect gesture events.\n *\n * Note that applications still need to include the HammerJS script itself. This module\n * simply sets up the coordination layer between HammerJS and Angular's EventManager.\n *\n * @publicApi\n */\nexport declare class HammerModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<HammerModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<HammerModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<HammerModule>;\n}\n\n/**\n * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.\n *\n * Example:\n *\n * ```\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * @publicApi\n */\nexport declare function makeStateKey<T = void>(key: string): StateKey<T>;\n\n/**\n * A service for managing HTML `<meta>` tags.\n *\n * Properties of the `MetaDefinition` object match the attributes of the\n * HTML `<meta>` tag. These tags define document metadata that is important for\n * things like configuring a Content Security Policy, defining browser compatibility\n * and security settings, setting HTTP Headers, defining rich content for social sharing,\n * and Search Engine Optimization (SEO).\n *\n * To identify specific `<meta>` tags in a document, use an attribute selection\n * string in the format `\"tag_attribute='value string'\"`.\n * For example, an `attrSelector` value of `\"name='description'\"` matches a tag\n * whose `name` attribute has the value `\"description\"`.\n * Selectors are used with the `querySelector()` Document method,\n * in the format `meta[{attrSelector}]`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see [Document.querySelector()](https://developer.mozilla.org/docs/Web/API/Document/querySelector)\n *\n *\n * @publicApi\n */\nexport declare class Meta {\n    private _doc;\n    private _dom;\n    constructor(_doc: any);\n    /**\n     * Retrieves or creates a specific `<meta>` tag element in the current HTML document.\n     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n     * values in the provided tag definition, and verifies that all other attribute values are equal.\n     * If an existing element is found, it is returned and is not modified in any way.\n     * @param tag The definition of a `<meta>` element to match or create.\n     * @param forceCreation True to create a new element without checking whether one already exists.\n     * @returns The existing element with the same attributes and values if found,\n     * the new element if no match is found, or `null` if the tag parameter is not defined.\n     */\n    addTag(tag: MetaDefinition, forceCreation?: boolean): HTMLMetaElement | null;\n    /**\n     * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.\n     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n     * values in the provided tag definition, and verifies that all other attribute values are equal.\n     * @param tags An array of tag definitions to match or create.\n     * @param forceCreation True to create new elements without checking whether they already exist.\n     * @returns The matching elements if found, or the new elements.\n     */\n    addTags(tags: MetaDefinition[], forceCreation?: boolean): HTMLMetaElement[];\n    /**\n     * Retrieves a `<meta>` tag element in the current HTML document.\n     * @param attrSelector The tag attribute and value to match against, in the format\n     * `\"tag_attribute='value string'\"`.\n     * @returns The matching element, if any.\n     */\n    getTag(attrSelector: string): HTMLMetaElement | null;\n    /**\n     * Retrieves a set of `<meta>` tag elements in the current HTML document.\n     * @param attrSelector The tag attribute and value to match against, in the format\n     * `\"tag_attribute='value string'\"`.\n     * @returns The matching elements, if any.\n     */\n    getTags(attrSelector: string): HTMLMetaElement[];\n    /**\n     * Modifies an existing `<meta>` tag element in the current HTML document.\n     * @param tag The tag description with which to replace the existing tag content.\n     * @param selector A tag attribute and value to match against, to identify\n     * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n     * If not supplied, matches a tag with the same `name` or `property` attribute value as the\n     * replacement tag.\n     * @return The modified element.\n     */\n    updateTag(tag: MetaDefinition, selector?: string): HTMLMetaElement | null;\n    /**\n     * Removes an existing `<meta>` tag element from the current HTML document.\n     * @param attrSelector A tag attribute and value to match against, to identify\n     * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n     */\n    removeTag(attrSelector: string): void;\n    /**\n     * Removes an existing `<meta>` tag element from the current HTML document.\n     * @param meta The tag definition to match against to identify an existing tag.\n     */\n    removeTagElement(meta: HTMLMetaElement): void;\n    private _getOrCreateElement;\n    private _setMetaElementAttributes;\n    private _parseSelector;\n    private _containsAttributes;\n    private _getMetaKeyMap;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Meta, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Meta>;\n}\n\n/**\n * Represents the attributes of an HTML `<meta>` element. The element itself is\n * represented by the internal `HTMLMetaElement`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see `Meta`\n *\n * @publicApi\n */\nexport declare type MetaDefinition = {\n    charset?: string;\n    content?: string;\n    httpEquiv?: string;\n    id?: string;\n    itemprop?: string;\n    name?: string;\n    property?: string;\n    scheme?: string;\n    url?: string;\n} & {\n    [prop: string]: string;\n};\n\n/**\n * A factory function that returns a `PlatformRef` instance associated with browser service\n * providers.\n *\n * @publicApi\n */\nexport declare const platformBrowser: (extraProviders?: StaticProvider[]) => PlatformRef;\n\n/**\n * Returns a set of providers required to setup [Testability](api/core/Testability) for an\n * application bootstrapped using the `bootstrapApplication` function. The set of providers is\n * needed to support testing an application with Protractor (which relies on the Testability APIs\n * to be present).\n *\n * @returns An array of providers required to setup Testability for an application and make it\n *     available for testing using Protractor.\n *\n * @developerPreview\n * @publicApi\n */\nexport declare function provideProtractorTestingSupport(): Provider[];\n\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * @publicApi\n */\nexport declare interface SafeHtml extends SafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * @publicApi\n */\nexport declare interface SafeResourceUrl extends SafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * @publicApi\n */\nexport declare interface SafeScript extends SafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * @publicApi\n */\nexport declare interface SafeStyle extends SafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * @publicApi\n */\nexport declare interface SafeUrl extends SafeValue {\n}\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * @publicApi\n */\nexport declare interface SafeValue {\n}\n\n/**\n * A type-safe key to use with `TransferState`.\n *\n * Example:\n *\n * ```\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * @publicApi\n */\nexport declare type StateKey<T> = string & {\n    __not_a_string: never;\n    __value_type?: T;\n};\n\n/**\n * A service that can be used to get and set the title of a current HTML document.\n *\n * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n * title value.\n *\n * @publicApi\n */\nexport declare class Title {\n    private _doc;\n    constructor(_doc: any);\n    /**\n     * Get the title of the current HTML document.\n     */\n    getTitle(): string;\n    /**\n     * Set the title of the current HTML document.\n     * @param newTitle\n     */\n    setTitle(newTitle: string): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Title, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Title>;\n}\n\n/**\n * A key value store that is transferred from the application on the server side to the application\n * on the client side.\n *\n * The `TransferState` is available as an injectable token.\n * On the client, just inject this token using DI and use it, it will be lazily initialized.\n * On the server it's already included if `renderApplication` function is used. Otherwise, import\n * the `ServerTransferStateModule` module to make the `TransferState` available.\n *\n * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only\n * boolean, number, string, null and non-class objects will be serialized and deserialized in a\n * non-lossy manner.\n *\n * @publicApi\n */\nexport declare class TransferState {\n    private store;\n    private onSerializeCallbacks;\n    /**\n     * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n     */\n    get<T>(key: StateKey<T>, defaultValue: T): T;\n    /**\n     * Set the value corresponding to a key.\n     */\n    set<T>(key: StateKey<T>, value: T): void;\n    /**\n     * Remove a key from the store.\n     */\n    remove<T>(key: StateKey<T>): void;\n    /**\n     * Test whether a key exists in the store.\n     */\n    hasKey<T>(key: StateKey<T>): boolean;\n    /**\n     * Indicates whether the state is empty.\n     */\n    get isEmpty(): boolean;\n    /**\n     * Register a callback to provide the value for a key when `toJson` is called.\n     */\n    onSerialize<T>(key: StateKey<T>, callback: () => T): void;\n    /**\n     * Serialize the current state of the store to JSON.\n     */\n    toJson(): string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<TransferState, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<TransferState>;\n}\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport declare class ɵBrowserDomAdapter extends GenericBrowserDomAdapter {\n    static makeCurrent(): void;\n    onAndCancel(el: Node, evt: any, listener: any): Function;\n    dispatchEvent(el: Node, evt: any): void;\n    remove(node: Node): void;\n    createElement(tagName: string, doc?: Document): HTMLElement;\n    createHtmlDocument(): Document;\n    getDefaultDocument(): Document;\n    isElementNode(node: Node): boolean;\n    isShadowRoot(node: any): boolean;\n    /** @deprecated No longer being used in Ivy code. To be removed in version 14. */\n    getGlobalEventTarget(doc: Document, target: string): EventTarget | null;\n    getBaseHref(doc: Document): string | null;\n    resetBaseElement(): void;\n    getUserAgent(): string;\n    getCookie(name: string): string | null;\n}\n\nexport declare class ɵBrowserGetTestability implements GetTestability {\n    addToWindow(registry: TestabilityRegistry): void;\n    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;\n}\n\nexport declare class ɵDomEventsPlugin extends EventManagerPlugin {\n    constructor(doc: any);\n    supports(eventName: string): boolean;\n    addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n    removeEventListener(target: any, eventName: string, callback: Function): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵDomEventsPlugin, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵDomEventsPlugin>;\n}\n\nexport declare class ɵDomRendererFactory2 implements RendererFactory2 {\n    private eventManager;\n    private sharedStylesHost;\n    private appId;\n    private rendererByCompId;\n    private defaultRenderer;\n    constructor(eventManager: EventManager, sharedStylesHost: ɵDomSharedStylesHost, appId: string);\n    createRenderer(element: any, type: RendererType2 | null): Renderer2;\n    begin(): void;\n    end(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵDomRendererFactory2, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵDomRendererFactory2>;\n}\n\nexport declare class ɵDomSanitizerImpl extends DomSanitizer {\n    private _doc;\n    constructor(_doc: any);\n    sanitize(ctx: SecurityContext, value: SafeValue | string | null): string | null;\n    bypassSecurityTrustHtml(value: string): SafeHtml;\n    bypassSecurityTrustStyle(value: string): SafeStyle;\n    bypassSecurityTrustScript(value: string): SafeScript;\n    bypassSecurityTrustUrl(value: string): SafeUrl;\n    bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵDomSanitizerImpl, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵDomSanitizerImpl>;\n}\n\nexport declare class ɵDomSharedStylesHost extends ɵSharedStylesHost implements OnDestroy {\n    private _doc;\n    private _hostNodes;\n    constructor(_doc: any);\n    private _addStylesToHost;\n    addHost(hostNode: Node): void;\n    removeHost(hostNode: Node): void;\n    onStylesAdded(additions: Set<string>): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵDomSharedStylesHost, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵDomSharedStylesHost>;\n}\n\nexport declare function ɵescapeHtml(text: string): string;\n\nexport declare function ɵflattenStyles(compId: string, styles: Array<any | any[]>, target: string[]): string[];\n\nexport { ɵgetDOM }\n\n/**\n * Event plugin that adds Hammer support to an application.\n *\n * @ngModule HammerModule\n */\nexport declare class ɵHammerGesturesPlugin extends EventManagerPlugin {\n    private _config;\n    private console;\n    private loader?;\n    private _loaderPromise;\n    constructor(doc: any, _config: HammerGestureConfig, console: ɵConsole, loader?: HammerLoader | null | undefined);\n    supports(eventName: string): boolean;\n    addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n    isCustomEvent(eventName: string): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵHammerGesturesPlugin, [null, null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵHammerGesturesPlugin>;\n}\n\nexport declare function ɵinitDomAdapter(): void;\n\nexport declare const ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS: StaticProvider[];\n\n/**\n * @publicApi\n * A browser plug-in that provides support for handling of key events in Angular.\n */\nexport declare class ɵKeyEventsPlugin extends EventManagerPlugin {\n    /**\n     * Initializes an instance of the browser plug-in.\n     * @param doc The document in which key events will be detected.\n     */\n    constructor(doc: any);\n    /**\n     * Reports whether a named key event is supported.\n     * @param eventName The event name to query.\n     * @return True if the named key event is supported.\n     */\n    supports(eventName: string): boolean;\n    /**\n     * Registers a handler for a specific element and key event.\n     * @param element The HTML element to receive event notifications.\n     * @param eventName The name of the key event to listen for.\n     * @param handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @returns The key event that was registered.\n     */\n    addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n    /**\n     * Parses the user provided full keyboard event definition and normalizes it for\n     * later internal use. It ensures the string is all lowercase, converts special\n     * characters to a standard spelling, and orders all the values consistently.\n     *\n     * @param eventName The name of the key event to listen for.\n     * @returns an object with the full, normalized string, and the dom event name\n     * or null in the case when the event doesn't match a keyboard event.\n     */\n    static parseEventName(eventName: string): {\n        fullKey: string;\n        domEventName: string;\n    } | null;\n    /**\n     * Determines whether the actual keys pressed match the configured key code string.\n     * The `fullKeyCode` event is normalized in the `parseEventName` method when the\n     * event is attached to the DOM during the `addEventListener` call. This is unseen\n     * by the end user and is normalized for internal consistency and parsing.\n     *\n     * @param event The keyboard event.\n     * @param fullKeyCode The normalized user defined expected key event string\n     * @returns boolean.\n     */\n    static matchEventFullKeyCode(event: KeyboardEvent, fullKeyCode: string): boolean;\n    /**\n     * Configures a handler callback for a key event.\n     * @param fullKey The event name that combines all simultaneous keystrokes.\n     * @param handler The function that responds to the key event.\n     * @param zone The zone in which the event occurred.\n     * @returns A callback function.\n     */\n    static eventCallback(fullKey: string, handler: Function, zone: NgZone): Function;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵKeyEventsPlugin, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵKeyEventsPlugin>;\n}\n\nexport declare const ɵNAMESPACE_URIS: {\n    [ns: string]: string;\n};\n\nexport declare class ɵSharedStylesHost {\n    addStyles(styles: string[]): void;\n    onStylesAdded(additions: Set<string>): void;\n    getAllStyles(): string[];\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵSharedStylesHost, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵSharedStylesHost>;\n}\n\nexport declare function ɵshimContentAttribute(componentShortId: string): string;\n\nexport declare function ɵshimHostAttribute(componentShortId: string): string;\n\n/**\n * An id that identifies a particular application being bootstrapped, that should\n * match across the client/server boundary.\n */\nexport declare const ɵTRANSITION_ID: InjectionToken<unknown>;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/platform-browser/testing/index.d.ts",
      "node_modules/@angular/platform-browser/testing/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport * as i0 from '@angular/core';\nimport * as i1 from '@angular/platform-browser';\nimport { PlatformRef } from '@angular/core';\nimport { StaticProvider } from '@angular/core';\n\n/**\n * NgModule for testing.\n *\n * @publicApi\n */\nexport declare class BrowserTestingModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<BrowserTestingModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<BrowserTestingModule, never, never, [typeof i1.BrowserModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<BrowserTestingModule>;\n}\n\n/**\n * Platform for testing\n *\n * @publicApi\n */\nexport declare const platformBrowserTesting: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/platform-browser-dynamic/index.d.ts",
      "node_modules/@angular/platform-browser-dynamic/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { Compiler } from '@angular/core';\nimport { CompilerFactory } from '@angular/core';\nimport { CompilerOptions } from '@angular/core';\nimport { PlatformRef } from '@angular/core';\nimport { Provider } from '@angular/core';\nimport { StaticProvider } from '@angular/core';\nimport { Version } from '@angular/core';\n\n/**\n * @publicApi\n *\n * @deprecated\n * Ivy JIT mode doesn't require accessing this symbol.\n * See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes) for\n * additional context.\n */\nexport declare class JitCompilerFactory implements CompilerFactory {\n    private _defaultOptions;\n    createCompiler(options?: CompilerOptions[]): Compiler;\n}\n\n/**\n * @publicApi\n */\nexport declare const platformBrowserDynamic: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;\n\n/**\n * @publicApi\n *\n * @deprecated This was previously necessary in some cases to test AOT-compiled components with View\n *     Engine, but is no longer since Ivy.\n\n */\nexport declare const RESOURCE_CACHE_PROVIDER: Provider[];\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\n/**\n * @publicApi\n */\nexport declare const ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: StaticProvider[];\n\n/**\n * A platform that included corePlatform and the compiler.\n *\n * @publicApi\n */\nexport declare const ɵplatformCoreDynamic: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/platform-browser-dynamic/testing/index.d.ts",
      "node_modules/@angular/platform-browser-dynamic/testing/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport * as i0 from '@angular/core';\nimport * as i1 from '@angular/platform-browser/testing';\nimport { PlatformRef } from '@angular/core';\nimport { StaticProvider } from '@angular/core';\nimport { TestComponentRenderer } from '@angular/core/testing';\n\n/**\n * NgModule for testing.\n *\n * @publicApi\n */\nexport declare class BrowserDynamicTestingModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<BrowserDynamicTestingModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<BrowserDynamicTestingModule, never, never, [typeof i1.BrowserTestingModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<BrowserDynamicTestingModule>;\n}\n\n/**\n * @publicApi\n */\nexport declare const platformBrowserDynamicTesting: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;\n\n/**\n * A DOM based implementation of the TestComponentRenderer.\n */\nexport declare class ɵDOMTestComponentRenderer extends TestComponentRenderer {\n    private _doc;\n    constructor(_doc: any);\n    insertRootElement(rootElId: string): void;\n    removeAllRootElements(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵDOMTestComponentRenderer, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ɵDOMTestComponentRenderer>;\n}\n\n/**\n * Platform for dynamic tests\n *\n * @publicApi\n */\nexport declare const ɵplatformCoreDynamicTesting: (extraProviders?: any[]) => PlatformRef;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/router/index.d.ts",
      "node_modules/@angular/router/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { AfterContentInit } from '@angular/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Compiler } from '@angular/core';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { ComponentRef } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EnvironmentInjector } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { ImportedNgModuleProviders } from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { Location as Location_2 } from '@angular/common';\nimport { LocationStrategy } from '@angular/common';\nimport { ModuleWithProviders } from '@angular/core';\nimport { NgModuleFactory } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Provider } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { Type } from '@angular/core';\nimport { Version } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport declare class ActivatedRoute {\n    /** An observable of the URL segments matched by this route. */\n    url: Observable<UrlSegment[]>;\n    /** An observable of the matrix parameters scoped to this route. */\n    params: Observable<Params>;\n    /** An observable of the query parameters shared by all the routes. */\n    queryParams: Observable<Params>;\n    /** An observable of the URL fragment shared by all the routes. */\n    fragment: Observable<string | null>;\n    /** An observable of the static and resolved data of this route. */\n    data: Observable<Data>;\n    /** The outlet name of the route, a constant. */\n    outlet: string;\n    /** The component of the route, a constant. */\n    component: Type<any> | null;\n    /** The current snapshot of this route */\n    snapshot: ActivatedRouteSnapshot;\n    /** An Observable of the resolved route title */\n    readonly title: Observable<string | undefined>;\n    /** The configuration used to match this route. */\n    get routeConfig(): Route | null;\n    /** The root of the router state. */\n    get root(): ActivatedRoute;\n    /** The parent of this route in the router state tree. */\n    get parent(): ActivatedRoute | null;\n    /** The first child of this route in the router state tree. */\n    get firstChild(): ActivatedRoute | null;\n    /** The children of this route in the router state tree. */\n    get children(): ActivatedRoute[];\n    /** The path from the root of the router state tree to this route. */\n    get pathFromRoot(): ActivatedRoute[];\n    /**\n     * An Observable that contains a map of the required and optional parameters\n     * specific to the route.\n     * The map supports retrieving single and multiple values from the same parameter.\n     */\n    get paramMap(): Observable<ParamMap>;\n    /**\n     * An Observable that contains a map of the query parameters available to all routes.\n     * The map supports retrieving single and multiple values from the query parameter.\n     */\n    get queryParamMap(): Observable<ParamMap>;\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class ActivatedRouteSnapshot {\n    /** The URL segments matched by this route */\n    url: UrlSegment[];\n    /**\n     *  The matrix parameters scoped to this route.\n     *\n     *  You can compute all params (or data) in the router state or to get params outside\n     *  of an activated component by traversing the `RouterState` tree as in the following\n     *  example:\n     *  ```\n     *  collectRouteParams(router: Router) {\n     *    let params = {};\n     *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n     *    while (stack.length > 0) {\n     *      const route = stack.pop()!;\n     *      params = {...params, ...route.params};\n     *      stack.push(...route.children);\n     *    }\n     *    return params;\n     *  }\n     *  ```\n     */\n    params: Params;\n    /** The query parameters shared by all the routes */\n    queryParams: Params;\n    /** The URL fragment shared by all the routes */\n    fragment: string | null;\n    /** The static and resolved data of this route */\n    data: Data;\n    /** The outlet name of the route */\n    outlet: string;\n    /** The component of the route */\n    component: Type<any> | null;\n    /** The configuration used to match this route **/\n    readonly routeConfig: Route | null;\n    /** The resolved route title */\n    readonly title?: string;\n    /** The root of the router state */\n    get root(): ActivatedRouteSnapshot;\n    /** The parent of this route in the router state tree */\n    get parent(): ActivatedRouteSnapshot | null;\n    /** The first child of this route in the router state tree */\n    get firstChild(): ActivatedRouteSnapshot | null;\n    /** The children of this route in the router state tree */\n    get children(): ActivatedRouteSnapshot[];\n    /** The path from the root of the router state tree to this route */\n    get pathFromRoot(): ActivatedRouteSnapshot[];\n    get paramMap(): ParamMap;\n    get queryParamMap(): ParamMap;\n    toString(): string;\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ActivationEnd {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    readonly type = EventType.ActivationEnd;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ActivationStart {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    readonly type = EventType.ActivationStart;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport declare abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n    /**\n     * Whether the given route should detach for later reuse.\n     * Always returns false for `BaseRouteReuseStrategy`.\n     * */\n    shouldDetach(route: ActivatedRouteSnapshot): boolean;\n    /**\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n     */\n    store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void;\n    /** Returns `false`, meaning the route (and its subtree) is never reattached */\n    shouldAttach(route: ActivatedRouteSnapshot): boolean;\n    /** Returns `null` because this strategy does not store routes for later re-use. */\n    retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n    /**\n     * Determines if a route should be reused.\n     * This strategy returns `true` when the future route config and current route config are\n     * identical.\n     */\n    shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivate` function that checks whether the\n * current user has permission to activate the requested route.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivate {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivate(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: [CanActivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `CanActivateFn` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: [(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true]\n *       }\n *     ])\n *   ],\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanActivate {\n    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a child route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivateChild` function that checks whether the\n * current user has permission to activate the requested child route.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivateChild {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivateChild(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [CanActivateTeam],\n *         children: [\n *           {\n *              path: 'team/:id',\n *              component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `CanActivateChildFn` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true],\n *         children: [\n *           {\n *             path: 'team/:id',\n *             component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanActivateChild {\n    canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * The signature of a function used as a `canActivateChild` guard on a `Route`.\n *\n * @publicApi\n * @see `CanActivateChild`\n * @see `Route`\n */\nexport declare type CanActivateChildFn = (childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot) => Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n\n/**\n * The signature of a function used as a `canActivate` guard on a `Route`.\n *\n * @publicApi\n * @see `CanActivate`\n * @see `Route`\n */\nexport declare type CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be deactivated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanDeactivate` function that checks whether the\n * current user has permission to deactivate the requested route.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canDeactivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n *\n * @Injectable()\n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canDeactivate(\n *     component: TeamComponent,\n *     currentRoute: ActivatedRouteSnapshot,\n *     currentState: RouterStateSnapshot,\n *     nextState: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: [CanDeactivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `CanDeactivateFn` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: [(component: TeamComponent, currentRoute: ActivatedRouteSnapshot,\n * currentState: RouterStateSnapshot, nextState: RouterStateSnapshot) => true]\n *       }\n *     ])\n *   ],\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanDeactivate<T> {\n    canDeactivate(component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState?: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * The signature of a function used as a `canDeactivate` guard on a `Route`.\n *\n * @publicApi\n * @see `CanDeactivate`\n * @see `Route`\n */\nexport declare type CanDeactivateFn<T> = (component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState?: RouterStateSnapshot) => Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if children can be loaded.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation starts to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanLoad` function that decides whether the\n * current user has permission to load requested child routes.\n *\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canLoadChildren(user: UserToken, id: string, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanLoadTeamSection implements CanLoad {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canLoad(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canLoadChildren(this.currentUser, route, segments);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canLoad: [CanLoadTeamSection]\n *       }\n *     ])\n *   ],\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `CanLoadFn` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canLoad: [(route: Route, segments: UrlSegment[]) => true]\n *       }\n *     ])\n *   ],\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanLoad {\n    canLoad(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * The signature of a function used as a `canLoad` guard on a `Route`.\n *\n * @publicApi\n * @see `CanLoad`\n * @see `Route`\n */\nexport declare type CanLoadFn = (route: Route, segments: UrlSegment[]) => Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a `Route` can be matched.\n * If all guards return `true`, navigation continues and the `Router` will use the `Route` during\n * activation. If any guard returns `false`, the `Route` is skipped for matching and other `Route`\n * configurations are processed instead.\n *\n * The following example implements a `CanMatch` function that decides whether the\n * current user has permission to access the users page.\n *\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canAccess(user: UserToken, id: string, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanMatchTeamSection implements CanMatch {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canMatch(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canAccess(this.currentUser, route, segments);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canMatch: [CanMatchTeamSection]\n *       },\n *       {\n *         path: '**',\n *         component: NotFoundComponent\n *       }\n *     ])\n *   ],\n *   providers: [CanMatchTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * If the `CanMatchTeamSection` were to return `false`, the router would continue navigating to the\n * `team/:id` URL, but would load the `NotFoundComponent` because the `Route` for `'team/:id'`\n * could not be used for a URL match but the catch-all `**` `Route` did instead.\n *\n * You can alternatively provide an in-line function with the `CanMatchFn` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canMatch: [(route: Route, segments: UrlSegment[]) => true]\n *       },\n *       {\n *         path: '**',\n *         component: NotFoundComponent\n *       }\n *     ])\n *   ],\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanMatch {\n    canMatch(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * The signature of a function used as a `CanMatch` guard on a `Route`.\n *\n * @publicApi\n * @see `CanMatch`\n * @see `Route`\n */\nexport declare type CanMatchFn = (route: Route, segments: UrlSegment[]) => Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart`\n * @publicApi\n */\nexport declare class ChildActivationEnd {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    readonly type = EventType.ChildActivationEnd;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see  `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ChildActivationStart {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    readonly type = EventType.ChildActivationStart;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\nexport declare class ChildrenOutletContexts {\n    private contexts;\n    /** Called when a `RouterOutlet` directive is instantiated */\n    onChildOutletCreated(childName: string, outlet: RouterOutletContract): void;\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    onChildOutletDestroyed(childName: string): void;\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    onOutletDeactivated(): Map<string, OutletContext>;\n    onOutletReAttached(contexts: Map<string, OutletContext>): void;\n    getOrCreateContext(childName: string): OutletContext;\n    getContext(childName: string): OutletContext | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ChildrenOutletContexts, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ChildrenOutletContexts>;\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport declare function convertToParamMap(params: Params): ParamMap;\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport declare function createUrlTreeFromSnapshot(relativeTo: ActivatedRouteSnapshot, commands: any[], queryParams?: Params | null, fragment?: string | null): UrlTree;\n\n/**\n *\n * Represents static data associated with a particular route.\n *\n * @see `Route#data`\n *\n * @publicApi\n */\nexport declare type Data = {\n    [key: string | symbol]: any;\n};\n\n/**\n * A type alias for providers returned by `withDebugTracing` for use with `provideRouter`.\n *\n * @see `withDebugTracing`\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type DebugTracingFeature = RouterFeature<RouterFeatureKind.DebugTracingFeature>;\n\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\nexport declare class DefaultTitleStrategy extends TitleStrategy {\n    readonly title: Title;\n    constructor(title: Title);\n    /**\n     * Sets the title of the browser to the given value.\n     *\n     * @param title The `pageTitle` from the deepest primary route.\n     */\n    updateTitle(snapshot: RouterStateSnapshot): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultTitleStrategy, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<DefaultTitleStrategy>;\n}\n\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see UrlMatchResult\n * @see Route\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\nexport declare function defaultUrlMatcher(segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult | null;\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport declare class DefaultUrlSerializer implements UrlSerializer {\n    /** Parses a url into a `UrlTree` */\n    parse(url: string): UrlTree;\n    /** Converts a `UrlTree` into a url */\n    serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport declare type DetachedRouteHandle = {};\n\n/**\n * A type alias for providers returned by `withDisabledInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see `withDisabledInitialNavigation`\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type DisabledInitialNavigationFeature = RouterFeature<RouterFeatureKind.DisabledInitialNavigationFeature>;\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see `withEnabledBlockingInitialNavigation`\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type EnabledBlockingInitialNavigationFeature = RouterFeature<RouterFeatureKind.EnabledBlockingInitialNavigationFeature>;\n\n/**\n * Error handler that is invoked when a navigation error occurs.\n *\n * If the handler returns a value, the navigation Promise is resolved with this value.\n * If the handler throws an exception, the navigation Promise is rejected with\n * the exception.\n *\n * @publicApi\n */\ndeclare type ErrorHandler = (error: any) => any;\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](/guide/router#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfully.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationEnd): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\ndeclare type Event_2 = RouterEvent | NavigationStart | NavigationEnd | NavigationCancel | NavigationError | RoutesRecognized | GuardsCheckStart | GuardsCheckEnd | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart | ChildActivationEnd | ActivationStart | ActivationEnd | Scroll | ResolveStart | ResolveEnd;\nexport { Event_2 as Event }\n\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nexport declare const enum EventType {\n    NavigationStart = 0,\n    NavigationEnd = 1,\n    NavigationCancel = 2,\n    NavigationError = 3,\n    RoutesRecognized = 4,\n    ResolveStart = 5,\n    ResolveEnd = 6,\n    GuardsCheckStart = 7,\n    GuardsCheckEnd = 8,\n    RouteConfigLoadStart = 9,\n    RouteConfigLoadEnd = 10,\n    ChildActivationStart = 11,\n    ChildActivationEnd = 12,\n    ActivationStart = 13,\n    ActivationEnd = 14,\n    Scroll = 15\n}\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @see `forRoot()`\n *\n *\n * @publicApi\n */\nexport declare interface ExtraOptions extends InMemoryScrollingOptions, RouterConfigOptions {\n    /**\n     * When true, log all internal navigation events to the console.\n     * Use for debugging.\n     */\n    enableTracing?: boolean;\n    /**\n     * When true, enable the location strategy that uses the URL fragment\n     * instead of the history API.\n     */\n    useHash?: boolean;\n    /**\n     * One of `enabled`, `enabledBlocking`, `enabledNonBlocking` or `disabled`.\n     * When set to `enabled` or `enabledBlocking`, the initial navigation starts before the root\n     * component is created. The bootstrap is blocked until the initial navigation is complete. This\n     * value is required for [server-side rendering](guide/universal) to work. When set to\n     * `enabledNonBlocking`, the initial navigation starts after the root component has been created.\n     * The bootstrap is not blocked on the completion of the initial navigation. When set to\n     * `disabled`, the initial navigation is not performed. The location listener is set up before the\n     * root component gets created. Use if there is a reason to have more control over when the router\n     * starts its initial navigation due to some complex initialization logic.\n     */\n    initialNavigation?: InitialNavigation;\n    /**\n     * A custom error handler for failed navigations.\n     * If the handler returns a value, the navigation Promise is resolved with this value.\n     * If the handler throws an exception, the navigation Promise is rejected with the exception.\n     *\n     */\n    errorHandler?: ErrorHandler;\n    /**\n     * Configures a preloading strategy.\n     * One of `PreloadAllModules` or `NoPreloading` (the default).\n     */\n    preloadingStrategy?: any;\n    /**\n     * Configures the scroll offset the router will use when scrolling to an element.\n     *\n     * When given a tuple with x and y position value,\n     * the router uses that offset each time it scrolls.\n     * When given a function, the router invokes the function every time\n     * it restores scroll position.\n     */\n    scrollOffset?: [number, number] | (() => [number, number]);\n    /**\n     * A custom handler for malformed URI errors. The handler is invoked when `encodedURI` contains\n     * invalid character sequences.\n     * The default implementation is to redirect to the root URL, dropping\n     * any path or parameter information. The function takes three parameters:\n     *\n     * - `'URIError'` - Error thrown when parsing a bad URL.\n     * - `'UrlSerializer'` - UrlSerializer that’s configured with the router.\n     * - `'url'` -  The malformed URL that caused the URIError\n     * */\n    malformedUriErrorHandler?: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * Example:\n     *\n     * ```\n     * const routes = [\n     *   {\n     *     path: '',\n     *     component: ContainerComponent,\n     *     children: [\n     *       { path: 'a', component: AComponent },\n     *       { path: 'b', component: BComponent },\n     *     ]\n     *   }\n     * ];\n     * ```\n     *\n     * From the `ContainerComponent`, you should be able to navigate to `AComponent` using\n     * the following `routerLink`, but it will not work if `relativeLinkResolution` is set\n     * to `'legacy'`:\n     *\n     * `<a [routerLink]=\"['./a']\">Link to A</a>`\n     *\n     * However, this will work:\n     *\n     * `<a [routerLink]=\"['../a']\">Link to A</a>`\n     *\n     * In other words, you're required to use `../` rather than `./` when the relative link\n     * resolution is set to `'legacy'`.\n     *\n     * The default in v11 is `corrected`.\n     *\n     * @deprecated\n     */\n    relativeLinkResolution?: 'legacy' | 'corrected';\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see `GuardsCheckStart`\n *\n * @publicApi\n */\nexport declare class GuardsCheckEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    /** @docsNotRequired */\n    shouldActivate: boolean;\n    readonly type = EventType.GuardsCheckEnd;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot, \n    /** @docsNotRequired */\n    shouldActivate: boolean);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see `GuardsCheckEnd`\n *\n * @publicApi\n */\nexport declare class GuardsCheckStart extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    readonly type = EventType.GuardsCheckStart;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\ndeclare namespace i1 {\n    export {\n        RouterOutletContract,\n        RouterOutlet\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        RouterLink,\n        RouterLinkWithHref\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        RouterLinkActive\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        ɵEmptyOutletComponent,\n        ɵEmptyOutletComponent as EmptyOutletComponent\n    }\n}\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabledNonBlocking' - (default) The initial navigation starts after the\n * root component has been created. The bootstrap is not blocked on the completion of the initial\n * navigation.\n * * 'enabledBlocking' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value is required\n * for [server-side rendering](guide/universal) to work.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n *\n * @see `forRoot()`\n *\n * @publicApi\n */\nexport declare type InitialNavigation = 'disabled' | 'enabledBlocking' | 'enabledNonBlocking';\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` or\n * `withDisabledInitialNavigation` functions for use with `provideRouter`.\n *\n * @see `withEnabledBlockingInitialNavigation`\n * @see `withDisabledInitialNavigation`\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type InitialNavigationFeature = EnabledBlockingInitialNavigationFeature | DisabledInitialNavigationFeature;\n\n/**\n * A type alias for providers returned by `withInMemoryScrolling` for use with `provideRouter`.\n *\n * @see `withInMemoryScrolling`\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type InMemoryScrollingFeature = RouterFeature<RouterFeatureKind.InMemoryScrollingFeature>;\n\n/**\n * Configuration options for the scrolling feature which can be used with `withInMemoryScrolling`\n * function.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare interface InMemoryScrollingOptions {\n    /**\n     * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n     * Anchor scrolling is disabled by default.\n     *\n     * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n     * that we stored or scroll to the top.\n     */\n    anchorScrolling?: 'disabled' | 'enabled';\n    /**\n     * Configures if the scroll position needs to be restored when navigating back.\n     *\n     * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n     * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n     * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n     * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n     * navigation). This option will be the default in the future.\n     *\n     * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n     * in the following example.\n     *\n     * ```typescript\n     * class AppComponent {\n     *   movieData: any;\n     *\n     *   constructor(private router: Router, private viewportScroller: ViewportScroller,\n     * changeDetectorRef: ChangeDetectorRef) {\n     *   router.events.pipe(filter((event: Event): event is Scroll => event instanceof Scroll)\n     *     ).subscribe(e => {\n     *       fetch('http://example.com/movies.json').then(response => {\n     *         this.movieData = response.json();\n     *         // update the template with the data before restoring scroll\n     *         changeDetectorRef.detectChanges();\n     *\n     *         if (e.position) {\n     *           viewportScroller.scrollToPosition(e.position);\n     *         }\n     *       });\n     *     });\n     *   }\n     * }\n     * ```\n     */\n    scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n}\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see Router.isActive\n */\nexport declare interface IsActiveMatchOptions {\n    /**\n     * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n     *\n     * The matrix parameter matching is dependent on the strategy for matching the\n     * segments. That is, if the `paths` option is set to `'subset'`, only\n     * the matrix parameters of the matching segments will be compared.\n     *\n     * - `'exact'`: Requires that matching segments also have exact matrix parameter\n     * matches.\n     * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n     * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n     * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n     */\n    matrixParams: 'exact' | 'subset' | 'ignored';\n    /**\n     * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n     *\n     * - `'exact'`: the query parameters must match exactly.\n     * - `'subset'`: the active `UrlTree` may contain extra parameters,\n     * but must match the key and value of any that exist in the `UrlTree` in question.\n     * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n     */\n    queryParams: 'exact' | 'subset' | 'ignored';\n    /**\n     * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n     *\n     * - `'exact'`: all segments in each `UrlTree` must match.\n     * - `'subset'`: a `UrlTree` will be determined to be active if it\n     * is a subtree of the active route. That is, the active route may contain extra\n     * segments, but must at least have all the segments of the `UrlTree` in question.\n     */\n    paths: 'exact' | 'subset';\n    /**\n     * - `'exact'`: indicates that the `UrlTree` fragments must be equal.\n     * - `'ignored'`: the fragments will not be compared when determining if a\n     * `UrlTree` is active.\n     */\n    fragment: 'exact' | 'ignored';\n}\n\n/**\n *\n * A function that returns a set of routes to load.\n *\n * @see `LoadChildrenCallback`\n * @publicApi\n */\nexport declare type LoadChildren = LoadChildrenCallback;\n\n/**\n *\n * A function that is called to resolve a collection of lazy-loaded routes.\n * Must be an arrow function of the following form:\n * `() => import('...').then(mod => mod.MODULE)`\n * or\n * `() => import('...').then(mod => mod.ROUTES)`\n *\n * For example:\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n * or\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.routes').then(mod => mod.ROUTES),\n * }];\n * ```\n *\n * @see [Route.loadChildren](api/router/Route#loadChildren)\n * @publicApi\n */\nexport declare type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Routes | Observable<Type<any> | Routes> | Promise<NgModuleFactory<any> | Type<any> | Routes>;\n\ndeclare interface LoadedRouterConfig {\n    routes: Route[];\n    injector: EnvironmentInjector | undefined;\n}\n\n/**\n * Information about a navigation operation.\n * Retrieve the most recent navigation object with the\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\n *\n * * *id* : The unique identifier of the current navigation.\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\n * This is the value before the router has parsed or applied redirects to it.\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\n * * *finalUrl* : The extracted URL after redirects have been applied.\n * This URL may not be available immediately, therefore this property can be `undefined`.\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\n * * *trigger* : Identifies how this navigation was triggered.\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n * -- 'popstate'--Triggered by a popstate event.\n * -- 'hashchange'--Triggered by a hashchange event.\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\n * navigation.\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\n * own `previousNavigation`.\n *\n * @publicApi\n */\nexport declare interface Navigation {\n    /**\n     * The unique identifier of the current navigation.\n     */\n    id: number;\n    /**\n     * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n     * the value before the router has parsed or applied redirects to it.\n     */\n    initialUrl: UrlTree;\n    /**\n     * The initial target URL after being parsed with `UrlSerializer.extract()`.\n     */\n    extractedUrl: UrlTree;\n    /**\n     * The extracted URL after redirects have been applied.\n     * This URL may not be available immediately, therefore this property can be `undefined`.\n     * It is guaranteed to be set after the `RoutesRecognized` event fires.\n     */\n    finalUrl?: UrlTree;\n    /**\n     * Identifies how this navigation was triggered.\n     *\n     * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n     * * 'popstate'--Triggered by a popstate event.\n     * * 'hashchange'--Triggered by a hashchange event.\n     */\n    trigger: 'imperative' | 'popstate' | 'hashchange';\n    /**\n     * Options that controlled the strategy used for this navigation.\n     * See `NavigationExtras`.\n     */\n    extras: NavigationExtras;\n    /**\n     * The previously successful `Navigation` object. Only one previous navigation\n     * is available, therefore this previous `Navigation` object has a `null` value\n     * for its own `previousNavigation`.\n     */\n    previousNavigation: Navigation | null;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the navigation should be handled.\n *\n * @see [Router.navigate() method](api/router/Router#navigate)\n * @see [Router.navigateByUrl() method](api/router/Router#navigatebyurl)\n * @see [Routing and Navigation guide](guide/router)\n *\n * @publicApi\n */\nexport declare interface NavigationBehaviorOptions {\n    /**\n     * When true, navigates without pushing a new state into history.\n     *\n     * ```\n     * // Navigate silently to /view\n     * this.router.navigate(['/view'], { skipLocationChange: true });\n     * ```\n     */\n    skipLocationChange?: boolean;\n    /**\n     * When true, navigates while replacing the current state in history.\n     *\n     * ```\n     * // Navigate to /view\n     * this.router.navigate(['/view'], { replaceUrl: true });\n     * ```\n     */\n    replaceUrl?: boolean;\n    /**\n     * Developer-defined state that can be passed to any navigation.\n     * Access this value through the `Navigation.extras` object\n     * returned from the [Router.getCurrentNavigation()\n     * method](api/router/Router#getcurrentnavigation) while a navigation is executing.\n     *\n     * After a navigation completes, the router writes an object containing this\n     * value together with a `navigationId` to `history.state`.\n     * The value is written when `location.go()` or `location.replaceState()`\n     * is called before activating this route.\n     *\n     * Note that `history.state` does not pass an object equality test because\n     * the router adds the `navigationId` on each navigation.\n     *\n     */\n    state?: {\n        [k: string]: any;\n    };\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport declare class NavigationCancel extends RouterEvent {\n    /**\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n     * instead for a stable cancellation reason that can be used in production.\n     */\n    reason: string;\n    /**\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    readonly code?: NavigationCancellationCode | undefined;\n    readonly type = EventType.NavigationCancel;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /**\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n     * instead for a stable cancellation reason that can be used in production.\n     */\n    reason: string, \n    /**\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    code?: NavigationCancellationCode | undefined);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nexport declare const enum NavigationCancellationCode {\n    /**\n     * A navigation failed because a guard returned a `UrlTree` to redirect.\n     */\n    Redirect = 0,\n    /**\n     * A navigation failed because a more recent navigation started.\n     */\n    SupersededByNewNavigation = 1,\n    /**\n     * A navigation failed because one of the resolvers completed without emiting a value.\n     */\n    NoDataFromResolver = 2,\n    /**\n     * A navigation failed because a guard returned `false`.\n     */\n    GuardRejected = 3\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see `NavigationStart`\n * @see `NavigationCancel`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport declare class NavigationEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    readonly type = EventType.NavigationEnd;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationCancel`\n *\n * @publicApi\n */\nexport declare class NavigationError extends RouterEvent {\n    /** @docsNotRequired */\n    error: any;\n    /**\n     * The target of the navigation when the error occurred.\n     *\n     * Note that this can be `undefined` because an error could have occurred before the\n     * `RouterStateSnapshot` was created for the navigation.\n     */\n    readonly target?: RouterStateSnapshot | undefined;\n    readonly type = EventType.NavigationError;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    error: any, \n    /**\n     * The target of the navigation when the error occurred.\n     *\n     * Note that this can be `undefined` because an error could have occurred before the\n     * `RouterStateSnapshot` was created for the navigation.\n     */\n    target?: RouterStateSnapshot | undefined);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed or interpreted.\n *\n * @see [Router.navigate() method](api/router/Router#navigate)\n * @see [Router.navigateByUrl() method](api/router/Router#navigatebyurl)\n * @see [Router.createUrlTree() method](api/router/Router#createurltree)\n * @see [Routing and Navigation guide](guide/router)\n * @see UrlCreationOptions\n * @see NavigationBehaviorOptions\n *\n * @publicApi\n */\nexport declare interface NavigationExtras extends UrlCreationOptions, NavigationBehaviorOptions {\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport declare class NavigationStart extends RouterEvent {\n    readonly type = EventType.NavigationStart;\n    /**\n     * Identifies the call or event that triggered the navigation.\n     * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n     *\n     * @see `NavigationEnd`\n     * @see `NavigationCancel`\n     * @see `NavigationError`\n     */\n    navigationTrigger?: NavigationTrigger;\n    /**\n     * The navigation state that was previously supplied to the `pushState` call,\n     * when the navigation is triggered by a `popstate` event. Otherwise null.\n     *\n     * The state object is defined by `NavigationExtras`, and contains any\n     * developer-defined state value, as well as a unique ID that\n     * the router assigns to every router transition/navigation.\n     *\n     * From the perspective of the router, the router never \"goes back\".\n     * When the user clicks on the back button in the browser,\n     * a new navigation ID is created.\n     *\n     * Use the ID in this previous-state object to differentiate between a newly created\n     * state and one returned to by a `popstate` event, so that you can restore some\n     * remembered state, such as scroll position.\n     *\n     */\n    restoredState?: {\n        [k: string]: any;\n        navigationId: number;\n    } | null;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    navigationTrigger?: NavigationTrigger, \n    /** @docsNotRequired */\n    restoredState?: {\n        [k: string]: any;\n        navigationId: number;\n    } | null);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\ndeclare type NavigationTrigger = 'imperative' | 'popstate' | 'hashchange';\n\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\nexport declare class NoPreloading implements PreloadingStrategy {\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<NoPreloading, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<NoPreloading>;\n}\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport declare class OutletContext {\n    outlet: RouterOutletContract | null;\n    route: ActivatedRoute | null;\n    /**\n     * @deprecated Passing a resolver to retrieve a component factory is not required and is\n     *     deprecated since v14.\n     */\n    resolver: ComponentFactoryResolver | null;\n    injector: EnvironmentInjector | null;\n    children: ChildrenOutletContexts;\n    attachRef: ComponentRef<any> | null;\n}\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport declare interface ParamMap {\n    /**\n     * Reports whether the map contains a given parameter.\n     * @param name The parameter name.\n     * @returns True if the map contains the given parameter, false otherwise.\n     */\n    has(name: string): boolean;\n    /**\n     * Retrieves a single value for a parameter.\n     * @param name The parameter name.\n     * @return The parameter's single value,\n     * or the first value if the parameter has multiple values,\n     * or `null` when there is no such parameter.\n     */\n    get(name: string): string | null;\n    /**\n     * Retrieves multiple values for a parameter.\n     * @param name The parameter name.\n     * @return An array containing one or more values,\n     * or an empty array if there is no such parameter.\n     *\n     */\n    getAll(name: string): string[];\n    /** Names of the parameters in the map. */\n    readonly keys: string[];\n}\n\n/**\n * A collection of matrix and query URL parameters.\n * @see `convertToParamMap()`\n * @see `ParamMap`\n *\n * @publicApi\n */\nexport declare type Params = {\n    [key: string]: any;\n};\n\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\nexport declare class PreloadAllModules implements PreloadingStrategy {\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<PreloadAllModules, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<PreloadAllModules>;\n}\n\n/**\n * A type alias that represents a feature which enables preloading in Router.\n * The type is used to describe the return value of the `withPreloading` function.\n *\n * @see `withPreloading`\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type PreloadingFeature = RouterFeature<RouterFeatureKind.PreloadingFeature>;\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nexport declare abstract class PreloadingStrategy {\n    abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport declare const PRIMARY_OUTLET = \"primary\";\n\n/**\n * Sets up providers necessary to enable `Router` functionality for the application.\n * Allows to configure a set of routes as well as extra features that should be enabled.\n *\n * @usageNotes\n *\n * Basic example of how you can add a Router to your application:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent, {\n *   providers: [provideRouter(appRoutes)]\n * });\n * ```\n *\n * You can also enable optional features in the Router by adding functions from the `RouterFeatures`\n * type:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes,\n *         withDebugTracing(),\n *         withRouterConfig({paramsInheritanceStrategy: 'always'}))\n *     ]\n *   }\n * );\n * ```\n *\n * @see `RouterFeatures`\n *\n * @publicApi\n * @developerPreview\n * @param routes A set of `Route`s to use for the application routing table.\n * @param features Optional features to configure additional router behaviors.\n * @returns A set of providers to setup a Router.\n */\nexport declare function provideRouter(routes: Routes, ...features: RouterFeatures[]): Provider[];\n\n/**\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```\n * @NgModule({\n *   providers: [provideRoutes(ROUTES)]\n * })\n * class LazyLoadedChildModule {}\n * ```\n *\n * @publicApi\n */\nexport declare function provideRoutes(routes: Routes): Provider[];\n\n/**\n *\n * How to handle query parameters in a router link.\n * One of:\n * - `\"merge\"` : Merge new parameters with current parameters.\n * - `\"preserve\"` : Preserve current parameters.\n * - `\"\"` : Replace current parameters with new parameters. This is the default behavior.\n *\n * @see `UrlCreationOptions#queryParamsHandling`\n * @see `RouterLink`\n * @publicApi\n */\nexport declare type QueryParamsHandling = 'merge' | 'preserve' | '';\n\n/**\n * @description\n *\n * Interface that classes can implement to be a data provider.\n * A data provider class can be used with the router to resolve data during navigation.\n * The interface defines a `resolve()` method that is invoked right after the `ResolveStart`\n * router event. The router waits for the data to be resolved before the route is finally activated.\n *\n * The following example implements a `resolve()` method that retrieves the data\n * needed to activate the requested route.\n *\n * ```\n * @Injectable({ providedIn: 'root' })\n * export class HeroResolver implements Resolve<Hero> {\n *   constructor(private service: HeroService) {}\n *\n *   resolve(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<Hero>|Promise<Hero>|Hero {\n *     return this.service.getHero(route.paramMap.get('id'));\n *   }\n * }\n * ```\n *\n * Here, the defined `resolve()` function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroDetailComponent,\n *         resolve: {\n *           hero: HeroResolver\n *         }\n *       }\n *     ])\n *   ],\n *   exports: [RouterModule]\n * })\n * export class AppRoutingModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `ResolveFn` signature:\n *\n * ```\n * export const myHero: Hero = {\n *   // ...\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroComponent,\n *         resolve: {\n *           hero: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => myHero\n *         }\n *       }\n *     ])\n *   ],\n * })\n * export class AppModule {}\n * ```\n *\n * And you can access to your resolved data from `HeroComponent`:\n *\n * ```\n * @Component({\n *  selector: \"app-hero\",\n *  templateUrl: \"hero.component.html\",\n * })\n * export class HeroComponent {\n *\n *  constructor(private activatedRoute: ActivatedRoute) {}\n *\n *  ngOnInit() {\n *    this.activatedRoute.data.subscribe(({ hero }) => {\n *      // do something with your resolved data ...\n *    })\n *  }\n *\n * }\n * ```\n *\n * @usageNotes\n *\n * When both guard and resolvers are specified, the resolvers are not executed until\n * all guards have run and succeeded.\n * For example, consider the following route configuration:\n *\n * ```\n * {\n *  path: 'base'\n *  canActivate: [BaseGuard],\n *  resolve: {data: BaseDataResolver}\n *  children: [\n *   {\n *     path: 'child',\n *     guards: [ChildGuard],\n *     component: ChildComponent,\n *     resolve: {childData: ChildDataResolver}\n *    }\n *  ]\n * }\n * ```\n * The order of execution is: BaseGuard, ChildGuard, BaseDataResolver, ChildDataResolver.\n *\n * @publicApi\n */\nexport declare interface Resolve<T> {\n    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T> | Promise<T> | T;\n}\n\n/**\n *\n * Represents the resolved data associated with a particular route.\n *\n * @see `Route#resolve`.\n *\n * @publicApi\n */\nexport declare type ResolveData = {\n    [key: string | symbol]: any | ResolveFn<unknown>;\n};\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * @publicApi\n */\nexport declare class ResolveEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    readonly type = EventType.ResolveEnd;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * Function type definition for a data provider.\n *\n * @see `Route#resolve`.\n * @publicApi\n */\nexport declare type ResolveFn<T> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => Observable<T> | Promise<T> | T;\n\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see `ResolveEnd`\n *\n * @publicApi\n */\nexport declare class ResolveStart extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    readonly type = EventType.ResolveStart;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * A configuration object that defines a single route.\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\n * The router attempts to match segments of a given URL against each route,\n * using the configuration options defined in this object.\n *\n * Supports static, parameterized, redirect, and wildcard routes, as well as\n * custom route data and resolve methods.\n *\n * For detailed usage information, see the [Routing Guide](guide/router).\n *\n * @usageNotes\n *\n * ### Simple Configuration\n *\n * The following route specifies that when navigating to, for example,\n * `/team/11/user/bob`, the router creates the 'Team' component\n * with the 'User' child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * ### Multiple Outlets\n *\n * The following route creates sibling components with multiple outlets.\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * ### Wild Cards\n *\n * The following route uses wild-card notation to specify a component\n * that is always instantiated regardless of where you navigate to.\n *\n * ```\n * [{\n *   path: '**',\n *   component: WildcardComponent\n * }]\n * ```\n *\n * ### Redirects\n *\n * The following route uses the `redirectTo` property to ignore a segment of\n * a given URL when looking for a child path.\n *\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\n * the Team component with the User child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * The redirect path can be relative, as shown in this example, or absolute.\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\n * the result URL is also absolute, '/user/jim'.\n\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any URL segments.\n *\n * In the following configuration, when navigating to\n * `/team/11`, the router instantiates the 'AllUsers' component.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * Empty-path routes can have children. In the following example, when navigating\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\n * the user component in it.\n *\n * Note that an empty path route inherits its parent's parameters and data.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * ### Matching Strategy\n *\n * The default path-match strategy is 'prefix', which means that the router\n * checks URL elements from the left to see if the URL matches a specified path.\n * For example, '/team/11/user' matches 'team/:id'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * You can specify the path-match strategy 'full' to make sure that the path\n * covers the whole unconsumed URL. It is important to do this when redirecting\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\n * the router would apply the redirect even when navigating to the redirect destination,\n * creating an endless loop.\n *\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\n * that the router applies the redirect if and only if navigating to '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * You can share parameters between sibling components.\n * For example, suppose that two sibling components should go next to each other,\n * and both of them require an ID parameter. You can accomplish this using a route\n * that does not specify a component at the top level.\n *\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\n * the main child and aux child components next to each other.\n * For this to work, the application component must have the primary and aux outlets defined.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * The router merges the parameters, data, and resolve of the componentless\n * parent into the parameters, data, and resolve of the children.\n *\n * This is especially useful when child components are defined\n * with an empty path string, as in the following example.\n * With this configuration, navigating to '/parent/10' creates\n * the main child and aux components.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up application load time by splitting the application\n * into multiple bundles and loading them on demand.\n * To use lazy loading, provide the `loadChildren` property in the `Route` object,\n * instead of the `children` property.\n *\n * Given the following example route, the router will lazy load\n * the associated module on demand using the browser native import system.\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * @publicApi\n */\nexport declare interface Route {\n    /**\n     * Used to define a page title for the route. This can be a static string or an `Injectable` that\n     * implements `Resolve`.\n     *\n     * @see `PageTitleStrategy`\n     */\n    title?: string | Type<Resolve<string>> | ResolveFn<string>;\n    /**\n     * The path to match against. Cannot be used together with a custom `matcher` function.\n     * A URL string that uses router matching notation.\n     * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\n     * Default is \"/\" (the root path).\n     *\n     */\n    path?: string;\n    /**\n     * The path-matching strategy, one of 'prefix' or 'full'.\n     * Default is 'prefix'.\n     *\n     * By default, the router checks URL elements from the left to see if the URL\n     * matches a given path and stops when there is a config match. Importantly there must still be a\n     * config match for each segment of the URL. For example, '/team/11/user' matches the prefix\n     * 'team/:id' if one of the route's children matches the segment 'user'. That is, the URL\n     * '/team/11/user' matches the config\n     * `{path: 'team/:id', children: [{path: ':user', component: User}]}`\n     * but does not match when there are no children as in `{path: 'team/:id', component: Team}`.\n     *\n     * The path-match strategy 'full' matches against the entire URL.\n     * It is important to do this when redirecting empty-path routes.\n     * Otherwise, because an empty path is a prefix of any URL,\n     * the router would apply the redirect even when navigating\n     * to the redirect destination, creating an endless loop.\n     *\n     */\n    pathMatch?: 'prefix' | 'full';\n    /**\n     * A custom URL-matching function. Cannot be used together with `path`.\n     */\n    matcher?: UrlMatcher;\n    /**\n     * The component to instantiate when the path matches.\n     * Can be empty if child routes specify components.\n     */\n    component?: Type<any>;\n    /**\n     * An object specifying a lazy-loaded component.\n     */\n    loadComponent?: () => Type<unknown> | Observable<Type<unknown>> | Promise<Type<unknown>>;\n    /**\n     * A URL to redirect to when the path matches.\n     *\n     * Absolute if the URL begins with a slash (/), otherwise relative to the path URL.\n     * Note that no further redirects are evaluated after an absolute redirect.\n     *\n     * When not present, router does not redirect.\n     */\n    redirectTo?: string;\n    /**\n     * Name of a `RouterOutlet` object where the component can be placed\n     * when the path matches.\n     */\n    outlet?: string;\n    /**\n     * An array of `CanActivateFn` or DI tokens used to look up `CanActivate()`\n     * handlers, in order to determine if the current user is allowed to\n     * activate the component. By default, any user can activate.\n     *\n     * When using a function rather than DI tokens, the function can call `inject` to get any required\n     * dependencies. This `inject` call must be done in a synchronous context.\n     */\n    canActivate?: Array<CanActivateFn | any>;\n    /**\n     * An array of `CanMatchFn` or DI tokens used to look up `CanMatch()`\n     * handlers, in order to determine if the current user is allowed to\n     * match the `Route`. By default, any route can match.\n     *\n     * When using a function rather than DI tokens, the function can call `inject` to get any required\n     * dependencies. This `inject` call must be done in a synchronous context.\n     */\n    canMatch?: Array<Type<CanMatch> | InjectionToken<CanMatchFn> | CanMatchFn>;\n    /**\n     * An array of `CanActivateChildFn` or DI tokens used to look up `CanActivateChild()` handlers,\n     * in order to determine if the current user is allowed to activate\n     * a child of the component. By default, any user can activate a child.\n     *\n     * When using a function rather than DI tokens, the function can call `inject` to get any required\n     * dependencies. This `inject` call must be done in a synchronous context.\n     */\n    canActivateChild?: Array<CanActivateChildFn | any>;\n    /**\n     * An array of `CanDeactivateFn` or DI tokens used to look up `CanDeactivate()`\n     * handlers, in order to determine if the current user is allowed to\n     * deactivate the component. By default, any user can deactivate.\n     *\n     * When using a function rather than DI tokens, the function can call `inject` to get any required\n     * dependencies. This `inject` call must be done in a synchronous context.\n     */\n    canDeactivate?: Array<CanDeactivateFn<any> | any>;\n    /**\n     * An array of `CanLoadFn` or DI tokens used to look up `CanLoad()`\n     * handlers, in order to determine if the current user is allowed to\n     * load the component. By default, any user can load.\n     *\n     * When using a function rather than DI tokens, the function can call `inject` to get any required\n     * dependencies. This `inject` call must be done in a synchronous context.\n     */\n    canLoad?: Array<CanLoadFn | any>;\n    /**\n     * Additional developer-defined data provided to the component via\n     * `ActivatedRoute`. By default, no additional data is passed.\n     */\n    data?: Data;\n    /**\n     * A map of DI tokens used to look up data resolvers. See `Resolve`.\n     */\n    resolve?: ResolveData;\n    /**\n     * An array of child `Route` objects that specifies a nested route\n     * configuration.\n     */\n    children?: Routes;\n    /**\n     * An object specifying lazy-loaded child routes.\n     */\n    loadChildren?: LoadChildren;\n    /**\n     * Defines when guards and resolvers will be run. One of\n     * - `paramsOrQueryParamsChange` : Run when query parameters change.\n     * - `always` : Run on every execution.\n     * By default, guards and resolvers run only when the matrix\n     * parameters of the route change.\n     *\n     * @see RunGuardsAndResolvers\n     */\n    runGuardsAndResolvers?: RunGuardsAndResolvers;\n    /**\n     * A `Provider` array to use for this `Route` and its `children`.\n     *\n     * The `Router` will create a new `EnvironmentInjector` for this\n     * `Route` and use it for this `Route` and its `children`. If this\n     * route also has a `loadChildren` function which returns an `NgModuleRef`, this injector will be\n     * used as the parent of the lazy loaded module.\n     */\n    providers?: Array<Provider | ImportedNgModuleProviders>;\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see `RouteConfigLoadStart`\n *\n * @publicApi\n */\nexport declare class RouteConfigLoadEnd {\n    /** @docsNotRequired */\n    route: Route;\n    readonly type = EventType.RouteConfigLoadEnd;\n    constructor(\n    /** @docsNotRequired */\n    route: Route);\n    toString(): string;\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see `RouteConfigLoadEnd`\n *\n * @publicApi\n */\nexport declare class RouteConfigLoadStart {\n    /** @docsNotRequired */\n    route: Route;\n    readonly type = EventType.RouteConfigLoadStart;\n    constructor(\n    /** @docsNotRequired */\n    route: Route);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * A service that provides navigation among views and URL manipulation capabilities.\n *\n * @see `Route`.\n * @see [Routing and Navigation Guide](guide/router).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class Router {\n    private rootComponentType;\n    private urlSerializer;\n    private rootContexts;\n    private location;\n    config: Routes;\n    /**\n     * Represents the activated `UrlTree` that the `Router` is configured to handle (through\n     * `UrlHandlingStrategy`). That is, after we find the route config tree that we're going to\n     * activate, run guards, and are just about to activate the route, we set the currentUrlTree.\n     *\n     * This should match the `browserUrlTree` when a navigation succeeds. If the\n     * `UrlHandlingStrategy.shouldProcessUrl` is `false`, only the `browserUrlTree` is updated.\n     */\n    private currentUrlTree;\n    /**\n     * Meant to represent the entire browser url after a successful navigation. In the life of a\n     * navigation transition:\n     * 1. The rawUrl represents the full URL that's being navigated to\n     * 2. We apply redirects, which might only apply to _part_ of the URL (due to\n     * `UrlHandlingStrategy`).\n     * 3. Right before activation (because we assume activation will succeed), we update the\n     * rawUrlTree to be a combination of the urlAfterRedirects (again, this might only apply to part\n     * of the initial url) and the rawUrl of the transition (which was the original navigation url in\n     * its full form).\n     */\n    private rawUrlTree;\n    /**\n     * Meant to represent the part of the browser url that the `Router` is set up to handle (via the\n     * `UrlHandlingStrategy`). This value is updated immediately after the browser url is updated (or\n     * the browser url update is skipped via `skipLocationChange`). With that, note that\n     * `browserUrlTree` _may not_ reflect the actual browser URL for two reasons:\n     *\n     * 1. `UrlHandlingStrategy` only handles part of the URL\n     * 2. `skipLocationChange` does not update the browser url.\n     *\n     * So to reiterate, `browserUrlTree` only represents the Router's internal understanding of the\n     * current route, either before guards with `urlUpdateStrategy === 'eager'` or right before\n     * activation with `'deferred'`.\n     *\n     * This should match the `currentUrlTree` when the navigation succeeds.\n     */\n    private browserUrlTree;\n    private readonly transitions;\n    private navigations;\n    private lastSuccessfulNavigation;\n    private currentNavigation;\n    private disposed;\n    private locationSubscription?;\n    private navigationId;\n    /**\n     * The id of the currently active page in the router.\n     * Updated to the transition's target id on a successful navigation.\n     *\n     * This is used to track what page the router last activated. When an attempted navigation fails,\n     * the router can then use this to compute how to restore the state back to the previously active\n     * page.\n     */\n    private currentPageId;\n    /**\n     * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n     * important for computing the target page id for new navigations because we need to ensure each\n     * page id in the browser history is 1 more than the previous entry.\n     */\n    private get browserPageId();\n    private configLoader;\n    private ngModule;\n    private console;\n    private isNgZoneEnabled;\n    /**\n     * An event stream for routing events in this NgModule.\n     */\n    readonly events: Observable<Event_2>;\n    /**\n     * The current state of routing in this NgModule.\n     */\n    readonly routerState: RouterState;\n    /**\n     * A handler for navigation errors in this NgModule.\n     */\n    errorHandler: ErrorHandler;\n    /**\n     * A handler for errors thrown by `Router.parseUrl(url)`\n     * when `url` contains an invalid character.\n     * The most common case is a `%` sign\n     * that's not encoded and is not part of a percent encoded sequence.\n     */\n    malformedUriErrorHandler: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n    /**\n     * True if at least one navigation event has occurred,\n     * false otherwise.\n     */\n    navigated: boolean;\n    private lastSuccessfulId;\n    /**\n     * A strategy for extracting and merging URLs.\n     * Used for AngularJS to Angular migrations.\n     */\n    urlHandlingStrategy: UrlHandlingStrategy;\n    /**\n     * A strategy for re-using routes.\n     */\n    routeReuseStrategy: RouteReuseStrategy;\n    /**\n     * A strategy for setting the title based on the `routerState`.\n     */\n    titleStrategy?: TitleStrategy;\n    /**\n     * How to handle a navigation request to the current URL. One of:\n     *\n     * - `'ignore'` :  The router ignores the request.\n     * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n     *\n     * Note that this only configures whether the Route reprocesses the URL and triggers related\n     * action and events like redirects, guards, and resolvers. By default, the router re-uses a\n     * component instance when it re-navigates to the same component type without visiting a different\n     * component first. This behavior is configured by the `RouteReuseStrategy`. In order to reload\n     * routed components on same url navigation, you need to set `onSameUrlNavigation` to `'reload'`\n     * _and_ provide a `RouteReuseStrategy` which returns `false` for `shouldReuseRoute`.\n     */\n    onSameUrlNavigation: 'reload' | 'ignore';\n    /**\n     * How to merge parameters, data, resolved data, and title from parent to child\n     * routes. One of:\n     *\n     * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n     * for path-less or component-less routes.\n     * - `'always'` : Inherit parent parameters, data, and resolved data\n     * for all child routes.\n     */\n    paramsInheritanceStrategy: 'emptyOnly' | 'always';\n    /**\n     * Determines when the router updates the browser URL.\n     * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n     * Set to `'eager'` to update the browser URL at the beginning of navigation.\n     * You can choose to update early so that, if navigation fails,\n     * you can show an error message with the URL that failed.\n     */\n    urlUpdateStrategy: 'deferred' | 'eager';\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * @see `RouterModule`\n     *\n     * @deprecated\n     */\n    relativeLinkResolution: 'legacy' | 'corrected';\n    /**\n     * Configures how the Router attempts to restore state when a navigation is cancelled.\n     *\n     * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n     * router before the navigation started. This means that if the URL of the browser is updated\n     * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n     * than trying to restore to the previous location in the session history. This happens most\n     * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n     * buttons.\n     *\n     * 'computed' - Will attempt to return to the same index in the session history that corresponds\n     * to the Angular route when the navigation gets cancelled. For example, if the browser back\n     * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n     * and vice versa.\n     *\n     * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n     * handles a portion of the URL because the history restoration navigates to the previous place in\n     * the browser history rather than simply resetting a portion of the URL.\n     *\n     * The default value is `replace`.\n     *\n     */\n    canceledNavigationResolution: 'replace' | 'computed';\n    /**\n     * Creates the router service.\n     */\n    constructor(rootComponentType: Type<any> | null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location_2, injector: Injector, compiler: Compiler, config: Routes);\n    private setupNavigations;\n    private setTransition;\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    initialNavigation(): void;\n    /**\n     * Sets up the location change listener. This listener detects navigations triggered from outside\n     * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n     * navigation so that the correct events, guards, etc. are triggered.\n     */\n    setUpLocationChangeListener(): void;\n    /** The current URL. */\n    get url(): string;\n    /**\n     * Returns the current `Navigation` object when the router is navigating,\n     * and `null` when idle.\n     */\n    getCurrentNavigation(): Navigation | null;\n    /**\n     * Resets the route configuration used for navigation and generating links.\n     *\n     * @param config The route array for the new configuration.\n     *\n     * @usageNotes\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    resetConfig(config: Routes): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /** Disposes of the router. */\n    dispose(): void;\n    /**\n     * Appends URL segments to the current URL tree to create a new URL tree.\n     *\n     * @param commands An array of URL fragments with which to construct the new URL tree.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n     * property of the options object, if supplied.\n     * @param navigationExtras Options that control the navigation strategy.\n     * @returns The new URL tree.\n     *\n     * @usageNotes\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it,\n     * // you can do the following:\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     *\n     * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n     * tree should be created relative to the root.\n     * ```\n     */\n    createUrlTree(commands: any[], navigationExtras?: UrlCreationOptions): UrlTree;\n    /**\n     * Navigates to a view using an absolute route path.\n     *\n     * @param url An absolute path for a defined route. The function does not apply any delta to the\n     *     current URL.\n     * @param extras An object containing properties that modify the navigation strategy.\n     *\n     * @returns A Promise that resolves to 'true' when navigation succeeds,\n     * to 'false' when navigation fails, or is rejected on error.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to an absolute path.\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/router)\n     *\n     */\n    navigateByUrl(url: string | UrlTree, extras?: NavigationBehaviorOptions): Promise<boolean>;\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * @param commands An array of URL fragments with which to construct the target URL.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n     * of the options object, if supplied.\n     * @param extras An options object that determines how the URL should be constructed or\n     *     interpreted.\n     *\n     * @returns A Promise that resolves to `true` when navigation succeeds, to `false` when navigation\n     *     fails,\n     * or is rejected on error.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to a dynamic route path relative to the current URL.\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL, overriding the default behavior\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/router)\n     *\n     */\n    navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;\n    /** Serializes a `UrlTree` into a string */\n    serializeUrl(url: UrlTree): string;\n    /** Parses a string into a `UrlTree` */\n    parseUrl(url: string): UrlTree;\n    /**\n     * Returns whether the url is activated.\n     *\n     * @deprecated\n     * Use `IsActiveMatchOptions` instead.\n     *\n     * - The equivalent `IsActiveMatchOptions` for `true` is\n     * `{paths: 'exact', queryParams: 'exact', fragment: 'ignored', matrixParams: 'ignored'}`.\n     * - The equivalent for `false` is\n     * `{paths: 'subset', queryParams: 'subset', fragment: 'ignored', matrixParams: 'ignored'}`.\n     */\n    isActive(url: string | UrlTree, exact: boolean): boolean;\n    /**\n     * Returns whether the url is activated.\n     */\n    isActive(url: string | UrlTree, matchOptions: IsActiveMatchOptions): boolean;\n    private removeEmptyProps;\n    private processNavigations;\n    private scheduleNavigation;\n    private setBrowserUrl;\n    /**\n     * Performs the necessary rollback action to restore the browser URL to the\n     * state before the transition.\n     */\n    private restoreHistory;\n    private resetState;\n    private resetUrlToCurrentUrlTree;\n    private cancelNavigationTransition;\n    private generateNgRouterState;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Router, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Router>;\n}\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router service.\n *\n * @publicApi\n */\nexport declare const ROUTER_CONFIGURATION: InjectionToken<ExtraOptions>;\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\nexport declare const ROUTER_INITIALIZER: InjectionToken<(compRef: ComponentRef<any>) => void>;\n\ndeclare class RouterConfigLoader {\n    private injector;\n    private compiler;\n    private componentLoaders;\n    private childrenLoaders;\n    onLoadStartListener?: (r: Route) => void;\n    onLoadEndListener?: (r: Route) => void;\n    constructor(injector: Injector, compiler: Compiler);\n    loadComponent(route: Route): Observable<Type<unknown>>;\n    loadChildren(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig>;\n    private loadModuleFactoryOrRoutes;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterConfigLoader, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<RouterConfigLoader>;\n}\n\n/**\n * Extra configuration options that can be used with the `withRouterConfig` function.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare interface RouterConfigOptions {\n    /**\n     * Configures how the Router attempts to restore state when a navigation is cancelled.\n     *\n     * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n     * router before the navigation started. This means that if the URL of the browser is updated\n     * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n     * than trying to restore to the previous location in the session history. This happens most\n     * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n     * buttons.\n     *\n     * 'computed' - Will attempt to return to the same index in the session history that corresponds\n     * to the Angular route when the navigation gets cancelled. For example, if the browser back\n     * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n     * and vice versa.\n     *\n     * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n     * handles a portion of the URL because the history restoration navigates to the previous place in\n     * the browser history rather than simply resetting a portion of the URL.\n     *\n     * The default value is `replace` when not set.\n     */\n    canceledNavigationResolution?: 'replace' | 'computed';\n    /**\n     * Define what the router should do if it receives a navigation request to the current URL.\n     * Default is `ignore`, which causes the router ignores the navigation.\n     * This can disable features such as a \"refresh\" button.\n     * Use this option to configure the behavior when navigating to the\n     * current URL. Default is 'ignore'.\n     */\n    onSameUrlNavigation?: 'reload' | 'ignore';\n    /**\n     * Defines how the router merges parameters, data, and resolved data from parent to child\n     * routes. By default ('emptyOnly'), inherits parent parameters only for\n     * path-less or component-less routes.\n     *\n     * Set to 'always' to enable unconditional inheritance of parent parameters.\n     *\n     * Note that when dealing with matrix parameters, \"parent\" refers to the parent `Route`\n     * config which does not necessarily mean the \"URL segment to the left\". When the `Route` `path`\n     * contains multiple segments, the matrix parameters must appear on the last segment. For example,\n     * matrix parameters for `{path: 'a/b', component: MyComp}` should appear as `a/b;foo=bar` and not\n     * `a;foo=bar/b`.\n     *\n     */\n    paramsInheritanceStrategy?: 'emptyOnly' | 'always';\n    /**\n     * Defines when the router updates the browser URL. By default ('deferred'),\n     * update after successful navigation.\n     * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n     * Updating the URL early allows you to handle a failure of navigation by\n     * showing an error message with the URL that failed.\n     */\n    urlUpdateStrategy?: 'deferred' | 'eager';\n}\n\n/**\n * A type alias for providers returned by `withRouterConfig` for use with `provideRouter`.\n *\n * @see `withRouterConfig`\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type RouterConfigurationFeature = RouterFeature<RouterFeatureKind.RouterConfigurationFeature>;\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\nexport declare abstract class RouteReuseStrategy {\n    /** Determines if this route (and its subtree) should be detached to be reused later */\n    abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n    /**\n     * Stores the detached route.\n     *\n     * Storing a `null` value should erase the previously stored value.\n     */\n    abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\n    /** Determines if this route (and its subtree) should be reattached */\n    abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n    /** Retrieves the previously stored route */\n    abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n    /** Determines if a route should be reused */\n    abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * @see [Router events summary](guide/router-reference#router-events)\n * @publicApi\n */\nexport declare class RouterEvent {\n    /** A unique ID that the router assigns to every router navigation. */\n    id: number;\n    /** The URL that is the destination for this navigation. */\n    url: string;\n    constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    id: number, \n    /** The URL that is the destination for this navigation. */\n    url: string);\n}\n\n/**\n * Helper type to represent a Router feature.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare interface RouterFeature<FeatureKind extends RouterFeatureKind> {\n    ɵkind: FeatureKind;\n    ɵproviders: Provider[];\n}\n\n/**\n * The list of features as an enum to uniquely type each feature.\n */\ndeclare const enum RouterFeatureKind {\n    PreloadingFeature = 0,\n    DebugTracingFeature = 1,\n    EnabledBlockingInitialNavigationFeature = 2,\n    DisabledInitialNavigationFeature = 3,\n    InMemoryScrollingFeature = 4,\n    RouterConfigurationFeature = 5\n}\n\n/**\n * A type alias that represents all Router features available for use with `provideRouter`.\n * Features can be enabled by adding special functions to the `provideRouter` call.\n * See documentation for each symbol to find corresponding function name. See also `provideRouter`\n * documentation on how to use those functions.\n *\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n */\nexport declare type RouterFeatures = PreloadingFeature | DebugTracingFeature | InitialNavigationFeature | InMemoryScrollingFeature | RouterConfigurationFeature;\n\n/**\n * @description\n *\n * When applied to an element in a template, makes that element a link\n * that initiates navigation to a route. Navigation opens one or more routed components\n * in one or more `<router-outlet>` locations on the page.\n *\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\n * the following creates a static link to the route:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * You can use dynamic values to generate the link.\n * For a dynamic link, pass an array of path segments,\n * followed by the params for each segment.\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\n * generates a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one term and combined with dynamic segments.\n * For example, `['/team/11/user', userName, {details: true}]`\n *\n * The input that you provide to the link is treated as a delta to the current URL.\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\n * `/user/(jim//aux:team)`.\n * See {@link Router#createUrlTree createUrlTree} for more information.\n *\n * @usageNotes\n *\n * You can use absolute or relative paths in a link, set query parameters,\n * control how parameters are handled, and keep a history of navigation states.\n *\n * ### Relative link paths\n *\n * The first segment name can be prepended with `/`, `./`, or `../`.\n * * If the first segment begins with `/`, the router looks up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\n *   looks in the children of the current activated route.\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\n *\n * ### Setting and handling query params and fragments\n *\n * The following link adds a query parameter and a fragment to the generated URL:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * By default, the directive constructs the new URL using the given query parameters.\n * The example generates the link: `/user/bob?debug=true#education`.\n *\n * You can instruct the directive to handle query parameters differently\n * by specifying the `queryParamsHandling` option in the link.\n * Allowed values are:\n *\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\n *  - `'preserve'`: Preserve the current query params.\n *\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * See {@link UrlCreationOptions.queryParamsHandling UrlCreationOptions#queryParamsHandling}.\n *\n * ### Preserving navigation history\n *\n * You can provide a `state` value to be persisted to the browser's\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * Use {@link Router.getCurrentNavigation() Router#getCurrentNavigation} to retrieve a saved\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\n * event:\n *\n * ```\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLink implements OnChanges {\n    private router;\n    private route;\n    private readonly tabIndexAttribute;\n    private readonly renderer;\n    private readonly el;\n    private _preserveFragment;\n    private _skipLocationChange;\n    private _replaceUrl;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#queryParams UrlCreationOptions#queryParams}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParams?: Params | null;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#fragment UrlCreationOptions#fragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    fragment?: string;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#queryParamsHandling UrlCreationOptions#queryParamsHandling}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParamsHandling?: QueryParamsHandling | null;\n    /**\n     * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#state NavigationBehaviorOptions#state}\n     * @see {@link Router#navigateByUrl Router#navigateByUrl}\n     */\n    state?: {\n        [k: string]: any;\n    };\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * Specify a value here when you do not want to use the default value\n     * for `routerLink`, which is the current activated route.\n     * Note that a value of `undefined` here will use the `routerLink` default.\n     * @see {@link UrlCreationOptions#relativeTo UrlCreationOptions#relativeTo}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    relativeTo?: ActivatedRoute | null;\n    private commands;\n    constructor(router: Router, route: ActivatedRoute, tabIndexAttribute: string | null | undefined, renderer: Renderer2, el: ElementRef);\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#preserveFragment UrlCreationOptions#preserveFragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    set preserveFragment(preserveFragment: boolean | string | null | undefined);\n    get preserveFragment(): boolean;\n    /**\n     * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#skipLocationChange NavigationBehaviorOptions#skipLocationChange}\n     * @see {@link Router#navigateByUrl Router#navigateByUrl}\n     */\n    set skipLocationChange(skipLocationChange: boolean | string | null | undefined);\n    get skipLocationChange(): boolean;\n    /**\n     * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#replaceUrl NavigationBehaviorOptions#replaceUrl}\n     * @see {@link Router#navigateByUrl Router#navigateByUrl}\n     */\n    set replaceUrl(replaceUrl: boolean | string | null | undefined);\n    get replaceUrl(): boolean;\n    /**\n     * Modifies the tab index if there was not a tabindex attribute on the element during\n     * instantiation.\n     */\n    private setTabIndexIfNotOnNativeEl;\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n     *   - **null|undefined**: effectively disables the `routerLink`\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    set routerLink(commands: any[] | string | null | undefined);\n    /** @nodoc */\n    onClick(): boolean;\n    get urlTree(): UrlTree | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterLink, [null, null, { attribute: \"tabindex\"; }, null, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<RouterLink, \":not(a):not(area)[routerLink]\", never, { \"queryParams\": \"queryParams\"; \"fragment\": \"fragment\"; \"queryParamsHandling\": \"queryParamsHandling\"; \"state\": \"state\"; \"relativeTo\": \"relativeTo\"; \"preserveFragment\": \"preserveFragment\"; \"skipLocationChange\": \"skipLocationChange\"; \"replaceUrl\": \"replaceUrl\"; \"routerLink\": \"routerLink\"; }, {}, never, never, true>;\n}\n\n/**\n *\n * @description\n *\n * Tracks whether the linked route of an element is currently active, and allows you\n * to specify one or more CSS classes to add to the element when the linked route\n * is active.\n *\n * Use this directive to create a visual distinction for elements associated with an active route.\n * For example, the following code highlights the word \"Bob\" when the router\n * activates the associated route:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\n * added to the anchor tag. If the URL changes, the class is removed.\n *\n * You can set more than one class using a space-separated string or an array.\n * For example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\n * instance to a template variable.\n * For example, the following checks the status without assigning any CSS classes:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\n * For example, the following sets the active-link class on the `<div>`  parent tag\n * when the URL is either '/user/jim' or '/user/bob'.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * The `RouterLinkActive` directive can also be used to set the aria-current attribute\n * to provide an alternative distinction for active elements to visually impaired users.\n *\n * For example, the following code adds the 'active' class to the Home Page link when it is\n * indeed active and in such case also sets its aria-current attribute to 'page':\n *\n * ```\n * <a routerLink=\"/\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Home Page</a>\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {\n    private router;\n    private element;\n    private renderer;\n    private readonly cdr;\n    private link?;\n    private linkWithHref?;\n    links: QueryList<RouterLink>;\n    linksWithHrefs: QueryList<RouterLinkWithHref>;\n    private classes;\n    private routerEventsSubscription;\n    private linkInputChangesSubscription?;\n    readonly isActive: boolean;\n    /**\n     * Options to configure how to determine if the router link is active.\n     *\n     * These options are passed to the `Router.isActive()` function.\n     *\n     * @see Router.isActive\n     */\n    routerLinkActiveOptions: {\n        exact: boolean;\n    } | IsActiveMatchOptions;\n    /**\n     * Aria-current attribute to apply when the router link is active.\n     *\n     * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}\n     */\n    ariaCurrentWhenActive?: 'page' | 'step' | 'location' | 'date' | 'time' | true | false;\n    /**\n     *\n     * You can use the output `isActiveChange` to get notified each time the link becomes\n     * active or inactive.\n     *\n     * Emits:\n     * true  -> Route is active\n     * false -> Route is inactive\n     *\n     * ```\n     * <a\n     *  routerLink=\"/user/bob\"\n     *  routerLinkActive=\"active-link\"\n     *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\n     * ```\n     */\n    readonly isActiveChange: EventEmitter<boolean>;\n    constructor(router: Router, element: ElementRef, renderer: Renderer2, cdr: ChangeDetectorRef, link?: RouterLink | undefined, linkWithHref?: RouterLinkWithHref | undefined);\n    /** @nodoc */\n    ngAfterContentInit(): void;\n    private subscribeToEachLinkOnChanges;\n    set routerLinkActive(data: string[] | string);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    private update;\n    private isLinkActive;\n    private hasActiveLinks;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterLinkActive, [null, null, null, null, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<RouterLinkActive, \"[routerLinkActive]\", [\"routerLinkActive\"], { \"routerLinkActiveOptions\": \"routerLinkActiveOptions\"; \"ariaCurrentWhenActive\": \"ariaCurrentWhenActive\"; \"routerLinkActive\": \"routerLinkActive\"; }, { \"isActiveChange\": \"isActiveChange\"; }, [\"links\", \"linksWithHrefs\"], never, true>;\n}\n\n/**\n * @description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLinkWithHref implements OnChanges, OnDestroy {\n    private router;\n    private route;\n    private locationStrategy;\n    private _preserveFragment;\n    private _skipLocationChange;\n    private _replaceUrl;\n    target: string;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#queryParams UrlCreationOptions#queryParams}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParams?: Params | null;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#fragment UrlCreationOptions#fragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    fragment?: string;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#queryParamsHandling UrlCreationOptions#queryParamsHandling}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParamsHandling?: QueryParamsHandling | null;\n    /**\n     * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#state NavigationBehaviorOptions#state}\n     * @see {@link Router#navigateByUrl Router#navigateByUrl}\n     */\n    state?: {\n        [k: string]: any;\n    };\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * Specify a value here when you do not want to use the default value\n     * for `routerLink`, which is the current activated route.\n     * Note that a value of `undefined` here will use the `routerLink` default.\n     * @see {@link UrlCreationOptions#relativeTo UrlCreationOptions#relativeTo}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    relativeTo?: ActivatedRoute | null;\n    private commands;\n    private subscription;\n    href: string | null;\n    constructor(router: Router, route: ActivatedRoute, locationStrategy: LocationStrategy);\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#preserveFragment UrlCreationOptions#preserveFragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    set preserveFragment(preserveFragment: boolean | string | null | undefined);\n    get preserveFragment(): boolean;\n    /**\n     * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#skipLocationChange NavigationBehaviorOptions#skipLocationChange}\n     * @see {@link Router#navigateByUrl Router#navigateByUrl}\n     */\n    set skipLocationChange(skipLocationChange: boolean | string | null | undefined);\n    get skipLocationChange(): boolean;\n    /**\n     * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#replaceUrl NavigationBehaviorOptions#replaceUrl}\n     * @see {@link Router#navigateByUrl Router#navigateByUrl}\n     */\n    set replaceUrl(replaceUrl: boolean | string | null | undefined);\n    get replaceUrl(): boolean;\n    /**\n     * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n     *   - **null|undefined**: Disables the link by removing the `href`\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    set routerLink(commands: any[] | string | null | undefined);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): any;\n    /** @nodoc */\n    ngOnDestroy(): any;\n    /** @nodoc */\n    onClick(button: number, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean): boolean;\n    private updateTargetUrlAndHref;\n    get urlTree(): UrlTree | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterLinkWithHref, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<RouterLinkWithHref, \"a[routerLink],area[routerLink]\", never, { \"target\": \"target\"; \"queryParams\": \"queryParams\"; \"fragment\": \"fragment\"; \"queryParamsHandling\": \"queryParamsHandling\"; \"state\": \"state\"; \"relativeTo\": \"relativeTo\"; \"preserveFragment\": \"preserveFragment\"; \"skipLocationChange\": \"skipLocationChange\"; \"replaceUrl\": \"replaceUrl\"; \"routerLink\": \"routerLink\"; }, {}, never, never, true>;\n}\n\n/**\n * @description\n *\n * Adds directives and providers for in-app navigation among views defined in an application.\n * Use the Angular `Router` service to declaratively specify application states and manage state\n * transitions.\n *\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\n * However, only one `Router` service can be active.\n * To ensure this, there are two ways to register routes when importing this module:\n *\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\n * routes, and the `Router` service itself.\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\n * routes, but does not include the `Router` service.\n *\n * @see [Routing and Navigation guide](guide/router) for an\n * overview of how the `Router` service should be used.\n *\n * @publicApi\n */\nexport declare class RouterModule {\n    constructor(guard: any);\n    /**\n     * Creates and configures a module with all the router providers and directives.\n     * Optionally sets up an application listener to perform an initial navigation.\n     *\n     * When registering the NgModule at the root, import as follows:\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forRoot(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the application.\n     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n     * @return The new `NgModule`.\n     *\n     */\n    static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule>;\n    /**\n     * Creates a module with all the router directives and a provider registering routes,\n     * without creating a new Router service.\n     * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forChild(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the submodule.\n     * @return The new NgModule.\n     *\n     */\n    static forChild(routes: Routes): ModuleWithProviders<RouterModule>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterModule, [{ optional: true; }]>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<RouterModule, never, [typeof i1.RouterOutlet, typeof i2.RouterLink, typeof i2.RouterLinkWithHref, typeof i3.RouterLinkActive, typeof i4.ɵEmptyOutletComponent], [typeof i1.RouterOutlet, typeof i2.RouterLink, typeof i2.RouterLinkWithHref, typeof i3.RouterLinkActive, typeof i4.ɵEmptyOutletComponent]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<RouterModule>;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see [Routing tutorial](guide/router-tutorial-toh#named-outlets \"Example of a named\n * outlet and secondary route configuration\").\n * @see `RouterLink`\n * @see `Route`\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {\n    private parentContexts;\n    private location;\n    private changeDetector;\n    private environmentInjector;\n    private activated;\n    private _activatedRoute;\n    private name;\n    activateEvents: EventEmitter<any>;\n    deactivateEvents: EventEmitter<any>;\n    /**\n     * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n     * previously detached subtree.\n     **/\n    attachEvents: EventEmitter<unknown>;\n    /**\n     * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n     * subtree.\n     */\n    detachEvents: EventEmitter<unknown>;\n    constructor(parentContexts: ChildrenOutletContexts, location: ViewContainerRef, name: string, changeDetector: ChangeDetectorRef, environmentInjector: EnvironmentInjector);\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /** @nodoc */\n    ngOnInit(): void;\n    get isActivated(): boolean;\n    /**\n     * @returns The currently activated component instance.\n     * @throws An error if the outlet is not activated.\n     */\n    get component(): Object;\n    get activatedRoute(): ActivatedRoute;\n    get activatedRouteData(): Data;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach(): ComponentRef<any>;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void;\n    deactivate(): void;\n    activateWith(activatedRoute: ActivatedRoute, resolverOrInjector?: ComponentFactoryResolver | EnvironmentInjector | null): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterOutlet, [null, null, { attribute: \"name\"; }, null, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<RouterOutlet, \"router-outlet\", [\"outlet\"], {}, { \"activateEvents\": \"activate\"; \"deactivateEvents\": \"deactivate\"; \"attachEvents\": \"attach\"; \"detachEvents\": \"detach\"; }, never, never, true>;\n}\n\n/**\n * An interface that defines the contract for developing a component outlet for the `Router`.\n *\n * An outlet acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * A router outlet should register itself with the `Router` via\n * `ChildrenOutletContexts#onChildOutletCreated` and unregister with\n * `ChildrenOutletContexts#onChildOutletDestroyed`. When the `Router` identifies a matched `Route`,\n * it looks for a registered outlet in the `ChildrenOutletContexts` and activates it.\n *\n * @see `ChildrenOutletContexts`\n * @publicApi\n */\nexport declare interface RouterOutletContract {\n    /**\n     * Whether the given outlet is activated.\n     *\n     * An outlet is considered \"activated\" if it has an active component.\n     */\n    isActivated: boolean;\n    /** The instance of the activated component or `null` if the outlet is not activated. */\n    component: Object | null;\n    /**\n     * The `Data` of the `ActivatedRoute` snapshot.\n     */\n    activatedRouteData: Data;\n    /**\n     * The `ActivatedRoute` for the outlet or `null` if the outlet is not activated.\n     */\n    activatedRoute: ActivatedRoute | null;\n    /**\n     * Called by the `Router` when the outlet should activate (create a component).\n     */\n    activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector | null): void;\n    /**\n     * Called by the `Router` when the outlet should activate (create a component).\n     *\n     * @deprecated Passing a resolver to retrieve a component factory is not required and is\n     *     deprecated since v14.\n     */\n    activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null): void;\n    /**\n     * A request to destroy the currently activated component.\n     *\n     * When a `RouteReuseStrategy` indicates that an `ActivatedRoute` should be removed but stored for\n     * later re-use rather than destroyed, the `Router` will call `detach` instead.\n     */\n    deactivate(): void;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree.\n     *\n     * This is similar to `deactivate`, but the activated component should _not_ be destroyed.\n     * Instead, it is returned so that it can be reattached later via the `attach` method.\n     */\n    detach(): ComponentRef<unknown>;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree.\n     */\n    attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;\n    /**\n     * Emits an activate event when a new component is instantiated\n     **/\n    activateEvents?: EventEmitter<unknown>;\n    /**\n     * Emits a deactivate event when a component is destroyed.\n     */\n    deactivateEvents?: EventEmitter<unknown>;\n    /**\n     * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n     * previously detached subtree.\n     **/\n    attachEvents?: EventEmitter<unknown>;\n    /**\n     * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n     * subtree.\n     */\n    detachEvents?: EventEmitter<unknown>;\n}\n\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\nexport declare class RouterPreloader implements OnDestroy {\n    private router;\n    private injector;\n    private preloadingStrategy;\n    private loader;\n    private subscription?;\n    constructor(router: Router, compiler: Compiler, injector: EnvironmentInjector, preloadingStrategy: PreloadingStrategy, loader: RouterConfigLoader);\n    setUpPreloading(): void;\n    preload(): Observable<any>;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    private processRoutes;\n    private preloadConfig;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterPreloader, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<RouterPreloader>;\n}\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see `ActivatedRoute`\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport declare class RouterState extends Tree<ActivatedRoute> {\n    /** The current snapshot of the router state */\n    snapshot: RouterStateSnapshot;\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {\n    /** The url from which this snapshot was created */\n    url: string;\n    toString(): string;\n}\n\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `RouterModule.forChild()`, `provideRoutes`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nexport declare const ROUTES: InjectionToken<Route[][]>;\n\n/**\n * Represents a route configuration for the Router service.\n * An array of `Route` objects, used in `Router.config` and for nested route configurations\n * in `Route.children`.\n *\n * @see `Route`\n * @see `Router`\n * @see [Router configuration guide](guide/router-reference#configuration)\n * @publicApi\n */\nexport declare type Routes = Route[];\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport declare class RoutesRecognized extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    readonly type = EventType.RoutesRecognized;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * A policy for when to run guards and resolvers on a route.\n *\n * Guards and/or resolvers will always run when a route is activated or deactivated. When a route is\n * unchanged, the default behavior is the same as `paramsChange`.\n *\n * `paramsChange` : Rerun the guards and resolvers when path or\n * path param changes. This does not include query parameters. This option is the default.\n * - `always` : Run on every execution.\n * - `pathParamsChange` : Rerun guards and resolvers when the path params\n * change. This does not compare matrix or query parameters.\n * - `paramsOrQueryParamsChange` : Run when path, matrix, or query parameters change.\n * - `pathParamsOrQueryParamsChange` : Rerun guards and resolvers when the path params\n * change or query params have changed. This does not include matrix parameters.\n *\n * @see [Route.runGuardsAndResolvers](api/router/Route#runGuardsAndResolvers)\n * @publicApi\n */\nexport declare type RunGuardsAndResolvers = 'pathParamsChange' | 'pathParamsOrQueryParamsChange' | 'paramsChange' | 'paramsOrQueryParamsChange' | 'always' | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport declare class Scroll {\n    /** @docsNotRequired */\n    readonly routerEvent: NavigationEnd;\n    /** @docsNotRequired */\n    readonly position: [number, number] | null;\n    /** @docsNotRequired */\n    readonly anchor: string | null;\n    readonly type = EventType.Scroll;\n    constructor(\n    /** @docsNotRequired */\n    routerEvent: NavigationEnd, \n    /** @docsNotRequired */\n    position: [number, number] | null, \n    /** @docsNotRequired */\n    anchor: string | null);\n    toString(): string;\n}\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/router#setting-the-page-title)\n */\nexport declare abstract class TitleStrategy {\n    /** Performs the application title update. */\n    abstract updateTitle(snapshot: RouterStateSnapshot): void;\n    /**\n     * @returns The `title` of the deepest primary route.\n     */\n    buildTitle(snapshot: RouterStateSnapshot): string | undefined;\n    /**\n     * Given an `ActivatedRouteSnapshot`, returns the final value of the\n     * `Route.title` property, which can either be a static string or a resolved value.\n     */\n    getResolvedTitleForRoute(snapshot: ActivatedRouteSnapshot): any;\n    static ɵfac: i0.ɵɵFactoryDeclaration<TitleStrategy, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<TitleStrategy>;\n}\n\n\ndeclare class Tree<T> {\n    constructor(root: TreeNode<T>);\n    get root(): T;\n}\n\ndeclare class TreeNode<T> {\n    value: T;\n    children: TreeNode<T>[];\n    constructor(value: T, children: TreeNode<T>[]);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` URL.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed.\n *\n * @see [Router.navigate() method](api/router/Router#navigate)\n * @see [Router.createUrlTree() method](api/router/Router#createurltree)\n * @see [Routing and Navigation guide](guide/router)\n *\n * @publicApi\n */\nexport declare interface UrlCreationOptions {\n    /**\n     * Specifies a root URI to use for relative navigation.\n     *\n     * For example, consider the following route configuration where the parent route\n     * has two children.\n     *\n     * ```\n     * [{\n     *   path: 'parent',\n     *   component: ParentComponent,\n     *   children: [{\n     *     path: 'list',\n     *     component: ListComponent\n     *   },{\n     *     path: 'child',\n     *     component: ChildComponent\n     *   }]\n     * }]\n     * ```\n     *\n     * The following `go()` function navigates to the `list` route by\n     * interpreting the destination URI as relative to the activated `child`  route\n     *\n     * ```\n     *  @Component({...})\n     *  class ChildComponent {\n     *    constructor(private router: Router, private route: ActivatedRoute) {}\n     *\n     *    go() {\n     *      this.router.navigate(['../list'], { relativeTo: this.route });\n     *    }\n     *  }\n     * ```\n     *\n     * A value of `null` or `undefined` indicates that the navigation commands should be applied\n     * relative to the root.\n     */\n    relativeTo?: ActivatedRoute | null;\n    /**\n     * Sets query parameters to the URL.\n     *\n     * ```\n     * // Navigate to /results?page=1\n     * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n     * ```\n     */\n    queryParams?: Params | null;\n    /**\n     * Sets the hash fragment for the URL.\n     *\n     * ```\n     * // Navigate to /results#top\n     * this.router.navigate(['/results'], { fragment: 'top' });\n     * ```\n     */\n    fragment?: string;\n    /**\n     * How to handle query parameters in the router link for the next navigation.\n     * One of:\n     * * `preserve` : Preserve current parameters.\n     * * `merge` : Merge new with current parameters.\n     *\n     * The \"preserve\" option discards any new query params:\n     * ```\n     * // from /view1?page=1 to/view2?page=1\n     * this.router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\n     * });\n     * ```\n     * The \"merge\" option appends new query params to the params from the current URL:\n     * ```\n     * // from /view1?page=1 to/view2?page=1&otherKey=2\n     * this.router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\n     * });\n     * ```\n     * In case of a key collision between current parameters and those in the `queryParams` object,\n     * the new value is used.\n     *\n     */\n    queryParamsHandling?: QueryParamsHandling | null;\n    /**\n     * When true, preserves the URL fragment for the next navigation\n     *\n     * ```\n     * // Preserve fragment from /results#top to /view#top\n     * this.router.navigate(['/view'], { preserveFragment: true });\n     * ```\n     */\n    preserveFragment?: boolean;\n}\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\nexport declare abstract class UrlHandlingStrategy {\n    /**\n     * Tells the router if this URL should be processed.\n     *\n     * When it returns true, the router will execute the regular navigation.\n     * When it returns false, the router will set the router state to an empty state.\n     * As a result, all the active components will be destroyed.\n     *\n     */\n    abstract shouldProcessUrl(url: UrlTree): boolean;\n    /**\n     * Extracts the part of the URL that should be handled by the router.\n     * The rest of the URL will remain untouched.\n     */\n    abstract extract(url: UrlTree): UrlTree;\n    /**\n     * Merges the URL fragment with the rest of the URL.\n     */\n    abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * A function for matching a route against URLs. Implement a custom URL matcher\n * for `Route.matcher` when a combination of `path` and `pathMatch`\n * is not expressive enough. Cannot be used together with `path` and `pathMatch`.\n *\n * The function takes the following arguments and returns a `UrlMatchResult` object.\n * * *segments* : An array of URL segments.\n * * *group* : A segment group.\n * * *route* : The route to match against.\n *\n * The following example implementation matches HTML files.\n *\n * ```\n * export function htmlFiles(url: UrlSegment[]) {\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\n * ```\n *\n * @publicApi\n */\nexport declare type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult | null;\n\n/**\n * Represents the result of matching URLs with a custom matching function.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @see `UrlMatcher()`\n * @publicApi\n */\nexport declare type UrlMatchResult = {\n    consumed: UrlSegment[];\n    posParams?: {\n        [name: string]: UrlSegment;\n    };\n};\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class UrlSegment {\n    /** The path part of a URL segment */\n    path: string;\n    /** The matrix parameters associated with a segment */\n    parameters: {\n        [name: string]: string;\n    };\n    constructor(\n    /** The path part of a URL segment */\n    path: string, \n    /** The matrix parameters associated with a segment */\n    parameters: {\n        [name: string]: string;\n    });\n    get parameterMap(): ParamMap;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport declare class UrlSegmentGroup {\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments: UrlSegment[];\n    /** The list of children of this group */\n    children: {\n        [key: string]: UrlSegmentGroup;\n    };\n    /** The parent node in the url tree */\n    parent: UrlSegmentGroup | null;\n    constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments: UrlSegment[], \n    /** The list of children of this group */\n    children: {\n        [key: string]: UrlSegmentGroup;\n    });\n    /** Whether the segment has child segments */\n    hasChildren(): boolean;\n    /** Number of child segments */\n    get numberOfChildren(): number;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\nexport declare abstract class UrlSerializer {\n    /** Parse a url into a `UrlTree` */\n    abstract parse(url: string): UrlTree;\n    /** Converts a `UrlTree` into a url */\n    abstract serialize(tree: UrlTree): string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<UrlSerializer, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<UrlSerializer>;\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class UrlTree {\n    /** The root segment group of the URL tree */\n    root: UrlSegmentGroup;\n    /** The query params of the URL */\n    queryParams: Params;\n    /** The fragment of the URL */\n    fragment: string | null;\n    get queryParamMap(): ParamMap;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\n/**\n * Enables logging of all internal navigation events to the console.\n * Extra logging might be useful for debugging purposes to inspect Router event sequence.\n *\n * @usageNotes\n *\n * Basic example of how you can enable debug tracing:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDebugTracing())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function withDebugTracing(): DebugTracingFeature;\n\n/**\n * Disables initial navigation.\n *\n * Use if there is a reason to have more control over when the router starts its initial navigation\n * due to some complex initialization logic.\n *\n * @usageNotes\n *\n * Basic example of how you can disable initial navigation:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDisabledInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function withDisabledInitialNavigation(): DisabledInitialNavigationFeature;\n\n/**\n * Configures initial navigation to start before the root component is created.\n *\n * The bootstrap is blocked until the initial navigation is complete. This value is required for\n * [server-side rendering](guide/universal) to work.\n *\n * @usageNotes\n *\n * Basic example of how you can enable this navigation behavior:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withEnabledBlockingInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n * @returns A set of providers for use with `provideRouter`.\n */\nexport declare function withEnabledBlockingInitialNavigation(): EnabledBlockingInitialNavigationFeature;\n\n/**\n * Enables customizable scrolling behavior for router navigations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable scrolling feature:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withInMemoryScrolling())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n * @see `ViewportScroller`\n *\n * @publicApi\n * @developerPreview\n * @param options Set of configuration parameters to customize scrolling behavior, see\n *     `InMemoryScrollingOptions` for additional information.\n * @returns A set of providers for use with `provideRouter`.\n */\nexport declare function withInMemoryScrolling(options?: InMemoryScrollingOptions): InMemoryScrollingFeature;\n\n/**\n * Allows to configure a preloading strategy to use. The strategy is configured by providing a\n * reference to a class that implements a `PreloadingStrategy`.\n *\n * @usageNotes\n *\n * Basic example of how you can configure preloading:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withPreloading(PreloadAllModules))\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @param preloadingStrategy A reference to a class that implements a `PreloadingStrategy` that\n *     should be used.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\ndeclare function withPreloading(preloadingStrategy: Type<PreloadingStrategy>): PreloadingFeature;\nexport { withPreloading }\nexport { withPreloading as ɵwithPreloading }\n\n/**\n * Allows to provide extra parameters to configure Router.\n *\n * @usageNotes\n *\n * Basic example of how you can provide extra configuration options:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withRouterConfig({\n *          onSameUrlNavigation: 'reload'\n *       }))\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @param options A set of parameters to configure Router, see `RouterConfigOptions` for\n *     additional information.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\nexport declare function withRouterConfig(options: RouterConfigOptions): RouterConfigurationFeature;\n\nexport declare function ɵassignExtraOptionsToRouter(opts: ExtraOptions, router: Router): void;\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\nexport declare class ɵEmptyOutletComponent {\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵEmptyOutletComponent, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<ɵEmptyOutletComponent, \"ng-component\", never, {}, {}, never, never, true>;\n}\n\n/**\n * Flattens single-level nested arrays.\n */\nexport declare function ɵflatten<T>(arr: T[][]): T[];\n\nexport declare type ɵRestoredState = {\n    [k: string]: any;\n    navigationId: number;\n    ɵrouterPageId?: number;\n};\n\nexport declare const ɵROUTER_PROVIDERS: Provider[];\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/router/testing/index.d.ts",
      "node_modules/@angular/router/testing/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { ChildrenOutletContexts } from '@angular/router';\nimport { Compiler } from '@angular/core';\nimport { ExtraOptions } from '@angular/router';\nimport * as i0 from '@angular/core';\nimport * as i1 from '@angular/router';\nimport { Injector } from '@angular/core';\nimport { Location as Location_2 } from '@angular/common';\nimport { ModuleWithProviders } from '@angular/core';\nimport { Route } from '@angular/router';\nimport { Router } from '@angular/router';\nimport { RouteReuseStrategy } from '@angular/router';\nimport { Routes } from '@angular/router';\nimport { TitleStrategy } from '@angular/router';\nimport { UrlHandlingStrategy } from '@angular/router';\nimport { UrlSerializer } from '@angular/router';\n\n/**\n * @description\n *\n * Sets up the router to be used for testing.\n *\n * The modules sets up the router to be used for testing.\n * It provides spy implementations of `Location` and `LocationStrategy`.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * beforeEach(() => {\n *   TestBed.configureTestingModule({\n *     imports: [\n *       RouterTestingModule.withRoutes(\n *         [{path: '', component: BlankCmp}, {path: 'simple', component: SimpleCmp}]\n *       )\n *     ]\n *   });\n * });\n * ```\n *\n * @publicApi\n */\nexport declare class RouterTestingModule {\n    static withRoutes(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterTestingModule>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RouterTestingModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<RouterTestingModule, never, never, [typeof i1.RouterModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<RouterTestingModule>;\n}\n\n/**\n * Router setup factory function used for testing.\n *\n * @publicApi\n */\nexport declare function setupTestingRouter(urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts, location: Location_2, compiler: Compiler, injector: Injector, routes: Route[][], opts?: ExtraOptions | UrlHandlingStrategy | null, urlHandlingStrategy?: UrlHandlingStrategy, routeReuseStrategy?: RouteReuseStrategy, titleStrategy?: TitleStrategy): Router;\n\n/**\n * Router setup factory function used for testing. Only used internally to keep the factory that's\n * marked as publicApi cleaner (i.e. not having _both_ `TitleStrategy` and `DefaultTitleStrategy`).\n */\nexport declare function setupTestingRouterInternal(urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts, location: Location_2, compiler: Compiler, injector: Injector, routes: Route[][], titleStrategy: TitleStrategy, opts?: ExtraOptions | UrlHandlingStrategy, urlHandlingStrategy?: UrlHandlingStrategy, routeReuseStrategy?: RouteReuseStrategy): Router;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/router/upgrade/index.d.ts",
      "node_modules/@angular/router/upgrade/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { ComponentRef } from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { UpgradeModule } from '@angular/upgrade/static';\n\n/**\n * Creates an initializer that sets up `ngRoute` integration\n * along with setting up the Angular router.\n *\n * @usageNotes\n *\n * <code-example language=\"typescript\">\n * @NgModule({\n *  imports: [\n *   RouterModule.forRoot(SOME_ROUTES),\n *   UpgradeModule\n * ],\n * providers: [\n *   RouterUpgradeInitializer\n * ]\n * })\n * export class AppModule {\n *   ngDoBootstrap() {}\n * }\n * </code-example>\n *\n * @publicApi\n */\nexport declare const RouterUpgradeInitializer: {\n    provide: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\n    multi: boolean;\n    useFactory: (ngUpgrade: UpgradeModule) => () => void;\n    deps: (typeof UpgradeModule)[];\n};\n\n/**\n * Sets up a location change listener to trigger `history.pushState`.\n * Works around the problem that `onPopState` does not trigger `history.pushState`.\n * Must be called *after* calling `UpgradeModule.bootstrap`.\n *\n * @param ngUpgrade The upgrade NgModule.\n * @param urlType The location strategy.\n * @see `HashLocationStrategy`\n * @see `PathLocationStrategy`\n *\n * @publicApi\n */\nexport declare function setUpLocationSync(ngUpgrade: UpgradeModule, urlType?: 'path' | 'hash'): void;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/a11y/index.d.ts",
      "node_modules/@angular/cdk/a11y/index.d.ts"
    ],
    "content": "import { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ContentObserver } from '@angular/cdk/observers';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i4 from '@angular/cdk/observers';\nimport { InjectionToken } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nexport declare class A11yModule {\n    constructor(highContrastModeDetector: HighContrastModeDetector);\n    static ɵfac: i0.ɵɵFactoryDeclaration<A11yModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<A11yModule, [typeof i1.CdkAriaLive, typeof i2.CdkTrapFocus, typeof i3.CdkMonitorFocus], [typeof i4.ObserversModule], [typeof i1.CdkAriaLive, typeof i2.CdkTrapFocus, typeof i3.CdkMonitorFocus]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<A11yModule>;\n}\n\nexport declare class ActiveDescendantKeyManager<T> extends ListKeyManager<Highlightable & T> {\n    /**\n     * Sets the active item to the item at the specified index and adds the\n     * active styles to the newly active item. Also removes active styles\n     * from the previously active item.\n     * @param index Index of the item to be set as active.\n     */\n    setActiveItem(index: number): void;\n    /**\n     * Sets the active item to the item to the specified one and adds the\n     * active styles to the it. Also removes active styles from the\n     * previously active item.\n     * @param item Item to be set as active.\n     */\n    setActiveItem(item: T): void;\n}\n\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n */\nexport declare class AriaDescriber implements OnDestroy {\n    /**\n     * @deprecated To be turned into a required parameter.\n     * @breaking-change 14.0.0\n     */\n    private _platform?;\n    private _document;\n    /** Map of all registered message elements that have been placed into the document. */\n    private _messageRegistry;\n    /** Container for all registered messages. */\n    private _messagesContainer;\n    /** Unique ID for the service. */\n    private readonly _id;\n    constructor(_document: any, \n    /**\n     * @deprecated To be turned into a required parameter.\n     * @breaking-change 14.0.0\n     */\n    _platform?: Platform | undefined);\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    describe(hostElement: Element, message: string, role?: string): void;\n    /**\n     * Adds to the host element an aria-describedby reference to an already-existing message element.\n     */\n    describe(hostElement: Element, message: HTMLElement): void;\n    /** Removes the host element's aria-describedby reference to the message. */\n    removeDescription(hostElement: Element, message: string, role?: string): void;\n    /** Removes the host element's aria-describedby reference to the message element. */\n    removeDescription(hostElement: Element, message: HTMLElement): void;\n    /** Unregisters all created message elements and removes the message container. */\n    ngOnDestroy(): void;\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     */\n    private _createMessageElement;\n    /** Deletes the message element from the global messages container. */\n    private _deleteMessageElement;\n    /** Creates the global container for all aria-describedby messages. */\n    private _createMessagesContainer;\n    /** Removes all cdk-describedby messages that are hosted through the element. */\n    private _removeCdkDescribedByReferenceIds;\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     */\n    private _addMessageReference;\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     */\n    private _removeMessageReference;\n    /** Returns true if the element has been described by the provided message ID. */\n    private _isElementDescribedByMessage;\n    /** Determines whether a message can be described on a particular element. */\n    private _canBeDescribed;\n    /** Checks whether a node is an Element node. */\n    private _isElementNode;\n    static ɵfac: i0.ɵɵFactoryDeclaration<AriaDescriber, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<AriaDescriber>;\n}\n\n/** Possible politeness levels. */\nexport declare type AriaLivePoliteness = 'off' | 'polite' | 'assertive';\n\n/**\n * Attribute given to each host element that is described by a message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nexport declare const CDK_DESCRIBEDBY_HOST_ATTRIBUTE = \"cdk-describedby-host\";\n\n/**\n * ID prefix used for each created message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nexport declare const CDK_DESCRIBEDBY_ID_PREFIX = \"cdk-describedby-message\";\n\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nexport declare class CdkAriaLive implements OnDestroy {\n    private _elementRef;\n    private _liveAnnouncer;\n    private _contentObserver;\n    private _ngZone;\n    /** The aria-live politeness level to use when announcing messages. */\n    get politeness(): AriaLivePoliteness;\n    set politeness(value: AriaLivePoliteness);\n    private _politeness;\n    /** Time in milliseconds after which to clear out the announcer element. */\n    duration: number;\n    private _previousAnnouncedText?;\n    private _subscription;\n    constructor(_elementRef: ElementRef, _liveAnnouncer: LiveAnnouncer, _contentObserver: ContentObserver, _ngZone: NgZone);\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkAriaLive, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkAriaLive, \"[cdkAriaLive]\", [\"cdkAriaLive\"], { \"politeness\": \"cdkAriaLive\"; \"duration\": \"cdkAriaLiveDuration\"; }, {}, never, never, false>;\n}\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nexport declare class CdkMonitorFocus implements AfterViewInit, OnDestroy {\n    private _elementRef;\n    private _focusMonitor;\n    private _monitorSubscription;\n    private _focusOrigin;\n    readonly cdkFocusChange: EventEmitter<FocusOrigin>;\n    constructor(_elementRef: ElementRef<HTMLElement>, _focusMonitor: FocusMonitor);\n    get focusOrigin(): FocusOrigin;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMonitorFocus, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMonitorFocus, \"[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\", [\"cdkMonitorFocus\"], {}, { \"cdkFocusChange\": \"cdkFocusChange\"; }, never, never, false>;\n}\n\n/** Directive for trapping focus within a region. */\nexport declare class CdkTrapFocus implements OnDestroy, AfterContentInit, OnChanges, DoCheck {\n    private _elementRef;\n    private _focusTrapFactory;\n    /** Underlying FocusTrap instance. */\n    focusTrap: FocusTrap;\n    /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n    private _previouslyFocusedElement;\n    /** Whether the focus trap is active. */\n    get enabled(): boolean;\n    set enabled(value: BooleanInput);\n    /**\n     * Whether the directive should automatically move focus into the trapped region upon\n     * initialization and return focus to the previous activeElement upon destruction.\n     */\n    get autoCapture(): boolean;\n    set autoCapture(value: BooleanInput);\n    private _autoCapture;\n    constructor(_elementRef: ElementRef<HTMLElement>, _focusTrapFactory: FocusTrapFactory, \n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 13.0.0\n     */\n    _document: any);\n    ngOnDestroy(): void;\n    ngAfterContentInit(): void;\n    ngDoCheck(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    private _captureFocus;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTrapFocus, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTrapFocus, \"[cdkTrapFocus]\", [\"cdkTrapFocus\"], { \"enabled\": \"cdkTrapFocus\"; \"autoCapture\": \"cdkTrapFocusAutoCapture\"; }, {}, never, never, false>;\n}\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nexport declare class ConfigurableFocusTrap extends FocusTrap implements ManagedFocusTrap {\n    private _focusTrapManager;\n    private _inertStrategy;\n    /** Whether the FocusTrap is enabled. */\n    get enabled(): boolean;\n    set enabled(value: boolean);\n    constructor(_element: HTMLElement, _checker: InteractivityChecker, _ngZone: NgZone, _document: Document, _focusTrapManager: FocusTrapManager, _inertStrategy: FocusTrapInertStrategy, config: ConfigurableFocusTrapConfig);\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy(): void;\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable(): void;\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable(): void;\n}\n\n\n/**\n * Options for creating a ConfigurableFocusTrap.\n */\nexport declare interface ConfigurableFocusTrapConfig {\n    /**\n     * Whether to defer the creation of FocusTrap elements to be done manually by the user.\n     */\n    defer: boolean;\n}\n\n/** Factory that allows easy instantiation of configurable focus traps. */\nexport declare class ConfigurableFocusTrapFactory {\n    private _checker;\n    private _ngZone;\n    private _focusTrapManager;\n    private _document;\n    private _inertStrategy;\n    constructor(_checker: InteractivityChecker, _ngZone: NgZone, _focusTrapManager: FocusTrapManager, _document: any, _inertStrategy?: FocusTrapInertStrategy);\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param config The focus trap configuration.\n     * @returns The created focus trap instance.\n     */\n    create(element: HTMLElement, config?: ConfigurableFocusTrapConfig): ConfigurableFocusTrap;\n    /**\n     * @deprecated Pass a config object instead of the `deferCaptureElements` flag.\n     * @breaking-change 11.0.0\n     */\n    create(element: HTMLElement, deferCaptureElements: boolean): ConfigurableFocusTrap;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ConfigurableFocusTrapFactory, [null, null, null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ConfigurableFocusTrapFactory>;\n}\n\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nexport declare class EventListenerFocusTrapInertStrategy implements FocusTrapInertStrategy {\n    /** Focus event handler. */\n    private _listener;\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap: ConfigurableFocusTrap): void;\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap: ConfigurableFocusTrap): void;\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    private _trapFocus;\n}\n\n/** InjectionToken for FocusMonitorOptions. */\nexport declare const FOCUS_MONITOR_DEFAULT_OPTIONS: InjectionToken<FocusMonitorOptions>;\n\n/** The injection token used to specify the inert strategy. */\nexport declare const FOCUS_TRAP_INERT_STRATEGY: InjectionToken<FocusTrapInertStrategy>;\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply its label.\n */\nexport declare interface FocusableOption extends ListKeyManagerOption {\n    /** Focuses the `FocusableOption`. */\n    focus(origin?: FocusOrigin): void;\n}\n\nexport declare class FocusKeyManager<T> extends ListKeyManager<FocusableOption & T> {\n    private _origin;\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin: FocusOrigin): this;\n    /**\n     * Sets the active item to the item at the specified\n     * index and focuses the newly active item.\n     * @param index Index of the item to be set as active.\n     */\n    setActiveItem(index: number): void;\n    /**\n     * Sets the active item to the item that is specified and focuses it.\n     * @param item Item to be set as active.\n     */\n    setActiveItem(item: T): void;\n}\n\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nexport declare class FocusMonitor implements OnDestroy {\n    private _ngZone;\n    private _platform;\n    private readonly _inputModalityDetector;\n    /** The focus origin that the next focus event is a result of. */\n    private _origin;\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n    private _lastFocusOrigin;\n    /** Whether the window has just been focused. */\n    private _windowFocused;\n    /** The timeout id of the window focus timeout. */\n    private _windowFocusTimeoutId;\n    /** The timeout id of the origin clearing timeout. */\n    private _originTimeoutId;\n    /**\n     * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n     * focus events to touch interactions requires special logic.\n     */\n    private _originFromTouchInteraction;\n    /** Map of elements being monitored to their info. */\n    private _elementInfo;\n    /** The number of elements currently being monitored. */\n    private _monitoredElementCount;\n    /**\n     * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n     * as well as the number of monitored elements that they contain. We have to treat focus/blur\n     * handlers differently from the rest of the events, because the browser won't emit events\n     * to the document when focus moves inside of a shadow root.\n     */\n    private _rootNodeFocusListenerCount;\n    /**\n     * The specified detection mode, used for attributing the origin of a focus\n     * event.\n     */\n    private readonly _detectionMode;\n    /**\n     * Event listener for `focus` events on the window.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    private _windowFocusListener;\n    /** Used to reference correct document/window */\n    protected _document?: Document;\n    /** Subject for stopping our InputModalityDetector subscription. */\n    private readonly _stopInputModalityDetector;\n    constructor(_ngZone: NgZone, _platform: Platform, _inputModalityDetector: InputModalityDetector, \n    /** @breaking-change 11.0.0 make document required */\n    document: any | null, options: FocusMonitorOptions | null);\n    /**\n     * Event listener for `focus` and 'blur' events on the document.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    private _rootNodeFocusAndBlurListener;\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    monitor(element: HTMLElement, checkChildren?: boolean): Observable<FocusOrigin>;\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    monitor(element: ElementRef<HTMLElement>, checkChildren?: boolean): Observable<FocusOrigin>;\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: HTMLElement): void;\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: ElementRef<HTMLElement>): void;\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element Element to focus.\n     * @param origin Focus origin.\n     * @param options Options that can be used to configure the focus behavior.\n     */\n    focusVia(element: HTMLElement, origin: FocusOrigin, options?: FocusOptions_2): void;\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element Element to focus.\n     * @param origin Focus origin.\n     * @param options Options that can be used to configure the focus behavior.\n     */\n    focusVia(element: ElementRef<HTMLElement>, origin: FocusOrigin, options?: FocusOptions_2): void;\n    ngOnDestroy(): void;\n    /** Access injected document if available or fallback to global document reference */\n    private _getDocument;\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    private _getWindow;\n    private _getFocusOrigin;\n    /**\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\n     * subsequent programmatic focus call triggered by the touch interaction.\n     * @param focusEventTarget The target of the focus event under examination.\n     */\n    private _shouldBeAttributedToTouch;\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    private _setClasses;\n    /**\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n     * the origin being set.\n     * @param origin The origin to set.\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\n     */\n    private _setOrigin;\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    private _onFocus;\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event: FocusEvent, element: HTMLElement): void;\n    private _emitOrigin;\n    private _registerGlobalListeners;\n    private _removeGlobalListeners;\n    /** Updates all the state on an element once its focus origin has changed. */\n    private _originChanged;\n    /**\n     * Collects the `MonitoredElementInfo` of a particular element and\n     * all of its ancestors that have enabled `checkChildren`.\n     * @param element Element from which to start the search.\n     */\n    private _getClosestElementsInfo;\n    /**\n     * Returns whether an interaction is likely to have come from the user clicking the `label` of\n     * an `input` or `textarea` in order to focus it.\n     * @param focusEventTarget Target currently receiving focus.\n     */\n    private _isLastInteractionFromInputLabel;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FocusMonitor, [null, null, null, { optional: true; }, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<FocusMonitor>;\n}\n\n/** Detection mode used for attributing the origin of a focus event. */\nexport declare const enum FocusMonitorDetectionMode {\n    /**\n     * Any mousedown, keydown, or touchstart event that happened in the previous\n     * tick or the current tick will be used to assign a focus event's origin (to\n     * either mouse, keyboard, or touch). This is the default option.\n     */\n    IMMEDIATE = 0,\n    /**\n     * A focus event's origin is always attributed to the last corresponding\n     * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\n     */\n    EVENTUAL = 1\n}\n\n/** Injectable service-level options for FocusMonitor. */\nexport declare interface FocusMonitorOptions {\n    detectionMode?: FocusMonitorDetectionMode;\n}\n\n/**\n * Corresponds to the options that can be passed to the native `focus` event.\n * via https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n */\ndeclare interface FocusOptions_2 {\n    /** Whether the browser should scroll to the element when it is focused. */\n    preventScroll?: boolean;\n}\nexport { FocusOptions_2 as FocusOptions }\n\nexport declare type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n *\n * @deprecated Use `ConfigurableFocusTrap` instead.\n * @breaking-change 11.0.0\n */\nexport declare class FocusTrap {\n    readonly _element: HTMLElement;\n    private _checker;\n    readonly _ngZone: NgZone;\n    readonly _document: Document;\n    private _startAnchor;\n    private _endAnchor;\n    private _hasAttached;\n    protected startAnchorListener: () => boolean;\n    protected endAnchorListener: () => boolean;\n    /** Whether the focus trap is active. */\n    get enabled(): boolean;\n    set enabled(value: boolean);\n    protected _enabled: boolean;\n    constructor(_element: HTMLElement, _checker: InteractivityChecker, _ngZone: NgZone, _document: Document, deferAnchors?: boolean);\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy(): void;\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors(): boolean;\n    /**\n     * Waits for the zone to stabilize, then focuses the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady(options?: FocusOptions): Promise<boolean>;\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady(options?: FocusOptions): Promise<boolean>;\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady(options?: FocusOptions): Promise<boolean>;\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    private _getRegionBoundary;\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement(options?: FocusOptions): boolean;\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement(options?: FocusOptions): boolean;\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement(options?: FocusOptions): boolean;\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached(): boolean;\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    private _getFirstTabbableElement;\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    private _getLastTabbableElement;\n    /** Creates an anchor element. */\n    private _createAnchor;\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    private _toggleAnchorTabIndex;\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    protected toggleAnchors(enabled: boolean): void;\n    /** Executes a function when the zone is stable. */\n    private _executeOnStable;\n}\n\n/**\n * Factory that allows easy instantiation of focus traps.\n * @deprecated Use `ConfigurableFocusTrapFactory` instead.\n * @breaking-change 11.0.0\n */\nexport declare class FocusTrapFactory {\n    private _checker;\n    private _ngZone;\n    private _document;\n    constructor(_checker: InteractivityChecker, _ngZone: NgZone, _document: any);\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    create(element: HTMLElement, deferCaptureElements?: boolean): FocusTrap;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FocusTrapFactory, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<FocusTrapFactory>;\n}\n\n/**\n * A strategy that dictates how FocusTrap should prevent elements\n * outside of the FocusTrap from being focused.\n */\nexport declare interface FocusTrapInertStrategy {\n    /** Makes all elements outside focusTrap unfocusable. */\n    preventFocus(focusTrap: FocusTrap): void;\n    /** Reverts elements made unfocusable by preventFocus to their previous state. */\n    allowFocus(focusTrap: FocusTrap): void;\n}\n\n/** Injectable that ensures only the most recently enabled FocusTrap is active. */\ndeclare class FocusTrapManager {\n    private _focusTrapStack;\n    /**\n     * Disables the FocusTrap at the top of the stack, and then pushes\n     * the new FocusTrap onto the stack.\n     */\n    register(focusTrap: ManagedFocusTrap): void;\n    /**\n     * Removes the FocusTrap from the stack, and activates the\n     * FocusTrap that is the new top of the stack.\n     */\n    deregister(focusTrap: ManagedFocusTrap): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FocusTrapManager, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<FocusTrapManager>;\n}\n\n/** Set of possible high-contrast mode backgrounds. */\nexport declare const enum HighContrastMode {\n    NONE = 0,\n    BLACK_ON_WHITE = 1,\n    WHITE_ON_BLACK = 2\n}\n\n/**\n * Service to determine whether the browser is currently in a high-contrast-mode environment.\n *\n * Microsoft Windows supports an accessibility feature called \"High Contrast Mode\". This mode\n * changes the appearance of all applications, including web applications, to dramatically increase\n * contrast.\n *\n * IE, Edge, and Firefox currently support this mode. Chrome does not support Windows High Contrast\n * Mode. This service does not detect high-contrast mode as added by the Chrome \"High Contrast\"\n * browser extension.\n */\nexport declare class HighContrastModeDetector implements OnDestroy {\n    private _platform;\n    /**\n     * Figuring out the high contrast mode and adding the body classes can cause\n     * some expensive layouts. This flag is used to ensure that we only do it once.\n     */\n    private _hasCheckedHighContrastMode;\n    private _document;\n    private _breakpointSubscription;\n    constructor(_platform: Platform, document: any);\n    /** Gets the current high-contrast-mode for the page. */\n    getHighContrastMode(): HighContrastMode;\n    ngOnDestroy(): void;\n    /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n    _applyBodyHighContrastModeCssClasses(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<HighContrastModeDetector, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<HighContrastModeDetector>;\n}\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n */\nexport declare interface Highlightable extends ListKeyManagerOption {\n    /** Applies the styles for an active item to this item. */\n    setActiveStyles(): void;\n    /** Applies the styles for an inactive item to this item. */\n    setInactiveStyles(): void;\n}\n\ndeclare namespace i1 {\n    export {\n        LiveAnnouncer,\n        CdkAriaLive\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        FocusTrap,\n        FocusTrapFactory,\n        CdkTrapFocus\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        FocusOrigin,\n        FocusOptions_2 as FocusOptions,\n        FocusMonitorDetectionMode,\n        FocusMonitorOptions,\n        FOCUS_MONITOR_DEFAULT_OPTIONS,\n        FocusMonitor,\n        CdkMonitorFocus\n    }\n}\n\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nexport declare const INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS: InputModalityDetectorOptions;\n\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nexport declare const INPUT_MODALITY_DETECTOR_OPTIONS: InjectionToken<InputModalityDetectorOptions>;\n\n/**\n * The input modalities detected by this service. Null is used if the input modality is unknown.\n */\nexport declare type InputModality = 'keyboard' | 'mouse' | 'touch' | null;\n\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nexport declare class InputModalityDetector implements OnDestroy {\n    private readonly _platform;\n    /** Emits whenever an input modality is detected. */\n    readonly modalityDetected: Observable<InputModality>;\n    /** Emits when the input modality changes. */\n    readonly modalityChanged: Observable<InputModality>;\n    /** The most recently detected input modality. */\n    get mostRecentModality(): InputModality;\n    /**\n     * The most recently detected input modality event target. Is null if no input modality has been\n     * detected or if the associated event target is null for some unknown reason.\n     */\n    _mostRecentTarget: HTMLElement | null;\n    /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n    private readonly _modality;\n    /** Options for this InputModalityDetector. */\n    private readonly _options;\n    /**\n     * The timestamp of the last touch input modality. Used to determine whether mousedown events\n     * should be attributed to mouse or touch.\n     */\n    private _lastTouchMs;\n    /**\n     * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n     * bound.\n     */\n    private _onKeydown;\n    /**\n     * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    private _onMousedown;\n    /**\n     * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    private _onTouchstart;\n    constructor(_platform: Platform, ngZone: NgZone, document: Document, options?: InputModalityDetectorOptions);\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<InputModalityDetector, [null, null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<InputModalityDetector>;\n}\n\n/** Options to configure the behavior of the InputModalityDetector. */\nexport declare interface InputModalityDetectorOptions {\n    /** Keys to ignore when detecting keyboard input modality. */\n    ignoreKeys?: number[];\n}\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nexport declare class InteractivityChecker {\n    private _platform;\n    constructor(_platform: Platform);\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    isDisabled(element: HTMLElement): boolean;\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    isVisible(element: HTMLElement): boolean;\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    isTabbable(element: HTMLElement): boolean;\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @param config The config object with options to customize this method's behavior\n     * @returns Whether the element is focusable.\n     */\n    isFocusable(element: HTMLElement, config?: IsFocusableConfig): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<InteractivityChecker, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<InteractivityChecker>;\n}\n\n\n/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nexport declare function isFakeMousedownFromScreenReader(event: MouseEvent): boolean;\n\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nexport declare function isFakeTouchstartFromScreenReader(event: TouchEvent): boolean;\n\n/**\n * Configuration for the isFocusable method.\n */\nexport declare class IsFocusableConfig {\n    /**\n     * Whether to count an element as focusable even if it is not currently visible.\n     */\n    ignoreVisibility: boolean;\n}\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport declare class ListKeyManager<T extends ListKeyManagerOption> {\n    private _items;\n    private _activeItemIndex;\n    private _activeItem;\n    private _wrap;\n    private readonly _letterKeyStream;\n    private _typeaheadSubscription;\n    private _vertical;\n    private _horizontal;\n    private _allowedModifierKeys;\n    private _homeAndEnd;\n    /**\n     * Predicate function that can be used to check whether an item should be skipped\n     * by the key manager. By default, disabled items are skipped.\n     */\n    private _skipPredicateFn;\n    private _pressedLetters;\n    constructor(_items: QueryList<T> | T[]);\n    /**\n     * Stream that emits any time the TAB key is pressed, so components can react\n     * when focus is shifted off of the list.\n     */\n    readonly tabOut: Subject<void>;\n    /** Stream that emits whenever the active item of the list manager changes. */\n    readonly change: Subject<number>;\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate: (item: T) => boolean): this;\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap?: boolean): this;\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled?: boolean): this;\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this;\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys: ListKeyManagerModifierKey[]): this;\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval?: number): this;\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled?: boolean): this;\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    setActiveItem(index: number): void;\n    /**\n     * Sets the active item to the specified item.\n     * @param item The item to be set as active.\n     */\n    setActiveItem(item: T): void;\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event: KeyboardEvent): void;\n    /** Index of the currently active item. */\n    get activeItemIndex(): number | null;\n    /** The active item. */\n    get activeItem(): T | null;\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping(): boolean;\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive(): void;\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive(): void;\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive(): void;\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive(): void;\n    /**\n     * Allows setting the active without any other effects.\n     * @param index Index of the item to be set as active.\n     */\n    updateActiveItem(index: number): void;\n    /**\n     * Allows setting the active item without any other effects.\n     * @param item Item to be set as active.\n     */\n    updateActiveItem(item: T): void;\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    private _setActiveItemByDelta;\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    private _setActiveInWrapMode;\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    private _setActiveInDefaultMode;\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    private _setActiveItemByIndex;\n    /** Returns the items as an array. */\n    private _getItemsArray;\n}\n\n/** Modifier keys handled by the ListKeyManager. */\nexport declare type ListKeyManagerModifierKey = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';\n\n/** This interface is for items that can be passed to a ListKeyManager. */\nexport declare interface ListKeyManagerOption {\n    /** Whether the option is disabled. */\n    disabled?: boolean;\n    /** Gets the label for this option. */\n    getLabel?(): string;\n}\n\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nexport declare const LIVE_ANNOUNCER_DEFAULT_OPTIONS: InjectionToken<LiveAnnouncerDefaultOptions>;\n\nexport declare const LIVE_ANNOUNCER_ELEMENT_TOKEN: InjectionToken<HTMLElement | null>;\n\n/** @docs-private */\nexport declare function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY(): null;\n\nexport declare class LiveAnnouncer implements OnDestroy {\n    private _ngZone;\n    private _defaultOptions?;\n    private _liveElement;\n    private _document;\n    private _previousTimeout;\n    private _currentPromise;\n    private _currentResolve;\n    constructor(elementToken: any, _ngZone: NgZone, _document: any, _defaultOptions?: LiveAnnouncerDefaultOptions | undefined);\n    /**\n     * Announces a message to screen readers.\n     * @param message Message to be announced to the screen reader.\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    announce(message: string): Promise<void>;\n    /**\n     * Announces a message to screen readers.\n     * @param message Message to be announced to the screen reader.\n     * @param politeness The politeness of the announcer element.\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    announce(message: string, politeness?: AriaLivePoliteness): Promise<void>;\n    /**\n     * Announces a message to screen readers.\n     * @param message Message to be announced to the screen reader.\n     * @param duration Time in milliseconds after which to clear out the announcer element. Note\n     *   that this takes effect after the message has been added to the DOM, which can be up to\n     *   100ms after `announce` has been called.\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    announce(message: string, duration?: number): Promise<void>;\n    /**\n     * Announces a message to screen readers.\n     * @param message Message to be announced to the screen reader.\n     * @param politeness The politeness of the announcer element.\n     * @param duration Time in milliseconds after which to clear out the announcer element. Note\n     *   that this takes effect after the message has been added to the DOM, which can be up to\n     *   100ms after `announce` has been called.\n     * @returns Promise that will be resolved when the message is added to the DOM.\n     */\n    announce(message: string, politeness?: AriaLivePoliteness, duration?: number): Promise<void>;\n    /**\n     * Clears the current text from the announcer element. Can be used to prevent\n     * screen readers from reading the text out again while the user is going\n     * through the page landmarks.\n     */\n    clear(): void;\n    ngOnDestroy(): void;\n    private _createLiveElement;\n    static ɵfac: i0.ɵɵFactoryDeclaration<LiveAnnouncer, [{ optional: true; }, null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<LiveAnnouncer>;\n}\n\n/** Object that can be used to configure the default options for the LiveAnnouncer. */\nexport declare interface LiveAnnouncerDefaultOptions {\n    /** Default politeness for the announcements. */\n    politeness?: AriaLivePoliteness;\n    /** Default duration for the announcement messages. */\n    duration?: number;\n}\n\n/**\n * A FocusTrap managed by FocusTrapManager.\n * Implemented by ConfigurableFocusTrap to avoid circular dependency.\n */\ndeclare interface ManagedFocusTrap {\n    _enable(): void;\n    _disable(): void;\n    focusInitialElementWhenReady(): Promise<boolean>;\n}\n\n/**\n * ID used for the body container where all messages are appended.\n * @deprecated No longer being used. To be removed.\n * @breaking-change 14.0.0\n */\nexport declare const MESSAGES_CONTAINER_ID = \"cdk-describedby-message-container\";\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n */\nexport declare interface RegisteredMessage {\n    /** The element containing the message. */\n    messageElement: Element;\n    /** The number of elements that reference this message element via `aria-describedby`. */\n    referenceCount: number;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/accordion/index.d.ts",
      "node_modules/@angular/cdk/accordion/index.d.ts"
    ],
    "content": "import { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\n\n/**\n * Injection token that can be used to reference instances of `CdkAccordion`. It serves\n * as alternative token to the actual `CdkAccordion` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\ndeclare const CDK_ACCORDION: InjectionToken<CdkAccordion>;\n\n/**\n * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.\n */\nexport declare class CdkAccordion implements OnDestroy, OnChanges {\n    /** Emits when the state of the accordion changes */\n    readonly _stateChanges: Subject<SimpleChanges>;\n    /** Stream that emits true/false when openAll/closeAll is triggered. */\n    readonly _openCloseAllActions: Subject<boolean>;\n    /** A readonly id value to use for unique selection coordination. */\n    readonly id: string;\n    /** Whether the accordion should allow multiple expanded accordion items simultaneously. */\n    get multi(): boolean;\n    set multi(multi: BooleanInput);\n    private _multi;\n    /** Opens all enabled accordion items in an accordion where multi is enabled. */\n    openAll(): void;\n    /** Closes all enabled accordion items in an accordion where multi is enabled. */\n    closeAll(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkAccordion, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkAccordion, \"cdk-accordion, [cdkAccordion]\", [\"cdkAccordion\"], { \"multi\": \"multi\"; }, {}, never, never, false>;\n}\n\n/**\n * An basic directive expected to be extended and decorated as a component.  Sets up all\n * events and attributes needed to be managed by a CdkAccordion parent.\n */\nexport declare class CdkAccordionItem implements OnDestroy {\n    accordion: CdkAccordion;\n    private _changeDetectorRef;\n    protected _expansionDispatcher: UniqueSelectionDispatcher;\n    /** Subscription to openAll/closeAll events. */\n    private _openCloseAllSubscription;\n    /** Event emitted every time the AccordionItem is closed. */\n    readonly closed: EventEmitter<void>;\n    /** Event emitted every time the AccordionItem is opened. */\n    readonly opened: EventEmitter<void>;\n    /** Event emitted when the AccordionItem is destroyed. */\n    readonly destroyed: EventEmitter<void>;\n    /**\n     * Emits whenever the expanded state of the accordion changes.\n     * Primarily used to facilitate two-way binding.\n     * @docs-private\n     */\n    readonly expandedChange: EventEmitter<boolean>;\n    /** The unique AccordionItem id. */\n    readonly id: string;\n    /** Whether the AccordionItem is expanded. */\n    get expanded(): boolean;\n    set expanded(expanded: BooleanInput);\n    private _expanded;\n    /** Whether the AccordionItem is disabled. */\n    get disabled(): boolean;\n    set disabled(disabled: BooleanInput);\n    private _disabled;\n    /** Unregister function for _expansionDispatcher. */\n    private _removeUniqueSelectionListener;\n    constructor(accordion: CdkAccordion, _changeDetectorRef: ChangeDetectorRef, _expansionDispatcher: UniqueSelectionDispatcher);\n    /** Emits an event for the accordion item being destroyed. */\n    ngOnDestroy(): void;\n    /** Toggles the expanded state of the accordion item. */\n    toggle(): void;\n    /** Sets the expanded state of the accordion item to false. */\n    close(): void;\n    /** Sets the expanded state of the accordion item to true. */\n    open(): void;\n    private _subscribeToOpenCloseAllActions;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkAccordionItem, [{ optional: true; skipSelf: true; }, null, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkAccordionItem, \"cdk-accordion-item, [cdkAccordionItem]\", [\"cdkAccordionItem\"], { \"expanded\": \"expanded\"; \"disabled\": \"disabled\"; }, { \"closed\": \"closed\"; \"opened\": \"opened\"; \"destroyed\": \"destroyed\"; \"expandedChange\": \"expandedChange\"; }, never, never, false>;\n}\n\nexport declare class CdkAccordionModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkAccordionModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkAccordionModule, [typeof i1.CdkAccordion, typeof i2.CdkAccordionItem], never, [typeof i1.CdkAccordion, typeof i2.CdkAccordionItem]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<CdkAccordionModule>;\n}\n\ndeclare namespace i1 {\n    export {\n        CDK_ACCORDION,\n        CdkAccordion\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        CdkAccordionItem\n    }\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/bidi/index.d.ts",
      "node_modules/@angular/cdk/bidi/index.d.ts"
    ],
    "content": "import { AfterContentInit } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\n\nexport declare class BidiModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<BidiModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<BidiModule, [typeof i1.Dir], never, [typeof i1.Dir]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<BidiModule>;\n}\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nexport declare class Dir implements Directionality, AfterContentInit, OnDestroy {\n    /** Normalized direction that accounts for invalid/unsupported values. */\n    private _dir;\n    /** Whether the `value` has been set to its initial value. */\n    private _isInitialized;\n    /** Direction as passed in by the consumer. */\n    _rawDir: string;\n    /** Event emitted when the direction changes. */\n    readonly change: EventEmitter<Direction>;\n    /** @docs-private */\n    get dir(): Direction;\n    set dir(value: Direction | 'auto');\n    /** Current layout direction of the element. */\n    get value(): Direction;\n    /** Initialize once default value has been set. */\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Dir, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<Dir, \"[dir]\", [\"dir\"], { \"dir\": \"dir\"; }, { \"change\": \"dirChange\"; }, never, never, false>;\n}\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-browser because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\nexport declare const DIR_DOCUMENT: InjectionToken<Document>;\n\nexport declare type Direction = 'ltr' | 'rtl';\n\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nexport declare class Directionality implements OnDestroy {\n    /** The current 'ltr' or 'rtl' value. */\n    readonly value: Direction;\n    /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n    readonly change: EventEmitter<Direction>;\n    constructor(_document?: any);\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Directionality, [{ optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Directionality>;\n}\n\ndeclare namespace i1 {\n    export {\n        Dir\n    }\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/clipboard/index.d.ts",
      "node_modules/@angular/cdk/clipboard/index.d.ts"
    ],
    "content": "import { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\n\n/** Injection token that can be used to provide the default options to `CdkCopyToClipboard`. */\nexport declare const CDK_COPY_TO_CLIPBOARD_CONFIG: InjectionToken<CdkCopyToClipboardConfig>;\n\n/**\n * Provides behavior for a button that when clicked copies content into user's\n * clipboard.\n */\nexport declare class CdkCopyToClipboard implements OnDestroy {\n    private _clipboard;\n    private _ngZone;\n    /** Content to be copied. */\n    text: string;\n    /**\n     * How many times to attempt to copy the text. This may be necessary for longer text, because\n     * the browser needs time to fill an intermediate textarea element and copy the content.\n     */\n    attempts: number;\n    /**\n     * Emits when some text is copied to the clipboard. The\n     * emitted value indicates whether copying was successful.\n     */\n    readonly copied: EventEmitter<boolean>;\n    /** Copies that are currently being attempted. */\n    private _pending;\n    /** Whether the directive has been destroyed. */\n    private _destroyed;\n    /** Timeout for the current copy attempt. */\n    private _currentTimeout;\n    constructor(_clipboard: Clipboard_2, _ngZone: NgZone, config?: CdkCopyToClipboardConfig);\n    /** Copies the current text to the clipboard. */\n    copy(attempts?: number): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkCopyToClipboard, [null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkCopyToClipboard, \"[cdkCopyToClipboard]\", never, { \"text\": \"cdkCopyToClipboard\"; \"attempts\": \"cdkCopyToClipboardAttempts\"; }, { \"copied\": \"cdkCopyToClipboardCopied\"; }, never, never, false>;\n}\n\n/** Object that can be used to configure the default options for `CdkCopyToClipboard`. */\nexport declare interface CdkCopyToClipboardConfig {\n    /** Default number of attempts to make when copying text to the clipboard. */\n    attempts?: number;\n}\n\n/**\n * A service for copying text to the clipboard.\n */\ndeclare class Clipboard_2 {\n    private readonly _document;\n    constructor(document: any);\n    /**\n     * Copies the provided text into the user's clipboard.\n     *\n     * @param text The string to copy.\n     * @returns Whether the operation was successful.\n     */\n    copy(text: string): boolean;\n    /**\n     * Prepares a string to be copied later. This is useful for large strings\n     * which take too long to successfully render and be copied in the same tick.\n     *\n     * The caller must call `destroy` on the returned `PendingCopy`.\n     *\n     * @param text The string to copy.\n     * @returns the pending copy operation.\n     */\n    beginCopy(text: string): PendingCopy;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Clipboard_2, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Clipboard_2>;\n}\nexport { Clipboard_2 as Clipboard }\n\nexport declare class ClipboardModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<ClipboardModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<ClipboardModule, [typeof i1.CdkCopyToClipboard], never, [typeof i1.CdkCopyToClipboard]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<ClipboardModule>;\n}\n\ndeclare namespace i1 {\n    export {\n        CdkCopyToClipboardConfig,\n        CDK_COPY_TO_CLIPBOARD_CONFIG,\n        CdkCopyToClipboard\n    }\n}\n\n\n/**\n * A pending copy-to-clipboard operation.\n *\n * The implementation of copying text to the clipboard modifies the DOM and\n * forces a re-layout. This re-layout can take too long if the string is large,\n * causing the execCommand('copy') to happen too long after the user clicked.\n * This results in the browser refusing to copy. This object lets the\n * re-layout happen in a separate tick from copying by providing a copy function\n * that can be called later.\n *\n * Destroy must be called when no longer in use, regardless of whether `copy` is\n * called.\n */\nexport declare class PendingCopy {\n    private readonly _document;\n    private _textarea;\n    constructor(text: string, _document: Document);\n    /** Finishes copying the text. */\n    copy(): boolean;\n    /** Cleans up DOM changes used to perform the copy operation. */\n    destroy(): void;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/coercion/index.d.ts",
      "node_modules/@angular/cdk/coercion/index.d.ts"
    ],
    "content": "import { ElementRef } from '@angular/core';\n\n\n/**\n * Type describing the allowed values for a boolean input.\n * @docs-private\n */\nexport declare type BooleanInput = string | boolean | null | undefined;\n\n\n/** Wraps the provided value in an array, unless the provided value is an array. */\nexport declare function coerceArray<T>(value: T | T[]): T[];\n\nexport declare function coerceArray<T>(value: T | readonly T[]): readonly T[];\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nexport declare function coerceBooleanProperty(value: any): boolean;\n\n\n/** Coerces a value to a CSS pixel value. */\nexport declare function coerceCssPixelValue(value: any): string;\n\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nexport declare function coerceElement<T>(elementOrRef: ElementRef<T> | T): T;\n\n/** Coerces a data-bound value (typically a string) to a number. */\nexport declare function coerceNumberProperty(value: any): number;\n\nexport declare function coerceNumberProperty<D>(value: any, fallback: D): number | D;\n\n\n/**\n * Coerces a value to an array of trimmed non-empty strings.\n * Any input that is not an array, `null` or `undefined` will be turned into a string\n * via `toString()` and subsequently split with the given separator.\n * `null` and `undefined` will result in an empty array.\n * This results in the following outcomes:\n * - `null` -&gt; `[]`\n * - `[null]` -&gt; `[\"null\"]`\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\n *\n * Useful for defining CSS classes or table columns.\n * @param value the value to coerce into an array of strings\n * @param separator split-separator if value isn't an array\n */\nexport declare function coerceStringArray(value: any, separator?: string | RegExp): string[];\n\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nexport declare function _isNumberValue(value: any): boolean;\n\n\n/**\n * Type describing the allowed values for a number input\n * @docs-private\n */\nexport declare type NumberInput = string | number | null | undefined;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/collections/index.d.ts",
      "node_modules/@angular/cdk/collections/index.d.ts"
    ],
    "content": "import * as i0 from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { IterableChangeRecord } from '@angular/core';\nimport { IterableChanges } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/** DataSource wrapper for a native array. */\nexport declare class ArrayDataSource<T> extends DataSource<T> {\n    private _data;\n    constructor(_data: readonly T[] | Observable<readonly T[]>);\n    connect(): Observable<readonly T[]>;\n    disconnect(): void;\n}\n\n/**\n * Interface for any component that provides a view of some data collection and wants to provide\n * information regarding the view and any changes made.\n */\nexport declare interface CollectionViewer {\n    /**\n     * A stream that emits whenever the `CollectionViewer` starts looking at a new portion of the\n     * data. The `start` index is inclusive, while the `end` is exclusive.\n     */\n    viewChange: Observable<ListRange>;\n}\n\nexport declare abstract class DataSource<T> {\n    /**\n     * Connects a collection viewer (such as a data-table) to this data source. Note that\n     * the stream provided will be accessed during change detection and should not directly change\n     * values that are bound in template views.\n     * @param collectionViewer The component that exposes a view over the data provided by this\n     *     data source.\n     * @returns Observable that emits a new value when the data changes.\n     */\n    abstract connect(collectionViewer: CollectionViewer): Observable<readonly T[]>;\n    /**\n     * Disconnects a collection viewer (such as a data-table) from this data source. Can be used\n     * to perform any clean-up or tear-down operations when a view is being destroyed.\n     *\n     * @param collectionViewer The component that exposes a view over the data provided by this\n     *     data source.\n     */\n    abstract disconnect(collectionViewer: CollectionViewer): void;\n}\n\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport declare class _DisposeViewRepeaterStrategy<T, R, C extends _ViewRepeaterItemContext<T>> implements _ViewRepeater<T, R, C> {\n    applyChanges(changes: IterableChanges<R>, viewContainerRef: ViewContainerRef, itemContextFactory: _ViewRepeaterItemContextFactory<T, R, C>, itemValueResolver: _ViewRepeaterItemValueResolver<T, R>, itemViewChanged?: _ViewRepeaterItemChanged<R, C>): void;\n    detach(): void;\n}\n\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nexport declare function getMultipleValuesInSingleSelectionError(): Error;\n\n/** Checks whether an object is a data source. */\nexport declare function isDataSource(value: any): value is DataSource<any>;\n\n/** Represents a range of numbers with a specified start and end. */\nexport declare type ListRange = {\n    start: number;\n    end: number;\n};\n\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport declare class _RecycleViewRepeaterStrategy<T, R, C extends _ViewRepeaterItemContext<T>> implements _ViewRepeater<T, R, C> {\n    /**\n     * The size of the cache used to store unused views.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n     */\n    viewCacheSize: number;\n    /**\n     * View cache that stores embedded view instances that have been previously stamped out,\n     * but don't are not currently rendered. The view repeater will reuse these views rather than\n     * creating brand new ones.\n     *\n     * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n     */\n    private _viewCache;\n    /** Apply changes to the DOM. */\n    applyChanges(changes: IterableChanges<R>, viewContainerRef: ViewContainerRef, itemContextFactory: _ViewRepeaterItemContextFactory<T, R, C>, itemValueResolver: _ViewRepeaterItemValueResolver<T, R>, itemViewChanged?: _ViewRepeaterItemChanged<R, C>): void;\n    detach(): void;\n    /**\n     * Inserts a view for a new item, either from the cache or by creating a new\n     * one. Returns `undefined` if the item was inserted into a cached view.\n     */\n    private _insertView;\n    /** Detaches the view at the given index and inserts into the view cache. */\n    private _detachAndCacheView;\n    /** Moves view at the previous index to the current index. */\n    private _moveView;\n    /**\n     * Cache the given detached view. If the cache is full, the view will be\n     * destroyed.\n     */\n    private _maybeCacheView;\n    /** Inserts a recycled view from the cache at the given index. */\n    private _insertViewFromCache;\n}\n\n/**\n * Event emitted when the value of a MatSelectionModel has changed.\n * @docs-private\n */\nexport declare interface SelectionChange<T> {\n    /** Model that dispatched the event. */\n    source: SelectionModel<T>;\n    /** Options that were added to the model. */\n    added: T[];\n    /** Options that were removed from the model. */\n    removed: T[];\n}\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nexport declare class SelectionModel<T> {\n    private _multiple;\n    private _emitChanges;\n    compareWith?: ((o1: T, o2: T) => boolean) | undefined;\n    /** Currently-selected values. */\n    private _selection;\n    /** Keeps track of the deselected options that haven't been emitted by the change event. */\n    private _deselectedToEmit;\n    /** Keeps track of the selected options that haven't been emitted by the change event. */\n    private _selectedToEmit;\n    /** Cache for the array value of the selected items. */\n    private _selected;\n    /** Selected values. */\n    get selected(): T[];\n    /** Event emitted when the value has changed. */\n    readonly changed: Subject<SelectionChange<T>>;\n    constructor(_multiple?: boolean, initiallySelectedValues?: T[], _emitChanges?: boolean, compareWith?: ((o1: T, o2: T) => boolean) | undefined);\n    /**\n     * Selects a value or an array of values.\n     * @param values The values to select\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    select(...values: T[]): boolean | void;\n    /**\n     * Deselects a value or an array of values.\n     * @param values The values to deselect\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    deselect(...values: T[]): boolean | void;\n    /**\n     * Sets the selected values\n     * @param values The new selected values\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    setSelection(...values: T[]): boolean | void;\n    /**\n     * Toggles a value between selected and deselected.\n     * @param value The value to toggle\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    toggle(value: T): boolean | void;\n    /**\n     * Clears all of the selected values.\n     * @param flushEvent Whether to flush the changes in an event.\n     *   If false, the changes to the selection will be flushed along with the next event.\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    clear(flushEvent?: boolean): boolean | void;\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value: T): boolean;\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty(): boolean;\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue(): boolean;\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate?: (a: T, b: T) => number): void;\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection(): boolean;\n    /** Emits a change event and clears the records of selected and deselected values. */\n    private _emitChangeEvent;\n    /** Selects a value. */\n    private _markSelected;\n    /** Deselects a value. */\n    private _unmarkSelected;\n    /** Clears out the selected values. */\n    private _unmarkAll;\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    private _verifyValueAssignment;\n    /** Whether there are queued up change to be emitted. */\n    private _hasQueuedChanges;\n}\n\n/**\n * Interface for a class that can flatten hierarchical structured data and re-expand the flattened\n * data back into its original structure. Should be used in conjunction with the cdk-tree.\n */\nexport declare interface TreeDataNodeFlattener<T> {\n    /** Transforms a set of hierarchical structured data into a flattened data array. */\n    flattenNodes(structuredData: any[]): T[];\n    /**\n     * Expands a flattened array of data into its hierarchical form using the provided expansion\n     * model.\n     */\n    expandFlattenedNodes(nodes: T[], expansionModel: SelectionModel<T>): T[];\n    /**\n     * Put node descendants of node in array.\n     * If `onlyExpandable` is true, then only process expandable descendants.\n     */\n    nodeDescendents(node: T, nodes: T[], onlyExpandable: boolean): void;\n}\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nexport declare class UniqueSelectionDispatcher implements OnDestroy {\n    private _listeners;\n    /**\n     * Notify other items that selection for the given name has been set.\n     * @param id ID of the item.\n     * @param name Name of the item.\n     */\n    notify(id: string, name: string): void;\n    /**\n     * Listen for future changes to item selection.\n     * @return Function used to deregister listener\n     */\n    listen(listener: UniqueSelectionDispatcherListener): () => void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<UniqueSelectionDispatcher, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<UniqueSelectionDispatcher>;\n}\n\nexport declare type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nexport declare const _VIEW_REPEATER_STRATEGY: InjectionToken<_ViewRepeater<unknown, unknown, _ViewRepeaterItemContext<unknown>>>;\n\n/**\n * Describes a strategy for rendering items in a {@link ViewContainerRef}.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport declare interface _ViewRepeater<T, R, C extends _ViewRepeaterItemContext<T>> {\n    applyChanges(changes: IterableChanges<R>, viewContainerRef: ViewContainerRef, itemContextFactory: _ViewRepeaterItemContextFactory<T, R, C>, itemValueResolver: _ViewRepeaterItemValueResolver<T, R>, itemViewChanged?: _ViewRepeaterItemChanged<R, C>): void;\n    detach(): void;\n}\n\n/**\n * Meta data describing the state of a view after it was updated by a\n * {@link _ViewRepeater}.\n *\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport declare interface _ViewRepeaterItemChange<R, C> {\n    /** The view's context after it was changed. */\n    context?: C;\n    /** Indicates how the view was changed. */\n    operation: _ViewRepeaterOperation;\n    /** The view's corresponding change record. */\n    record: IterableChangeRecord<R>;\n}\n\n/**\n * Type for a callback to be executed after a view has changed.\n *\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport declare type _ViewRepeaterItemChanged<R, C> = (change: _ViewRepeaterItemChange<R, C>) => void;\n\n/**\n * The context for an embedded view in the repeater's view container.\n *\n * @template T The type for the embedded view's $implicit property.\n */\nexport declare interface _ViewRepeaterItemContext<T> {\n    $implicit?: T;\n}\n\n/**\n * A factory that derives the embedded view context for an item in a view\n * container.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport declare type _ViewRepeaterItemContextFactory<T, R, C extends _ViewRepeaterItemContext<T>> = (record: IterableChangeRecord<R>, adjustedPreviousIndex: number | null, currentIndex: number | null) => _ViewRepeaterItemInsertArgs<C>;\n\n/**\n * The arguments needed to construct an embedded view for an item in a view\n * container.\n *\n * @template C The type for the context passed to each embedded view.\n */\nexport declare interface _ViewRepeaterItemInsertArgs<C> {\n    templateRef: TemplateRef<C>;\n    context?: C;\n    index?: number;\n}\n\n/**\n * Extracts the value of an item from an {@link IterableChangeRecord}.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n */\nexport declare type _ViewRepeaterItemValueResolver<T, R> = (record: IterableChangeRecord<R>) => T;\n\n/** Indicates how a view was changed by a {@link _ViewRepeater}. */\nexport declare const enum _ViewRepeaterOperation {\n    /** The content of an existing view was replaced with another item. */\n    REPLACED = 0,\n    /** A new view was created with `createEmbeddedView`. */\n    INSERTED = 1,\n    /** The position of a view changed, but the content remains the same. */\n    MOVED = 2,\n    /** A view was detached from the view container. */\n    REMOVED = 3\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/dialog/index.d.ts",
      "node_modules/@angular/cdk/dialog/index.d.ts"
    ],
    "content": "import { BasePortalOutlet } from '@angular/cdk/portal';\nimport { CdkPortalOutlet } from '@angular/cdk/portal';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ComponentRef } from '@angular/core';\nimport { ComponentType } from '@angular/cdk/overlay';\nimport { Direction } from '@angular/cdk/bidi';\nimport { DomPortal } from '@angular/cdk/portal';\nimport { ElementRef } from '@angular/core';\nimport { EmbeddedViewRef } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/cdk/overlay';\nimport * as i3 from '@angular/cdk/portal';\nimport * as i4 from '@angular/cdk/a11y';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { InteractivityChecker } from '@angular/cdk/a11y';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { OverlayContainer } from '@angular/cdk/overlay';\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { PositionStrategy } from '@angular/cdk/overlay';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { StaticProvider } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/** Options for where to set focus to automatically on dialog open */\nexport declare type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\n/**\n * Internal component that wraps user-provided dialog content.\n * @docs-private\n */\nexport declare class CdkDialogContainer<C extends DialogConfig = DialogConfig> extends BasePortalOutlet implements OnDestroy {\n    protected _elementRef: ElementRef;\n    protected _focusTrapFactory: FocusTrapFactory;\n    readonly _config: C;\n    private _interactivityChecker;\n    private _ngZone;\n    private _overlayRef;\n    private _focusMonitor?;\n    protected _document: Document;\n    /** The portal outlet inside of this container into which the dialog content will be loaded. */\n    _portalOutlet: CdkPortalOutlet;\n    /** The class that traps and manages focus within the dialog. */\n    private _focusTrap;\n    /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n    private _elementFocusedBeforeDialogWasOpened;\n    /**\n     * Type of interaction that led to the dialog being closed. This is used to determine\n     * whether the focus style will be applied when returning focus to its original location\n     * after the dialog is closed.\n     */\n    _closeInteractionType: FocusOrigin | null;\n    /** ID of the element that should be considered as the dialog's label. */\n    _ariaLabelledBy: string | null;\n    constructor(_elementRef: ElementRef, _focusTrapFactory: FocusTrapFactory, _document: any, _config: C, _interactivityChecker: InteractivityChecker, _ngZone: NgZone, _overlayRef: OverlayRef, _focusMonitor?: FocusMonitor | undefined);\n    protected _contentAttached(): void;\n    /**\n     * Can be used by child classes to customize the initial focus\n     * capturing behavior (e.g. if it's tied to an animation).\n     */\n    protected _captureInitialFocus(): void;\n    ngOnDestroy(): void;\n    /**\n     * Attach a ComponentPortal as content to this dialog container.\n     * @param portal Portal to be attached as the dialog content.\n     */\n    attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n    /**\n     * Attach a TemplatePortal as content to this dialog container.\n     * @param portal Portal to be attached as the dialog content.\n     */\n    attachTemplatePortal<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n    /**\n     * Attaches a DOM portal to the dialog container.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    attachDomPortal: (portal: DomPortal) => void;\n    /** Captures focus if it isn't already inside the dialog. */\n    _recaptureFocus(): void;\n    /**\n     * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n     * attribute to forcefully focus it. The attribute is removed after focus is moved.\n     * @param element The element to focus.\n     */\n    private _forceFocus;\n    /**\n     * Focuses the first element that matches the given selector within the focus trap.\n     * @param selector The CSS selector for the element to set focus to.\n     */\n    private _focusByCssSelector;\n    /**\n     * Moves the focus inside the focus trap. When autoFocus is not set to 'dialog', if focus\n     * cannot be moved then focus will go to the dialog container.\n     */\n    protected _trapFocus(): void;\n    /** Restores focus to the element that was focused before the dialog opened. */\n    private _restoreFocus;\n    /** Focuses the dialog container. */\n    private _focusDialogContainer;\n    /** Returns whether focus is inside the dialog. */\n    private _containsFocus;\n    /** Sets up the focus trap. */\n    private _initializeFocusTrap;\n    /** Sets up the listener that handles clicks on the dialog backdrop. */\n    private _handleBackdropClicks;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkDialogContainer<any>, [null, null, { optional: true; }, null, null, null, null, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkDialogContainer<any>, \"cdk-dialog-container\", never, {}, {}, never, never, false>;\n}\n\n/** Injection token that can be used to provide default options for the dialog module. */\nexport declare const DEFAULT_DIALOG_CONFIG: InjectionToken<DialogConfig<unknown, unknown, BasePortalOutlet>>;\n\nexport declare class Dialog implements OnDestroy {\n    private _overlay;\n    private _injector;\n    private _defaultOptions;\n    private _parentDialog;\n    private _overlayContainer;\n    private _openDialogsAtThisLevel;\n    private readonly _afterAllClosedAtThisLevel;\n    private readonly _afterOpenedAtThisLevel;\n    private _ariaHiddenElements;\n    private _scrollStrategy;\n    /** Keeps track of the currently-open dialogs. */\n    get openDialogs(): readonly DialogRef<any, any>[];\n    /** Stream that emits when a dialog has been opened. */\n    get afterOpened(): Subject<DialogRef<any, any>>;\n    /**\n     * Stream that emits when all open dialog have finished closing.\n     * Will emit on subscribe if there are no open dialogs to begin with.\n     */\n    readonly afterAllClosed: Observable<void>;\n    constructor(_overlay: Overlay, _injector: Injector, _defaultOptions: DialogConfig, _parentDialog: Dialog, _overlayContainer: OverlayContainer, scrollStrategy: any);\n    /**\n     * Opens a modal dialog containing the given component.\n     * @param component Type of the component to load into the dialog.\n     * @param config Extra configuration options.\n     * @returns Reference to the newly-opened dialog.\n     */\n    open<R = unknown, D = unknown, C = unknown>(component: ComponentType<C>, config?: DialogConfig<D, DialogRef<R, C>>): DialogRef<R, C>;\n    /**\n     * Opens a modal dialog containing the given template.\n     * @param template TemplateRef to instantiate as the dialog content.\n     * @param config Extra configuration options.\n     * @returns Reference to the newly-opened dialog.\n     */\n    open<R = unknown, D = unknown, C = unknown>(template: TemplateRef<C>, config?: DialogConfig<D, DialogRef<R, C>>): DialogRef<R, C>;\n    open<R = unknown, D = unknown, C = unknown>(componentOrTemplateRef: ComponentType<C> | TemplateRef<C>, config?: DialogConfig<D, DialogRef<R, C>>): DialogRef<R, C>;\n    /**\n     * Closes all of the currently-open dialogs.\n     */\n    closeAll(): void;\n    /**\n     * Finds an open dialog by its id.\n     * @param id ID to use when looking up the dialog.\n     */\n    getDialogById<R, C>(id: string): DialogRef<R, C> | undefined;\n    ngOnDestroy(): void;\n    /**\n     * Creates an overlay config from a dialog config.\n     * @param config The dialog configuration.\n     * @returns The overlay configuration.\n     */\n    private _getOverlayConfig;\n    /**\n     * Attaches a dialog container to a dialog's already-created overlay.\n     * @param overlay Reference to the dialog's underlying overlay.\n     * @param config The dialog configuration.\n     * @returns A promise resolving to a ComponentRef for the attached container.\n     */\n    private _attachContainer;\n    /**\n     * Attaches the user-provided component to the already-created dialog container.\n     * @param componentOrTemplateRef The type of component being loaded into the dialog,\n     *     or a TemplateRef to instantiate as the content.\n     * @param dialogRef Reference to the dialog being opened.\n     * @param dialogContainer Component that is going to wrap the dialog content.\n     * @param config Configuration used to open the dialog.\n     */\n    private _attachDialogContent;\n    /**\n     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\n     * of a dialog to close itself and, optionally, to return a value.\n     * @param config Config object that is used to construct the dialog.\n     * @param dialogRef Reference to the dialog being opened.\n     * @param dialogContainer Component that is going to wrap the dialog content.\n     * @param fallbackInjector Injector to use as a fallback when a lookup fails in the custom\n     * dialog injector, if the user didn't provide a custom one.\n     * @returns The custom injector that can be used inside the dialog.\n     */\n    private _createInjector;\n    /**\n     * Removes a dialog from the array of open dialogs.\n     * @param dialogRef Dialog to be removed.\n     * @param emitEvent Whether to emit an event if this is the last dialog.\n     */\n    private _removeOpenDialog;\n    /** Hides all of the content that isn't an overlay from assistive technology. */\n    private _hideNonDialogContentFromAssistiveTechnology;\n    private _getAfterAllClosed;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Dialog, [null, null, { optional: true; }, { optional: true; skipSelf: true; }, null, null]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Dialog>;\n}\n\n/** Injection token for the Dialog's Data. */\nexport declare const DIALOG_DATA: InjectionToken<any>;\n\n/** Injection token for the Dialog's ScrollStrategy. */\nexport declare const DIALOG_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\nexport declare const DIALOG_SCROLL_STRATEGY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\nexport declare function DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/** Additional options that can be passed in when closing a dialog. */\nexport declare interface DialogCloseOptions {\n    /** Focus original to use when restoring focus. */\n    focusOrigin?: FocusOrigin;\n}\n\n/** Configuration for opening a modal dialog. */\nexport declare class DialogConfig<D = unknown, R = unknown, C extends BasePortalOutlet = BasePortalOutlet> {\n    /**\n     * Where the attached component should live in Angular's *logical* component tree.\n     * This affects what is available for injection and the change detection order for the\n     * component instantiated inside of the dialog. This does not affect where the dialog\n     * content will be rendered.\n     */\n    viewContainerRef?: ViewContainerRef;\n    /**\n     * Injector used for the instantiation of the component to be attached. If provided,\n     * takes precedence over the injector indirectly provided by `ViewContainerRef`.\n     */\n    injector?: Injector;\n    /** ID for the dialog. If omitted, a unique one will be generated. */\n    id?: string;\n    /** The ARIA role of the dialog element. */\n    role?: DialogRole;\n    /** Optional CSS class or classes applied to the overlay panel. */\n    panelClass?: string | string[];\n    /** Whether the dialog has a backdrop. */\n    hasBackdrop?: boolean;\n    /** Optional CSS class or classes applied to the overlay backdrop. */\n    backdropClass?: string | string[];\n    /** Whether the dialog closes with the escape key or pointer events outside the panel element. */\n    disableClose?: boolean;\n    /** Width of the dialog. */\n    width?: string;\n    /** Height of the dialog. */\n    height?: string;\n    /** Min-width of the dialog. If a number is provided, assumes pixel units. */\n    minWidth?: number | string;\n    /** Min-height of the dialog. If a number is provided, assumes pixel units. */\n    minHeight?: number | string;\n    /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */\n    maxWidth?: number | string;\n    /** Max-height of the dialog. If a number is provided, assumes pixel units. */\n    maxHeight?: number | string;\n    /** Strategy to use when positioning the dialog. Defaults to centering it on the page. */\n    positionStrategy?: PositionStrategy;\n    /** Data being injected into the child component. */\n    data?: D | null;\n    /** Layout direction for the dialog's content. */\n    direction?: Direction;\n    /** ID of the element that describes the dialog. */\n    ariaDescribedBy?: string | null;\n    /** ID of the element that labels the dialog. */\n    ariaLabelledBy?: string | null;\n    /** Dialog label applied via `aria-label` */\n    ariaLabel?: string | null;\n    /** Whether this is a modal dialog. Used to set the `aria-modal` attribute. */\n    ariaModal?: boolean;\n    /**\n     * Where the dialog should focus on open.\n     * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n     * AutoFocusTarget instead.\n     */\n    autoFocus?: AutoFocusTarget | string | boolean;\n    /**\n     * Whether the dialog should restore focus to the previously-focused element upon closing.\n     * Has the following behavior based on the type that is passed in:\n     * - `boolean` - when true, will return focus to the element that was focused before the dialog\n     *    was opened, otherwise won't restore focus at all.\n     * - `string` - focus will be restored to the first element that matches the CSS selector.\n     * - `HTMLElement` - focus will be restored to the specific element.\n     */\n    restoreFocus?: boolean | string | HTMLElement;\n    /**\n     * Scroll strategy to be used for the dialog. This determines how\n     * the dialog responds to scrolling underneath the panel element.\n     */\n    scrollStrategy?: ScrollStrategy;\n    /**\n     * Whether the dialog should close when the user navigates backwards or forwards through browser\n     * history. This does not apply to navigation via anchor element unless using URL-hash based\n     * routing (`HashLocationStrategy` in the Angular router).\n     */\n    closeOnNavigation?: boolean;\n    /**\n     * Whether the dialog should close when the dialog service is destroyed. This is useful if\n     * another service is wrapping the dialog and is managing the destruction instead.\n     */\n    closeOnDestroy?: boolean;\n    /** Alternate `ComponentFactoryResolver` to use when resolving the associated component. */\n    componentFactoryResolver?: ComponentFactoryResolver;\n    /**\n     * Providers that will be exposed to the contents of the dialog. Can also\n     * be provided as a function in order to generate the providers lazily.\n     */\n    providers?: StaticProvider[] | ((dialogRef: R, config: DialogConfig<D, R, C>, container: C) => StaticProvider[]);\n    /**\n     * Component into which the dialog content will be rendered. Defaults to `CdkDialogContainer`.\n     * A configuration object can be passed in to customize the providers that will be exposed\n     * to the dialog container.\n     */\n    container?: Type<C> | {\n        type: Type<C>;\n        providers: (config: DialogConfig<D, R, C>) => StaticProvider[];\n    };\n    /**\n     * Context that will be passed to template-based dialogs.\n     * A function can be passed in to resolve the context lazily.\n     */\n    templateContext?: Record<string, any> | (() => Record<string, any>);\n}\n\nexport declare class DialogModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<DialogModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<DialogModule, [typeof i1.CdkDialogContainer], [typeof i2.OverlayModule, typeof i3.PortalModule, typeof i4.A11yModule], [typeof i3.PortalModule, typeof i1.CdkDialogContainer]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<DialogModule>;\n}\n\n/**\n * Reference to a dialog opened via the Dialog service.\n */\nexport declare class DialogRef<R = unknown, C = unknown> {\n    readonly overlayRef: OverlayRef;\n    readonly config: DialogConfig<any, DialogRef<R, C>, BasePortalOutlet>;\n    /**\n     * Instance of component opened into the dialog. Will be\n     * null when the dialog is opened using a `TemplateRef`.\n     */\n    readonly componentInstance: C | null;\n    /** Instance of the container that is rendering out the dialog content. */\n    readonly containerInstance: BasePortalOutlet & {\n        _closeInteractionType?: FocusOrigin;\n    };\n    /** Whether the user is allowed to close the dialog. */\n    disableClose: boolean | undefined;\n    /** Emits when the dialog has been closed. */\n    readonly closed: Observable<R | undefined>;\n    /** Emits when the backdrop of the dialog is clicked. */\n    readonly backdropClick: Observable<MouseEvent>;\n    /** Emits when on keyboard events within the dialog. */\n    readonly keydownEvents: Observable<KeyboardEvent>;\n    /** Emits on pointer events that happen outside of the dialog. */\n    readonly outsidePointerEvents: Observable<MouseEvent>;\n    /** Unique ID for the dialog. */\n    readonly id: string;\n    constructor(overlayRef: OverlayRef, config: DialogConfig<any, DialogRef<R, C>, BasePortalOutlet>);\n    /**\n     * Close the dialog.\n     * @param result Optional result to return to the dialog opener.\n     * @param options Additional options to customize the closing behavior.\n     */\n    close(result?: R, options?: DialogCloseOptions): void;\n    /** Updates the position of the dialog based on the current position strategy. */\n    updatePosition(): this;\n    /**\n     * Updates the dialog's width and height.\n     * @param width New width of the dialog.\n     * @param height New height of the dialog.\n     */\n    updateSize(width?: string | number, height?: string | number): this;\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes: string | string[]): this;\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes: string | string[]): this;\n}\n\n/** Valid ARIA roles for a dialog. */\nexport declare type DialogRole = 'dialog' | 'alertdialog';\n\ndeclare namespace i1 {\n    export {\n        throwDialogContentAlreadyAttachedError,\n        CdkDialogContainer\n    }\n}\n\nexport declare function throwDialogContentAlreadyAttachedError(): void;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/drag-drop/index.d.ts",
      "node_modules/@angular/cdk/drag-drop/index.d.ts"
    ],
    "content": "import { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Direction } from '@angular/cdk/bidi';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i7 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\n/**\n * Injection token that can be used to configure the\n * behavior of the drag&drop-related components.\n */\nexport declare const CDK_DRAG_CONFIG: InjectionToken<DragDropConfig>;\n\n/**\n * Injection token that can be used to reference instances of `CdkDragHandle`. It serves as\n * alternative token to the actual `CdkDragHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const CDK_DRAG_HANDLE: InjectionToken<CdkDragHandle>;\n\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * @docs-private\n */\nexport declare const CDK_DRAG_PARENT: InjectionToken<{}>;\n\n/**\n * Injection token that can be used to reference instances of `CdkDragPlaceholder`. It serves as\n * alternative token to the actual `CdkDragPlaceholder` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const CDK_DRAG_PLACEHOLDER: InjectionToken<CdkDragPlaceholder<any>>;\n\n/**\n * Injection token that can be used to reference instances of `CdkDragPreview`. It serves as\n * alternative token to the actual `CdkDragPreview` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const CDK_DRAG_PREVIEW: InjectionToken<CdkDragPreview<any>>;\n\n/**\n * Injection token that can be used to reference instances of `CdkDropList`. It serves as\n * alternative token to the actual `CdkDropList` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const CDK_DROP_LIST: InjectionToken<CdkDropList<any>>;\n\n/**\n * Injection token that can be used to reference instances of `CdkDropListGroup`. It serves as\n * alternative token to the actual `CdkDropListGroup` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const CDK_DROP_LIST_GROUP: InjectionToken<CdkDropListGroup<unknown>>;\n\n/** Element that can be moved inside a CdkDropList container. */\nexport declare class CdkDrag<T = any> implements AfterViewInit, OnChanges, OnDestroy {\n    /** Element that the draggable is attached to. */\n    element: ElementRef<HTMLElement>;\n    /** Droppable container that the draggable is a part of. */\n    dropContainer: CdkDropListInternal;\n    private _ngZone;\n    private _viewContainerRef;\n    private _dir;\n    private _changeDetectorRef;\n    private _selfHandle?;\n    private _parentDrag?;\n    private readonly _destroyed;\n    private static _dragInstances;\n    /** Reference to the underlying drag instance. */\n    _dragRef: DragRef<CdkDrag<T>>;\n    /** Elements that can be used to drag the draggable item. */\n    _handles: QueryList<CdkDragHandle>;\n    /** Element that will be used as a template to create the draggable item's preview. */\n    _previewTemplate: CdkDragPreview;\n    /** Template for placeholder element rendered to show where a draggable would be dropped. */\n    _placeholderTemplate: CdkDragPlaceholder;\n    /** Arbitrary data to attach to this drag instance. */\n    data: T;\n    /** Locks the position of the dragged element along the specified axis. */\n    lockAxis: DragAxis;\n    /**\n     * Selector that will be used to determine the root draggable element, starting from\n     * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful\n     * when trying to enable dragging on an element that you might not have access to.\n     */\n    rootElementSelector: string;\n    /**\n     * Node or selector that will be used to determine the element to which the draggable's\n     * position will be constrained. If a string is passed in, it'll be used as a selector that\n     * will be matched starting from the element's parent and going up the DOM until a match\n     * has been found.\n     */\n    boundaryElement: string | ElementRef<HTMLElement> | HTMLElement;\n    /**\n     * Amount of milliseconds to wait after the user has put their\n     * pointer down before starting to drag the element.\n     */\n    dragStartDelay: DragStartDelay;\n    /**\n     * Sets the position of a `CdkDrag` that is outside of a drop container.\n     * Can be used to restore the element's position for a returning user.\n     */\n    freeDragPosition: Point;\n    /** Whether starting to drag this element is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /**\n     * Function that can be used to customize the logic of how the position of the drag item\n     * is limited while it's being dragged. Gets called with a point containing the current position\n     * of the user's pointer on the page, a reference to the item being dragged and its dimensions.\n     * Should return a point describing where the item should be rendered.\n     */\n    constrainPosition?: (userPointerPosition: Point, dragRef: DragRef, dimensions: ClientRect, pickupPositionInElement: Point) => Point;\n    /** Class to be added to the preview element. */\n    previewClass: string | string[];\n    /**\n     * Configures the place into which the preview of the item will be inserted. Can be configured\n     * globally through `CDK_DROP_LIST`. Possible values:\n     * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that\n     * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain\n     * its inherited styles.\n     * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that\n     * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be\n     * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors\n     * like `:nth-child` and some flexbox configurations.\n     * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.\n     * Same advantages and disadvantages as `parent`.\n     */\n    previewContainer: PreviewContainer;\n    /** Emits when the user starts dragging the item. */\n    readonly started: EventEmitter<CdkDragStart>;\n    /** Emits when the user has released a drag item, before any animations have started. */\n    readonly released: EventEmitter<CdkDragRelease>;\n    /** Emits when the user stops dragging an item in the container. */\n    readonly ended: EventEmitter<CdkDragEnd>;\n    /** Emits when the user has moved the item into a new container. */\n    readonly entered: EventEmitter<CdkDragEnter<any>>;\n    /** Emits when the user removes the item its container by dragging it into another container. */\n    readonly exited: EventEmitter<CdkDragExit<any>>;\n    /** Emits when the user drops the item inside a container. */\n    readonly dropped: EventEmitter<CdkDragDrop<any>>;\n    /**\n     * Emits as the user is dragging the item. Use with caution,\n     * because this event will fire for every pixel that the user has dragged.\n     */\n    readonly moved: Observable<CdkDragMove<T>>;\n    constructor(\n    /** Element that the draggable is attached to. */\n    element: ElementRef<HTMLElement>, \n    /** Droppable container that the draggable is a part of. */\n    dropContainer: CdkDropListInternal, \n    /**\n     * @deprecated `_document` parameter no longer being used and will be removed.\n     * @breaking-change 12.0.0\n     */\n    _document: any, _ngZone: NgZone, _viewContainerRef: ViewContainerRef, config: DragDropConfig, _dir: Directionality, dragDrop: DragDrop, _changeDetectorRef: ChangeDetectorRef, _selfHandle?: CdkDragHandle | undefined, _parentDrag?: CdkDrag<any> | undefined);\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    getPlaceholderElement(): HTMLElement;\n    /** Returns the root draggable element. */\n    getRootElement(): HTMLElement;\n    /** Resets a standalone drag item to its initial position. */\n    reset(): void;\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     */\n    getFreeDragPosition(): Readonly<Point>;\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @param value New position to be set.\n     */\n    setFreeDragPosition(value: Point): void;\n    ngAfterViewInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Syncs the root element with the `DragRef`. */\n    private _updateRootElement;\n    /** Gets the boundary element, based on the `boundaryElement` value. */\n    private _getBoundaryElement;\n    /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */\n    private _syncInputs;\n    /** Handles the events from the underlying `DragRef`. */\n    private _handleEvents;\n    /** Assigns the default input values based on a provided config object. */\n    private _assignDefaults;\n    /** Sets up the listener that syncs the handles with the drag ref. */\n    private _setupHandlesListener;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkDrag<any>, [null, { optional: true; skipSelf: true; }, null, null, null, { optional: true; }, { optional: true; }, null, null, { optional: true; self: true; }, { optional: true; skipSelf: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkDrag<any>, \"[cdkDrag]\", [\"cdkDrag\"], { \"data\": \"cdkDragData\"; \"lockAxis\": \"cdkDragLockAxis\"; \"rootElementSelector\": \"cdkDragRootElement\"; \"boundaryElement\": \"cdkDragBoundary\"; \"dragStartDelay\": \"cdkDragStartDelay\"; \"freeDragPosition\": \"cdkDragFreeDragPosition\"; \"disabled\": \"cdkDragDisabled\"; \"constrainPosition\": \"cdkDragConstrainPosition\"; \"previewClass\": \"cdkDragPreviewClass\"; \"previewContainer\": \"cdkDragPreviewContainer\"; }, { \"started\": \"cdkDragStarted\"; \"released\": \"cdkDragReleased\"; \"ended\": \"cdkDragEnded\"; \"entered\": \"cdkDragEntered\"; \"exited\": \"cdkDragExited\"; \"dropped\": \"cdkDragDropped\"; \"moved\": \"cdkDragMoved\"; }, [\"_previewTemplate\", \"_placeholderTemplate\", \"_handles\"], never, false>;\n}\n\n/** Event emitted when the user drops a draggable item inside a drop container. */\nexport declare interface CdkDragDrop<T, O = T, I = any> {\n    /** Index of the item when it was picked up. */\n    previousIndex: number;\n    /** Current index of the item. */\n    currentIndex: number;\n    /** Item that is being dropped. */\n    item: CdkDrag<I>;\n    /** Container in which the item was dropped. */\n    container: CdkDropList<T>;\n    /** Container from which the item was picked up. Can be the same as the `container`. */\n    previousContainer: CdkDropList<O>;\n    /** Whether the user's pointer was over the container when the item was dropped. */\n    isPointerOverContainer: boolean;\n    /** Distance in pixels that the user has dragged since the drag sequence started. */\n    distance: {\n        x: number;\n        y: number;\n    };\n    /** Position where the pointer was when the item was dropped */\n    dropPoint: {\n        x: number;\n        y: number;\n    };\n    /** Native event that caused the drop event. */\n    event: MouseEvent | TouchEvent;\n}\n\n/** Event emitted when the user stops dragging a draggable. */\nexport declare interface CdkDragEnd<T = any> {\n    /** Draggable that emitted the event. */\n    source: CdkDrag<T>;\n    /** Distance in pixels that the user has dragged since the drag sequence started. */\n    distance: {\n        x: number;\n        y: number;\n    };\n    /** Position where the pointer was when the item was dropped */\n    dropPoint: {\n        x: number;\n        y: number;\n    };\n    /** Native event that caused the dragging to stop. */\n    event: MouseEvent | TouchEvent;\n}\n\n/** Event emitted when the user moves an item into a new drop container. */\nexport declare interface CdkDragEnter<T = any, I = T> {\n    /** Container into which the user has moved the item. */\n    container: CdkDropList<T>;\n    /** Item that was moved into the container. */\n    item: CdkDrag<I>;\n    /** Index at which the item has entered the container. */\n    currentIndex: number;\n}\n\n/**\n * Event emitted when the user removes an item from a\n * drop container by moving it into another one.\n */\nexport declare interface CdkDragExit<T = any, I = T> {\n    /** Container from which the user has a removed an item. */\n    container: CdkDropList<T>;\n    /** Item that was removed from the container. */\n    item: CdkDrag<I>;\n}\n\n/** Handle that can be used to drag a CdkDrag instance. */\nexport declare class CdkDragHandle implements OnDestroy {\n    element: ElementRef<HTMLElement>;\n    /** Closest parent draggable instance. */\n    _parentDrag: {} | undefined;\n    /** Emits when the state of the handle has changed. */\n    readonly _stateChanges: Subject<CdkDragHandle>;\n    /** Whether starting to drag through this handle is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    constructor(element: ElementRef<HTMLElement>, parentDrag?: any);\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkDragHandle, [null, { optional: true; skipSelf: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkDragHandle, \"[cdkDragHandle]\", never, { \"disabled\": \"cdkDragHandleDisabled\"; }, {}, never, never, false>;\n}\n\n/** Event emitted as the user is dragging a draggable item. */\nexport declare interface CdkDragMove<T = any> {\n    /** Item that is being dragged. */\n    source: CdkDrag<T>;\n    /** Position of the user's pointer on the page. */\n    pointerPosition: {\n        x: number;\n        y: number;\n    };\n    /** Native event that is causing the dragging. */\n    event: MouseEvent | TouchEvent;\n    /** Distance in pixels that the user has dragged since the drag sequence started. */\n    distance: {\n        x: number;\n        y: number;\n    };\n    /**\n     * Indicates the direction in which the user is dragging the element along each axis.\n     * `1` means that the position is increasing (e.g. the user is moving to the right or downwards),\n     * whereas `-1` means that it's decreasing (they're moving to the left or upwards). `0` means\n     * that the position hasn't changed.\n     */\n    delta: {\n        x: -1 | 0 | 1;\n        y: -1 | 0 | 1;\n    };\n}\n\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n */\nexport declare class CdkDragPlaceholder<T = any> {\n    templateRef: TemplateRef<T>;\n    /** Context data to be added to the placeholder template instance. */\n    data: T;\n    constructor(templateRef: TemplateRef<T>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkDragPlaceholder<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkDragPlaceholder<any>, \"ng-template[cdkDragPlaceholder]\", never, { \"data\": \"data\"; }, {}, never, never, false>;\n}\n\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n */\nexport declare class CdkDragPreview<T = any> {\n    templateRef: TemplateRef<T>;\n    /** Context data to be added to the preview template instance. */\n    data: T;\n    /** Whether the preview should preserve the same size as the item that is being dragged. */\n    get matchSize(): boolean;\n    set matchSize(value: BooleanInput);\n    private _matchSize;\n    constructor(templateRef: TemplateRef<T>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkDragPreview<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkDragPreview<any>, \"ng-template[cdkDragPreview]\", never, { \"data\": \"data\"; \"matchSize\": \"matchSize\"; }, {}, never, never, false>;\n}\n\n/** Event emitted when the user releases an item, before any animations have started. */\nexport declare interface CdkDragRelease<T = any> {\n    /** Draggable that emitted the event. */\n    source: CdkDrag<T>;\n    /** Native event that caused the release event. */\n    event: MouseEvent | TouchEvent;\n}\n\n/** Event emitted when the user swaps the position of two drag items. */\nexport declare interface CdkDragSortEvent<T = any, I = T> {\n    /** Index from which the item was sorted previously. */\n    previousIndex: number;\n    /** Index that the item is currently in. */\n    currentIndex: number;\n    /** Container that the item belongs to. */\n    container: CdkDropList<T>;\n    /** Item that is being sorted. */\n    item: CdkDrag<I>;\n}\n\n/** Event emitted when the user starts dragging a draggable. */\nexport declare interface CdkDragStart<T = any> {\n    /** Draggable that emitted the event. */\n    source: CdkDrag<T>;\n    /** Native event that started the drag sequence. */\n    event: MouseEvent | TouchEvent;\n}\n\n/** Container that wraps a set of draggable items. */\nexport declare class CdkDropList<T = any> implements OnDestroy {\n    /** Element that the drop list is attached to. */\n    element: ElementRef<HTMLElement>;\n    private _changeDetectorRef;\n    private _scrollDispatcher;\n    private _dir?;\n    private _group?;\n    /** Emits when the list has been destroyed. */\n    private readonly _destroyed;\n    /** Whether the element's scrollable parents have been resolved. */\n    private _scrollableParentsResolved;\n    /** Keeps track of the drop lists that are currently on the page. */\n    private static _dropLists;\n    /** Reference to the underlying drop list instance. */\n    _dropListRef: DropListRef<CdkDropList<T>>;\n    /**\n     * Other draggable containers that this container is connected to and into which the\n     * container's items can be transferred. Can either be references to other drop containers,\n     * or their unique IDs.\n     */\n    connectedTo: (CdkDropList | string)[] | CdkDropList | string;\n    /** Arbitrary data to attach to this container. */\n    data: T;\n    /** Direction in which the list is oriented. */\n    orientation: DropListOrientation;\n    /**\n     * Unique ID for the drop zone. Can be used as a reference\n     * in the `connectedTo` of another `CdkDropList`.\n     */\n    id: string;\n    /** Locks the position of the draggable elements inside the container along the specified axis. */\n    lockAxis: DragAxis;\n    /** Whether starting a dragging sequence from this container is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Whether sorting within this drop list is disabled. */\n    sortingDisabled: BooleanInput;\n    /**\n     * Function that is used to determine whether an item\n     * is allowed to be moved into a drop container.\n     */\n    enterPredicate: (drag: CdkDrag, drop: CdkDropList) => boolean;\n    /** Functions that is used to determine whether an item can be sorted into a particular index. */\n    sortPredicate: (index: number, drag: CdkDrag, drop: CdkDropList) => boolean;\n    /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */\n    autoScrollDisabled: BooleanInput;\n    /** Number of pixels to scroll for each frame when auto-scrolling an element. */\n    autoScrollStep: NumberInput;\n    /** Emits when the user drops an item inside the container. */\n    readonly dropped: EventEmitter<CdkDragDrop<T, any>>;\n    /**\n     * Emits when the user has moved a new drag item into this container.\n     */\n    readonly entered: EventEmitter<CdkDragEnter<T>>;\n    /**\n     * Emits when the user removes an item from the container\n     * by dragging it into another container.\n     */\n    readonly exited: EventEmitter<CdkDragExit<T>>;\n    /** Emits as the user is swapping items while actively dragging. */\n    readonly sorted: EventEmitter<CdkDragSortEvent<T>>;\n    /**\n     * Keeps track of the items that are registered with this container. Historically we used to\n     * do this with a `ContentChildren` query, however queries don't handle transplanted views very\n     * well which means that we can't handle cases like dragging the headers of a `mat-table`\n     * correctly. What we do instead is to have the items register themselves with the container\n     * and then we sort them based on their position in the DOM.\n     */\n    private _unsortedItems;\n    constructor(\n    /** Element that the drop list is attached to. */\n    element: ElementRef<HTMLElement>, dragDrop: DragDrop, _changeDetectorRef: ChangeDetectorRef, _scrollDispatcher: ScrollDispatcher, _dir?: Directionality | undefined, _group?: CdkDropListGroup<CdkDropList<any>> | undefined, config?: DragDropConfig);\n    /** Registers an items with the drop list. */\n    addItem(item: CdkDrag): void;\n    /** Removes an item from the drop list. */\n    removeItem(item: CdkDrag): void;\n    /** Gets the registered items in the list, sorted by their position in the DOM. */\n    getSortedItems(): CdkDrag[];\n    ngOnDestroy(): void;\n    /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */\n    private _setupInputSyncSubscription;\n    /** Handles events from the underlying DropListRef. */\n    private _handleEvents;\n    /** Assigns the default input values based on a provided config object. */\n    private _assignDefaults;\n    /** Syncs up the registered drag items with underlying drop list ref. */\n    private _syncItemsWithRef;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkDropList<any>, [null, null, null, null, { optional: true; }, { optional: true; skipSelf: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkDropList<any>, \"[cdkDropList], cdk-drop-list\", [\"cdkDropList\"], { \"connectedTo\": \"cdkDropListConnectedTo\"; \"data\": \"cdkDropListData\"; \"orientation\": \"cdkDropListOrientation\"; \"id\": \"id\"; \"lockAxis\": \"cdkDropListLockAxis\"; \"disabled\": \"cdkDropListDisabled\"; \"sortingDisabled\": \"cdkDropListSortingDisabled\"; \"enterPredicate\": \"cdkDropListEnterPredicate\"; \"sortPredicate\": \"cdkDropListSortPredicate\"; \"autoScrollDisabled\": \"cdkDropListAutoScrollDisabled\"; \"autoScrollStep\": \"cdkDropListAutoScrollStep\"; }, { \"dropped\": \"cdkDropListDropped\"; \"entered\": \"cdkDropListEntered\"; \"exited\": \"cdkDropListExited\"; \"sorted\": \"cdkDropListSorted\"; }, never, never, false>;\n}\n\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n */\nexport declare class CdkDropListGroup<T> implements OnDestroy {\n    /** Drop lists registered inside the group. */\n    readonly _items: Set<T>;\n    /** Whether starting a dragging sequence from inside this group is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkDropListGroup<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkDropListGroup<any>, \"[cdkDropListGroup]\", [\"cdkDropListGroup\"], { \"disabled\": \"cdkDropListGroupDisabled\"; }, {}, never, never, false>;\n}\n\n/**\n * Internal compile-time-only representation of a `CdkDropList`.\n * Used to avoid circular import issues between the `CdkDropList` and the `CdkDrag`.\n * @docs-private\n */\ndeclare interface CdkDropListInternal extends CdkDropList {\n}\n\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @param currentArray Array from which to copy the item.\n * @param targetArray Array into which is copy the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n *\n */\nexport declare function copyArrayItem<T = any>(currentArray: T[], targetArray: T[], currentIndex: number, targetIndex: number): void;\n\n/** Possible axis along which dragging can be locked. */\nexport declare type DragAxis = 'x' | 'y';\n\n/** Function that can be used to constrain the position of a dragged element. */\nexport declare type DragConstrainPosition = (point: Point, dragRef: DragRef) => Point;\n\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nexport declare class DragDrop {\n    private _document;\n    private _ngZone;\n    private _viewportRuler;\n    private _dragDropRegistry;\n    constructor(_document: any, _ngZone: NgZone, _viewportRuler: ViewportRuler, _dragDropRegistry: DragDropRegistry<DragRef, DropListRef>);\n    /**\n     * Turns an element into a draggable item.\n     * @param element Element to which to attach the dragging functionality.\n     * @param config Object used to configure the dragging behavior.\n     */\n    createDrag<T = any>(element: ElementRef<HTMLElement> | HTMLElement, config?: DragRefConfig): DragRef<T>;\n    /**\n     * Turns an element into a drop list.\n     * @param element Element to which to attach the drop list functionality.\n     */\n    createDropList<T = any>(element: ElementRef<HTMLElement> | HTMLElement): DropListRef<T>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<DragDrop, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<DragDrop>;\n}\n\n/**\n * Object that can be used to configure the drag\n * items and drop lists within a module or a component.\n */\nexport declare interface DragDropConfig extends Partial<DragRefConfig> {\n    lockAxis?: DragAxis;\n    dragStartDelay?: DragStartDelay;\n    constrainPosition?: DragConstrainPosition;\n    previewClass?: string | string[];\n    boundaryElement?: string;\n    rootElementSelector?: string;\n    draggingDisabled?: boolean;\n    sortingDisabled?: boolean;\n    listAutoScrollDisabled?: boolean;\n    listOrientation?: DropListOrientation;\n    zIndex?: number;\n    previewContainer?: 'global' | 'parent';\n}\n\nexport declare class DragDropModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<DragDropModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<DragDropModule, [typeof i1.CdkDropList, typeof i2.CdkDropListGroup, typeof i3.CdkDrag, typeof i4.CdkDragHandle, typeof i5.CdkDragPreview, typeof i6.CdkDragPlaceholder], never, [typeof i7.CdkScrollableModule, typeof i1.CdkDropList, typeof i2.CdkDropListGroup, typeof i3.CdkDrag, typeof i4.CdkDragHandle, typeof i5.CdkDragPreview, typeof i6.CdkDragPlaceholder]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<DragDropModule>;\n}\n\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * @docs-private\n */\nexport declare class DragDropRegistry<I extends {\n    isDragging(): boolean;\n}, C> implements OnDestroy {\n    private _ngZone;\n    private _document;\n    /** Registered drop container instances. */\n    private _dropInstances;\n    /** Registered drag item instances. */\n    private _dragInstances;\n    /** Drag item instances that are currently being dragged. */\n    private _activeDragInstances;\n    /** Keeps track of the event listeners that we've bound to the `document`. */\n    private _globalListeners;\n    /**\n     * Predicate function to check if an item is being dragged.  Moved out into a property,\n     * because it'll be called a lot and we don't want to create a new function every time.\n     */\n    private _draggingPredicate;\n    /**\n     * Emits the `touchmove` or `mousemove` events that are dispatched\n     * while the user is dragging a drag item instance.\n     */\n    readonly pointerMove: Subject<TouchEvent | MouseEvent>;\n    /**\n     * Emits the `touchend` or `mouseup` events that are dispatched\n     * while the user is dragging a drag item instance.\n     */\n    readonly pointerUp: Subject<TouchEvent | MouseEvent>;\n    /**\n     * Emits when the viewport has been scrolled while the user is dragging an item.\n     * @deprecated To be turned into a private member. Use the `scrolled` method instead.\n     * @breaking-change 13.0.0\n     */\n    readonly scroll: Subject<Event>;\n    constructor(_ngZone: NgZone, _document: any);\n    /** Adds a drop container to the registry. */\n    registerDropContainer(drop: C): void;\n    /** Adds a drag item instance to the registry. */\n    registerDragItem(drag: I): void;\n    /** Removes a drop container from the registry. */\n    removeDropContainer(drop: C): void;\n    /** Removes a drag item instance from the registry. */\n    removeDragItem(drag: I): void;\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param drag Drag instance which is being dragged.\n     * @param event Event that initiated the dragging.\n     */\n    startDragging(drag: I, event: TouchEvent | MouseEvent): void;\n    /** Stops dragging a drag item instance. */\n    stopDragging(drag: I): void;\n    /** Gets whether a drag item instance is currently being dragged. */\n    isDragging(drag: I): boolean;\n    /**\n     * Gets a stream that will emit when any element on the page is scrolled while an item is being\n     * dragged.\n     * @param shadowRoot Optional shadow root that the current dragging sequence started from.\n     *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can\n     *   be used to include an additional top-level listener at the shadow root level.\n     */\n    scrolled(shadowRoot?: DocumentOrShadowRoot | null): Observable<Event>;\n    ngOnDestroy(): void;\n    /**\n     * Event listener that will prevent the default browser action while the user is dragging.\n     * @param event Event whose default action should be prevented.\n     */\n    private _preventDefaultWhileDragging;\n    /** Event listener for `touchmove` that is bound even if no dragging is happening. */\n    private _persistentTouchmoveListener;\n    /** Clears out the global event listeners from the `document`. */\n    private _clearGlobalListeners;\n    static ɵfac: i0.ɵɵFactoryDeclaration<DragDropRegistry<any, any>, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<DragDropRegistry<any, any>>;\n}\n\n/** Template that can be used to create a drag helper element (e.g. a preview or a placeholder). */\ndeclare interface DragHelperTemplate<T = any> {\n    template: TemplateRef<T> | null;\n    viewContainer: ViewContainerRef;\n    context: T;\n}\n\n/** Template that can be used to create a drag preview element. */\ndeclare interface DragPreviewTemplate<T = any> extends DragHelperTemplate<T> {\n    matchSize?: boolean;\n}\n\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n */\nexport declare class DragRef<T = any> {\n    private _config;\n    private _document;\n    private _ngZone;\n    private _viewportRuler;\n    private _dragDropRegistry;\n    /** Element displayed next to the user's pointer while the element is dragged. */\n    private _preview;\n    /** Reference to the view of the preview element. */\n    private _previewRef;\n    /** Container into which to insert the preview. */\n    private _previewContainer;\n    /** Reference to the view of the placeholder element. */\n    private _placeholderRef;\n    /** Element that is rendered instead of the draggable item while it is being sorted. */\n    private _placeholder;\n    /** Coordinates within the element at which the user picked up the element. */\n    private _pickupPositionInElement;\n    /** Coordinates on the page at which the user picked up the element. */\n    private _pickupPositionOnPage;\n    /**\n     * Anchor node used to save the place in the DOM where the element was\n     * picked up so that it can be restored at the end of the drag sequence.\n     */\n    private _anchor;\n    /**\n     * CSS `transform` applied to the element when it isn't being dragged. We need a\n     * passive transform in order for the dragged element to retain its new position\n     * after the user has stopped dragging and because we need to know the relative\n     * position in case they start dragging again. This corresponds to `element.style.transform`.\n     */\n    private _passiveTransform;\n    /** CSS `transform` that is applied to the element while it's being dragged. */\n    private _activeTransform;\n    /** Inline `transform` value that the element had before the first dragging sequence. */\n    private _initialTransform?;\n    /**\n     * Whether the dragging sequence has been started. Doesn't\n     * necessarily mean that the element has been moved.\n     */\n    private _hasStartedDragging;\n    /** Whether the element has moved since the user started dragging it. */\n    private _hasMoved;\n    /** Drop container in which the DragRef resided when dragging began. */\n    private _initialContainer;\n    /** Index at which the item started in its initial container. */\n    private _initialIndex;\n    /** Cached positions of scrollable parent elements. */\n    private _parentPositions;\n    /** Emits when the item is being moved. */\n    private readonly _moveEvents;\n    /** Keeps track of the direction in which the user is dragging along each axis. */\n    private _pointerDirectionDelta;\n    /** Pointer position at which the last change in the delta occurred. */\n    private _pointerPositionAtLastDirectionChange;\n    /** Position of the pointer at the last pointer event. */\n    private _lastKnownPointerPosition;\n    /**\n     * Root DOM node of the drag instance. This is the element that will\n     * be moved around as the user is dragging.\n     */\n    private _rootElement;\n    /**\n     * Nearest ancestor SVG, relative to which coordinates are calculated if dragging SVGElement\n     */\n    private _ownerSVGElement;\n    /**\n     * Inline style value of `-webkit-tap-highlight-color` at the time the\n     * dragging was started. Used to restore the value once we're done dragging.\n     */\n    private _rootElementTapHighlight;\n    /** Subscription to pointer movement events. */\n    private _pointerMoveSubscription;\n    /** Subscription to the event that is dispatched when the user lifts their pointer. */\n    private _pointerUpSubscription;\n    /** Subscription to the viewport being scrolled. */\n    private _scrollSubscription;\n    /** Subscription to the viewport being resized. */\n    private _resizeSubscription;\n    /**\n     * Time at which the last touch event occurred. Used to avoid firing the same\n     * events multiple times on touch devices where the browser will fire a fake\n     * mouse event for each touch event, after a certain time.\n     */\n    private _lastTouchEventTime;\n    /** Time at which the last dragging sequence was started. */\n    private _dragStartTime;\n    /** Cached reference to the boundary element. */\n    private _boundaryElement;\n    /** Whether the native dragging interactions have been enabled on the root element. */\n    private _nativeInteractionsEnabled;\n    /** Client rect of the root element when the dragging sequence has started. */\n    private _initialClientRect?;\n    /** Cached dimensions of the preview element. Should be read via `_getPreviewRect`. */\n    private _previewRect?;\n    /** Cached dimensions of the boundary element. */\n    private _boundaryRect?;\n    /** Element that will be used as a template to create the draggable item's preview. */\n    private _previewTemplate?;\n    /** Template for placeholder element rendered to show where a draggable would be dropped. */\n    private _placeholderTemplate?;\n    /** Elements that can be used to drag the draggable item. */\n    private _handles;\n    /** Registered handles that are currently disabled. */\n    private _disabledHandles;\n    /** Droppable container that the draggable is a part of. */\n    private _dropContainer?;\n    /** Layout direction of the item. */\n    private _direction;\n    /** Ref that the current drag item is nested in. */\n    private _parentDragRef;\n    /**\n     * Cached shadow root that the element is placed in. `null` means that the element isn't in\n     * the shadow DOM and `undefined` means that it hasn't been resolved yet. Should be read via\n     * `_getShadowRoot`, not directly.\n     */\n    private _cachedShadowRoot;\n    /** Axis along which dragging is locked. */\n    lockAxis: 'x' | 'y';\n    /**\n     * Amount of milliseconds to wait after the user has put their\n     * pointer down before starting to drag the element.\n     */\n    dragStartDelay: number | {\n        touch: number;\n        mouse: number;\n    };\n    /** Class to be added to the preview element. */\n    previewClass: string | string[] | undefined;\n    /** Whether starting to drag this element is disabled. */\n    get disabled(): boolean;\n    set disabled(value: boolean);\n    private _disabled;\n    /** Emits as the drag sequence is being prepared. */\n    readonly beforeStarted: Subject<void>;\n    /** Emits when the user starts dragging the item. */\n    readonly started: Subject<{\n        source: DragRef;\n        event: MouseEvent | TouchEvent;\n    }>;\n    /** Emits when the user has released a drag item, before any animations have started. */\n    readonly released: Subject<{\n        source: DragRef;\n        event: MouseEvent | TouchEvent;\n    }>;\n    /** Emits when the user stops dragging an item in the container. */\n    readonly ended: Subject<{\n        source: DragRef;\n        distance: Point;\n        dropPoint: Point;\n        event: MouseEvent | TouchEvent;\n    }>;\n    /** Emits when the user has moved the item into a new container. */\n    readonly entered: Subject<{\n        container: DropListRefInternal;\n        item: DragRef;\n        currentIndex: number;\n    }>;\n    /** Emits when the user removes the item its container by dragging it into another container. */\n    readonly exited: Subject<{\n        container: DropListRefInternal;\n        item: DragRef;\n    }>;\n    /** Emits when the user drops the item inside a container. */\n    readonly dropped: Subject<{\n        previousIndex: number;\n        currentIndex: number;\n        item: DragRef;\n        container: DropListRefInternal;\n        previousContainer: DropListRefInternal;\n        distance: Point;\n        dropPoint: Point;\n        isPointerOverContainer: boolean;\n        event: MouseEvent | TouchEvent;\n    }>;\n    /**\n     * Emits as the user is dragging the item. Use with caution,\n     * because this event will fire for every pixel that the user has dragged.\n     */\n    readonly moved: Observable<{\n        source: DragRef;\n        pointerPosition: {\n            x: number;\n            y: number;\n        };\n        event: MouseEvent | TouchEvent;\n        distance: Point;\n        delta: {\n            x: -1 | 0 | 1;\n            y: -1 | 0 | 1;\n        };\n    }>;\n    /** Arbitrary data that can be attached to the drag item. */\n    data: T;\n    /**\n     * Function that can be used to customize the logic of how the position of the drag item\n     * is limited while it's being dragged. Gets called with a point containing the current position\n     * of the user's pointer on the page, a reference to the item being dragged and its dimensions.\n     * Should return a point describing where the item should be rendered.\n     */\n    constrainPosition?: (userPointerPosition: Point, dragRef: DragRef, dimensions: ClientRect, pickupPositionInElement: Point) => Point;\n    constructor(element: ElementRef<HTMLElement> | HTMLElement, _config: DragRefConfig, _document: Document, _ngZone: NgZone, _viewportRuler: ViewportRuler, _dragDropRegistry: DragDropRegistry<DragRef, DropListRefInternal>);\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    getPlaceholderElement(): HTMLElement;\n    /** Returns the root draggable element. */\n    getRootElement(): HTMLElement;\n    /**\n     * Gets the currently-visible element that represents the drag item.\n     * While dragging this is the placeholder, otherwise it's the root element.\n     */\n    getVisibleElement(): HTMLElement;\n    /** Registers the handles that can be used to drag the element. */\n    withHandles(handles: (HTMLElement | ElementRef<HTMLElement>)[]): this;\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @param template Template that from which to stamp out the preview.\n     */\n    withPreviewTemplate(template: DragPreviewTemplate | null): this;\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @param template Template that from which to stamp out the placeholder.\n     */\n    withPlaceholderTemplate(template: DragHelperTemplate | null): this;\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     */\n    withRootElement(rootElement: ElementRef<HTMLElement> | HTMLElement): this;\n    /**\n     * Element to which the draggable's position will be constrained.\n     */\n    withBoundaryElement(boundaryElement: ElementRef<HTMLElement> | HTMLElement | null): this;\n    /** Sets the parent ref that the ref is nested in.  */\n    withParent(parent: DragRef<unknown> | null): this;\n    /** Removes the dragging functionality from the DOM element. */\n    dispose(): void;\n    /** Checks whether the element is currently being dragged. */\n    isDragging(): boolean;\n    /** Resets a standalone drag item to its initial position. */\n    reset(): void;\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param handle Handle element that should be disabled.\n     */\n    disableHandle(handle: HTMLElement): void;\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param handle Handle element to be enabled.\n     */\n    enableHandle(handle: HTMLElement): void;\n    /** Sets the layout direction of the draggable item. */\n    withDirection(direction: Direction): this;\n    /** Sets the container that the item is part of. */\n    _withDropContainer(container: DropListRefInternal): void;\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     */\n    getFreeDragPosition(): Readonly<Point>;\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @param value New position to be set.\n     */\n    setFreeDragPosition(value: Point): this;\n    /**\n     * Sets the container into which to insert the preview element.\n     * @param value Container into which to insert the preview.\n     */\n    withPreviewContainer(value: PreviewContainer): this;\n    /** Updates the item's sort order based on the last-known pointer position. */\n    _sortFromLastPointerPosition(): void;\n    /** Unsubscribes from the global subscriptions. */\n    private _removeSubscriptions;\n    /** Destroys the preview element and its ViewRef. */\n    private _destroyPreview;\n    /** Destroys the placeholder element and its ViewRef. */\n    private _destroyPlaceholder;\n    /** Handler for the `mousedown`/`touchstart` events. */\n    private _pointerDown;\n    /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */\n    private _pointerMove;\n    /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */\n    private _pointerUp;\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @param event Browser event object that ended the sequence.\n     */\n    private _endDragSequence;\n    /** Starts the dragging sequence. */\n    private _startDragSequence;\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @param referenceElement Element that started the drag sequence.\n     * @param event Browser event object that started the sequence.\n     */\n    private _initializeDragSequence;\n    /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */\n    private _cleanupDragArtifacts;\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     */\n    private _updateActiveDropContainer;\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     */\n    private _createPreviewElement;\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @returns Promise that resolves when the animation completes.\n     */\n    private _animatePreviewToPlaceholder;\n    /** Creates an element that will be shown instead of the current element while dragging. */\n    private _createPlaceholderElement;\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @param referenceElement Element that initiated the dragging.\n     * @param event Event that initiated the dragging.\n     */\n    private _getPointerPositionInElement;\n    /** Determines the point of the page that was touched by the user. */\n    private _getPointerPositionOnPage;\n    /** Gets the pointer position on the page, accounting for any position constraints. */\n    private _getConstrainedPointerPosition;\n    /** Updates the current drag delta, based on the user's current pointer position on the page. */\n    private _updatePointerDirectionDelta;\n    /** Toggles the native drag interactions, based on how many handles are registered. */\n    private _toggleNativeDragInteractions;\n    /** Removes the manually-added event listeners from the root element. */\n    private _removeRootElementListeners;\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @param x New transform value along the X axis.\n     * @param y New transform value along the Y axis.\n     */\n    private _applyRootElementTransform;\n    /**\n     * Applies a `transform` to the preview, taking into account any existing transforms on it.\n     * @param x New transform value along the X axis.\n     * @param y New transform value along the Y axis.\n     */\n    private _applyPreviewTransform;\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @param currentPosition Current position of the user's pointer.\n     */\n    private _getDragDistance;\n    /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */\n    private _cleanupCachedDimensions;\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     */\n    private _containInsideBoundaryOnResize;\n    /** Gets the drag start delay, based on the event type. */\n    private _getDragStartDelay;\n    /** Updates the internal state of the draggable element when scrolling has occurred. */\n    private _updateOnScroll;\n    /** Gets the scroll position of the viewport. */\n    private _getViewportScrollPosition;\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    private _getShadowRoot;\n    /** Gets the element into which the drag preview should be inserted. */\n    private _getPreviewInsertionPoint;\n    /** Lazily resolves and returns the dimensions of the preview. */\n    private _getPreviewRect;\n    /** Handles a native `dragstart` event. */\n    private _nativeDragStart;\n    /** Gets a handle that is the target of an event. */\n    private _getTargetHandle;\n}\n\n/** Object that can be used to configure the behavior of DragRef. */\nexport declare interface DragRefConfig {\n    /**\n     * Minimum amount of pixels that the user should\n     * drag, before the CDK initiates a drag sequence.\n     */\n    dragStartThreshold: number;\n    /**\n     * Amount the pixels the user should drag before the CDK\n     * considers them to have changed the drag direction.\n     */\n    pointerDirectionChangeThreshold: number;\n    /** `z-index` for the absolutely-positioned elements that are created by the drag item. */\n    zIndex?: number;\n    /** Ref that the current drag item is nested in. */\n    parentDragRef?: DragRef;\n}\n\n/**\n * Internal compile-time-only representation of a `DragRef`.\n * Used to avoid circular import issues between the `DragRef` and the `DropListRef`.\n * @docs-private\n */\ndeclare interface DragRefInternal extends DragRef {\n}\n\n/** Possible values that can be used to configure the drag start delay. */\nexport declare type DragStartDelay = number | {\n    touch: number;\n    mouse: number;\n};\n\n/** Possible orientations for a drop list. */\nexport declare type DropListOrientation = 'horizontal' | 'vertical';\n\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n */\nexport declare class DropListRef<T = any> {\n    private _dragDropRegistry;\n    private _ngZone;\n    private _viewportRuler;\n    /** Element that the drop list is attached to. */\n    element: HTMLElement | ElementRef<HTMLElement>;\n    /** Whether starting a dragging sequence from this container is disabled. */\n    disabled: boolean;\n    /** Whether sorting items within the list is disabled. */\n    sortingDisabled: boolean;\n    /** Locks the position of the draggable elements inside the container along the specified axis. */\n    lockAxis: 'x' | 'y';\n    /**\n     * Whether auto-scrolling the view when the user\n     * moves their pointer close to the edges is disabled.\n     */\n    autoScrollDisabled: boolean;\n    /** Number of pixels to scroll for each frame when auto-scrolling an element. */\n    autoScrollStep: number;\n    /**\n     * Function that is used to determine whether an item\n     * is allowed to be moved into a drop container.\n     */\n    enterPredicate: (drag: DragRefInternal, drop: DropListRef) => boolean;\n    /** Function that is used to determine whether an item can be sorted into a particular index. */\n    sortPredicate: (index: number, drag: DragRefInternal, drop: DropListRef) => boolean;\n    /** Emits right before dragging has started. */\n    readonly beforeStarted: Subject<void>;\n    /**\n     * Emits when the user has moved a new drag item into this container.\n     */\n    readonly entered: Subject<{\n        item: DragRefInternal;\n        container: DropListRef;\n        currentIndex: number;\n    }>;\n    /**\n     * Emits when the user removes an item from the container\n     * by dragging it into another container.\n     */\n    readonly exited: Subject<{\n        item: DragRefInternal;\n        container: DropListRef;\n    }>;\n    /** Emits when the user drops an item inside the container. */\n    readonly dropped: Subject<{\n        item: DragRefInternal;\n        currentIndex: number;\n        previousIndex: number;\n        container: DropListRef;\n        previousContainer: DropListRef;\n        isPointerOverContainer: boolean;\n        distance: Point;\n        dropPoint: Point;\n        event: MouseEvent | TouchEvent;\n    }>;\n    /** Emits as the user is swapping items while actively dragging. */\n    readonly sorted: Subject<{\n        previousIndex: number;\n        currentIndex: number;\n        container: DropListRef;\n        item: DragRefInternal;\n    }>;\n    /** Arbitrary data that can be attached to the drop list. */\n    data: T;\n    /** Whether an item in the list is being dragged. */\n    private _isDragging;\n    /** Keeps track of the positions of any parent scrollable elements. */\n    private _parentPositions;\n    /** Strategy being used to sort items within the list. */\n    private _sortStrategy;\n    /** Cached `ClientRect` of the drop list. */\n    private _clientRect;\n    /** Draggable items in the container. */\n    private _draggables;\n    /** Drop lists that are connected to the current one. */\n    private _siblings;\n    /** Connected siblings that currently have a dragged item. */\n    private _activeSiblings;\n    /** Subscription to the window being scrolled. */\n    private _viewportScrollSubscription;\n    /** Vertical direction in which the list is currently scrolling. */\n    private _verticalScrollDirection;\n    /** Horizontal direction in which the list is currently scrolling. */\n    private _horizontalScrollDirection;\n    /** Node that is being auto-scrolled. */\n    private _scrollNode;\n    /** Used to signal to the current auto-scroll sequence when to stop. */\n    private readonly _stopScrollTimers;\n    /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */\n    private _cachedShadowRoot;\n    /** Reference to the document. */\n    private _document;\n    /** Elements that can be scrolled while the user is dragging. */\n    private _scrollableElements;\n    /** Initial value for the element's `scroll-snap-type` style. */\n    private _initialScrollSnap;\n    constructor(element: ElementRef<HTMLElement> | HTMLElement, _dragDropRegistry: DragDropRegistry<DragRefInternal, DropListRef>, _document: any, _ngZone: NgZone, _viewportRuler: ViewportRuler);\n    /** Removes the drop list functionality from the DOM element. */\n    dispose(): void;\n    /** Whether an item from this list is currently being dragged. */\n    isDragging(): boolean;\n    /** Starts dragging an item. */\n    start(): void;\n    /**\n     * Attempts to move an item into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param index Index at which the item entered. If omitted, the container will try to figure it\n     *   out automatically.\n     */\n    enter(item: DragRefInternal, pointerX: number, pointerY: number, index?: number): void;\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param item Item that was dragged out.\n     */\n    exit(item: DragRefInternal): void;\n    /**\n     * Drops an item into this container.\n     * @param item Item being dropped into the container.\n     * @param currentIndex Index at which the item should be inserted.\n     * @param previousIndex Index of the item when dragging started.\n     * @param previousContainer Container from which the item got dragged in.\n     * @param isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param distance Distance the user has dragged since the start of the dragging sequence.\n     * @param event Event that triggered the dropping sequence.\n     *\n     * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.\n     */\n    drop(item: DragRefInternal, currentIndex: number, previousIndex: number, previousContainer: DropListRef, isPointerOverContainer: boolean, distance: Point, dropPoint: Point, event?: MouseEvent | TouchEvent): void;\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @param items Items that are a part of this list.\n     */\n    withItems(items: DragRefInternal[]): this;\n    /** Sets the layout direction of the drop list. */\n    withDirection(direction: Direction): this;\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @param connectedTo Other containers that the current containers should be connected to.\n     */\n    connectedTo(connectedTo: DropListRef[]): this;\n    /**\n     * Sets the orientation of the container.\n     * @param orientation New orientation for the container.\n     */\n    withOrientation(orientation: 'vertical' | 'horizontal'): this;\n    /**\n     * Sets which parent elements are can be scrolled while the user is dragging.\n     * @param elements Elements that can be scrolled.\n     */\n    withScrollableParents(elements: HTMLElement[]): this;\n    /** Gets the scrollable parents that are registered with this drop container. */\n    getScrollableParents(): readonly HTMLElement[];\n    /**\n     * Figures out the index of an item in the container.\n     * @param item Item whose index should be determined.\n     */\n    getItemIndex(item: DragRefInternal): number;\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     */\n    isReceiving(): boolean;\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    _sortItem(item: DragRefInternal, pointerX: number, pointerY: number, pointerDelta: {\n        x: number;\n        y: number;\n    }): void;\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param pointerX User's pointer position along the x axis.\n     * @param pointerY User's pointer position along the y axis.\n     */\n    _startScrollingIfNecessary(pointerX: number, pointerY: number): void;\n    /** Stops any currently-running auto-scroll sequences. */\n    _stopScrolling(): void;\n    /** Starts the dragging sequence within the list. */\n    private _draggingStarted;\n    /** Caches the positions of the configured scrollable parents. */\n    private _cacheParentPositions;\n    /** Resets the container to its initial state. */\n    private _reset;\n    /** Starts the interval that'll auto-scroll the element. */\n    private _startScrollInterval;\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param x Pointer position along the X axis.\n     * @param y Pointer position along the Y axis.\n     */\n    _isOverContainer(x: number, y: number): boolean;\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param item Drag item that is being moved.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _getSiblingContainerFromPosition(item: DragRefInternal, x: number, y: number): DropListRef | undefined;\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param item Item that is being dragged into the list.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _canReceive(item: DragRefInternal, x: number, y: number): boolean;\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param sibling Sibling in which dragging has started.\n     */\n    _startReceiving(sibling: DropListRef, items: DragRefInternal[]): void;\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param sibling Sibling whose dragging has stopped.\n     */\n    _stopReceiving(sibling: DropListRef): void;\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     */\n    private _listenToScrollEvents;\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    private _getShadowRoot;\n    /** Notifies any siblings that may potentially receive the item. */\n    private _notifyReceivingSiblings;\n}\n\n/**\n * Internal compile-time-only representation of a `DropListRef`.\n * Used to avoid circular import issues between the `DropListRef` and the `DragRef`.\n * @docs-private\n */\ndeclare interface DropListRefInternal extends DropListRef {\n}\n\ndeclare namespace i1 {\n    export {\n        CdkDropListInternal,\n        CDK_DROP_LIST,\n        CdkDropList\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        CDK_DROP_LIST_GROUP,\n        CdkDropListGroup\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        CdkDrag\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        CDK_DRAG_HANDLE,\n        CdkDragHandle\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        CDK_DRAG_PREVIEW,\n        CdkDragPreview\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        CDK_DRAG_PLACEHOLDER,\n        CdkDragPlaceholder\n    }\n}\n\n\n/**\n * Moves an item one index in an array to another.\n * @param array Array in which to move the item.\n * @param fromIndex Starting index of the item.\n * @param toIndex Index to which the item should be moved.\n */\nexport declare function moveItemInArray<T = any>(array: T[], fromIndex: number, toIndex: number): void;\n\n/** Point on the page or within an element. */\nexport declare interface Point {\n    x: number;\n    y: number;\n}\n\n/**\n * Possible places into which the preview of a drag item can be inserted.\n * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that\n * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain\n * its inherited styles.\n * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that\n * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be\n * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors\n * like `:nth-child` and some flexbox configurations.\n * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.\n * Same advantages and disadvantages as `parent`.\n */\nexport declare type PreviewContainer = 'global' | 'parent' | ElementRef<HTMLElement> | HTMLElement;\n\n/**\n * Moves an item from one array to another.\n * @param currentArray Array from which to transfer the item.\n * @param targetArray Array into which to put the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n */\nexport declare function transferArrayItem<T = any>(currentArray: T[], targetArray: T[], currentIndex: number, targetIndex: number): void;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/index.d.ts",
      "node_modules/@angular/cdk/index.d.ts"
    ],
    "content": "import { Version } from '@angular/core';\n\n/** Current version of the Angular Component Development Kit. */\nexport declare const VERSION: Version;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/keycodes/index.d.ts",
      "node_modules/@angular/cdk/keycodes/index.d.ts"
    ],
    "content": "export declare const A = 65;\n\nexport declare const ALT = 18;\n\nexport declare const APOSTROPHE = 192;\n\nexport declare const AT_SIGN = 64;\n\nexport declare const B = 66;\n\nexport declare const BACKSLASH = 220;\n\nexport declare const BACKSPACE = 8;\n\nexport declare const C = 67;\n\nexport declare const CAPS_LOCK = 20;\n\nexport declare const CLOSE_SQUARE_BRACKET = 221;\n\nexport declare const COMMA = 188;\n\nexport declare const CONTEXT_MENU = 93;\n\nexport declare const CONTROL = 17;\n\nexport declare const D = 68;\n\nexport declare const DASH = 189;\n\nexport declare const DELETE = 46;\n\nexport declare const DOWN_ARROW = 40;\n\nexport declare const E = 69;\n\nexport declare const EIGHT = 56;\n\nexport declare const END = 35;\n\nexport declare const ENTER = 13;\n\nexport declare const EQUALS = 187;\n\nexport declare const ESCAPE = 27;\n\nexport declare const F = 70;\n\nexport declare const F1 = 112;\n\nexport declare const F10 = 121;\n\nexport declare const F11 = 122;\n\nexport declare const F12 = 123;\n\nexport declare const F2 = 113;\n\nexport declare const F3 = 114;\n\nexport declare const F4 = 115;\n\nexport declare const F5 = 116;\n\nexport declare const F6 = 117;\n\nexport declare const F7 = 118;\n\nexport declare const F8 = 119;\n\nexport declare const F9 = 120;\n\nexport declare const FF_EQUALS = 61;\n\nexport declare const FF_MINUS = 173;\n\nexport declare const FF_MUTE = 181;\n\nexport declare const FF_SEMICOLON = 59;\n\nexport declare const FF_VOLUME_DOWN = 182;\n\nexport declare const FF_VOLUME_UP = 183;\n\nexport declare const FIRST_MEDIA = 166;\n\nexport declare const FIVE = 53;\n\nexport declare const FOUR = 52;\n\nexport declare const G = 71;\n\nexport declare const H = 72;\n\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nexport declare function hasModifierKey(event: KeyboardEvent, ...modifiers: ModifierKey[]): boolean;\n\nexport declare const HOME = 36;\n\nexport declare const I = 73;\n\nexport declare const INSERT = 45;\n\nexport declare const J = 74;\n\nexport declare const K = 75;\n\nexport declare const L = 76;\n\nexport declare const LAST_MEDIA = 183;\n\nexport declare const LEFT_ARROW = 37;\n\nexport declare const M = 77;\n\n\nexport declare const MAC_ENTER = 3;\n\nexport declare const MAC_META = 224;\n\nexport declare const MAC_WK_CMD_LEFT = 91;\n\nexport declare const MAC_WK_CMD_RIGHT = 93;\n\nexport declare const META = 91;\n\n\ndeclare type ModifierKey = 'altKey' | 'shiftKey' | 'ctrlKey' | 'metaKey';\n\nexport declare const MUTE = 173;\n\nexport declare const N = 78;\n\nexport declare const NINE = 57;\n\nexport declare const NUM_CENTER = 12;\n\nexport declare const NUM_LOCK = 144;\n\nexport declare const NUMPAD_DIVIDE = 111;\n\nexport declare const NUMPAD_EIGHT = 104;\n\nexport declare const NUMPAD_FIVE = 101;\n\nexport declare const NUMPAD_FOUR = 100;\n\nexport declare const NUMPAD_MINUS = 109;\n\nexport declare const NUMPAD_MULTIPLY = 106;\n\nexport declare const NUMPAD_NINE = 105;\n\nexport declare const NUMPAD_ONE = 97;\n\nexport declare const NUMPAD_PERIOD = 110;\n\nexport declare const NUMPAD_PLUS = 107;\n\nexport declare const NUMPAD_SEVEN = 103;\n\nexport declare const NUMPAD_SIX = 102;\n\nexport declare const NUMPAD_THREE = 99;\n\nexport declare const NUMPAD_TWO = 98;\n\nexport declare const NUMPAD_ZERO = 96;\n\nexport declare const O = 79;\n\nexport declare const ONE = 49;\n\nexport declare const OPEN_SQUARE_BRACKET = 219;\n\nexport declare const P = 80;\n\nexport declare const PAGE_DOWN = 34;\n\nexport declare const PAGE_UP = 33;\n\nexport declare const PAUSE = 19;\n\nexport declare const PERIOD = 190;\n\nexport declare const PLUS_SIGN = 43;\n\nexport declare const PRINT_SCREEN = 44;\n\nexport declare const Q = 81;\n\nexport declare const QUESTION_MARK = 63;\n\nexport declare const R = 82;\n\nexport declare const RIGHT_ARROW = 39;\n\nexport declare const S = 83;\n\nexport declare const SCROLL_LOCK = 145;\n\nexport declare const SEMICOLON = 186;\n\nexport declare const SEVEN = 55;\n\nexport declare const SHIFT = 16;\n\nexport declare const SINGLE_QUOTE = 222;\n\nexport declare const SIX = 54;\n\nexport declare const SLASH = 191;\n\nexport declare const SPACE = 32;\n\nexport declare const T = 84;\n\nexport declare const TAB = 9;\n\nexport declare const THREE = 51;\n\nexport declare const TILDE = 192;\n\nexport declare const TWO = 50;\n\nexport declare const U = 85;\n\nexport declare const UP_ARROW = 38;\n\nexport declare const V = 86;\n\nexport declare const VOLUME_DOWN = 174;\n\nexport declare const VOLUME_UP = 175;\n\nexport declare const W = 87;\n\nexport declare const X = 88;\n\nexport declare const Y = 89;\n\nexport declare const Z = 90;\n\nexport declare const ZERO = 48;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/layout/index.d.ts",
      "node_modules/@angular/cdk/layout/index.d.ts"
    ],
    "content": "import * as i0 from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\n\n/** Utility for checking the matching state of @media queries. */\nexport declare class BreakpointObserver implements OnDestroy {\n    private _mediaMatcher;\n    private _zone;\n    /**  A map of all media queries currently being listened for. */\n    private _queries;\n    /** A subject for all other observables to takeUntil based on. */\n    private readonly _destroySubject;\n    constructor(_mediaMatcher: MediaMatcher, _zone: NgZone);\n    /** Completes the active subject, signalling to all other observables to complete. */\n    ngOnDestroy(): void;\n    /**\n     * Whether one or more media queries match the current viewport size.\n     * @param value One or more media queries to check.\n     * @returns Whether any of the media queries match.\n     */\n    isMatched(value: string | readonly string[]): boolean;\n    /**\n     * Gets an observable of results for the given queries that will emit new results for any changes\n     * in matching of the given queries.\n     * @param value One or more media queries to check.\n     * @returns A stream of matches for the given queries.\n     */\n    observe(value: string | readonly string[]): Observable<BreakpointState>;\n    /** Registers a specific query to be listened for. */\n    private _registerQuery;\n    static ɵfac: i0.ɵɵFactoryDeclaration<BreakpointObserver, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<BreakpointObserver>;\n}\n\n\nexport declare const Breakpoints: {\n    XSmall: string;\n    Small: string;\n    Medium: string;\n    Large: string;\n    XLarge: string;\n    Handset: string;\n    Tablet: string;\n    Web: string;\n    HandsetPortrait: string;\n    TabletPortrait: string;\n    WebPortrait: string;\n    HandsetLandscape: string;\n    TabletLandscape: string;\n    WebLandscape: string;\n};\n\n/** The current state of a layout breakpoint. */\nexport declare interface BreakpointState {\n    /** Whether the breakpoint is currently matching. */\n    matches: boolean;\n    /**\n     * A key boolean pair for each query provided to the observe method,\n     * with its current matched state.\n     */\n    breakpoints: {\n        [key: string]: boolean;\n    };\n}\n\nexport declare class LayoutModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<LayoutModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<LayoutModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<LayoutModule>;\n}\n\n/** A utility for calling matchMedia queries. */\nexport declare class MediaMatcher {\n    private _platform;\n    /** The internal matchMedia method to return back a MediaQueryList like object. */\n    private _matchMedia;\n    constructor(_platform: Platform);\n    /**\n     * Evaluates the given media query and returns the native MediaQueryList from which results\n     * can be retrieved.\n     * Confirms the layout engine will trigger for the selector query provided and returns the\n     * MediaQueryList for the query provided.\n     */\n    matchMedia(query: string): MediaQueryList;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MediaMatcher, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MediaMatcher>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/listbox/index.d.ts",
      "node_modules/@angular/cdk/listbox/index.d.ts"
    ],
    "content": "import { AbstractControl } from '@angular/forms';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { AfterContentInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { Highlightable } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport { ListKeyManagerOption } from '@angular/cdk/a11y';\nimport { OnDestroy } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { Subject } from 'rxjs';\nimport { ValidationErrors } from '@angular/forms';\nimport { Validator } from '@angular/forms';\n\nexport declare class CdkListbox<T = unknown> implements AfterContentInit, OnDestroy, ControlValueAccessor, Validator {\n    /** The id of the option's host element. */\n    get id(): string;\n    set id(value: string);\n    private _id;\n    private _generatedId;\n    /** The tabindex to use when the listbox is enabled. */\n    get enabledTabIndex(): number | null;\n    set enabledTabIndex(value: number | null);\n    private _enabledTabIndex?;\n    /** The value selected in the listbox, represented as an array of option values. */\n    get value(): readonly T[];\n    set value(value: readonly T[]);\n    /**\n     * Whether the listbox allows multiple options to be selected. If the value switches from `true`\n     * to `false`, and more than one option is selected, all options are deselected.\n     */\n    get multiple(): boolean;\n    set multiple(value: BooleanInput);\n    /** Whether the listbox is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Whether the listbox will use active descendant or will move focus onto the options. */\n    get useActiveDescendant(): boolean;\n    set useActiveDescendant(shouldUseActiveDescendant: BooleanInput);\n    private _useActiveDescendant;\n    /** The orientation of the listbox. Only affects keyboard interaction, not visual layout. */\n    get orientation(): 'horizontal' | 'vertical';\n    set orientation(value: 'horizontal' | 'vertical');\n    private _orientation;\n    /** The function used to compare option values. */\n    get compareWith(): undefined | ((o1: T, o2: T) => boolean);\n    set compareWith(fn: undefined | ((o1: T, o2: T) => boolean));\n    /**\n     * Whether the keyboard navigation should wrap when the user presses arrow down on the last item\n     * or arrow up on the first item.\n     */\n    get navigationWrapDisabled(): BooleanInput;\n    set navigationWrapDisabled(wrap: BooleanInput);\n    private _navigationWrapDisabled;\n    /** Whether keyboard navigation should skip over disabled items. */\n    get navigateDisabledOptions(): BooleanInput;\n    set navigateDisabledOptions(skip: BooleanInput);\n    private _navigateDisabledOptions;\n    /** Emits when the selected value(s) in the listbox change. */\n    readonly valueChange: Subject<ListboxValueChangeEvent<T>>;\n    /** The child options in this listbox. */\n    protected options: QueryList<CdkOption<T>>;\n    /** The selection model used by the listbox. */\n    protected selectionModel: ListboxSelectionModel<T>;\n    /** The key manager that manages keyboard navigation for this listbox. */\n    protected listKeyManager: ActiveDescendantKeyManager<CdkOption<T>>;\n    /** Emits when the listbox is destroyed. */\n    protected readonly destroyed: Subject<void>;\n    /** The host element of the listbox. */\n    protected readonly element: HTMLElement;\n    /** The change detector for this listbox. */\n    protected readonly changeDetectorRef: ChangeDetectorRef;\n    /** Whether the currently selected value in the selection model is invalid. */\n    private _invalid;\n    /** The last user-triggered option. */\n    private _lastTriggered;\n    /** Callback called when the listbox has been touched */\n    private _onTouched;\n    /** Callback called when the listbox value changes */\n    private _onChange;\n    /** Callback called when the form validator changes. */\n    private _onValidatorChange;\n    /** Emits when an option has been clicked. */\n    private _optionClicked;\n    /** The directionality of the page. */\n    private readonly _dir;\n    /** A predicate that skips disabled options. */\n    private readonly _skipDisabledPredicate;\n    /** A predicate that does not skip any options. */\n    private readonly _skipNonePredicate;\n    /**\n     * Validator that produces an error if multiple values are selected in a single selection\n     * listbox.\n     * @param control The control to validate\n     * @return A validation error or null\n     */\n    private _validateUnexpectedMultipleValues;\n    /**\n     * Validator that produces an error if any selected values are not valid options for this listbox.\n     * @param control The control to validate\n     * @return A validation error or null\n     */\n    private _validateUnexpectedOptionValues;\n    /** The combined set of validators for this listbox. */\n    private _validators;\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Toggle the selected state of the given option.\n     * @param option The option to toggle\n     */\n    toggle(option: CdkOption<T>): void;\n    /**\n     * Toggle the selected state of the given value.\n     * @param value The value to toggle\n     */\n    toggleValue(value: T): void;\n    /**\n     * Select the given option.\n     * @param option The option to select\n     */\n    select(option: CdkOption<T>): void;\n    /**\n     * Select the given value.\n     * @param value The value to select\n     */\n    selectValue(value: T): void;\n    /**\n     * Deselect the given option.\n     * @param option The option to deselect\n     */\n    deselect(option: CdkOption<T>): void;\n    /**\n     * Deselect the given value.\n     * @param value The value to deselect\n     */\n    deselectValue(value: T): void;\n    /**\n     * Set the selected state of all options.\n     * @param isSelected The new selected state to set\n     */\n    setAllSelected(isSelected: boolean): void;\n    /**\n     * Get whether the given option is selected.\n     * @param option The option to get the selected state of\n     */\n    isSelected(option: CdkOption<T>): boolean;\n    /**\n     * Get whether the given value is selected.\n     * @param value The value to get the selected state of\n     */\n    isValueSelected(value: T): boolean;\n    /**\n     * Registers a callback to be invoked when the listbox's value changes from user input.\n     * @param fn The callback to register\n     * @docs-private\n     */\n    registerOnChange(fn: (value: readonly T[]) => void): void;\n    /**\n     * Registers a callback to be invoked when the listbox is blurred by the user.\n     * @param fn The callback to register\n     * @docs-private\n     */\n    registerOnTouched(fn: () => {}): void;\n    /**\n     * Sets the listbox's value.\n     * @param value The new value of the listbox\n     * @docs-private\n     */\n    writeValue(value: readonly T[]): void;\n    /**\n     * Sets the disabled state of the listbox.\n     * @param isDisabled The new disabled state\n     * @docs-private\n     */\n    setDisabledState(isDisabled: boolean): void;\n    /**\n     * Validate the given control\n     * @docs-private\n     */\n    validate(control: AbstractControl<any, any>): ValidationErrors | null;\n    /**\n     * Registers a callback to be called when the form validator changes.\n     * @param fn The callback to call\n     * @docs-private\n     */\n    registerOnValidatorChange(fn: () => void): void;\n    /** Focus the listbox's host element. */\n    focus(): void;\n    /**\n     * Triggers the given option in response to user interaction.\n     * - In single selection mode: selects the option and deselects any other selected option.\n     * - In multi selection mode: toggles the selected state of the option.\n     * @param option The option to trigger\n     */\n    protected triggerOption(option: CdkOption<T> | null): void;\n    /**\n     * Trigger the given range of options in response to user interaction.\n     * Should only be called in multi-selection mode.\n     * @param trigger The option that was triggered\n     * @param from The start index of the options to toggle\n     * @param to The end index of the options to toggle\n     * @param on Whether to toggle the option range on\n     */\n    protected triggerRange(trigger: CdkOption<T> | null, from: number, to: number, on: boolean): void;\n    /**\n     * Sets the given option as active.\n     * @param option The option to make active\n     */\n    _setActiveOption(option: CdkOption<T>): void;\n    /** Called when the listbox receives focus. */\n    protected _handleFocus(): void;\n    /** Called when the user presses keydown on the listbox. */\n    protected _handleKeydown(event: KeyboardEvent): void;\n    /**\n     * Called when the focus leaves an element in the listbox.\n     * @param event The focusout event\n     */\n    protected _handleFocusOut(event: FocusEvent): void;\n    /** Get the id of the active option if active descendant is being used. */\n    protected _getAriaActiveDescendant(): string | null | undefined;\n    /** Get the tabindex for the listbox. */\n    protected _getTabIndex(): number | null;\n    /** Initialize the key manager. */\n    private _initKeyManager;\n    /** Focus the active option. */\n    private _focusActiveOption;\n    /**\n     * Set the selected values.\n     * @param value The list of new selected values.\n     */\n    private _setSelection;\n    /** Update the internal value of the listbox based on the selection model. */\n    private _updateInternalValue;\n    /**\n     * Gets the index of the given value in the given list of options.\n     * @param cache The cache of indices found so far\n     * @param value The value to find\n     * @return The index of the value in the options list\n     */\n    private _getIndexForValue;\n    /**\n     * Handle the user clicking an option.\n     * @param option The option that was clicked.\n     */\n    private _handleOptionClicked;\n    /** Verifies that no two options represent the same value under the compareWith function. */\n    private _verifyNoOptionValueCollisions;\n    /**\n     * Coerces a value into an array representing a listbox selection.\n     * @param value The value to coerce\n     * @return An array\n     */\n    private _coerceValue;\n    /**\n     * Get the sublist of values that do not represent valid option values in this listbox.\n     * @param values The list of values\n     * @return The sublist of values that are not valid option values\n     */\n    private _getInvalidOptionValues;\n    /** Get the index of the last triggered option. */\n    private _getLastTriggeredIndex;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkListbox<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkListbox<any>, \"[cdkListbox]\", [\"cdkListbox\"], { \"id\": \"id\"; \"enabledTabIndex\": \"tabindex\"; \"value\": \"cdkListboxValue\"; \"multiple\": \"cdkListboxMultiple\"; \"disabled\": \"cdkListboxDisabled\"; \"useActiveDescendant\": \"cdkListboxUseActiveDescendant\"; \"orientation\": \"cdkListboxOrientation\"; \"compareWith\": \"cdkListboxCompareWith\"; \"navigationWrapDisabled\": \"cdkListboxNavigationWrapDisabled\"; \"navigateDisabledOptions\": \"cdkListboxNavigatesDisabledOptions\"; }, { \"valueChange\": \"cdkListboxValueChange\"; }, [\"options\"], never, false>;\n}\n\nexport declare class CdkListboxModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkListboxModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkListboxModule, [typeof i1.CdkListbox, typeof i1.CdkOption], never, [typeof i1.CdkListbox, typeof i1.CdkOption]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<CdkListboxModule>;\n}\n\n/** A selectable option in a listbox. */\nexport declare class CdkOption<T = unknown> implements ListKeyManagerOption, Highlightable, OnDestroy {\n    /** The id of the option's host element. */\n    get id(): string;\n    set id(value: string);\n    private _id;\n    private _generatedId;\n    /** The value of this option. */\n    value: T;\n    /**\n     * The text used to locate this item during listbox typeahead. If not specified,\n     * the `textContent` of the item will be used.\n     */\n    typeaheadLabel: string;\n    /** Whether this option is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** The tabindex of the option when it is enabled. */\n    get enabledTabIndex(): number | null;\n    set enabledTabIndex(value: number | null);\n    private _enabledTabIndex?;\n    /** The option's host element */\n    readonly element: HTMLElement;\n    /** The parent listbox this option belongs to. */\n    protected readonly listbox: CdkListbox<T>;\n    /** Emits when the option is destroyed. */\n    protected destroyed: Subject<void>;\n    /** Emits when the option is clicked. */\n    readonly _clicked: Subject<MouseEvent>;\n    /** Whether the option is currently active. */\n    private _active;\n    ngOnDestroy(): void;\n    /** Whether this option is selected. */\n    isSelected(): boolean;\n    /** Whether this option is active. */\n    isActive(): boolean;\n    /** Toggle the selected state of this option. */\n    toggle(): void;\n    /** Select this option if it is not selected. */\n    select(): void;\n    /** Deselect this option if it is selected. */\n    deselect(): void;\n    /** Focus this option. */\n    focus(): void;\n    /** Get the label for this element which is required by the FocusableOption interface. */\n    getLabel(): string;\n    /**\n     * Set the option as active.\n     * @docs-private\n     */\n    setActiveStyles(): void;\n    /**\n     * Set the option as inactive.\n     * @docs-private\n     */\n    setInactiveStyles(): void;\n    /** Handle focus events on the option. */\n    protected _handleFocus(): void;\n    /** Get the tabindex for this option. */\n    protected _getTabIndex(): number | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkOption<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkOption<any>, \"[cdkOption]\", [\"cdkOption\"], { \"id\": \"id\"; \"value\": \"cdkOption\"; \"typeaheadLabel\": \"cdkOptionTypeaheadLabel\"; \"disabled\": \"cdkOptionDisabled\"; \"enabledTabIndex\": \"tabindex\"; }, {}, never, never, false>;\n}\n\ndeclare namespace i1 {\n    export {\n        CdkOption,\n        CdkListbox,\n        ListboxValueChangeEvent\n    }\n}\n\n/**\n * An implementation of SelectionModel that internally always represents the selection as a\n * multi-selection. This is necessary so that we can recover the full selection if the user\n * switches the listbox from single-selection to multi-selection after initialization.\n *\n * This selection model may report multiple selected values, even if it is in single-selection\n * mode. It is up to the user (CdkListbox) to check for invalid selections.\n */\ndeclare class ListboxSelectionModel<T> extends SelectionModel<T> {\n    multiple: boolean;\n    constructor(multiple?: boolean, initiallySelectedValues?: T[], emitChanges?: boolean, compareWith?: (o1: T, o2: T) => boolean);\n    isMultipleSelection(): boolean;\n    select(...values: T[]): boolean | void;\n}\n\n/** Change event that is fired whenever the value of the listbox changes. */\nexport declare interface ListboxValueChangeEvent<T> {\n    /** The new value of the listbox. */\n    readonly value: readonly T[];\n    /** Reference to the listbox that emitted the event. */\n    readonly listbox: CdkListbox<T>;\n    /** Reference to the option that was triggered. */\n    readonly option: CdkOption<T> | null;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/menu/index.d.ts",
      "node_modules/@angular/cdk/menu/index.d.ts"
    ],
    "content": "import { AfterContentInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ConnectedPosition } from '@angular/cdk/overlay';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i10 from '@angular/cdk/overlay';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Optional } from '@angular/core';\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { QueryList } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/** Injection token used to return classes implementing the Menu interface */\nexport declare const CDK_MENU: InjectionToken<Menu>;\n\n/**\n * A directive that opens a menu when a user right-clicks within its host element.\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\n */\nexport declare class CdkContextMenuTrigger extends CdkMenuTriggerBase implements OnDestroy {\n    /** The CDK overlay service. */\n    private readonly _overlay;\n    /** The directionality of the page. */\n    private readonly _directionality;\n    /** The app's context menu tracking registry */\n    private readonly _contextMenuTracker;\n    /** Whether the context menu is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    constructor();\n    /**\n     * Open the attached menu at the specified location.\n     * @param coordinates where to open the context menu\n     */\n    open(coordinates: ContextMenuCoordinates): void;\n    /** Close the currently opened context menu. */\n    close(): void;\n    /**\n     * Open the context menu and closes any previously open menus.\n     * @param event the mouse event which opens the context menu.\n     */\n    _openOnContextMenu(event: MouseEvent): void;\n    /**\n     * Get the configuration object used to create the overlay.\n     * @param coordinates the location to place the opened menu\n     */\n    private _getOverlayConfig;\n    /**\n     * Get the position strategy for the overlay which specifies where to place the menu.\n     * @param coordinates the location to place the opened menu\n     */\n    private _getOverlayPositionStrategy;\n    /** Subscribe to the menu stack close events and close this menu when requested. */\n    private _setMenuStackCloseListener;\n    /**\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n     * click occurs outside the menus.\n     * @param ignoreFirstAuxClick Whether to ignore the first auxclick event outside the menu.\n     */\n    private _subscribeToOutsideClicks;\n    /**\n     * Open the attached menu at the specified location.\n     * @param coordinates where to open the context menu\n     * @param ignoreFirstOutsideAuxClick Whether to ignore the first auxclick outside the menu after opening.\n     */\n    private _open;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkContextMenuTrigger, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkContextMenuTrigger, \"[cdkContextMenuTriggerFor]\", [\"cdkContextMenuTriggerFor\"], { \"menuTemplateRef\": \"cdkContextMenuTriggerFor\"; \"menuPosition\": \"cdkContextMenuPosition\"; \"disabled\": \"cdkContextMenuDisabled\"; }, { \"opened\": \"cdkContextMenuOpened\"; \"closed\": \"cdkContextMenuClosed\"; }, never, never, false>;\n}\n\n/**\n * Directive which configures the element as a Menu which should contain child elements marked as\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\n * contains accessible keyboard and mouse handling logic.\n *\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\n */\nexport declare class CdkMenu extends CdkMenuBase implements AfterContentInit, OnDestroy {\n    private _parentTrigger;\n    /** Event emitted when the menu is closed. */\n    readonly closed: EventEmitter<void>;\n    /** The direction items in the menu flow. */\n    readonly orientation = \"vertical\";\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n    readonly isInline: boolean;\n    constructor();\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Handle keyboard events for the Menu.\n     * @param event The keyboard event to be handled.\n     */\n    _handleKeyEvent(event: KeyboardEvent): void;\n    /**\n     * Set focus the either the current, previous or next item based on the FocusNext event.\n     * @param focusNext The element to focus.\n     */\n    private _toggleMenuFocus;\n    /** Subscribe to the MenuStack emptied events. */\n    private _subscribeToMenuStackEmptied;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenu, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenu, \"[cdkMenu]\", [\"cdkMenu\"], {}, { \"closed\": \"closed\"; }, never, never, false>;\n}\n\n/**\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\n * this directive is applied to should contain components marked with CdkMenuItem.\n *\n */\nexport declare class CdkMenuBar extends CdkMenuBase implements AfterContentInit {\n    /** The direction items in the menu flow. */\n    readonly orientation = \"horizontal\";\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n    readonly isInline = true;\n    ngAfterContentInit(): void;\n    /**\n     * Handle keyboard events for the Menu.\n     * @param event The keyboard event to be handled.\n     */\n    _handleKeyEvent(event: KeyboardEvent): void;\n    /**\n     * Set focus to either the current, previous or next item based on the FocusNext event, then\n     * open the previous or next item.\n     * @param focusNext The element to focus.\n     */\n    private _toggleOpenMenu;\n    /** Subscribe to the MenuStack emptied events. */\n    private _subscribeToMenuStackEmptied;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuBar, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuBar, \"[cdkMenuBar]\", [\"cdkMenuBar\"], {}, {}, never, never, false>;\n}\n\n/**\n * Abstract directive that implements shared logic common to all menus.\n * This class can be extended to create custom menu types.\n */\nexport declare abstract class CdkMenuBase extends CdkMenuGroup implements Menu, AfterContentInit, OnDestroy {\n    /** The menu's native DOM host element. */\n    readonly nativeElement: HTMLElement;\n    /** The Angular zone. */\n    protected ngZone: NgZone;\n    /** The stack of menus this menu belongs to. */\n    readonly menuStack: MenuStack;\n    /** The menu aim service used by this menu. */\n    protected readonly menuAim: MenuAim | null;\n    /** The directionality (text direction) of the current page. */\n    protected readonly dir: Directionality | null;\n    /** The id of the menu's host element. */\n    id: string;\n    /** All child MenuItem elements nested in this Menu. */\n    readonly items: QueryList<CdkMenuItem>;\n    /** The direction items in the menu flow. */\n    orientation: 'horizontal' | 'vertical';\n    /**\n     * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\n     * user triggers with a trigger element).\n     */\n    isInline: boolean;\n    /** Handles keyboard events for the menu. */\n    protected keyManager: FocusKeyManager<CdkMenuItem>;\n    /** Emits when the MenuBar is destroyed. */\n    protected readonly destroyed: Subject<void>;\n    /** The Menu Item which triggered the open submenu. */\n    protected triggerItem?: CdkMenuItem;\n    /** Tracks the users mouse movements over the menu. */\n    protected pointerTracker?: PointerFocusTracker<CdkMenuItem>;\n    /** Whether this menu's menu stack has focus. */\n    private _menuStackHasFocus;\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Place focus on the first MenuItem in the menu and set the focus origin.\n     * @param focusOrigin The origin input mode of the focus event.\n     */\n    focusFirstItem(focusOrigin?: FocusOrigin): void;\n    /**\n     * Place focus on the last MenuItem in the menu and set the focus origin.\n     * @param focusOrigin The origin input mode of the focus event.\n     */\n    focusLastItem(focusOrigin?: FocusOrigin): void;\n    /** Gets the tabindex for this menu. */\n    _getTabIndex(): 0 | -1 | null;\n    /**\n     * Close the open menu if the current active item opened the requested MenuStackItem.\n     * @param menu The menu requested to be closed.\n     * @param options Options to configure the behavior on close.\n     *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\n     */\n    protected closeOpenMenu(menu: MenuStackItem, options?: {\n        focusParentTrigger?: boolean;\n    }): void;\n    /** Setup the FocusKeyManager with the correct orientation for the menu. */\n    private _setKeyManager;\n    /**\n     * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\n     * and stop tracking it when the menu is closed.\n     */\n    private _subscribeToMenuOpen;\n    /** Subscribe to the MenuStack close events. */\n    private _subscribeToMenuStackClosed;\n    /** Subscribe to the MenuStack hasFocus events. */\n    private _subscribeToMenuStackHasFocus;\n    /**\n     * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\n     * with the latest menu item under mouse focus.\n     */\n    private _setUpPointerTracker;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuBase, never, never, { \"id\": \"id\"; }, {}, [\"items\"], never, false>;\n}\n\n/**\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\n */\nexport declare class CdkMenuGroup {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuGroup, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuGroup, \"[cdkMenuGroup]\", [\"cdkMenuGroup\"], {}, {}, never, never, false>;\n}\n\n/**\n * Directive which provides the ability for an element to be focused and navigated to using the\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\n * behavior when clicked.\n */\nexport declare class CdkMenuItem implements FocusableOption, FocusableElement, Toggler, OnDestroy {\n    /** The directionality (text direction) of the current page. */\n    protected readonly _dir: Directionality | null;\n    /** The menu's native DOM host element. */\n    readonly _elementRef: ElementRef<HTMLElement>;\n    /** The Angular zone. */\n    protected _ngZone: NgZone;\n    /** The menu aim service used by this menu. */\n    private readonly _menuAim;\n    /** The stack of menus this menu belongs to. */\n    private readonly _menuStack;\n    /** The parent menu in which this menuitem resides. */\n    private readonly _parentMenu;\n    /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\n    private readonly _menuTrigger;\n    /**  Whether the CdkMenuItem is disabled - defaults to false */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /**\n     * The text used to locate this item during menu typeahead. If not specified,\n     * the `textContent` of the item will be used.\n     */\n    typeaheadLabel: string | null;\n    /**\n     * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\n     * event.\n     */\n    readonly triggered: EventEmitter<void>;\n    /** Whether the menu item opens a menu. */\n    readonly hasMenu: boolean;\n    /**\n     * The tabindex for this menu item managed internally and used for implementing roving a\n     * tab index.\n     */\n    _tabindex: 0 | -1;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n    protected closeOnSpacebarTrigger: boolean;\n    /** Emits when the menu item is destroyed. */\n    protected readonly destroyed: Subject<void>;\n    constructor();\n    ngOnDestroy(): void;\n    /** Place focus on the element. */\n    focus(): void;\n    /**\n     * If the menu item is not disabled and the element does not have a menu trigger attached, emit\n     * on the cdkMenuItemTriggered emitter and close all open menus.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n    trigger(options?: {\n        keepOpen: boolean;\n    }): void;\n    /** Return true if this MenuItem has an attached menu and it is open. */\n    isMenuOpen(): boolean;\n    /**\n     * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\n     * @return the menu if it is open, otherwise undefined.\n     */\n    getMenu(): Menu | undefined;\n    /** Get the CdkMenuTrigger associated with this element. */\n    getMenuTrigger(): CdkMenuTrigger | null;\n    /** Get the label for this element which is required by the FocusableOption interface. */\n    getLabel(): string;\n    /** Reset the tabindex to -1. */\n    _resetTabIndex(): void;\n    /**\n     * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\n     * is not in a menu bar.\n     */\n    _setTabIndex(event?: MouseEvent): void;\n    /**\n     * Handles keyboard events for the menu item, specifically either triggering the user defined\n     * callback or opening/closing the current menu based on whether the left or right arrow key was\n     * pressed.\n     * @param event the keyboard event to handle\n     */\n    _onKeydown(event: KeyboardEvent): void;\n    /** Whether this menu item is standalone or within a menu or menu bar. */\n    private _isStandaloneItem;\n    /**\n     * Handles the user pressing the back arrow key.\n     * @param event The keyboard event.\n     */\n    private _backArrowPressed;\n    /**\n     * Handles the user pressing the forward arrow key.\n     * @param event The keyboard event.\n     */\n    private _forwardArrowPressed;\n    /**\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n     * into.\n     */\n    private _setupMouseEnter;\n    /**\n     * Return true if the enclosing parent menu is configured in a horizontal orientation, false\n     * otherwise or if no parent.\n     */\n    private _isParentVertical;\n    /** Sets the `type` attribute of the menu item. */\n    private _setType;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItem, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItem, \"[cdkMenuItem]\", [\"cdkMenuItem\"], { \"disabled\": \"cdkMenuItemDisabled\"; \"typeaheadLabel\": \"cdkMenuitemTypeaheadLabel\"; }, { \"triggered\": \"cdkMenuItemTriggered\"; }, never, never, false>;\n}\n\n/**\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\n * conventional checkbox.\n */\nexport declare class CdkMenuItemCheckbox extends CdkMenuItemSelectable {\n    /**\n     * Toggle the checked state of the checkbox.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n    trigger(options?: {\n        keepOpen: boolean;\n    }): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemCheckbox, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemCheckbox, \"[cdkMenuItemCheckbox]\", [\"cdkMenuItemCheckbox\"], {}, {}, never, never, false>;\n}\n\n/**\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\n */\nexport declare class CdkMenuItemRadio extends CdkMenuItemSelectable implements OnDestroy {\n    /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\n    private readonly _selectionDispatcher;\n    /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\n    private _id;\n    /** Function to unregister the selection dispatcher */\n    private _removeDispatcherListener;\n    constructor();\n    ngOnDestroy(): void;\n    /**\n     * Toggles the checked state of the radio-button.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n    trigger(options?: {\n        keepOpen: boolean;\n    }): void;\n    /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\n    private _registerDispatcherListener;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemRadio, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemRadio, \"[cdkMenuItemRadio]\", [\"cdkMenuItemRadio\"], {}, {}, never, never, false>;\n}\n\n/** Base class providing checked state for selectable MenuItems. */\nexport declare abstract class CdkMenuItemSelectable extends CdkMenuItem {\n    /** Whether the element is checked */\n    get checked(): boolean;\n    set checked(value: BooleanInput);\n    private _checked;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n    protected closeOnSpacebarTrigger: boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemSelectable, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemSelectable, never, never, { \"checked\": \"cdkMenuItemChecked\"; }, {}, never, never, false>;\n}\n\n/** Module that declares components and directives for the CDK menu. */\nexport declare class CdkMenuModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkMenuModule, [typeof i1.CdkMenuBar, typeof i2.CdkMenu, typeof i3.CdkMenuItem, typeof i4.CdkMenuItemRadio, typeof i5.CdkMenuItemCheckbox, typeof i6.CdkMenuTrigger, typeof i7.CdkMenuGroup, typeof i8.CdkContextMenuTrigger, typeof i9.CdkTargetMenuAim], [typeof i10.OverlayModule], [typeof i1.CdkMenuBar, typeof i2.CdkMenu, typeof i3.CdkMenuItem, typeof i4.CdkMenuItemRadio, typeof i5.CdkMenuItemCheckbox, typeof i6.CdkMenuTrigger, typeof i7.CdkMenuGroup, typeof i8.CdkContextMenuTrigger, typeof i9.CdkTargetMenuAim]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<CdkMenuModule>;\n}\n\n/**\n * A directive that turns its host element into a trigger for a popup menu.\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\n * state.\n */\nexport declare class CdkMenuTrigger extends CdkMenuTriggerBase implements OnDestroy {\n    /** The host element. */\n    private readonly _elementRef;\n    /** The CDK overlay service. */\n    private readonly _overlay;\n    /** The Angular zone. */\n    private readonly _ngZone;\n    /** The parent menu this trigger belongs to. */\n    private readonly _parentMenu;\n    /** The menu aim service used by this menu. */\n    private readonly _menuAim;\n    /** The directionality of the page. */\n    private readonly _directionality;\n    constructor();\n    /** Toggle the attached menu. */\n    toggle(): void;\n    /** Open the attached menu. */\n    open(): void;\n    /** Close the opened menu. */\n    close(): void;\n    /**\n     * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\n     */\n    getMenu(): Menu | undefined;\n    /**\n     * Handles keyboard events for the menu item.\n     * @param event The keyboard event to handle\n     */\n    _toggleOnKeydown(event: KeyboardEvent): void;\n    /**\n     * Sets whether the trigger's menu stack has focus.\n     * @param hasFocus Whether the menu stack has focus.\n     */\n    _setHasFocus(hasFocus: boolean): void;\n    /**\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n     * into.\n     */\n    private _subscribeToMouseEnter;\n    /** Close out any sibling menu trigger menus. */\n    private _closeSiblingTriggers;\n    /** Get the configuration object used to create the overlay. */\n    private _getOverlayConfig;\n    /** Build the position strategy for the overlay which specifies where to place the menu. */\n    private _getOverlayPositionStrategy;\n    /** Get the preferred positions for the opened menu relative to the menu item. */\n    private _getOverlayPositions;\n    /**\n     * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\n     * this triggers when requested.\n     */\n    private _registerCloseHandler;\n    /**\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n     * click occurs outside the menus.\n     */\n    private _subscribeToOutsideClicks;\n    /** Subscribe to the MenuStack hasFocus events. */\n    private _subscribeToMenuStackHasFocus;\n    /** Subscribe to the MenuStack closed events. */\n    private _subscribeToMenuStackClosed;\n    /** Sets the role attribute for this trigger if needed. */\n    private _setRole;\n    /** Sets thte `type` attribute of the trigger. */\n    private _setType;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuTrigger, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuTrigger, \"[cdkMenuTriggerFor]\", [\"cdkMenuTriggerFor\"], { \"menuTemplateRef\": \"cdkMenuTriggerFor\"; \"menuPosition\": \"cdkMenuPosition\"; }, { \"opened\": \"cdkMenuOpened\"; \"closed\": \"cdkMenuClosed\"; }, never, never, false>;\n}\n\n/**\n * Abstract directive that implements shared logic common to all menu triggers.\n * This class can be extended to create custom menu trigger types.\n */\nexport declare abstract class CdkMenuTriggerBase implements OnDestroy {\n    /** The DI injector for this component. */\n    readonly injector: Injector;\n    /** The view container ref for this component */\n    protected readonly viewContainerRef: ViewContainerRef;\n    /** The menu stack in which this menu resides. */\n    protected readonly menuStack: MenuStack;\n    /**\n     * A list of preferred menu positions to be used when constructing the\n     * `FlexibleConnectedPositionStrategy` for this trigger's menu.\n     */\n    menuPosition: ConnectedPosition[];\n    /** Emits when the attached menu is requested to open */\n    readonly opened: EventEmitter<void>;\n    /** Emits when the attached menu is requested to close */\n    readonly closed: EventEmitter<void>;\n    /** Template reference variable to the menu this trigger opens */\n    menuTemplateRef: TemplateRef<unknown>;\n    /** A reference to the overlay which manages the triggered menu */\n    protected overlayRef: OverlayRef | null;\n    /** Emits when this trigger is destroyed. */\n    protected readonly destroyed: Subject<void>;\n    /** Emits when the outside pointer events listener on the overlay should be stopped. */\n    protected readonly stopOutsideClicksListener: Observable<void>;\n    /** The child menu opened by this trigger. */\n    protected childMenu?: Menu;\n    /** The content of the menu panel opened by this trigger. */\n    private _menuPortal;\n    /** The injector to use for the child menu opened by this trigger. */\n    private _childMenuInjector?;\n    ngOnDestroy(): void;\n    /** Whether the attached menu is open. */\n    isOpen(): boolean;\n    /** Registers a child menu as having been opened by this trigger. */\n    registerChildMenu(child: Menu): void;\n    /**\n     * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\n     * content to change dynamically and be reflected in the application.\n     */\n    protected getMenuContentPortal(): TemplatePortal<any>;\n    /**\n     * Whether the given element is inside the scope of this trigger's menu stack.\n     * @param element The element to check.\n     * @return Whether the element is inside the scope of this trigger's menu stack.\n     */\n    protected isElementInsideMenuStack(element: Element): boolean;\n    /** Destroy and unset the overlay reference it if exists */\n    private _destroyOverlay;\n    /** Gets the injector to use when creating a child menu. */\n    private _getChildMenuInjector;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuTriggerBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuTriggerBase, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\n */\nexport declare class CdkTargetMenuAim {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTargetMenuAim, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTargetMenuAim, \"[cdkTargetMenuAim]\", [\"cdkTargetMenuAim\"], {}, {}, never, never, false>;\n}\n\n/** Options that can be provided to the close or closeAll methods. */\nexport declare interface CloseOptions {\n    /** The element to focus next if the close operation causes the menu stack to become empty. */\n    focusNextOnEmpty?: FocusNext;\n    /** Whether to focus the parent trigger after closing the menu. */\n    focusParentTrigger?: boolean;\n}\n\n/** The coordinates where the context menu should open. */\nexport declare type ContextMenuCoordinates = {\n    x: number;\n    y: number;\n};\n\n/** Tracks the last open context menu trigger across the entire application. */\nexport declare class ContextMenuTracker {\n    /** The last open context menu trigger. */\n    private static _openContextMenuTrigger?;\n    /**\n     * Close the previous open context menu and set the given one as being open.\n     * @param trigger The trigger for the currently open Context Menu.\n     */\n    update(trigger: CdkContextMenuTrigger): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ContextMenuTracker, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ContextMenuTracker>;\n}\n\n/** Item to track for mouse focus events. */\nexport declare interface FocusableElement {\n    /** A reference to the element to be tracked. */\n    _elementRef: ElementRef<HTMLElement>;\n}\n\n/** The relative item in the inline menu to focus after closing all popup menus. */\nexport declare const enum FocusNext {\n    nextItem = 0,\n    previousItem = 1,\n    currentItem = 2\n}\n\ndeclare namespace i1 {\n    export {\n        CdkMenuBar\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        CdkMenu\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        CdkMenuItem\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        CdkMenuItemRadio\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        CdkMenuItemCheckbox\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        CdkMenuTrigger\n    }\n}\n\ndeclare namespace i7 {\n    export {\n        CdkMenuGroup\n    }\n}\n\ndeclare namespace i8 {\n    export {\n        ContextMenuTracker,\n        ContextMenuCoordinates,\n        CdkContextMenuTrigger\n    }\n}\n\ndeclare namespace i9 {\n    export {\n        MenuAim,\n        MENU_AIM,\n        Toggler,\n        TargetMenuAim,\n        CdkTargetMenuAim\n    }\n}\n\n/** Interface which specifies Menu operations and used to break circular dependency issues */\nexport declare interface Menu extends MenuStackItem {\n    /** The id of the menu's host element. */\n    id: string;\n    /** The menu's native DOM host element. */\n    nativeElement: HTMLElement;\n    /** The direction items in the menu flow. */\n    readonly orientation: 'horizontal' | 'vertical';\n    /** Place focus on the first MenuItem in the menu. */\n    focusFirstItem(focusOrigin: FocusOrigin): void;\n    /** Place focus on the last MenuItem in the menu. */\n    focusLastItem(focusOrigin: FocusOrigin): void;\n}\n\n/** Injection token used for an implementation of MenuAim. */\nexport declare const MENU_AIM: InjectionToken<MenuAim>;\n\n/** Injection token used for an implementation of MenuStack. */\nexport declare const MENU_STACK: InjectionToken<MenuStack>;\n\n/** Injection token used for an implementation of MenuStack. */\nexport declare const MENU_TRIGGER: InjectionToken<CdkMenuTriggerBase>;\n\n/**\n * MenuAim is responsible for determining if a sibling menuitem's menu should be closed when a\n * Toggler item is hovered into. It is up to the hovered in item to call the MenuAim service in\n * order to determine if it may perform its close actions.\n */\nexport declare interface MenuAim {\n    /**\n     * Set the Menu and its PointerFocusTracker.\n     * @param menu The menu that this menu aim service controls.\n     * @param pointerTracker The `PointerFocusTracker` for the given menu.\n     */\n    initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>): void;\n    /**\n     * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n     * the submenu.\n     * @param doToggle the function called when the user is not moving towards the submenu.\n     */\n    toggle(doToggle: () => void): void;\n}\n\n/**\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\n * from the `empty` observable specifying the next focus action which the listener should perform\n * as requested by the closer.\n */\nexport declare class MenuStack {\n    /** The ID of this menu stack. */\n    readonly id: string;\n    /** All MenuStackItems tracked by this MenuStack. */\n    private readonly _elements;\n    /** Emits the element which was popped off of the stack when requested by a closer. */\n    private readonly _close;\n    /** Emits once the MenuStack has become empty after popping off elements. */\n    private readonly _empty;\n    /** Emits whether any menu in the menu stack has focus. */\n    private readonly _hasFocus;\n    /** Observable which emits the MenuStackItem which has been requested to close. */\n    readonly closed: Observable<MenuStackCloseEvent>;\n    /** Observable which emits whether any menu in the menu stack has focus. */\n    readonly hasFocus: Observable<boolean>;\n    /**\n     * Observable which emits when the MenuStack is empty after popping off the last element. It\n     * emits a FocusNext event which specifies the action the closer has requested the listener\n     * perform.\n     */\n    readonly emptied: Observable<FocusNext | undefined>;\n    /**\n     * Whether the inline menu associated with this menu stack is vertical or horizontal.\n     * `null` indicates there is no inline menu associated with this menu stack.\n     */\n    private _inlineMenuOrientation;\n    /** Creates a menu stack that originates from an inline menu. */\n    static inline(orientation: 'vertical' | 'horizontal'): MenuStack;\n    /**\n     * Adds an item to the menu stack.\n     * @param menu the MenuStackItem to put on the stack.\n     */\n    push(menu: MenuStackItem): void;\n    /**\n     * Pop items off of the stack up to and including `lastItem` and emit each on the close\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n     * @param lastItem the last item to pop off the stack.\n     * @param options Options that configure behavior on close.\n     */\n    close(lastItem: MenuStackItem, options?: CloseOptions): void;\n    /**\n     * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n     * @param lastItem the element which should be left on the stack\n     * @return whether or not an item was removed from the stack\n     */\n    closeSubMenuOf(lastItem: MenuStackItem): boolean;\n    /**\n     * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\n     * @param options Options that configure behavior on close.\n     */\n    closeAll(options?: CloseOptions): void;\n    /** Return true if this stack is empty. */\n    isEmpty(): boolean;\n    /** Return the length of the stack. */\n    length(): number;\n    /** Get the top most element on the stack. */\n    peek(): MenuStackItem | undefined;\n    /** Whether the menu stack is associated with an inline menu. */\n    hasInlineMenu(): boolean;\n    /** The orientation of the associated inline menu. */\n    inlineMenuOrientation(): \"vertical\" | \"horizontal\" | null;\n    /** Sets whether the menu stack contains the focused element. */\n    setHasFocus(hasFocus: boolean): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MenuStack, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MenuStack>;\n}\n\n/** Event dispatched when a menu is closed. */\nexport declare interface MenuStackCloseEvent {\n    /** The menu being closed. */\n    item: MenuStackItem;\n    /** Whether to focus the parent trigger after closing the menu. */\n    focusParentTrigger?: boolean;\n}\n\n/** A single item (menu) in the menu stack. */\nexport declare interface MenuStackItem {\n    /** A reference to the menu stack this menu stack item belongs to. */\n    menuStack?: MenuStack;\n}\n\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\nexport declare const PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER: (orientation: 'vertical' | 'horizontal') => {\n    provide: InjectionToken<MenuStack>;\n    deps: Optional[][];\n    useFactory: (parentMenuStack?: MenuStack) => MenuStack;\n};\n\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\nexport declare const PARENT_OR_NEW_MENU_STACK_PROVIDER: {\n    provide: InjectionToken<MenuStack>;\n    deps: Optional[][];\n    useFactory: (parentMenuStack?: MenuStack) => MenuStack;\n};\n\n/**\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\n * observables which emit when the users mouse enters and leaves a tracked element.\n */\nexport declare class PointerFocusTracker<T extends FocusableElement> {\n    /** The list of items being tracked. */\n    private readonly _items;\n    /** Emits when an element is moused into. */\n    readonly entered: Observable<T>;\n    /** Emits when an element is moused out. */\n    readonly exited: Observable<T>;\n    /** The element currently under mouse focus. */\n    activeElement?: T;\n    /** The element previously under mouse focus. */\n    previousElement?: T;\n    /** Emits when this is destroyed. */\n    private readonly _destroyed;\n    constructor(\n    /** The list of items being tracked. */\n    _items: QueryList<T>);\n    /** Stop the managers listeners. */\n    destroy(): void;\n    /**\n     * Gets a stream of pointer (mouse) entries into the given items.\n     * This should typically run outside the Angular zone.\n     */\n    private _getItemPointerEntries;\n    /**\n     * Gets a stream of pointer (mouse) exits out of the given items.\n     * This should typically run outside the Angular zone.\n     */\n    private _getItemPointerExits;\n}\n\n/**\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\n * trajectory of the user's mouse movement in the current menu to determine if the\n * mouse is moving towards an open submenu.\n *\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\n * to submenu.\n */\nexport declare class TargetMenuAim implements MenuAim, OnDestroy {\n    /** The Angular zone. */\n    private readonly _ngZone;\n    /** The last NUM_POINTS mouse move events. */\n    private readonly _points;\n    /** Reference to the root menu in which we are tracking mouse moves. */\n    private _menu;\n    /** Reference to the root menu's mouse manager. */\n    private _pointerTracker;\n    /** The id associated with the current timeout call waiting to resolve. */\n    private _timeoutId;\n    /** Emits when this service is destroyed. */\n    private readonly _destroyed;\n    ngOnDestroy(): void;\n    /**\n     * Set the Menu and its PointerFocusTracker.\n     * @param menu The menu that this menu aim service controls.\n     * @param pointerTracker The `PointerFocusTracker` for the given menu.\n     */\n    initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>): void;\n    /**\n     * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n     * the submenu.\n     * @param doToggle the function called when the user is not moving towards the submenu.\n     */\n    toggle(doToggle: () => void): void;\n    /**\n     * Start the delayed toggle handler if one isn't running already.\n     *\n     * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\n     * users mouse is on an item in the current menu.\n     *\n     * @param doToggle the function called when the user is not moving towards the submenu.\n     */\n    private _startTimeout;\n    /** Whether the user is heading towards the open submenu. */\n    private _isMovingToSubmenu;\n    /** Get the bounding DOMRect for the open submenu. */\n    private _getSubmenuBounds;\n    /**\n     * Check if a reference to the PointerFocusTracker and menu element is provided.\n     * @throws an error if neither reference is provided.\n     */\n    private _checkConfigured;\n    /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\n    private _subscribeToMouseMoves;\n    static ɵfac: i0.ɵɵFactoryDeclaration<TargetMenuAim, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<TargetMenuAim>;\n}\n\n/** An element which when hovered over may open or close a menu. */\nexport declare interface Toggler {\n    /** Gets the open menu, or undefined if no menu is open. */\n    getMenu(): Menu | undefined;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/observers/index.d.ts",
      "node_modules/@angular/cdk/observers/index.d.ts"
    ],
    "content": "import { AfterContentInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\n\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nexport declare class CdkObserveContent implements AfterContentInit, OnDestroy {\n    private _contentObserver;\n    private _elementRef;\n    private _ngZone;\n    /** Event emitted for each change in the element's content. */\n    readonly event: EventEmitter<MutationRecord[]>;\n    /**\n     * Whether observing content is disabled. This option can be used\n     * to disconnect the underlying MutationObserver until it is needed.\n     */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Debounce interval for emitting the changes. */\n    get debounce(): number;\n    set debounce(value: NumberInput);\n    private _debounce;\n    private _currentSubscription;\n    constructor(_contentObserver: ContentObserver, _elementRef: ElementRef<HTMLElement>, _ngZone: NgZone);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    private _subscribe;\n    private _unsubscribe;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkObserveContent, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkObserveContent, \"[cdkObserveContent]\", [\"cdkObserveContent\"], { \"disabled\": \"cdkObserveContentDisabled\"; \"debounce\": \"debounce\"; }, { \"event\": \"cdkObserveContent\"; }, never, never, false>;\n}\n\n/** An injectable service that allows watching elements for changes to their content. */\nexport declare class ContentObserver implements OnDestroy {\n    private _mutationObserverFactory;\n    /** Keeps track of the existing MutationObservers so they can be reused. */\n    private _observedElements;\n    constructor(_mutationObserverFactory: MutationObserverFactory);\n    ngOnDestroy(): void;\n    /**\n     * Observe content changes on an element.\n     * @param element The element to observe for content changes.\n     */\n    observe(element: Element): Observable<MutationRecord[]>;\n    /**\n     * Observe content changes on an element.\n     * @param element The element to observe for content changes.\n     */\n    observe(element: ElementRef<Element>): Observable<MutationRecord[]>;\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     */\n    private _observeElement;\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     */\n    private _unobserveElement;\n    /** Clean up the underlying MutationObserver for the specified element. */\n    private _cleanupObserver;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ContentObserver, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ContentObserver>;\n}\n\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\nexport declare class MutationObserverFactory {\n    create(callback: MutationCallback): MutationObserver | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MutationObserverFactory, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MutationObserverFactory>;\n}\n\nexport declare class ObserversModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<ObserversModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<ObserversModule, [typeof CdkObserveContent], never, [typeof CdkObserveContent]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<ObserversModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/overlay/index.d.ts",
      "node_modules/@angular/cdk/overlay/index.d.ts"
    ],
    "content": "import { BooleanInput } from '@angular/cdk/coercion';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ComponentRef } from '@angular/core';\nimport { ComponentType } from '@angular/cdk/portal';\nimport { Direction } from '@angular/cdk/bidi';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EmbeddedViewRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/cdk/bidi';\nimport * as i3 from '@angular/cdk/portal';\nimport * as i4 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { Location as Location_2 } from '@angular/common';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { Portal } from '@angular/cdk/portal';\nimport { PortalOutlet } from '@angular/cdk/portal';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\n/**\n * Service for dispatching events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\ndeclare abstract class BaseOverlayDispatcher implements OnDestroy {\n    /** Currently attached overlays in the order they were attached. */\n    _attachedOverlays: OverlayReference[];\n    protected _document: Document;\n    protected _isAttached: boolean;\n    constructor(document: any);\n    ngOnDestroy(): void;\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef: OverlayReference): void;\n    /** Remove an overlay from the list of attached overlay refs. */\n    remove(overlayRef: OverlayReference): void;\n    /** Detaches the global event listener. */\n    protected abstract detach(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<BaseOverlayDispatcher, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<BaseOverlayDispatcher>;\n}\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nexport declare class BlockScrollStrategy implements ScrollStrategy {\n    private _viewportRuler;\n    private _previousHTMLStyles;\n    private _previousScrollPosition;\n    private _isEnabled;\n    private _document;\n    constructor(_viewportRuler: ViewportRuler, document: any);\n    /** Attaches this scroll strategy to an overlay. */\n    attach(): void;\n    /** Blocks page-level scroll while the attached overlay is open. */\n    enable(): void;\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    disable(): void;\n    private _canBeEnabled;\n}\n\n/** Injection token that determines the scroll handling while the connected overlay is open. */\ndeclare const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\ndeclare const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\ndeclare function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => RepositionScrollStrategy;\n\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\nexport declare class CdkConnectedOverlay implements OnDestroy, OnChanges {\n    private _overlay;\n    private _dir;\n    private _overlayRef;\n    private _templatePortal;\n    private _hasBackdrop;\n    private _lockPosition;\n    private _growAfterOpen;\n    private _flexibleDimensions;\n    private _push;\n    private _backdropSubscription;\n    private _attachSubscription;\n    private _detachSubscription;\n    private _positionSubscription;\n    private _offsetX;\n    private _offsetY;\n    private _position;\n    private _scrollStrategyFactory;\n    /** Origin for the connected overlay. */\n    origin: CdkOverlayOrigin | FlexibleConnectedPositionStrategyOrigin;\n    /** Registered connected position pairs. */\n    positions: ConnectedPosition[];\n    /**\n     * This input overrides the positions input if specified. It lets users pass\n     * in arbitrary positioning strategies.\n     */\n    positionStrategy: FlexibleConnectedPositionStrategy;\n    /** The offset in pixels for the overlay connection point on the x-axis */\n    get offsetX(): number;\n    set offsetX(offsetX: number);\n    /** The offset in pixels for the overlay connection point on the y-axis */\n    get offsetY(): number;\n    set offsetY(offsetY: number);\n    /** The width of the overlay panel. */\n    width: number | string;\n    /** The height of the overlay panel. */\n    height: number | string;\n    /** The min width of the overlay panel. */\n    minWidth: number | string;\n    /** The min height of the overlay panel. */\n    minHeight: number | string;\n    /** The custom class to be set on the backdrop element. */\n    backdropClass: string | string[];\n    /** The custom class to add to the overlay pane element. */\n    panelClass: string | string[];\n    /** Margin between the overlay and the viewport edges. */\n    viewportMargin: number;\n    /** Strategy to be used when handling scroll events while the overlay is open. */\n    scrollStrategy: ScrollStrategy;\n    /** Whether the overlay is open. */\n    open: boolean;\n    /** Whether the overlay can be closed by user interaction. */\n    disableClose: boolean;\n    /** CSS selector which to set the transform origin. */\n    transformOriginSelector: string;\n    /** Whether or not the overlay should attach a backdrop. */\n    get hasBackdrop(): boolean;\n    set hasBackdrop(value: BooleanInput);\n    /** Whether or not the overlay should be locked when scrolling. */\n    get lockPosition(): boolean;\n    set lockPosition(value: BooleanInput);\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    get flexibleDimensions(): boolean;\n    set flexibleDimensions(value: BooleanInput);\n    /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n    get growAfterOpen(): boolean;\n    set growAfterOpen(value: BooleanInput);\n    /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    get push(): boolean;\n    set push(value: BooleanInput);\n    /** Event emitted when the backdrop is clicked. */\n    readonly backdropClick: EventEmitter<MouseEvent>;\n    /** Event emitted when the position has changed. */\n    readonly positionChange: EventEmitter<ConnectedOverlayPositionChange>;\n    /** Event emitted when the overlay has been attached. */\n    readonly attach: EventEmitter<void>;\n    /** Event emitted when the overlay has been detached. */\n    readonly detach: EventEmitter<void>;\n    /** Emits when there are keyboard events that are targeted at the overlay. */\n    readonly overlayKeydown: EventEmitter<KeyboardEvent>;\n    /** Emits when there are mouse outside click events that are targeted at the overlay. */\n    readonly overlayOutsideClick: EventEmitter<MouseEvent>;\n    constructor(_overlay: Overlay, templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef, scrollStrategyFactory: any, _dir: Directionality);\n    /** The associated overlay reference. */\n    get overlayRef(): OverlayRef;\n    /** The element's layout direction. */\n    get dir(): Direction;\n    ngOnDestroy(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    /** Creates an overlay */\n    private _createOverlay;\n    /** Builds the overlay config based on the directive's inputs */\n    private _buildConfig;\n    /** Updates the state of a position strategy, based on the values of the directive inputs. */\n    private _updatePositionStrategy;\n    /** Returns the position strategy of the overlay to be set on the overlay config */\n    private _createPositionStrategy;\n    private _getFlexibleConnectedPositionStrategyOrigin;\n    /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n    private _attachOverlay;\n    /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n    private _detachOverlay;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkConnectedOverlay, [null, null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkConnectedOverlay, \"[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]\", [\"cdkConnectedOverlay\"], { \"origin\": \"cdkConnectedOverlayOrigin\"; \"positions\": \"cdkConnectedOverlayPositions\"; \"positionStrategy\": \"cdkConnectedOverlayPositionStrategy\"; \"offsetX\": \"cdkConnectedOverlayOffsetX\"; \"offsetY\": \"cdkConnectedOverlayOffsetY\"; \"width\": \"cdkConnectedOverlayWidth\"; \"height\": \"cdkConnectedOverlayHeight\"; \"minWidth\": \"cdkConnectedOverlayMinWidth\"; \"minHeight\": \"cdkConnectedOverlayMinHeight\"; \"backdropClass\": \"cdkConnectedOverlayBackdropClass\"; \"panelClass\": \"cdkConnectedOverlayPanelClass\"; \"viewportMargin\": \"cdkConnectedOverlayViewportMargin\"; \"scrollStrategy\": \"cdkConnectedOverlayScrollStrategy\"; \"open\": \"cdkConnectedOverlayOpen\"; \"disableClose\": \"cdkConnectedOverlayDisableClose\"; \"transformOriginSelector\": \"cdkConnectedOverlayTransformOriginOn\"; \"hasBackdrop\": \"cdkConnectedOverlayHasBackdrop\"; \"lockPosition\": \"cdkConnectedOverlayLockPosition\"; \"flexibleDimensions\": \"cdkConnectedOverlayFlexibleDimensions\"; \"growAfterOpen\": \"cdkConnectedOverlayGrowAfterOpen\"; \"push\": \"cdkConnectedOverlayPush\"; }, { \"backdropClick\": \"backdropClick\"; \"positionChange\": \"positionChange\"; \"attach\": \"attach\"; \"detach\": \"detach\"; \"overlayKeydown\": \"overlayKeydown\"; \"overlayOutsideClick\": \"overlayOutsideClick\"; }, never, never, false>;\n}\n\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nexport declare class CdkOverlayOrigin {\n    /** Reference to the element on which the directive is applied. */\n    elementRef: ElementRef;\n    constructor(\n    /** Reference to the element on which the directive is applied. */\n    elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkOverlayOrigin, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkOverlayOrigin, \"[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]\", [\"cdkOverlayOrigin\"], {}, {}, never, never, false>;\n}\n\nexport { CdkScrollable }\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nexport declare class CloseScrollStrategy implements ScrollStrategy {\n    private _scrollDispatcher;\n    private _ngZone;\n    private _viewportRuler;\n    private _config?;\n    private _scrollSubscription;\n    private _overlayRef;\n    private _initialScrollPosition;\n    constructor(_scrollDispatcher: ScrollDispatcher, _ngZone: NgZone, _viewportRuler: ViewportRuler, _config?: CloseScrollStrategyConfig | undefined);\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef: OverlayReference): void;\n    /** Enables the closing of the attached overlay on scroll. */\n    enable(): void;\n    /** Disables the closing the attached overlay on scroll. */\n    disable(): void;\n    detach(): void;\n    /** Detaches the overlay ref and disables the scroll strategy. */\n    private _detach;\n}\n\n/**\n * Config options for the CloseScrollStrategy.\n */\ndeclare interface CloseScrollStrategyConfig {\n    /** Amount of pixels the user has to scroll before the overlay is closed. */\n    threshold?: number;\n}\n\nexport { ComponentType }\n\n/** The change event emitted by the strategy when a fallback position is used. */\nexport declare class ConnectedOverlayPositionChange {\n    /** The position used as a result of this change. */\n    connectionPair: ConnectionPositionPair;\n    /** @docs-private */\n    scrollableViewProperties: ScrollingVisibility;\n    constructor(\n    /** The position used as a result of this change. */\n    connectionPair: ConnectionPositionPair, \n    /** @docs-private */\n    scrollableViewProperties: ScrollingVisibility);\n}\n\n/** A connected position as specified by the user. */\nexport declare interface ConnectedPosition {\n    originX: 'start' | 'center' | 'end';\n    originY: 'top' | 'center' | 'bottom';\n    overlayX: 'start' | 'center' | 'end';\n    overlayY: 'top' | 'center' | 'bottom';\n    weight?: number;\n    offsetX?: number;\n    offsetY?: number;\n    panelClass?: string | string[];\n}\n\n/** The points of the origin element and the overlay element to connect. */\nexport declare class ConnectionPositionPair {\n    /** Offset along the X axis. */\n    offsetX?: number | undefined;\n    /** Offset along the Y axis. */\n    offsetY?: number | undefined;\n    /** Class(es) to be applied to the panel while this position is active. */\n    panelClass?: string | string[] | undefined;\n    /** X-axis attachment point for connected overlay origin. Can be 'start', 'end', or 'center'. */\n    originX: HorizontalConnectionPos;\n    /** Y-axis attachment point for connected overlay origin. Can be 'top', 'bottom', or 'center'. */\n    originY: VerticalConnectionPos;\n    /** X-axis attachment point for connected overlay. Can be 'start', 'end', or 'center'. */\n    overlayX: HorizontalConnectionPos;\n    /** Y-axis attachment point for connected overlay. Can be 'top', 'bottom', or 'center'. */\n    overlayY: VerticalConnectionPos;\n    constructor(origin: OriginConnectionPosition, overlay: OverlayConnectionPosition, \n    /** Offset along the X axis. */\n    offsetX?: number | undefined, \n    /** Offset along the Y axis. */\n    offsetY?: number | undefined, \n    /** Class(es) to be applied to the panel while this position is active. */\n    panelClass?: string | string[] | undefined);\n}\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nexport declare class FlexibleConnectedPositionStrategy implements PositionStrategy {\n    private _viewportRuler;\n    private _document;\n    private _platform;\n    private _overlayContainer;\n    /** The overlay to which this strategy is attached. */\n    private _overlayRef;\n    /** Whether we're performing the very first positioning of the overlay. */\n    private _isInitialRender;\n    /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n    private _lastBoundingBoxSize;\n    /** Whether the overlay was pushed in a previous positioning. */\n    private _isPushed;\n    /** Whether the overlay can be pushed on-screen on the initial open. */\n    private _canPush;\n    /** Whether the overlay can grow via flexible width/height after the initial open. */\n    private _growAfterOpen;\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    private _hasFlexibleDimensions;\n    /** Whether the overlay position is locked. */\n    private _positionLocked;\n    /** Cached origin dimensions */\n    private _originRect;\n    /** Cached overlay dimensions */\n    private _overlayRect;\n    /** Cached viewport dimensions */\n    private _viewportRect;\n    /** Cached container dimensions */\n    private _containerRect;\n    /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n    private _viewportMargin;\n    /** The Scrollable containers used to check scrollable view properties on position change. */\n    private _scrollables;\n    /** Ordered list of preferred positions, from most to least desirable. */\n    _preferredPositions: ConnectionPositionPair[];\n    /** The origin element against which the overlay will be positioned. */\n    private _origin;\n    /** The overlay pane element. */\n    private _pane;\n    /** Whether the strategy has been disposed of already. */\n    private _isDisposed;\n    /**\n     * Parent element for the overlay panel used to constrain the overlay panel's size to fit\n     * within the viewport.\n     */\n    private _boundingBox;\n    /** The last position to have been calculated as the best fit position. */\n    private _lastPosition;\n    /** Subject that emits whenever the position changes. */\n    private readonly _positionChanges;\n    /** Subscription to viewport size changes. */\n    private _resizeSubscription;\n    /** Default offset for the overlay along the x axis. */\n    private _offsetX;\n    /** Default offset for the overlay along the y axis. */\n    private _offsetY;\n    /** Selector to be used when finding the elements on which to set the transform origin. */\n    private _transformOriginSelector;\n    /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n    private _appliedPanelClasses;\n    /** Amount by which the overlay was pushed in each axis during the last time it was positioned. */\n    private _previousPushAmount;\n    /** Observable sequence of position changes. */\n    positionChanges: Observable<ConnectedOverlayPositionChange>;\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions(): ConnectionPositionPair[];\n    constructor(connectedTo: FlexibleConnectedPositionStrategyOrigin, _viewportRuler: ViewportRuler, _document: Document, _platform: Platform, _overlayContainer: OverlayContainer);\n    /** Attaches this position strategy to an overlay. */\n    attach(overlayRef: OverlayReference): void;\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin best fits on-screen.\n     *\n     * The selection of a position goes as follows:\n     *  - If any positions fit completely within the viewport as-is,\n     *      choose the first position that does so.\n     *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,\n     *      choose the position with the greatest available size modified by the positions' weight.\n     *  - If pushing is enabled, take the position that went off-screen the least and push it\n     *      on-screen.\n     *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n     * @docs-private\n     */\n    apply(): void;\n    detach(): void;\n    /** Cleanup after the element gets destroyed. */\n    dispose(): void;\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    reapplyLastPosition(): void;\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables: CdkScrollable[]): this;\n    /**\n     * Adds new preferred positions.\n     * @param positions List of positions options for this overlay.\n     */\n    withPositions(positions: ConnectedPosition[]): this;\n    /**\n     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n     * @param margin Required margin between the overlay and the viewport edge in pixels.\n     */\n    withViewportMargin(margin: number): this;\n    /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n    withFlexibleDimensions(flexibleDimensions?: boolean): this;\n    /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n    withGrowAfterOpen(growAfterOpen?: boolean): this;\n    /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    withPush(canPush?: boolean): this;\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked?: boolean): this;\n    /**\n     * Sets the origin, relative to which to position the overlay.\n     * Using an element origin is useful for building components that need to be positioned\n     * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n     * used for cases like contextual menus which open relative to the user's pointer.\n     * @param origin Reference to the new origin.\n     */\n    setOrigin(origin: FlexibleConnectedPositionStrategyOrigin): this;\n    /**\n     * Sets the default offset for the overlay's connection point on the x-axis.\n     * @param offset New offset in the X axis.\n     */\n    withDefaultOffsetX(offset: number): this;\n    /**\n     * Sets the default offset for the overlay's connection point on the y-axis.\n     * @param offset New offset in the Y axis.\n     */\n    withDefaultOffsetY(offset: number): this;\n    /**\n     * Configures that the position strategy should set a `transform-origin` on some elements\n     * inside the overlay, depending on the current position that is being applied. This is\n     * useful for the cases where the origin of an animation can change depending on the\n     * alignment of the overlay.\n     * @param selector CSS selector that will be used to find the target\n     *    elements onto which to set the transform origin.\n     */\n    withTransformOriginOn(selector: string): this;\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     */\n    private _getOriginPoint;\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     */\n    private _getOverlayPoint;\n    /** Gets how well an overlay at the given point will fit within the viewport. */\n    private _getOverlayFit;\n    /**\n     * Whether the overlay can fit within the viewport when it may resize either its width or height.\n     * @param fit How well the overlay fits in the viewport at some position.\n     * @param point The (x, y) coordinates of the overlay at some position.\n     * @param viewport The geometry of the viewport.\n     */\n    private _canFitWithFlexibleDimensions;\n    /**\n     * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n     * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the\n     * right and bottom).\n     *\n     * @param start Starting point from which the overlay is pushed.\n     * @param rawOverlayRect Dimensions of the overlay.\n     * @param scrollPosition Current viewport scroll position.\n     * @returns The point at which to position the overlay after pushing. This is effectively a new\n     *     originPoint.\n     */\n    private _pushOverlayOnScreen;\n    /**\n     * Applies a computed position to the overlay and emits a position change.\n     * @param position The position preference\n     * @param originPoint The point on the origin element where the overlay is connected.\n     */\n    private _applyPosition;\n    /** Sets the transform origin based on the configured selector and the passed-in position.  */\n    private _setTransformOrigin;\n    /**\n     * Gets the position and size of the overlay's sizing container.\n     *\n     * This method does no measuring and applies no styles so that we can cheaply compute the\n     * bounds for all positions and choose the best fit based on these results.\n     */\n    private _calculateBoundingBoxRect;\n    /**\n     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n     * origin's connection point and stretches to the bounds of the viewport.\n     *\n     * @param origin The point on the origin element where the overlay is connected.\n     * @param position The position preference\n     */\n    private _setBoundingBoxStyles;\n    /** Resets the styles for the bounding box so that a new positioning can be computed. */\n    private _resetBoundingBoxStyles;\n    /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n    private _resetOverlayElementStyles;\n    /** Sets positioning styles to the overlay element. */\n    private _setOverlayElementStyles;\n    /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n    private _getExactOverlayY;\n    /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n    private _getExactOverlayX;\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     */\n    private _getScrollVisibility;\n    /** Subtracts the amount that an element is overflowing on an axis from its length. */\n    private _subtractOverflows;\n    /** Narrows the given viewport rect by the current _viewportMargin. */\n    private _getNarrowedViewportRect;\n    /** Whether the we're dealing with an RTL context */\n    private _isRtl;\n    /** Determines whether the overlay uses exact or flexible positioning. */\n    private _hasExactPosition;\n    /** Retrieves the offset of a position along the x or y axis. */\n    private _getOffset;\n    /** Validates that the current position match the expected values. */\n    private _validatePositions;\n    /** Adds a single CSS class or an array of classes on the overlay panel. */\n    private _addPanelClasses;\n    /** Clears the classes that the position strategy has applied from the overlay panel. */\n    private _clearPanelClasses;\n    /** Returns the ClientRect of the current origin. */\n    private _getOriginRect;\n}\n\n/** Possible values that can be set as the origin of a FlexibleConnectedPositionStrategy. */\nexport declare type FlexibleConnectedPositionStrategyOrigin = ElementRef | Element | (Point & {\n    width?: number;\n    height?: number;\n});\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nexport declare class FullscreenOverlayContainer extends OverlayContainer implements OnDestroy {\n    private _fullScreenEventName;\n    private _fullScreenListener;\n    constructor(_document: any, platform: Platform);\n    ngOnDestroy(): void;\n    protected _createContainer(): void;\n    private _adjustParentForFullscreenChange;\n    private _addFullscreenChangeListener;\n    private _getEventName;\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    getFullscreenElement(): Element;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FullscreenOverlayContainer, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<FullscreenOverlayContainer>;\n}\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nexport declare class GlobalPositionStrategy implements PositionStrategy {\n    /** The overlay to which this strategy is attached. */\n    private _overlayRef;\n    private _cssPosition;\n    private _topOffset;\n    private _bottomOffset;\n    private _alignItems;\n    private _xPosition;\n    private _xOffset;\n    private _width;\n    private _height;\n    private _isDisposed;\n    attach(overlayRef: OverlayReference): void;\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    top(value?: string): this;\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    left(value?: string): this;\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    bottom(value?: string): this;\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    right(value?: string): this;\n    /**\n     * Sets the overlay to the start of the viewport, depending on the overlay direction.\n     * This will be to the left in LTR layouts and to the right in RTL.\n     * @param offset Offset from the edge of the screen.\n     */\n    start(value?: string): this;\n    /**\n     * Sets the overlay to the end of the viewport, depending on the overlay direction.\n     * This will be to the right in LTR layouts and to the left in RTL.\n     * @param offset Offset from the edge of the screen.\n     */\n    end(value?: string): this;\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    width(value?: string): this;\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    height(value?: string): this;\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    centerHorizontally(offset?: string): this;\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    centerVertically(offset?: string): this;\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     */\n    apply(): void;\n    /**\n     * Cleans up the DOM changes from the position strategy.\n     * @docs-private\n     */\n    dispose(): void;\n}\n\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\nexport declare type HorizontalConnectionPos = 'start' | 'center' | 'end';\n\ndeclare namespace i1 {\n    export {\n        CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n        CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n        CdkOverlayOrigin,\n        CdkConnectedOverlay,\n        CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER\n    }\n}\n\n/** An object where all of its properties cannot be written. */\ndeclare type ImmutableObject<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n/** Scroll strategy that doesn't do anything. */\nexport declare class NoopScrollStrategy implements ScrollStrategy {\n    /** Does nothing, as this scroll strategy is a no-op. */\n    enable(): void;\n    /** Does nothing, as this scroll strategy is a no-op. */\n    disable(): void;\n    /** Does nothing, as this scroll strategy is a no-op. */\n    attach(): void;\n}\n\n/** A connection point on the origin element. */\nexport declare interface OriginConnectionPosition {\n    originX: HorizontalConnectionPos;\n    originY: VerticalConnectionPos;\n}\n\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nexport declare class Overlay {\n    /** Scrolling strategies that can be used when creating an overlay. */\n    scrollStrategies: ScrollStrategyOptions;\n    private _overlayContainer;\n    private _componentFactoryResolver;\n    private _positionBuilder;\n    private _keyboardDispatcher;\n    private _injector;\n    private _ngZone;\n    private _document;\n    private _directionality;\n    private _location;\n    private _outsideClickDispatcher;\n    private _animationsModuleType?;\n    private _appRef;\n    constructor(\n    /** Scrolling strategies that can be used when creating an overlay. */\n    scrollStrategies: ScrollStrategyOptions, _overlayContainer: OverlayContainer, _componentFactoryResolver: ComponentFactoryResolver, _positionBuilder: OverlayPositionBuilder, _keyboardDispatcher: OverlayKeyboardDispatcher, _injector: Injector, _ngZone: NgZone, _document: any, _directionality: Directionality, _location: Location_2, _outsideClickDispatcher: OverlayOutsideClickDispatcher, _animationsModuleType?: string | undefined);\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    create(config?: OverlayConfig): OverlayRef;\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    position(): OverlayPositionBuilder;\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @returns Newly-created pane element\n     */\n    private _createPaneElement;\n    /**\n     * Creates the host element that wraps around an overlay\n     * and can be used for advanced positioning.\n     * @returns Newly-create host element.\n     */\n    private _createHostElement;\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param pane The DOM element to turn into a portal outlet.\n     * @returns A portal outlet for the given DOM element.\n     */\n    private _createPortalOutlet;\n    static ɵfac: i0.ɵɵFactoryDeclaration<Overlay, [null, null, null, null, null, null, null, null, null, null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Overlay>;\n}\n\n/** Initial configuration used when creating an overlay. */\nexport declare class OverlayConfig {\n    /** Strategy with which to position the overlay. */\n    positionStrategy?: PositionStrategy;\n    /** Strategy to be used when handling scroll events while the overlay is open. */\n    scrollStrategy?: ScrollStrategy;\n    /** Custom class to add to the overlay pane. */\n    panelClass?: string | string[];\n    /** Whether the overlay has a backdrop. */\n    hasBackdrop?: boolean;\n    /** Custom class to add to the backdrop */\n    backdropClass?: string | string[];\n    /** The width of the overlay panel. If a number is provided, pixel units are assumed. */\n    width?: number | string;\n    /** The height of the overlay panel. If a number is provided, pixel units are assumed. */\n    height?: number | string;\n    /** The min-width of the overlay panel. If a number is provided, pixel units are assumed. */\n    minWidth?: number | string;\n    /** The min-height of the overlay panel. If a number is provided, pixel units are assumed. */\n    minHeight?: number | string;\n    /** The max-width of the overlay panel. If a number is provided, pixel units are assumed. */\n    maxWidth?: number | string;\n    /** The max-height of the overlay panel. If a number is provided, pixel units are assumed. */\n    maxHeight?: number | string;\n    /**\n     * Direction of the text in the overlay panel. If a `Directionality` instance\n     * is passed in, the overlay will handle changes to its value automatically.\n     */\n    direction?: Direction | Directionality;\n    /**\n     * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n     * Note that this usually doesn't include clicking on links (unless the user is using\n     * the `HashLocationStrategy`).\n     */\n    disposeOnNavigation?: boolean;\n    constructor(config?: OverlayConfig);\n}\n\n/** A connection point on the overlay element. */\nexport declare interface OverlayConnectionPosition {\n    overlayX: HorizontalConnectionPos;\n    overlayY: VerticalConnectionPos;\n}\n\n/** Container inside which all overlays will render. */\nexport declare class OverlayContainer implements OnDestroy {\n    protected _platform: Platform;\n    protected _containerElement: HTMLElement;\n    protected _document: Document;\n    constructor(document: any, _platform: Platform);\n    ngOnDestroy(): void;\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    getContainerElement(): HTMLElement;\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    protected _createContainer(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayContainer, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayContainer>;\n}\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nexport declare class OverlayKeyboardDispatcher extends BaseOverlayDispatcher {\n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    private _ngZone?;\n    constructor(document: any, \n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    _ngZone?: NgZone | undefined);\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef: OverlayReference): void;\n    /** Detaches the global keyboard event listener. */\n    protected detach(): void;\n    /** Keyboard event listener that will be attached to the body. */\n    private _keydownListener;\n    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayKeyboardDispatcher, [null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayKeyboardDispatcher>;\n}\n\nexport declare class OverlayModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<OverlayModule, [typeof i1.CdkConnectedOverlay, typeof i1.CdkOverlayOrigin], [typeof i2.BidiModule, typeof i3.PortalModule, typeof i4.ScrollingModule], [typeof i1.CdkConnectedOverlay, typeof i1.CdkOverlayOrigin, typeof i4.ScrollingModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<OverlayModule>;\n}\n\n/**\n * Service for dispatching mouse click events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nexport declare class OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {\n    private _platform;\n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    private _ngZone?;\n    private _cursorOriginalValue;\n    private _cursorStyleIsSet;\n    private _pointerDownEventTarget;\n    constructor(document: any, _platform: Platform, \n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    _ngZone?: NgZone | undefined);\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef: OverlayReference): void;\n    /** Detaches the global keyboard event listener. */\n    protected detach(): void;\n    private _addEventListeners;\n    /** Store pointerdown event target to track origin of click. */\n    private _pointerDownListener;\n    /** Click event listener that will be attached to the body propagate phase. */\n    private _clickListener;\n    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayOutsideClickDispatcher, [null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayOutsideClickDispatcher>;\n}\n\n/** Builder for overlay position strategy. */\nexport declare class OverlayPositionBuilder {\n    private _viewportRuler;\n    private _document;\n    private _platform;\n    private _overlayContainer;\n    constructor(_viewportRuler: ViewportRuler, _document: any, _platform: Platform, _overlayContainer: OverlayContainer);\n    /**\n     * Creates a global position strategy.\n     */\n    global(): GlobalPositionStrategy;\n    /**\n     * Creates a flexible position strategy.\n     * @param origin Origin relative to which to position the overlay.\n     */\n    flexibleConnectedTo(origin: FlexibleConnectedPositionStrategyOrigin): FlexibleConnectedPositionStrategy;\n    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayPositionBuilder, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayPositionBuilder>;\n}\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nexport declare class OverlayRef implements PortalOutlet, OverlayReference {\n    private _portalOutlet;\n    private _host;\n    private _pane;\n    private _config;\n    private _ngZone;\n    private _keyboardDispatcher;\n    private _document;\n    private _location;\n    private _outsideClickDispatcher;\n    private _animationsDisabled;\n    private _backdropElement;\n    private _backdropTimeout;\n    private readonly _backdropClick;\n    private readonly _attachments;\n    private readonly _detachments;\n    private _positionStrategy;\n    private _scrollStrategy;\n    private _locationChanges;\n    private _backdropClickHandler;\n    private _backdropTransitionendHandler;\n    /**\n     * Reference to the parent of the `_host` at the time it was detached. Used to restore\n     * the `_host` to its original position in the DOM when it gets re-attached.\n     */\n    private _previousHostParent;\n    /** Stream of keydown events dispatched to this overlay. */\n    readonly _keydownEvents: Subject<KeyboardEvent>;\n    /** Stream of mouse outside events dispatched to this overlay. */\n    readonly _outsidePointerEvents: Subject<MouseEvent>;\n    constructor(_portalOutlet: PortalOutlet, _host: HTMLElement, _pane: HTMLElement, _config: ImmutableObject<OverlayConfig>, _ngZone: NgZone, _keyboardDispatcher: OverlayKeyboardDispatcher, _document: Document, _location: Location_2, _outsideClickDispatcher: OverlayOutsideClickDispatcher, _animationsDisabled?: boolean);\n    /** The overlay's HTML element */\n    get overlayElement(): HTMLElement;\n    /** The overlay's backdrop HTML element. */\n    get backdropElement(): HTMLElement | null;\n    /**\n     * Wrapper around the panel element. Can be used for advanced\n     * positioning where a wrapper with specific styling is\n     * required around the overlay pane.\n     */\n    get hostElement(): HTMLElement;\n    attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n    attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n    attach(portal: any): any;\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    detach(): any;\n    /** Cleans up the overlay from the DOM. */\n    dispose(): void;\n    /** Whether the overlay has attached content. */\n    hasAttached(): boolean;\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    backdropClick(): Observable<MouseEvent>;\n    /** Gets an observable that emits when the overlay has been attached. */\n    attachments(): Observable<void>;\n    /** Gets an observable that emits when the overlay has been detached. */\n    detachments(): Observable<void>;\n    /** Gets an observable of keydown events targeted to this overlay. */\n    keydownEvents(): Observable<KeyboardEvent>;\n    /** Gets an observable of pointer events targeted outside this overlay. */\n    outsidePointerEvents(): Observable<MouseEvent>;\n    /** Gets the current overlay configuration, which is immutable. */\n    getConfig(): OverlayConfig;\n    /** Updates the position of the overlay based on the position strategy. */\n    updatePosition(): void;\n    /** Switches to a new position strategy and updates the overlay position. */\n    updatePositionStrategy(strategy: PositionStrategy): void;\n    /** Update the size properties of the overlay. */\n    updateSize(sizeConfig: OverlaySizeConfig): void;\n    /** Sets the LTR/RTL direction for the overlay. */\n    setDirection(dir: Direction | Directionality): void;\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes: string | string[]): void;\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes: string | string[]): void;\n    /**\n     * Returns the layout direction of the overlay panel.\n     */\n    getDirection(): Direction;\n    /** Switches to a new scroll strategy. */\n    updateScrollStrategy(strategy: ScrollStrategy): void;\n    /** Updates the text direction of the overlay panel. */\n    private _updateElementDirection;\n    /** Updates the size of the overlay element based on the overlay config. */\n    private _updateElementSize;\n    /** Toggles the pointer events for the overlay pane element. */\n    private _togglePointerEvents;\n    /** Attaches a backdrop for this overlay. */\n    private _attachBackdrop;\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     */\n    private _updateStackingOrder;\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    detachBackdrop(): void;\n    /** Toggles a single CSS class or an array of classes on an element. */\n    private _toggleClasses;\n    /** Detaches the overlay content next time the zone stabilizes. */\n    private _detachContentWhenStable;\n    /** Disposes of a scroll strategy. */\n    private _disposeScrollStrategy;\n    /** Removes a backdrop element from the DOM. */\n    private _disposeBackdrop;\n}\n\n/**\n * Basic interface for an overlay. Used to avoid circular type references between\n * `OverlayRef`, `PositionStrategy` and `ScrollStrategy`, and `OverlayConfig`.\n * @docs-private\n */\ndeclare interface OverlayReference {\n    attach: (portal: Portal<any>) => any;\n    detach: () => any;\n    dispose: () => void;\n    overlayElement: HTMLElement;\n    hostElement: HTMLElement;\n    backdropElement: HTMLElement | null;\n    getConfig: () => any;\n    hasAttached: () => boolean;\n    updateSize: (config: any) => void;\n    updatePosition: () => void;\n    getDirection: () => Direction;\n    setDirection: (dir: Direction | Directionality) => void;\n    backdropClick: () => Observable<MouseEvent>;\n    attachments: () => Observable<void>;\n    detachments: () => Observable<void>;\n    keydownEvents: () => Observable<KeyboardEvent>;\n    outsidePointerEvents: () => Observable<MouseEvent>;\n    addPanelClass: (classes: string | string[]) => void;\n    removePanelClass: (classes: string | string[]) => void;\n    readonly _outsidePointerEvents: Subject<MouseEvent>;\n    readonly _keydownEvents: Subject<KeyboardEvent>;\n}\n\n/** Size properties for an overlay. */\nexport declare interface OverlaySizeConfig {\n    width?: number | string;\n    height?: number | string;\n    minWidth?: number | string;\n    minHeight?: number | string;\n    maxWidth?: number | string;\n    maxHeight?: number | string;\n}\n\n/** A simple (x, y) coordinate. */\ndeclare interface Point {\n    x: number;\n    y: number;\n}\n\n/** Strategy for setting the position on an overlay. */\nexport declare interface PositionStrategy {\n    /** Attaches this position strategy to an overlay. */\n    attach(overlayRef: OverlayReference): void;\n    /** Updates the position of the overlay element. */\n    apply(): void;\n    /** Called when the overlay is detached. */\n    detach?(): void;\n    /** Cleans up any DOM modifications made by the position strategy, if necessary. */\n    dispose(): void;\n}\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nexport declare class RepositionScrollStrategy implements ScrollStrategy {\n    private _scrollDispatcher;\n    private _viewportRuler;\n    private _ngZone;\n    private _config?;\n    private _scrollSubscription;\n    private _overlayRef;\n    constructor(_scrollDispatcher: ScrollDispatcher, _viewportRuler: ViewportRuler, _ngZone: NgZone, _config?: RepositionScrollStrategyConfig | undefined);\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef: OverlayReference): void;\n    /** Enables repositioning of the attached overlay on scroll. */\n    enable(): void;\n    /** Disables repositioning of the attached overlay on scroll. */\n    disable(): void;\n    detach(): void;\n}\n\n/**\n * Config options for the RepositionScrollStrategy.\n */\nexport declare interface RepositionScrollStrategyConfig {\n    /** Time in milliseconds to throttle the scroll events. */\n    scrollThrottle?: number;\n    /** Whether to close the overlay once the user has scrolled away completely. */\n    autoClose?: boolean;\n}\n\nexport { ScrollDispatcher }\n\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nexport declare class ScrollingVisibility {\n    isOriginClipped: boolean;\n    isOriginOutsideView: boolean;\n    isOverlayClipped: boolean;\n    isOverlayOutsideView: boolean;\n}\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n */\nexport declare interface ScrollStrategy {\n    /** Enable this scroll strategy (called when the attached overlay is attached to a portal). */\n    enable: () => void;\n    /** Disable this scroll strategy (called when the attached overlay is detached from a portal). */\n    disable: () => void;\n    /** Attaches this `ScrollStrategy` to an overlay. */\n    attach: (overlayRef: OverlayReference) => void;\n    /** Detaches the scroll strategy from the current overlay. */\n    detach?: () => void;\n}\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nexport declare class ScrollStrategyOptions {\n    private _scrollDispatcher;\n    private _viewportRuler;\n    private _ngZone;\n    private _document;\n    constructor(_scrollDispatcher: ScrollDispatcher, _viewportRuler: ViewportRuler, _ngZone: NgZone, document: any);\n    /** Do nothing on scroll. */\n    noop: () => NoopScrollStrategy;\n    /**\n     * Close the overlay as soon as the user scrolls.\n     * @param config Configuration to be used inside the scroll strategy.\n     */\n    close: (config?: CloseScrollStrategyConfig) => CloseScrollStrategy;\n    /** Block scrolling. */\n    block: () => BlockScrollStrategy;\n    /**\n     * Update the overlay's position on scroll.\n     * @param config Configuration to be used inside the scroll strategy.\n     * Allows debouncing the reposition calls.\n     */\n    reposition: (config?: RepositionScrollStrategyConfig) => RepositionScrollStrategy;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ScrollStrategyOptions, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ScrollStrategyOptions>;\n}\n\nexport declare const STANDARD_DROPDOWN_ADJACENT_POSITIONS: ConnectedPosition[];\n\nexport declare const STANDARD_DROPDOWN_BELOW_POSITIONS: ConnectedPosition[];\n\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nexport declare function validateHorizontalPosition(property: string, value: HorizontalConnectionPos): void;\n\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nexport declare function validateVerticalPosition(property: string, value: VerticalConnectionPos): void;\n\n/** Vertical dimension of a connection point on the perimeter of the origin or overlay element. */\nexport declare type VerticalConnectionPos = 'top' | 'center' | 'bottom';\n\nexport { ViewportRuler }\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/platform/index.d.ts",
      "node_modules/@angular/cdk/platform/index.d.ts"
    ],
    "content": "import * as i0 from '@angular/core';\n\n/** Gets the target of an event while accounting for Shadow DOM. */\nexport declare function _getEventTarget<T extends EventTarget>(event: Event): T | null;\n\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nexport declare function _getFocusedElementPierceShadowDom(): HTMLElement | null;\n\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nexport declare function getRtlScrollAxisType(): RtlScrollAxisType;\n\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nexport declare function _getShadowRoot(element: HTMLElement): ShadowRoot | null;\n\n\n/** @returns The input types supported by this browser. */\nexport declare function getSupportedInputTypes(): Set<string>;\n\n\n/** Gets whether the code is currently running in a test environment. */\nexport declare function _isTestEnvironment(): boolean;\n\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nexport declare function normalizePassiveListenerOptions(options: AddEventListenerOptions): AddEventListenerOptions | boolean;\n\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nexport declare class Platform {\n    private _platformId;\n    /** Whether the Angular application is being rendered in the browser. */\n    isBrowser: boolean;\n    /** Whether the current browser is Microsoft Edge. */\n    EDGE: boolean;\n    /** Whether the current rendering engine is Microsoft Trident. */\n    TRIDENT: boolean;\n    /** Whether the current rendering engine is Blink. */\n    BLINK: boolean;\n    /** Whether the current rendering engine is WebKit. */\n    WEBKIT: boolean;\n    /** Whether the current platform is Apple iOS. */\n    IOS: boolean;\n    /** Whether the current browser is Firefox. */\n    FIREFOX: boolean;\n    /** Whether the current platform is Android. */\n    ANDROID: boolean;\n    /** Whether the current browser is Safari. */\n    SAFARI: boolean;\n    constructor(_platformId: Object);\n    static ɵfac: i0.ɵɵFactoryDeclaration<Platform, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<Platform>;\n}\n\nexport declare class PlatformModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<PlatformModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<PlatformModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<PlatformModule>;\n}\n\n\n/** The possible ways the browser may handle the horizontal scroll axis in RTL languages. */\nexport declare const enum RtlScrollAxisType {\n    /**\n     * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled\n     * all the way right.\n     */\n    NORMAL = 0,\n    /**\n     * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n     * all the way right.\n     */\n    NEGATED = 1,\n    /**\n     * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n     * all the way right.\n     */\n    INVERTED = 2\n}\n\n\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport declare function supportsPassiveEventListeners(): boolean;\n\n/** Check whether the browser supports scroll behaviors. */\nexport declare function supportsScrollBehavior(): boolean;\n\n\n/** Checks whether the user's browser support Shadow DOM. */\nexport declare function _supportsShadowDom(): boolean;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/portal/index.d.ts",
      "node_modules/@angular/cdk/portal/index.d.ts"
    ],
    "content": "import { ApplicationRef } from '@angular/core';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { ComponentRef } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EmbeddedViewRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport declare abstract class BasePortalHost extends BasePortalOutlet {\n}\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nexport declare abstract class BasePortalOutlet implements PortalOutlet {\n    /** The portal currently attached to the host. */\n    protected _attachedPortal: Portal<any> | null;\n    /** A function that will permanently dispose this host. */\n    private _disposeFn;\n    /** Whether this host has already been permanently disposed. */\n    private _isDisposed;\n    /** Whether this host has an attached portal. */\n    hasAttached(): boolean;\n    attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n    attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n    attach(portal: any): any;\n    abstract attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n    abstract attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n    readonly attachDomPortal: null | ((portal: DomPortal) => any);\n    /** Detaches a previously attached portal. */\n    detach(): void;\n    /** Permanently dispose of this portal host. */\n    dispose(): void;\n    /** @docs-private */\n    setDisposeFn(fn: () => void): void;\n    private _invokeDisposeFn;\n}\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nexport declare class CdkPortal extends TemplatePortal {\n    constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkPortal, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkPortal, \"[cdkPortal]\", [\"cdkPortal\"], {}, {}, never, never, false>;\n}\n\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nexport declare class CdkPortalOutlet extends BasePortalOutlet implements OnInit, OnDestroy {\n    private _componentFactoryResolver;\n    private _viewContainerRef;\n    private _document;\n    /** Whether the portal component is initialized. */\n    private _isInitialized;\n    /** Reference to the currently-attached component/view ref. */\n    private _attachedRef;\n    constructor(_componentFactoryResolver: ComponentFactoryResolver, _viewContainerRef: ViewContainerRef, \n    /**\n     * @deprecated `_document` parameter to be made required.\n     * @breaking-change 9.0.0\n     */\n    _document?: any);\n    /** Portal associated with the Portal outlet. */\n    get portal(): Portal<any> | null;\n    set portal(portal: Portal<any> | null | undefined | '');\n    /** Emits when a portal is attached to the outlet. */\n    readonly attached: EventEmitter<CdkPortalOutletAttachedRef>;\n    /** Component or view reference that is attached to the portal. */\n    get attachedRef(): CdkPortalOutletAttachedRef;\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n    /**\n     * Attach the given TemplatePortal to this PortalHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n    /**\n     * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    attachDomPortal: (portal: DomPortal) => void;\n    /** Gets the root node of the portal outlet. */\n    private _getRootNode;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkPortalOutlet, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkPortalOutlet, \"[cdkPortalOutlet]\", [\"cdkPortalOutlet\"], { \"portal\": \"cdkPortalOutlet\"; }, { \"attached\": \"attached\"; }, never, never, false>;\n}\n\n/**\n * Possible attached references to the CdkPortalOutlet.\n */\nexport declare type CdkPortalOutletAttachedRef = ComponentRef<any> | EmbeddedViewRef<any> | null;\n\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nexport declare class ComponentPortal<T> extends Portal<ComponentRef<T>> {\n    /** The type of the component that will be instantiated for attachment. */\n    component: ComponentType<T>;\n    /**\n     * [Optional] Where the attached component should live in Angular's *logical* component tree.\n     * This is different from where the component *renders*, which is determined by the PortalOutlet.\n     * The origin is necessary when the host is outside of the Angular application context.\n     */\n    viewContainerRef?: ViewContainerRef | null;\n    /** [Optional] Injector used for the instantiation of the component. */\n    injector?: Injector | null;\n    /**\n     * Alternate `ComponentFactoryResolver` to use when resolving the associated component.\n     * Defaults to using the resolver from the outlet that the portal is attached to.\n     */\n    componentFactoryResolver?: ComponentFactoryResolver | null;\n    constructor(component: ComponentType<T>, viewContainerRef?: ViewContainerRef | null, injector?: Injector | null, componentFactoryResolver?: ComponentFactoryResolver | null);\n}\n\n/** Interface that can be used to generically type a class. */\nexport declare interface ComponentType<T> {\n    new (...args: any[]): T;\n}\n\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nexport declare class DomPortal<T = HTMLElement> extends Portal<T> {\n    /** DOM node hosting the portal's content. */\n    readonly element: T;\n    constructor(element: T | ElementRef<T>);\n}\n\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport declare class DomPortalHost extends DomPortalOutlet {\n}\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nexport declare class DomPortalOutlet extends BasePortalOutlet {\n    /** Element into which the content is projected. */\n    outletElement: Element;\n    private _componentFactoryResolver?;\n    private _appRef?;\n    private _defaultInjector?;\n    private _document;\n    /**\n     * @param outletElement Element into which the content is projected.\n     * @param _componentFactoryResolver Used to resolve the component factory.\n     *   Only required when attaching component portals.\n     * @param _appRef Reference to the application. Only used in component portals when there\n     *   is no `ViewContainerRef` available.\n     * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't\n     *   have one. Only used for component portals.\n     * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually\n     *   become a required parameter.\n     */\n    constructor(\n    /** Element into which the content is projected. */\n    outletElement: Element, _componentFactoryResolver?: ComponentFactoryResolver | undefined, _appRef?: ApplicationRef | undefined, _defaultInjector?: Injector | undefined, \n    /**\n     * @deprecated `_document` Parameter to be made required.\n     * @breaking-change 10.0.0\n     */\n    _document?: any);\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n    /**\n     * Attaches a DOM portal by transferring its content into the outlet.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    attachDomPortal: (portal: DomPortal) => void;\n    /**\n     * Clears out a portal from the DOM.\n     */\n    dispose(): void;\n    /** Gets the root HTMLElement for an instantiated component. */\n    private _getComponentRootNode;\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nexport declare abstract class Portal<T> {\n    private _attachedHost;\n    /** Attach this portal to a host. */\n    attach(host: PortalOutlet): T;\n    /** Detach this portal from its host */\n    detach(): void;\n    /** Whether this portal is attached to a host. */\n    get isAttached(): boolean;\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    setAttachedHost(host: PortalOutlet | null): void;\n}\n\n/**\n * @deprecated Use `PortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport declare type PortalHost = PortalOutlet;\n\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport declare class PortalHostDirective extends CdkPortalOutlet {\n    static ɵfac: i0.ɵɵFactoryDeclaration<PortalHostDirective, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<PortalHostDirective, \"[cdkPortalHost], [portalHost]\", [\"cdkPortalHost\"], { \"portal\": \"cdkPortalHost\"; }, {}, never, never, false>;\n}\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nexport declare class PortalInjector implements Injector {\n    private _parentInjector;\n    private _customTokens;\n    constructor(_parentInjector: Injector, _customTokens: WeakMap<any, any>);\n    get(token: any, notFoundValue?: any): any;\n}\n\nexport declare class PortalModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<PortalModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<PortalModule, [typeof CdkPortal, typeof CdkPortalOutlet, typeof TemplatePortalDirective, typeof PortalHostDirective], never, [typeof CdkPortal, typeof CdkPortalOutlet, typeof TemplatePortalDirective, typeof PortalHostDirective]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<PortalModule>;\n}\n\n/** A `PortalOutlet` is an space that can contain a single `Portal`. */\nexport declare interface PortalOutlet {\n    /** Attaches a portal to this outlet. */\n    attach(portal: Portal<any>): any;\n    /** Detaches the currently attached portal from this outlet. */\n    detach(): any;\n    /** Performs cleanup before the outlet is destroyed. */\n    dispose(): void;\n    /** Whether there is currently a portal attached to this outlet. */\n    hasAttached(): boolean;\n}\n\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nexport declare class TemplatePortal<C = any> extends Portal<EmbeddedViewRef<C>> {\n    /** The embedded template that will be used to instantiate an embedded View in the host. */\n    templateRef: TemplateRef<C>;\n    /** Reference to the ViewContainer into which the template will be stamped out. */\n    viewContainerRef: ViewContainerRef;\n    /** Contextual data to be passed in to the embedded view. */\n    context?: C | undefined;\n    /** The injector to use for the embedded view. */\n    injector?: Injector | undefined;\n    constructor(\n    /** The embedded template that will be used to instantiate an embedded View in the host. */\n    templateRef: TemplateRef<C>, \n    /** Reference to the ViewContainer into which the template will be stamped out. */\n    viewContainerRef: ViewContainerRef, \n    /** Contextual data to be passed in to the embedded view. */\n    context?: C | undefined, \n    /** The injector to use for the embedded view. */\n    injector?: Injector | undefined);\n    get origin(): ElementRef;\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    attach(host: PortalOutlet, context?: C | undefined): EmbeddedViewRef<C>;\n    detach(): void;\n}\n\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\nexport declare class TemplatePortalDirective extends CdkPortal {\n    static ɵfac: i0.ɵɵFactoryDeclaration<TemplatePortalDirective, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<TemplatePortalDirective, \"[cdk-portal], [portal]\", [\"cdkPortal\"], {}, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/index.d.ts",
      "node_modules/@angular/cdk/schematics/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './utils';\nexport * from './ng-update/public-api';\nexport * from './update-tool/public-api';\nexport * from '@schematics/angular/utility/ast-utils';\nexport * from '@schematics/angular/utility/ng-ast-utils';\nimport * as parse5 from 'parse5';\nexport { parse5 };\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-add/index.d.ts",
      "node_modules/@angular/cdk/schematics/ng-add/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\n/**\n * Schematic factory entry-point for the `ng-add` schematic. The ng-add schematic will be\n * automatically executed if developers run `ng add @angular/cdk`.\n *\n * By default, the CLI already installs the package that has been specified with `ng add`.\n * We just store the version in the `package.json` in case the package manager didn't. Also\n * this ensures that there will be no error that says that the CDK does not support `ng add`.\n */\nexport default function (): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-add/package-config.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\n/** Adds a package to the package.json in the given host tree. */\nexport declare function addPackageToPackageJson(host: Tree, pkg: string, version: string): Tree;\n/** Gets the version of the specified package by looking at the package.json in the given tree. */\nexport declare function getPackageVersionFromPackageJson(tree: Tree, name: string): string | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-add/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport interface Schema {\n    /** Name of the project to target. */\n    project: string;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-generate/drag-drop/index.d.ts",
      "node_modules/@angular/cdk/schematics/ng-generate/drag-drop/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/** Scaffolds a new Angular component that uses the Drag and Drop module. */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-generate/drag-drop/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Schema as ComponentSchema } from '@schematics/angular/component/schema';\nexport interface Schema extends ComponentSchema {\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/attribute-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface AttributeSelectorUpgradeData {\n    /** The attribute name to replace. */\n    replace: string;\n    /** The new name for the attribute. */\n    replaceWith: string;\n}\nexport declare const attributeSelectors: VersionChanges<AttributeSelectorUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/class-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface ClassNameUpgradeData {\n    /** The Class name to replace. */\n    replace: string;\n    /** The new name for the Class. */\n    replaceWith: string;\n}\nexport declare const classNames: VersionChanges<ClassNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/constructor-checks.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport declare type ConstructorChecksUpgradeData = string;\n/**\n * List of class names for which the constructor signature has been changed. The new constructor\n * signature types don't need to be stored here because the signature will be determined\n * automatically through type checking.\n */\nexport declare const constructorChecks: VersionChanges<ConstructorChecksUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/css-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface CssSelectorUpgradeData {\n    /** The CSS selector to replace. */\n    replace: string;\n    /** The new CSS selector. */\n    replaceWith: string;\n    /**\n     * Controls which file types in which this replacement is made. If omitted, it is made in all\n     * files.\n     */\n    replaceIn?: {\n        /** Replace this name in stylesheet files. */\n        stylesheet?: boolean;\n        /** Replace this name in HTML files. */\n        html?: boolean;\n        /** Replace this name in TypeScript strings. */\n        tsStringLiterals?: boolean;\n    };\n}\nexport declare const cssSelectors: VersionChanges<CssSelectorUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/element-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface ElementSelectorUpgradeData {\n    /** The element name to replace. */\n    replace: string;\n    /** The new name for the element. */\n    replaceWith: string;\n}\nexport declare const elementSelectors: VersionChanges<ElementSelectorUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/index.d.ts",
      "node_modules/@angular/cdk/schematics/ng-update/data/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './attribute-selectors';\nexport * from './class-names';\nexport * from './constructor-checks';\nexport * from './css-selectors';\nexport * from './element-selectors';\nexport * from './input-names';\nexport * from './method-call-checks';\nexport * from './output-names';\nexport * from './property-names';\nexport * from './symbol-removal';\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/input-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface InputNameUpgradeData {\n    /** The @Input() name to replace. */\n    replace: string;\n    /** The new name for the @Input(). */\n    replaceWith: string;\n    /** Controls which elements and attributes in which this replacement is made. */\n    limitedTo: {\n        /** Limit to elements with any of these element tags. */\n        elements?: string[];\n        /** Limit to elements with any of these attributes. */\n        attributes?: string[];\n    };\n}\nexport declare const inputNames: VersionChanges<InputNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/method-call-checks.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface MethodCallUpgradeData {\n    className: string;\n    method: string;\n    invalidArgCounts: {\n        count: number;\n        message: string;\n    }[];\n}\nexport declare const methodCallChecks: VersionChanges<MethodCallUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/output-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface OutputNameUpgradeData {\n    /** The @Output() name to replace. */\n    replace: string;\n    /** The new name for the @Output(). */\n    replaceWith: string;\n    /** Controls which elements and attributes in which this replacement is made. */\n    limitedTo: {\n        /** Limit to elements with any of these element tags. */\n        elements?: string[];\n        /** Limit to elements with any of these attributes. */\n        attributes?: string[];\n    };\n}\nexport declare const outputNames: VersionChanges<OutputNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/property-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface PropertyNameUpgradeData {\n    /** The property name to replace. */\n    replace: string;\n    /** The new name for the property. */\n    replaceWith: string;\n    /** Controls which classes in which this replacement is made. */\n    limitedTo: {\n        /** Replace the property only when its type is one of the given Classes. */\n        classes: string[];\n    };\n}\nexport declare const propertyNames: VersionChanges<PropertyNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/data/symbol-removal.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '../../update-tool/version-changes';\nexport interface SymbolRemovalUpgradeData {\n    /** Module that the symbol was removed from. */\n    module: string;\n    /** Name of the symbol being removed. */\n    name: string;\n    /** Message to log explaining why the symbol was removed. */\n    message: string;\n}\nexport declare const symbolRemoval: VersionChanges<SymbolRemovalUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/devkit-file-system.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Path } from '@angular-devkit/core';\nimport { Tree, UpdateRecorder } from '@angular-devkit/schematics';\nimport { DirectoryEntry, FileSystem } from '../update-tool/file-system';\n/**\n * File system that leverages the virtual tree from the CLI devkit. This file\n * system is commonly used by `ng update` migrations that run as part of the\n * Angular CLI.\n */\nexport declare class DevkitFileSystem extends FileSystem {\n    private _tree;\n    private _updateRecorderCache;\n    constructor(_tree: Tree);\n    resolve(...segments: string[]): Path;\n    edit(filePath: Path): UpdateRecorder;\n    commitEdits(): void;\n    fileExists(filePath: Path): boolean;\n    directoryExists(dirPath: Path): boolean;\n    overwrite(filePath: Path, content: string): void;\n    create(filePath: Path, content: string): void;\n    delete(filePath: Path): void;\n    read(filePath: Path): string | null;\n    readDirectory(dirPath: Path): DirectoryEntry;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/devkit-migration-rule.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule, SchematicContext } from '@angular-devkit/schematics';\nimport { MigrationCtor } from '../update-tool/migration';\nimport { TargetVersion } from '../update-tool/target-version';\nimport { DevkitContext, DevkitMigrationCtor } from './devkit-migration';\nimport { UpgradeData } from './upgrade-data';\n/** List of migrations which run for the CDK update. */\nexport declare const cdkMigrations: MigrationCtor<UpgradeData>[];\nexport declare type NullableDevkitMigration = MigrationCtor<UpgradeData | null, DevkitContext>;\ndeclare type PostMigrationFn = (context: SchematicContext, targetVersion: TargetVersion, hasFailure: boolean) => void;\n/**\n * Creates a Angular schematic rule that runs the upgrade for the\n * specified target version.\n */\nexport declare function createMigrationSchematicRule(targetVersion: TargetVersion, extraMigrations: NullableDevkitMigration[], upgradeData: UpgradeData, onMigrationCompleteFn?: PostMigrationFn): Rule;\n/** Whether the given migration type refers to a devkit migration */\nexport declare function isDevkitMigration(value: MigrationCtor<any, any>): value is DevkitMigrationCtor<any>;\nexport {};\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/devkit-migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { SchematicContext, Tree } from '@angular-devkit/schematics';\nimport { ProjectDefinition } from '@angular-devkit/core/src/workspace';\nimport { Constructor, Migration, PostMigrationAction } from '../update-tool/migration';\nimport { TargetVersion } from '../update-tool/target-version';\nexport declare type DevkitContext = {\n    /** Devkit tree for the current migrations. Can be used to insert/remove files. */\n    tree: Tree;\n    /** Name of the project the migrations run against. */\n    projectName: string;\n    /** Workspace project the migrations run against. */\n    project: ProjectDefinition;\n    /** Whether the migrations run for a test target. */\n    isTestTarget: boolean;\n};\nexport declare abstract class DevkitMigration<Data> extends Migration<Data, DevkitContext> {\n    /** Prints an informative message with context on the current target. */\n    protected printInfo(text: string): void;\n    /**\n     * Optional static method that will be called once the migration of all project\n     * targets has been performed. This method can be used to make changes respecting the\n     * migration result of all individual targets. e.g. removing HammerJS if it\n     * is not needed in any project target.\n     */\n    static globalPostMigration?(tree: Tree, targetVersion: TargetVersion, context: SchematicContext): PostMigrationAction;\n}\nexport declare type DevkitMigrationCtor<Data> = Constructor<DevkitMigration<Data>> & {\n    [m in keyof typeof DevkitMigration]: typeof DevkitMigration[m];\n};\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/find-stylesheets.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\n/**\n * Finds stylesheets in the given directory from within the specified tree.\n * @param tree Devkit tree where stylesheet files can be found in.\n * @param startDirectory Optional start directory where stylesheets should be searched in.\n *   This can be useful if only stylesheets within a given folder are relevant (to avoid\n *   unnecessary iterations).\n */\nexport declare function findStylesheetFiles(tree: Tree, startDirectory?: string): string[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/html-parsing/angular.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Finds the specified Angular @Input in the given elements with tag name. */\nexport declare function findInputsOnElementWithTag(html: string, inputName: string, tagNames: string[]): number[];\n/** Finds the specified Angular @Input in elements that have one of the specified attributes. */\nexport declare function findInputsOnElementWithAttr(html: string, inputName: string, attrs: string[]): number[];\n/** Finds the specified Angular @Output in the given elements with tag name. */\nexport declare function findOutputsOnElementWithTag(html: string, outputName: string, tagNames: string[]): number[];\n/** Finds the specified Angular @Output in elements that have one of the specified attributes. */\nexport declare function findOutputsOnElementWithAttr(html: string, outputName: string, attrs: string[]): number[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/html-parsing/elements.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Element } from 'parse5';\n/**\n * Parses a HTML fragment and traverses all AST nodes in order find elements that\n * include the specified attribute.\n */\nexport declare function findElementsWithAttribute(html: string, attributeName: string): Element[];\n/**\n * Finds elements with explicit tag names that also contain the specified attribute. Returns the\n * attribute start offset based on the specified HTML.\n */\nexport declare function findAttributeOnElementWithTag(html: string, name: string, tagNames: string[]): number[];\n/**\n * Finds elements that contain the given attribute and contain at least one of the other\n * specified attributes. Returns the primary attribute's start offset based on the specified HTML.\n */\nexport declare function findAttributeOnElementWithAttrs(html: string, name: string, attrs: string[]): number[];\n/** Gets the start offset of the given attribute from a Parse5 element. */\nexport declare function getStartOffsetOfAttribute(element: any, attributeName: string): number;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/index.d.ts",
      "node_modules/@angular/cdk/schematics/ng-update/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\n/** Entry point for the migration schematics with target of Angular CDK 6.0.0 */\nexport declare function updateToV6(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 7.0.0 */\nexport declare function updateToV7(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 8.0.0 */\nexport declare function updateToV8(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 9.0.0 */\nexport declare function updateToV9(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 10.0.0 */\nexport declare function updateToV10(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 11.0.0 */\nexport declare function updateToV11(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 12.0.0 */\nexport declare function updateToV12(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 13.0.0 */\nexport declare function updateToV13(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 14.0.0 */\nexport declare function updateToV14(): Rule;\n/** Entry point for the migration schematics with target of Angular CDK 15.0.0 */\nexport declare function updateToV15(): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/attribute-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { ResolvedResource } from '../../update-tool/component-resource-collector';\nimport { Migration } from '../../update-tool/migration';\nimport { AttributeSelectorUpgradeData } from '../data/attribute-selectors';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every string literal, template and stylesheet\n * in order to switch deprecated attribute selectors to the updated selector.\n */\nexport declare class AttributeSelectorsMigration extends Migration<UpgradeData> {\n    /** Required upgrade changes for specified target version. */\n    data: AttributeSelectorUpgradeData[];\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    visitTemplate(template: ResolvedResource): void;\n    visitStylesheet(stylesheet: ResolvedResource): void;\n    private _visitStringLiteralLike;\n    private _replaceSelector;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/class-inheritance.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { Migration } from '../../update-tool/migration';\nimport { PropertyNameUpgradeData } from '../data/property-names';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that identifies class declarations that extend CDK or Material classes\n * which had a public property change.\n */\nexport declare class ClassInheritanceMigration extends Migration<UpgradeData> {\n    /**\n     * Map of classes that have been updated. Each class name maps to the according property\n     * change data.\n     */\n    propertyNames: Map<string, PropertyNameUpgradeData>;\n    enabled: boolean;\n    init(): void;\n    visitNode(node: ts.Node): void;\n    private _visitClassDeclaration;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/class-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { Migration } from '../../update-tool/migration';\nimport { ClassNameUpgradeData } from '../data';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every identifier that is part of Angular Material or thr CDK\n * and replaces the outdated name with the new one if specified in the upgrade data.\n */\nexport declare class ClassNamesMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: ClassNameUpgradeData[];\n    /**\n     * List of identifier names that have been imported from `@angular/material` or `@angular/cdk`\n     * in the current source file and therefore can be considered trusted.\n     */\n    trustedIdentifiers: Set<string>;\n    /** List of namespaces that have been imported from `@angular/material` or `@angular/cdk`. */\n    trustedNamespaces: Set<string>;\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    /** Method that is called for every identifier inside of the specified project. */\n    private _visitIdentifier;\n    /** Creates a failure and replacement for the specified identifier. */\n    private _createFailureWithReplacement;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/constructor-signature.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { Migration } from '../../update-tool/migration';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that visits every TypeScript new expression or super call and checks if\n * the parameter type signature is invalid and needs to be updated manually.\n */\nexport declare class ConstructorSignatureMigration extends Migration<UpgradeData> {\n    data: string[];\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    /**\n     * Method that will be called for each source file of the upgrade project. In order to\n     * properly determine invalid constructor signatures, we take advantage of the pre-emit\n     * diagnostics from TypeScript.\n     *\n     * By using the diagnostics, the migration can handle type assignability. Not using\n     * diagnostics would mean that we need to use simple type equality checking which is\n     * too strict. See related issue: https://github.com/Microsoft/TypeScript/issues/9879\n     */\n    private _visitSourceFile;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/css-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { ResolvedResource } from '../../update-tool/component-resource-collector';\nimport { Migration } from '../../update-tool/migration';\nimport { CssSelectorUpgradeData } from '../data/css-selectors';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every string literal, template and stylesheet in\n * order to migrate outdated CSS selectors to the new selector.\n */\nexport declare class CssSelectorsMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: CssSelectorUpgradeData[];\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    visitTemplate(template: ResolvedResource): void;\n    visitStylesheet(stylesheet: ResolvedResource): void;\n    private _visitStringLiteralLike;\n    private _replaceSelector;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/element-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { ResolvedResource } from '../../update-tool/component-resource-collector';\nimport { Migration } from '../../update-tool/migration';\nimport { ElementSelectorUpgradeData } from '../data/element-selectors';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every string literal, template and stylesheet in order\n * to migrate outdated element selectors to the new one.\n */\nexport declare class ElementSelectorsMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: ElementSelectorUpgradeData[];\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    visitTemplate(template: ResolvedResource): void;\n    visitStylesheet(stylesheet: ResolvedResource): void;\n    private _visitStringLiteralLike;\n    private _replaceSelector;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/input-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ResolvedResource } from '../../update-tool/component-resource-collector';\nimport { Migration } from '../../update-tool/migration';\nimport { InputNameUpgradeData } from '../data';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every template or stylesheet and replaces outdated input\n * names to the new input name. Selectors in stylesheets could also target input\n * bindings declared as static attribute. See for example:\n *\n * e.g. `<my-component color=\"primary\">` becomes `my-component[color]`\n */\nexport declare class InputNamesMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: InputNameUpgradeData[];\n    enabled: boolean;\n    visitStylesheet(stylesheet: ResolvedResource): void;\n    visitTemplate(template: ResolvedResource): void;\n    private _replaceInputName;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/method-call-arguments.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { Migration } from '../../update-tool/migration';\nimport { MethodCallUpgradeData } from '../data';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that visits every TypeScript method call expression and checks if the\n * argument count is invalid and needs to be *manually* updated.\n */\nexport declare class MethodCallArgumentsMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: MethodCallUpgradeData[];\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    private _checkPropertyAccessMethodCall;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/misc-template.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ResolvedResource } from '../../update-tool/component-resource-collector';\nimport { Migration } from '../../update-tool/migration';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every template and reports if there are\n * instances of outdated Angular CDK API that can't be migrated automatically.\n */\nexport declare class MiscTemplateMigration extends Migration<UpgradeData> {\n    enabled: boolean;\n    visitTemplate(template: ResolvedResource): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/output-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ResolvedResource } from '../../update-tool/component-resource-collector';\nimport { Migration } from '../../update-tool/migration';\nimport { OutputNameUpgradeData } from '../data';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every inline or external HTML template and switches\n * changed output binding names to the proper new output name.\n */\nexport declare class OutputNamesMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: OutputNameUpgradeData[];\n    enabled: boolean;\n    visitTemplate(template: ResolvedResource): void;\n    private _replaceOutputName;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/property-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { Migration } from '../../update-tool/migration';\nimport { PropertyNameUpgradeData } from '../data';\nimport { UpgradeData } from '../upgrade-data';\n/**\n * Migration that walks through every property access expression and updates\n * accessed properties that have been updated to a new name.\n */\nexport declare class PropertyNamesMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: PropertyNameUpgradeData[];\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    private _visitPropertyAccessExpression;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/symbol-removal.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { Migration } from '../../update-tool/migration';\nimport { SymbolRemovalUpgradeData } from '../data';\nimport { UpgradeData } from '../upgrade-data';\n/** Migration that flags imports for symbols that have been removed. */\nexport declare class SymbolRemovalMigration extends Migration<UpgradeData> {\n    /** Change data that upgrades to the specified target version. */\n    data: SymbolRemovalUpgradeData[];\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/migrations/tilde-import-v13/tilde-import-migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ResolvedResource } from '../../../update-tool/component-resource-collector';\nimport { DevkitMigration } from '../../devkit-migration';\n/** Migration that removes tilde symbols from imports. */\nexport declare class TildeImportMigration extends DevkitMigration<null> {\n    enabled: boolean;\n    visitStylesheet(stylesheet: ResolvedResource): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/public-api.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './data/index';\nexport * from './devkit-migration';\nexport * from './devkit-migration-rule';\nexport * from './html-parsing/angular';\nexport * from './html-parsing/elements';\nexport * from './typescript/base-types';\nexport * from './typescript/imports';\nexport * from './typescript/literal';\nexport * from './typescript/module-specifiers';\nexport * from './upgrade-data';\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/typescript/base-types.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/** Determines the base types of the specified class declaration. */\nexport declare function determineBaseTypes(node: ts.ClassDeclaration): string[] | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/typescript/imports.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/** Checks whether the given node is part of an import specifier node. */\nexport declare function isImportSpecifierNode(node: ts.Node): boolean;\n/** Checks whether the given node is part of an export specifier node. */\nexport declare function isExportSpecifierNode(node: ts.Node): boolean;\n/** Checks whether the given node is part of a namespace import. */\nexport declare function isNamespaceImportNode(node: ts.Node): boolean;\n/** Finds the parent import declaration of a given TypeScript node. */\nexport declare function getImportDeclaration(node: ts.Node): ts.ImportDeclaration;\n/** Finds the parent export declaration of a given TypeScript node */\nexport declare function getExportDeclaration(node: ts.Node): ts.ExportDeclaration;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/typescript/literal.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/** Finds all start indices of the given search string in the input string. */\nexport declare function findAllSubstringIndices(input: string, search: string): number[];\n/**\n * Checks whether the given node is either a string literal or a no-substitution template\n * literal. Note that we cannot use `ts.isStringLiteralLike()` because if developers update\n * an outdated project, their TypeScript version is not automatically being updated\n * and therefore could throw because the function is not available yet.\n * https://github.com/Microsoft/TypeScript/commit/8518343dc8762475a5e92c9f80b5c5725bd81796\n */\nexport declare function isStringLiteralLike(node: ts.Node): node is ts.StringLiteral | ts.NoSubstitutionTemplateLiteral;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/typescript/module-specifiers.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/** Name of the Angular Material module specifier. */\nexport declare const materialModuleSpecifier = \"@angular/material\";\n/** Name of the Angular CDK module specifier. */\nexport declare const cdkModuleSpecifier = \"@angular/cdk\";\n/** Whether the specified node is part of an Angular Material or CDK import declaration. */\nexport declare function isMaterialImportDeclaration(node: ts.Node): boolean;\n/** Whether the specified node is part of an Angular Material or CDK import declaration. */\nexport declare function isMaterialExportDeclaration(node: ts.Node): boolean;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/ng-update/upgrade-data.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration } from '../update-tool/migration';\nimport { ValueOfChanges, VersionChanges } from '../update-tool/version-changes';\nimport { AttributeSelectorUpgradeData, ClassNameUpgradeData, ConstructorChecksUpgradeData, CssSelectorUpgradeData, ElementSelectorUpgradeData, InputNameUpgradeData, MethodCallUpgradeData, OutputNameUpgradeData, PropertyNameUpgradeData, SymbolRemovalUpgradeData } from './data';\n/** Upgrade data for the Angular CDK. */\nexport declare const cdkUpgradeData: UpgradeData;\n/**\n * Interface that describes the upgrade data that needs to be defined when using the CDK\n * upgrade rules.\n */\nexport interface UpgradeData {\n    attributeSelectors: VersionChanges<AttributeSelectorUpgradeData>;\n    classNames: VersionChanges<ClassNameUpgradeData>;\n    constructorChecks: VersionChanges<ConstructorChecksUpgradeData>;\n    cssSelectors: VersionChanges<CssSelectorUpgradeData>;\n    elementSelectors: VersionChanges<ElementSelectorUpgradeData>;\n    inputNames: VersionChanges<InputNameUpgradeData>;\n    methodCallChecks: VersionChanges<MethodCallUpgradeData>;\n    outputNames: VersionChanges<OutputNameUpgradeData>;\n    propertyNames: VersionChanges<PropertyNameUpgradeData>;\n    symbolRemoval: VersionChanges<SymbolRemovalUpgradeData>;\n}\n/**\n * Gets the reduced upgrade data for the specified data key. The function reads out the\n * target version and upgrade data object from the migration and resolves the specified\n * data portion that is specifically tied to the target version.\n */\nexport declare function getVersionUpgradeData<T extends keyof UpgradeData, U = ValueOfChanges<UpgradeData[T]>>(migration: Migration<UpgradeData>, dataName: T): U[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/paths.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Path to the schematic collection for non-migration schematics. */\nexport declare const COLLECTION_PATH: string;\n/** Path to the schematic collection that includes the migrations. */\nexport declare const MIGRATION_PATH: string;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/component-resource-collector.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { FileSystem, WorkspacePath } from './file-system';\nimport { LineAndCharacter } from './utils/line-mappings';\nexport interface ResolvedResource {\n    /** Class declaration that contains this resource. */\n    container: ts.ClassDeclaration | null;\n    /** File content of the given template. */\n    content: string;\n    /** Start offset of the resource content (e.g. in the inline source file) */\n    start: number;\n    /** Whether the given resource is inline or not. */\n    inline: boolean;\n    /** Path to the file that contains this resource. */\n    filePath: WorkspacePath;\n    /**\n     * Gets the character and line of a given position index in the resource.\n     * If the resource is declared inline within a TypeScript source file, the line and\n     * character are based on the full source file content.\n     */\n    getCharacterAndLineOfPosition: (pos: number) => LineAndCharacter;\n}\n/**\n * Collector that can be used to find Angular templates and stylesheets referenced within\n * given TypeScript source files (inline or external referenced files)\n */\nexport declare class ComponentResourceCollector {\n    typeChecker: ts.TypeChecker;\n    private _fileSystem;\n    resolvedTemplates: ResolvedResource[];\n    resolvedStylesheets: ResolvedResource[];\n    constructor(typeChecker: ts.TypeChecker, _fileSystem: FileSystem);\n    visitNode(node: ts.Node): void;\n    private _visitClassDeclaration;\n    /** Resolves an external stylesheet by reading its content and computing line mappings. */\n    resolveExternalStylesheet(filePath: WorkspacePath, container: ts.ClassDeclaration | null): ResolvedResource | null;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/file-system.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { UpdateRecorder } from './update-recorder';\n/**\n * A workspace path semantically is equivalent to the `Path` type provided by the\n * Angular devkit. Paths denoted with such a type are guaranteed to be representing\n * paths of a given virtual file system. This means that the root of a path can be\n * different, and does not necessarily need to match the root in the real file system.\n *\n * For example: Consider we have a project in `/home/<..>/my-project`. Then a path\n * like `/package.json` could actually refer to the `package.json` file in `my-project`.\n * Note that in the real file system this would not match though.\n *\n * One wonder why another type has been declared for such paths, when there already\n * is the `Path` type provided by the devkit. We do this for a couple of reasons:\n *\n *   1. The update-tool cannot have a dependency on the Angular devkit as that one\n *      is not synced into g3. We want to be able to run migrations in g3 if needed.\n */\nexport declare type WorkspacePath = string & {\n    __PRIVATE_DEVKIT_PATH: void;\n};\n/** Interface that describes a directory. */\nexport interface DirectoryEntry {\n    /** List of directories inside the directory. */\n    directories: string[];\n    /** List of files inside the directory. */\n    files: string[];\n}\n/**\n * Abstraction of the file system that migrations can use to record and apply\n * changes. This is necessary to support virtual file systems as used in the CLI devkit.\n */\nexport declare abstract class FileSystem {\n    /** Checks whether the given file exists. */\n    abstract fileExists(path: WorkspacePath): boolean;\n    /** Checks whether the given directory exists. */\n    abstract directoryExists(path: WorkspacePath): boolean;\n    /** Gets the contents of the given file. */\n    abstract read(filePath: WorkspacePath): string | null;\n    /** Reads the given directory to retrieve children. */\n    abstract readDirectory(dirPath: WorkspacePath): DirectoryEntry;\n    /**\n     * Creates an update recorder for the given file. Edits can be recorded and\n     * committed in batches. Changes are not applied automatically because otherwise\n     * migrations would need to re-read files, or account for shifted file contents.\n     */\n    abstract edit(filePath: WorkspacePath): UpdateRecorder;\n    /** Applies all changes which have been recorded in update recorders. */\n    abstract commitEdits(): void;\n    /** Creates a new file with the given content. */\n    abstract create(filePath: WorkspacePath, content: string): void;\n    /** Overwrites an existing file with the given content. */\n    abstract overwrite(filePath: WorkspacePath, content: string): void;\n    /** Deletes the given file. */\n    abstract delete(filePath: WorkspacePath): void;\n    /**\n     * Resolves given paths to a resolved path in the file system. For example, the devkit\n     * tree considers the actual workspace directory as file system root.\n     *\n     * Follows the same semantics as the native path `resolve` method. i.e. segments\n     * are processed in reverse. The last segment is considered the target and the\n     * function will iterate from the target through other segments until it finds an\n     * absolute path segment.\n     */\n    abstract resolve(...segments: string[]): WorkspacePath;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/index.d.ts",
      "node_modules/@angular/cdk/schematics/update-tool/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { FileSystem, WorkspacePath } from './file-system';\nimport { UpdateLogger } from './logger';\nimport { MigrationCtor } from './migration';\nimport { TargetVersion } from './target-version';\n/**\n * An update project that can be run against individual migrations. An update project\n * accepts a TypeScript program and a context that is provided to all migrations. The\n * context is usually not used by migrations, but in some cases migrations rely on\n * specifics from the tool that performs the update (e.g. the Angular CLI). In those cases,\n * the context can provide the necessary specifics to the migrations in a type-safe way.\n */\nexport declare class UpdateProject<Context> {\n    /** Context provided to all migrations. */\n    private _context;\n    /** TypeScript program using workspace paths. */\n    private _program;\n    /** File system used for reading, writing and editing files. */\n    private _fileSystem;\n    /**\n     * Set of analyzed files. Used for avoiding multiple migration runs if\n     * files overlap between targets.\n     */\n    private _analyzedFiles;\n    /** Logger used for printing messages. */\n    private _logger;\n    private readonly _typeChecker;\n    constructor(\n    /** Context provided to all migrations. */\n    _context: Context, \n    /** TypeScript program using workspace paths. */\n    _program: ts.Program, \n    /** File system used for reading, writing and editing files. */\n    _fileSystem: FileSystem, \n    /**\n     * Set of analyzed files. Used for avoiding multiple migration runs if\n     * files overlap between targets.\n     */\n    _analyzedFiles?: Set<WorkspacePath>, \n    /** Logger used for printing messages. */\n    _logger?: UpdateLogger);\n    /**\n     * Migrates the project to the specified target version.\n     * @param migrationTypes Migrations that should be run.\n     * @param target Version the project should be updated to.\n     * @param data Upgrade data that is passed to all migration rules.\n     * @param additionalStylesheetPaths Additional stylesheets that should be migrated, if not\n     *   referenced in an Angular component. This is helpful for global stylesheets in a project.\n     */\n    migrate<Data>(migrationTypes: MigrationCtor<Data, Context>[], target: TargetVersion, data: Data, additionalStylesheetPaths?: string[]): {\n        hasFailures: boolean;\n    };\n    /**\n     * Creates instances of the given migrations with the specified target\n     * version and data.\n     */\n    private _createMigrations;\n    /**\n     * Creates a program form the specified tsconfig and patches the host\n     * to read files and directories through the given file system.\n     */\n    static createProgramFromTsconfig(tsconfigPath: WorkspacePath, fs: FileSystem): ts.Program;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/logger.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport interface UpdateLogger {\n    debug(message: string): void;\n    error(message: string): void;\n    fatal(message: string): void;\n    info(message: string): void;\n    warn(message: string): void;\n}\nexport declare const defaultLogger: UpdateLogger;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { ResolvedResource } from './component-resource-collector';\nimport { FileSystem, WorkspacePath } from './file-system';\nimport { UpdateLogger } from './logger';\nimport { TargetVersion } from './target-version';\nimport { LineAndCharacter } from './utils/line-mappings';\nexport interface MigrationFailure {\n    filePath: WorkspacePath;\n    message: string;\n    position?: LineAndCharacter;\n}\nexport declare type PostMigrationAction = void | {\n    /** Whether the package manager should run upon migration completion. */\n    runPackageManager: boolean;\n};\n/** Creates a constructor type for the specified type. */\nexport declare type Constructor<T> = new (...args: any[]) => T;\n/** Gets a constructor type for the passed migration data. */\nexport declare type MigrationCtor<Data, Context = any> = Constructor<Migration<Data, Context>>;\nexport declare abstract class Migration<Data, Context = any> {\n    /** TypeScript program for the migration. */\n    program: ts.Program;\n    /** TypeChecker instance for the analysis program. */\n    typeChecker: ts.TypeChecker;\n    /** Version for which the migration rule should run. */\n    targetVersion: TargetVersion;\n    /** Context data for the migration. */\n    context: Context;\n    /** Upgrade data passed to the migration. */\n    upgradeData: Data;\n    /** File system that can be used for modifying files. */\n    fileSystem: FileSystem;\n    /** Logger that can be used to print messages as part of the migration. */\n    logger: UpdateLogger;\n    /** List of migration failures that need to be reported. */\n    failures: MigrationFailure[];\n    /** Whether the migration is enabled or not. */\n    abstract enabled: boolean;\n    constructor(\n    /** TypeScript program for the migration. */\n    program: ts.Program, \n    /** TypeChecker instance for the analysis program. */\n    typeChecker: ts.TypeChecker, \n    /** Version for which the migration rule should run. */\n    targetVersion: TargetVersion, \n    /** Context data for the migration. */\n    context: Context, \n    /** Upgrade data passed to the migration. */\n    upgradeData: Data, \n    /** File system that can be used for modifying files. */\n    fileSystem: FileSystem, \n    /** Logger that can be used to print messages as part of the migration. */\n    logger: UpdateLogger);\n    /** Method can be used to perform global analysis of the program. */\n    init(): void;\n    /**\n     * Method that will be called once all nodes, templates and stylesheets\n     * have been visited.\n     */\n    postAnalysis(): void;\n    /**\n     * Method that will be called for each node in a given source file. Unlike tslint, this\n     * function will only retrieve TypeScript nodes that need to be casted manually. This\n     * allows us to only walk the program source files once per program and not per\n     * migration rule (significant performance boost).\n     */\n    visitNode(node: ts.Node): void;\n    /** Method that will be called for each Angular template in the program. */\n    visitTemplate(template: ResolvedResource): void;\n    /** Method that will be called for each stylesheet in the program. */\n    visitStylesheet(stylesheet: ResolvedResource): void;\n    /** Creates a failure with a specified message at the given node location. */\n    protected createFailureAtNode(node: ts.Node, message: string): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/public-api.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './component-resource-collector';\nexport * from './file-system';\nexport * from './index';\nexport * from './migration';\nexport * from './target-version';\nexport * from './utils/decorators';\nexport * from './utils/imports';\nexport * from './version-changes';\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/target-version.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Possible versions that can be automatically migrated by `ng update`. */\nexport declare enum TargetVersion {\n    V6 = \"version 6\",\n    V7 = \"version 7\",\n    V8 = \"version 8\",\n    V9 = \"version 9\",\n    V10 = \"version 10\",\n    V11 = \"version 11\",\n    V12 = \"version 12\",\n    V13 = \"version 13\",\n    V14 = \"version 14\",\n    V15 = \"version 15\"\n}\n/**\n * Returns all versions that are supported by \"ng update\". The versions are determined\n * based on the \"TargetVersion\" enum.\n */\nexport declare function getAllVersionNames(): string[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/update-recorder.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Update recorder that can be used to apply changes to a source file. */\nexport interface UpdateRecorder {\n    insertLeft(index: number, content: string): UpdateRecorder;\n    insertRight(index: number, content: string): UpdateRecorder;\n    remove(index: number, length: number): UpdateRecorder;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/utils/decorators.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { Import } from './imports';\nexport declare type CallExpressionDecorator = ts.Decorator & {\n    expression: ts.CallExpression;\n};\nexport interface NgDecorator {\n    name: string;\n    node: CallExpressionDecorator;\n}\n/**\n * Gets all decorators which are imported from an Angular package\n * (e.g. \"@angular/core\") from a list of decorators.\n */\nexport declare function getAngularDecorators(typeChecker: ts.TypeChecker, decorators: readonly ts.Decorator[]): readonly NgDecorator[];\nexport declare function getCallDecoratorImport(typeChecker: ts.TypeChecker, decorator: ts.Decorator): Import | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/utils/functions.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/**\n * Unwraps a given expression TypeScript node. Expressions can be wrapped within multiple\n * parentheses. e.g. \"(((({exp}))))()\". The function should return the TypeScript node\n * referring to the inner expression. e.g \"exp\".\n */\nexport declare function unwrapExpression(node: ts.Expression | ts.ParenthesizedExpression): ts.Expression;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/utils/imports.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/** Interface describing a resolved import. */\nexport interface Import {\n    /** Name of the imported symbol. */\n    symbolName: string;\n    /** Module name from which the symbol has been imported. */\n    moduleName: string;\n}\n/** Resolves the import of the specified identifier. */\nexport declare function getImportOfIdentifier(node: ts.Identifier, typeChecker: ts.TypeChecker): Import | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/utils/line-mappings.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport interface LineAndCharacter {\n    character: number;\n    line: number;\n}\n/** Gets the line and character for the given position from the line starts map. */\nexport declare function getLineAndCharacterFromPosition(lineStartsMap: number[], position: number): {\n    character: number;\n    line: number;\n};\n/**\n * Computes the line start map of the given text. This can be used in order to\n * retrieve the line and character of a given text position index.\n */\nexport declare function computeLineStartsMap(text: string): number[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/utils/parse-tsconfig.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { FileSystem, WorkspacePath } from '../file-system';\nexport declare function parseTsconfigFile(tsconfigPath: WorkspacePath, fileSystem: FileSystem): ts.ParsedCommandLine;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/utils/property-name.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/** Type that describes a property name with an obtainable text. */\ndeclare type PropertyNameWithText = Exclude<ts.PropertyName, ts.ComputedPropertyName>;\n/**\n * Gets the text of the given property name. Returns null if the property\n * name couldn't be determined statically.\n */\nexport declare function getPropertyNameText(node: ts.PropertyName): string | null;\n/** Checks whether the given property name has a text. */\nexport declare function hasPropertyNameText(node: ts.PropertyName): node is PropertyNameWithText;\nexport {};\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/utils/virtual-host.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport { FileSystem } from '../file-system';\ndeclare module 'typescript' {\n    interface FileSystemEntries {\n        readonly files: readonly string[];\n        readonly directories: readonly string[];\n    }\n    const matchFiles: undefined | ((path: string, extensions: readonly string[] | undefined, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string, depth: number | undefined, getFileSystemEntries: (path: string) => FileSystemEntries, realpath: (path: string) => string, directoryExists: (path: string) => boolean) => string[]);\n}\n/**\n * Implementation of a TypeScript parse config host that relies fully on\n * a given virtual file system.\n */\nexport declare class FileSystemHost implements ts.ParseConfigHost {\n    private _fileSystem;\n    useCaseSensitiveFileNames: boolean;\n    constructor(_fileSystem: FileSystem);\n    fileExists(path: string): boolean;\n    readFile(path: string): string | undefined;\n    readDirectory(rootDir: string, extensions: string[], excludes: string[] | undefined, includes: string[], depth?: number): string[];\n    private _getFileSystemEntries;\n}\n/**\n * Creates a TypeScript compiler host that fully relies fully on the given\n * virtual file system. i.e. no interactions with the working directory.\n */\nexport declare function createFileSystemCompilerHost(options: ts.CompilerOptions, fileSystem: FileSystem): ts.CompilerHost;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/update-tool/version-changes.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { TargetVersion } from './target-version';\nexport declare type VersionChanges<T> = {\n    [target in TargetVersion]?: ReadableChange<T>[];\n};\nexport declare type ReadableChange<T> = {\n    pr: string;\n    changes: T[];\n};\n/** Conditional type that unwraps the value of a version changes type. */\nexport declare type ValueOfChanges<T> = T extends VersionChanges<infer X> ? X : null;\n/**\n * Gets the changes for a given target version from the specified version changes object.\n *\n * For readability and a good overview of breaking changes, the version change data always\n * includes the related Pull Request link. Since this data is not needed when performing the\n * upgrade, this unused data can be removed and the changes data can be flattened into an\n * easy iterable array.\n */\nexport declare function getChangesForTarget<T>(target: TargetVersion, data: VersionChanges<T>): T[];\n/**\n * Gets all changes from the specified version changes object. This is helpful in case a migration\n * rule does not distinguish data based on the target version, but for readability the\n * upgrade data is separated for each target version.\n */\nexport declare function getAllChanges<T>(data: VersionChanges<T>): T[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/ast.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\nimport { Schema as ComponentOptions } from '@schematics/angular/component/schema';\nimport { ProjectDefinition } from '@angular-devkit/core/src/workspace';\nimport * as ts from 'typescript';\n/** Reads file given path and returns TypeScript source file. */\nexport declare function parseSourceFile(host: Tree, path: string): ts.SourceFile;\n/** Import and add module to root app module. */\nexport declare function addModuleImportToRootModule(host: Tree, moduleName: string, src: string, project: ProjectDefinition): void;\n/**\n * Import and add module to specific module path.\n * @param host the tree we are updating\n * @param modulePath src location of the module to import\n * @param moduleName name of module to import\n * @param src src location to import\n */\nexport declare function addModuleImportToModule(host: Tree, modulePath: string, moduleName: string, src: string): void;\n/** Wraps the internal find module from options with undefined path handling  */\nexport declare function findModuleFromOptions(host: Tree, options: ComponentOptions): Promise<string | undefined>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/ast/ng-module-imports.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\n/**\n * Whether the Angular module in the given path imports the specified module class name.\n */\nexport declare function hasNgModuleImport(tree: Tree, modulePath: string, className: string): boolean;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/ast/standalone.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\nimport * as ts from 'typescript';\n/**\n * Checks whether the providers from a module are being imported in a `bootstrapApplication` call.\n * @param tree File tree of the project.\n * @param filePath Path of the file in which to check.\n * @param className Class name of the module to search for.\n */\nexport declare function importsProvidersFrom(tree: Tree, filePath: string, className: string): boolean;\n/**\n * Adds an `importProvidersFrom` call to the `bootstrapApplication` call.\n * @param tree File tree of the project.\n * @param filePath Path to the file that should be updated.\n * @param moduleName Name of the module that should be imported.\n * @param modulePath Path from which to import the module.\n */\nexport declare function addModuleImportToStandaloneBootstrap(tree: Tree, filePath: string, moduleName: string, modulePath: string): void;\n/** Finds the call to `bootstrapApplication` within a file. */\nexport declare function findBootstrapApplicationCall(sourceFile: ts.SourceFile): ts.CallExpression | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/build-component.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema as ComponentOptions } from '@schematics/angular/component/schema';\n/**\n * Rule that copies and interpolates the files that belong to this schematic context. Additionally\n * a list of file paths can be passed to this rule in order to expose them inside the EJS\n * template context.\n *\n * This allows inlining the external template or stylesheet files in EJS without having\n * to manually duplicate the file content.\n */\nexport declare function buildComponent(options: ComponentOptions, additionalFiles?: {\n    [key: string]: string;\n}): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/get-project.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ProjectDefinition, WorkspaceDefinition } from '@angular-devkit/core/src/workspace';\n/**\n * Finds the specified project configuration in the workspace. Throws an error if the project\n * couldn't be found.\n */\nexport declare function getProjectFromWorkspace(workspace: WorkspaceDefinition, projectName: string | undefined): ProjectDefinition;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/html-manipulation.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\nimport { Element } from 'parse5';\n/** Appends the given element HTML fragment to the `<head>` element of the specified HTML file. */\nexport declare function appendHtmlElementToHead(host: Tree, htmlFilePath: string, elementHtml: string): void;\n/** Parses the given HTML file and returns the head element if available. */\nexport declare function getHtmlHeadTagElement(htmlContent: string): Element | null;\n/** Adds a class to the body of the document. */\nexport declare function addBodyClass(host: Tree, htmlFilePath: string, className: string): void;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/index.d.ts",
      "node_modules/@angular/cdk/schematics/utils/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './ast';\nexport * from './ast/ng-module-imports';\nexport * from './build-component';\nexport * from './get-project';\nexport * from './html-manipulation';\nexport * from './parse5-element';\nexport * from './project-index-file';\nexport * from './project-main-file';\nexport * from './project-style-file';\nexport * from './project-targets';\nexport * from './schematic-options';\nexport { importsProvidersFrom, addModuleImportToStandaloneBootstrap } from './ast/standalone';\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/parse5-element.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Element } from 'parse5';\n/** Determines the indentation of child elements for the given Parse5 element. */\nexport declare function getChildElementIndentation(element: Element): number;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/project-index-file.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Path } from '@angular-devkit/core';\nimport { ProjectDefinition } from '@angular-devkit/core/src/workspace';\n/** Gets the path of the index file in the given project. */\nexport declare function getProjectIndexFiles(project: ProjectDefinition): Path[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/project-main-file.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Path } from '@angular-devkit/core';\nimport { ProjectDefinition } from '@angular-devkit/core/src/workspace';\n/** Looks for the main TypeScript file in the given project and returns its path. */\nexport declare function getProjectMainFile(project: ProjectDefinition): Path;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/project-style-file.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ProjectDefinition } from '@angular-devkit/core/src/workspace';\n/**\n * Gets a style file with the given extension in a project and returns its path. If no\n * extension is specified, any style file with a valid extension will be returned.\n */\nexport declare function getProjectStyleFile(project: ProjectDefinition, extension?: string): string | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/project-targets.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ProjectDefinition, TargetDefinition } from '@angular-devkit/core/src/workspace';\nimport { JsonValue } from '@angular-devkit/core';\n/** Object that maps a CLI target to its default builder name. */\nexport declare const defaultTargetBuilders: {\n    build: string;\n    test: string;\n};\n/** Resolves the architect options for the build target of the given project. */\nexport declare function getProjectTargetOptions(project: ProjectDefinition, buildTarget: string): Record<string, JsonValue | undefined>;\n/** Gets all targets from the given project that match the specified builder name. */\nexport declare function getTargetsByBuilderName(project: ProjectDefinition, builderName: string): TargetDefinition[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/project-tsconfig-paths.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ProjectDefinition, WorkspaceDefinition } from '@angular-devkit/core/src/workspace';\nimport { Tree } from '@angular-devkit/schematics';\nimport { WorkspacePath } from '../update-tool/file-system';\n/** Gets the tsconfig path from the given target within the specified project. */\nexport declare function getTargetTsconfigPath(project: ProjectDefinition, targetName: string): WorkspacePath | null;\n/** Resolve the workspace configuration of the specified tree gracefully. */\nexport declare function getWorkspaceConfigGracefully(tree: Tree): Promise<WorkspaceDefinition | null>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/schematics/utils/schematic-options.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ProjectDefinition } from '@angular-devkit/core/src/workspace';\nimport { Schema } from '@schematics/angular/component/schema';\n/**\n * Returns the default options for the `@schematics/angular:component` schematic which would\n * have been specified at project initialization (ng new or ng init).\n *\n * This is necessary because the Angular CLI only exposes the default values for the \"--style\",\n * \"--inlineStyle\", \"--skipTests\" and \"--inlineTemplate\" options to the \"component\" schematic.\n */\nexport declare function getDefaultComponentOptions(project: ProjectDefinition): Partial<Schema>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/scrolling/index.d.ts",
      "node_modules/@angular/cdk/scrolling/index.d.ts"
    ],
    "content": "import { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { CollectionViewer } from '@angular/cdk/collections';\nimport { DataSource } from '@angular/cdk/collections';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i7 from '@angular/cdk/bidi';\nimport { InjectionToken } from '@angular/core';\nimport { IterableDiffers } from '@angular/core';\nimport { ListRange } from '@angular/cdk/collections';\nimport { NgIterable } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';\nimport { Subject } from 'rxjs';\nimport { Subscription } from 'rxjs';\nimport { TemplateRef } from '@angular/core';\nimport { TrackByFunction } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\nexport declare type _Bottom = {\n    bottom?: number;\n};\n\n/** A virtual scroll strategy that supports fixed-size items. */\nexport declare class CdkFixedSizeVirtualScroll implements OnChanges {\n    /** The size of the items in the list (in pixels). */\n    get itemSize(): number;\n    set itemSize(value: NumberInput);\n    _itemSize: number;\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx(): number;\n    set minBufferPx(value: NumberInput);\n    _minBufferPx: number;\n    /**\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n     */\n    get maxBufferPx(): number;\n    set maxBufferPx(value: NumberInput);\n    _maxBufferPx: number;\n    /** The scroll strategy used by this directive. */\n    _scrollStrategy: FixedSizeVirtualScrollStrategy;\n    ngOnChanges(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFixedSizeVirtualScroll, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFixedSizeVirtualScroll, \"cdk-virtual-scroll-viewport[itemSize]\", never, { \"itemSize\": \"itemSize\"; \"minBufferPx\": \"minBufferPx\"; \"maxBufferPx\": \"maxBufferPx\"; }, {}, never, never, false>;\n}\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nexport declare class CdkScrollable implements OnInit, OnDestroy {\n    protected elementRef: ElementRef<HTMLElement>;\n    protected scrollDispatcher: ScrollDispatcher;\n    protected ngZone: NgZone;\n    protected dir?: Directionality | undefined;\n    protected readonly _destroyed: Subject<void>;\n    protected _elementScrolled: Observable<Event>;\n    constructor(elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir?: Directionality | undefined);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Returns observable that emits when a scroll event is fired on the host element. */\n    elementScrolled(): Observable<Event>;\n    /** Gets the ElementRef for the viewport. */\n    getElementRef(): ElementRef<HTMLElement>;\n    /**\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param options specified the offsets to scroll to.\n     */\n    scrollTo(options: ExtendedScrollToOptions): void;\n    private _applyScrollToOptions;\n    /**\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param from The edge to measure from.\n     */\n    measureScrollOffset(from: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkScrollable, [null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkScrollable, \"[cdk-scrollable], [cdkScrollable]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class CdkScrollableModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkScrollableModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkScrollableModule, [typeof i1.CdkScrollable], never, [typeof i1.CdkScrollable]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<CdkScrollableModule>;\n}\n\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\nexport declare class CdkVirtualForOf<T> implements CdkVirtualScrollRepeater<T>, CollectionViewer, DoCheck, OnDestroy {\n    /** The view container to add items to. */\n    private _viewContainerRef;\n    /** The template to use when stamping out new items. */\n    private _template;\n    /** The set of available differs. */\n    private _differs;\n    /** The strategy used to render items in the virtual scroll viewport. */\n    private _viewRepeater;\n    /** The virtual scrolling viewport that these items are being rendered in. */\n    private _viewport;\n    /** Emits when the rendered view of the data changes. */\n    readonly viewChange: Subject<ListRange>;\n    /** Subject that emits when a new DataSource instance is given. */\n    private readonly _dataSourceChanges;\n    /** The DataSource to display. */\n    get cdkVirtualForOf(): DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined;\n    set cdkVirtualForOf(value: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined);\n    _cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined;\n    /**\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n     * the item and produces a value to be used as the item's identity when tracking changes.\n     */\n    get cdkVirtualForTrackBy(): TrackByFunction<T> | undefined;\n    set cdkVirtualForTrackBy(fn: TrackByFunction<T> | undefined);\n    private _cdkVirtualForTrackBy;\n    /** The template used to stamp out new elements. */\n    set cdkVirtualForTemplate(value: TemplateRef<CdkVirtualForOfContext<T>>);\n    /**\n     * The size of the cache used to store templates that are not being used for re-use later.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n     */\n    get cdkVirtualForTemplateCacheSize(): number;\n    set cdkVirtualForTemplateCacheSize(size: NumberInput);\n    /** Emits whenever the data in the current DataSource changes. */\n    readonly dataStream: Observable<readonly T[]>;\n    /** The differ used to calculate changes to the data. */\n    private _differ;\n    /** The most recent data emitted from the DataSource. */\n    private _data;\n    /** The currently rendered items. */\n    private _renderedItems;\n    /** The currently rendered range of indices. */\n    private _renderedRange;\n    /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n    private _needsUpdate;\n    private readonly _destroyed;\n    constructor(\n    /** The view container to add items to. */\n    _viewContainerRef: ViewContainerRef, \n    /** The template to use when stamping out new items. */\n    _template: TemplateRef<CdkVirtualForOfContext<T>>, \n    /** The set of available differs. */\n    _differs: IterableDiffers, \n    /** The strategy used to render items in the virtual scroll viewport. */\n    _viewRepeater: _RecycleViewRepeaterStrategy<T, T, CdkVirtualForOfContext<T>>, \n    /** The virtual scrolling viewport that these items are being rendered in. */\n    _viewport: CdkVirtualScrollViewport, ngZone: NgZone);\n    /**\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n     * in the specified range. Throws an error if the range includes items that are not currently\n     * rendered.\n     */\n    measureRangeSize(range: ListRange, orientation: 'horizontal' | 'vertical'): number;\n    ngDoCheck(): void;\n    ngOnDestroy(): void;\n    /** React to scroll state changes in the viewport. */\n    private _onRenderedDataChange;\n    /** Swap out one `DataSource` for another. */\n    private _changeDataSource;\n    /** Update the `CdkVirtualForOfContext` for all views. */\n    private _updateContext;\n    /** Apply changes to the DOM. */\n    private _applyChanges;\n    /** Update the computed properties on the `CdkVirtualForOfContext`. */\n    private _updateComputedContextProperties;\n    private _getEmbeddedViewArgs;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualForOf<any>, [null, null, null, null, { skipSelf: true; }, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualForOf<any>, \"[cdkVirtualFor][cdkVirtualForOf]\", never, { \"cdkVirtualForOf\": \"cdkVirtualForOf\"; \"cdkVirtualForTrackBy\": \"cdkVirtualForTrackBy\"; \"cdkVirtualForTemplate\": \"cdkVirtualForTemplate\"; \"cdkVirtualForTemplateCacheSize\": \"cdkVirtualForTemplateCacheSize\"; }, {}, never, never, false>;\n}\n\n/** The context for an item rendered by `CdkVirtualForOf` */\nexport declare type CdkVirtualForOfContext<T> = {\n    /** The item value. */\n    $implicit: T;\n    /** The DataSource, Observable, or NgIterable that was passed to *cdkVirtualFor. */\n    cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T>;\n    /** The index of the item in the DataSource. */\n    index: number;\n    /** The number of items in the DataSource. */\n    count: number;\n    /** Whether this is the first item in the DataSource. */\n    first: boolean;\n    /** Whether this is the last item in the DataSource. */\n    last: boolean;\n    /** Whether the index is even. */\n    even: boolean;\n    /** Whether the index is odd. */\n    odd: boolean;\n};\n\n/**\n * Extending the {@link CdkScrollable} to be used as scrolling container for virtual scrolling.\n */\nexport declare abstract class CdkVirtualScrollable extends CdkScrollable {\n    constructor(elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir?: Directionality);\n    /**\n     * Measure the viewport size for the provided orientation.\n     *\n     * @param orientation The orientation to measure the size from.\n     */\n    measureViewportSize(orientation: 'horizontal' | 'vertical'): number;\n    /**\n     * Measure the bounding ClientRect size including the scroll offset.\n     *\n     * @param from The edge to measure from.\n     */\n    abstract measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollable, [null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualScrollable, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * Provides a virtual scrollable for the element it is attached to.\n */\nexport declare class CdkVirtualScrollableElement extends CdkVirtualScrollable {\n    constructor(elementRef: ElementRef, scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir: Directionality);\n    measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollableElement, [null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualScrollableElement, \"[cdkVirtualScrollingElement]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Provides as virtual scrollable for the global / window scrollbar.\n */\nexport declare class CdkVirtualScrollableWindow extends CdkVirtualScrollable {\n    protected _elementScrolled: Observable<Event>;\n    constructor(scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir: Directionality);\n    measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollableWindow, [null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualScrollableWindow, \"cdk-virtual-scroll-viewport[scrollWindow]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * An item to be repeated by the VirtualScrollViewport\n */\nexport declare interface CdkVirtualScrollRepeater<T> {\n    readonly dataStream: Observable<readonly T[]>;\n    measureRangeSize(range: ListRange, orientation: 'horizontal' | 'vertical'): number;\n}\n\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\nexport declare class CdkVirtualScrollViewport extends CdkVirtualScrollable implements OnInit, OnDestroy {\n    elementRef: ElementRef<HTMLElement>;\n    private _changeDetectorRef;\n    private _scrollStrategy;\n    scrollable: CdkVirtualScrollable;\n    private _platform;\n    /** Emits when the viewport is detached from a CdkVirtualForOf. */\n    private readonly _detachedSubject;\n    /** Emits when the rendered range changes. */\n    private readonly _renderedRangeSubject;\n    /** The direction the viewport scrolls. */\n    get orientation(): 'horizontal' | 'vertical';\n    set orientation(orientation: 'horizontal' | 'vertical');\n    private _orientation;\n    /**\n     * Whether rendered items should persist in the DOM after scrolling out of view. By default, items\n     * will be removed.\n     */\n    get appendOnly(): boolean;\n    set appendOnly(value: BooleanInput);\n    private _appendOnly;\n    /** Emits when the index of the first element visible in the viewport changes. */\n    readonly scrolledIndexChange: Observable<number>;\n    /** The element that wraps the rendered content. */\n    _contentWrapper: ElementRef<HTMLElement>;\n    /** A stream that emits whenever the rendered range changes. */\n    readonly renderedRangeStream: Observable<ListRange>;\n    /**\n     * The total size of all content (in pixels), including content that is not currently rendered.\n     */\n    private _totalContentSize;\n    /** A string representing the `style.width` property value to be used for the spacer element. */\n    _totalContentWidth: string;\n    /** A string representing the `style.height` property value to be used for the spacer element. */\n    _totalContentHeight: string;\n    /**\n     * The CSS transform applied to the rendered subset of items so that they appear within the bounds\n     * of the visible viewport.\n     */\n    private _renderedContentTransform;\n    /** The currently rendered range of indices. */\n    private _renderedRange;\n    /** The length of the data bound to this viewport (in number of items). */\n    private _dataLength;\n    /** The size of the viewport (in pixels). */\n    private _viewportSize;\n    /** the currently attached CdkVirtualScrollRepeater. */\n    private _forOf;\n    /** The last rendered content offset that was set. */\n    private _renderedContentOffset;\n    /**\n     * Whether the last rendered content offset was to the end of the content (and therefore needs to\n     * be rewritten as an offset to the start of the content).\n     */\n    private _renderedContentOffsetNeedsRewrite;\n    /** Whether there is a pending change detection cycle. */\n    private _isChangeDetectionPending;\n    /** A list of functions to run after the next change detection cycle. */\n    private _runAfterChangeDetection;\n    /** Subscription to changes in the viewport size. */\n    private _viewportChanges;\n    constructor(elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, ngZone: NgZone, _scrollStrategy: VirtualScrollStrategy, dir: Directionality, scrollDispatcher: ScrollDispatcher, viewportRuler: ViewportRuler, scrollable: CdkVirtualScrollable);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n    attach(forOf: CdkVirtualScrollRepeater<any>): void;\n    /** Detaches the current `CdkVirtualForOf`. */\n    detach(): void;\n    /** Gets the length of the data bound to this viewport (in number of items). */\n    getDataLength(): number;\n    /** Gets the size of the viewport (in pixels). */\n    getViewportSize(): number;\n    /** Get the current rendered range of items. */\n    getRenderedRange(): ListRange;\n    measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;\n    /**\n     * Sets the total size of all content (in pixels), including content that is not currently\n     * rendered.\n     */\n    setTotalContentSize(size: number): void;\n    /** Sets the currently rendered range of indices. */\n    setRenderedRange(range: ListRange): void;\n    /**\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n     */\n    getOffsetToRenderedContentStart(): number | null;\n    /**\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\n     * (in pixels).\n     */\n    setRenderedContentOffset(offset: number, to?: 'to-start' | 'to-end'): void;\n    /**\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n     * @param offset The offset to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToOffset(offset: number, behavior?: ScrollBehavior): void;\n    /**\n     * Scrolls to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToIndex(index: number, behavior?: ScrollBehavior): void;\n    /**\n     * Gets the current scroll offset from the start of the scrollable (in pixels).\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n     *     in horizontal mode.\n     */\n    measureScrollOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;\n    /**\n     * Measures the offset of the viewport from the scrolling container\n     * @param from The edge to measure from.\n     */\n    measureViewportOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;\n    /** Measure the combined size of all of the rendered items. */\n    measureRenderedContentSize(): number;\n    /**\n     * Measure the total combined size of the given range. Throws if the range includes items that are\n     * not rendered.\n     */\n    measureRangeSize(range: ListRange): number;\n    /** Update the viewport dimensions and re-render. */\n    checkViewportSize(): void;\n    /** Measure the viewport size. */\n    private _measureViewportSize;\n    /** Queue up change detection to run. */\n    private _markChangeDetectionNeeded;\n    /** Run change detection. */\n    private _doChangeDetection;\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\n    private _calculateSpacerSize;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollViewport, [null, null, null, { optional: true; }, { optional: true; }, null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkVirtualScrollViewport, \"cdk-virtual-scroll-viewport\", never, { \"orientation\": \"orientation\"; \"appendOnly\": \"appendOnly\"; }, { \"scrolledIndexChange\": \"scrolledIndexChange\"; }, never, [\"*\"], false>;\n}\n\n/** Time in ms to throttle the resize events by default. */\nexport declare const DEFAULT_RESIZE_TIME = 20;\n\n/** Time in ms to throttle the scrolling events by default. */\nexport declare const DEFAULT_SCROLL_TIME = 20;\n\nexport declare type _End = {\n    end?: number;\n};\n\n/**\n * An extended version of ScrollToOptions that allows expressing scroll offsets relative to the\n * top, bottom, left, right, start, or end of the viewport rather than just the top and left.\n * Please note: the top and bottom properties are mutually exclusive, as are the left, right,\n * start, and end properties.\n */\nexport declare type ExtendedScrollToOptions = _XAxis & _YAxis & ScrollOptions;\n\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nexport declare class FixedSizeVirtualScrollStrategy implements VirtualScrollStrategy {\n    private readonly _scrolledIndexChange;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    scrolledIndexChange: Observable<number>;\n    /** The attached viewport. */\n    private _viewport;\n    /** The size of the items in the virtually scrolling list. */\n    private _itemSize;\n    /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n    private _minBufferPx;\n    /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n    private _maxBufferPx;\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize: number, minBufferPx: number, maxBufferPx: number);\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport: CdkVirtualScrollViewport): void;\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach(): void;\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize: number, minBufferPx: number, maxBufferPx: number): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled(): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged(): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered(): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged(): void;\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index: number, behavior: ScrollBehavior): void;\n    /** Update the viewport's total content size. */\n    private _updateTotalContentSize;\n    /** Update the viewport's rendered range. */\n    private _updateRenderedRange;\n}\n\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nexport declare function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir: CdkFixedSizeVirtualScroll): FixedSizeVirtualScrollStrategy;\n\ndeclare namespace i1 {\n    export {\n        _Without,\n        _XOR,\n        _Top,\n        _Bottom,\n        _Left,\n        _Right,\n        _Start,\n        _End,\n        _XAxis,\n        _YAxis,\n        ExtendedScrollToOptions,\n        CdkScrollable\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        _fixedSizeVirtualScrollStrategyFactory,\n        FixedSizeVirtualScrollStrategy,\n        CdkFixedSizeVirtualScroll\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        CdkVirtualForOfContext,\n        CdkVirtualForOf\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        CdkVirtualScrollViewport\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        CdkVirtualScrollableWindow\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        CdkVirtualScrollableElement\n    }\n}\n\nexport declare type _Left = {\n    left?: number;\n};\n\nexport declare type _Right = {\n    right?: number;\n};\n\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nexport declare class ScrollDispatcher implements OnDestroy {\n    private _ngZone;\n    private _platform;\n    /** Used to reference correct document/window */\n    protected _document: Document;\n    constructor(_ngZone: NgZone, _platform: Platform, document: any);\n    /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n    private readonly _scrolled;\n    /** Keeps track of the global `scroll` and `resize` subscriptions. */\n    _globalSubscription: Subscription | null;\n    /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n    private _scrolledCount;\n    /**\n     * Map of all the scrollable references that are registered with the service and their\n     * scroll event subscriptions.\n     */\n    scrollContainers: Map<CdkScrollable, Subscription>;\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    register(scrollable: CdkScrollable): void;\n    /**\n     * De-registers a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    deregister(scrollable: CdkScrollable): void;\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    scrolled(auditTimeInMs?: number): Observable<CdkScrollable | void>;\n    ngOnDestroy(): void;\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementOrElementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    ancestorScrolled(elementOrElementRef: ElementRef | HTMLElement, auditTimeInMs?: number): Observable<CdkScrollable | void>;\n    /** Returns all registered Scrollables that contain the provided element. */\n    getAncestorScrollContainers(elementOrElementRef: ElementRef | HTMLElement): CdkScrollable[];\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    private _getWindow;\n    /** Returns true if the element is contained within the provided Scrollable. */\n    private _scrollableContainsElement;\n    /** Sets up the global scroll listeners. */\n    private _addGlobalListener;\n    /** Cleans up the global scroll listener. */\n    private _removeGlobalListener;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ScrollDispatcher, [null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ScrollDispatcher>;\n}\n\n/**\n * @docs-primary-export\n */\nexport declare class ScrollingModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<ScrollingModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<ScrollingModule, [typeof i2.CdkFixedSizeVirtualScroll, typeof i3.CdkVirtualForOf, typeof i4.CdkVirtualScrollViewport, typeof i5.CdkVirtualScrollableWindow, typeof i6.CdkVirtualScrollableElement], [typeof i7.BidiModule, typeof CdkScrollableModule], [typeof i7.BidiModule, typeof CdkScrollableModule, typeof i2.CdkFixedSizeVirtualScroll, typeof i3.CdkVirtualForOf, typeof i4.CdkVirtualScrollViewport, typeof i5.CdkVirtualScrollableWindow, typeof i6.CdkVirtualScrollableElement]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<ScrollingModule>;\n}\n\nexport declare type _Start = {\n    start?: number;\n};\n\nexport declare type _Top = {\n    top?: number;\n};\n\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\nexport declare class ViewportRuler implements OnDestroy {\n    private _platform;\n    /** Cached viewport dimensions. */\n    private _viewportSize;\n    /** Stream of viewport change events. */\n    private readonly _change;\n    /** Event listener that will be used to handle the viewport change events. */\n    private _changeListener;\n    /** Used to reference correct document/window */\n    protected _document: Document;\n    constructor(_platform: Platform, ngZone: NgZone, document: any);\n    ngOnDestroy(): void;\n    /** Returns the viewport's width and height. */\n    getViewportSize(): Readonly<{\n        width: number;\n        height: number;\n    }>;\n    /** Gets a ClientRect for the viewport's bounds. */\n    getViewportRect(): {\n        top: number;\n        left: number;\n        bottom: number;\n        right: number;\n        height: number;\n        width: number;\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    getViewportScrollPosition(): ViewportScrollPosition;\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * This stream emits outside of the Angular zone.\n     * @param throttleTime Time in milliseconds to throttle the stream.\n     */\n    change(throttleTime?: number): Observable<Event>;\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    private _getWindow;\n    /** Updates the cached viewport size. */\n    private _updateViewportSize;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ViewportRuler, [null, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ViewportRuler>;\n}\n\n/** Object that holds the scroll position of the viewport in each direction. */\nexport declare interface ViewportScrollPosition {\n    top: number;\n    left: number;\n}\n\n/** The injection token used to specify the virtual scrolling strategy. */\nexport declare const VIRTUAL_SCROLL_STRATEGY: InjectionToken<VirtualScrollStrategy>;\n\nexport declare const VIRTUAL_SCROLLABLE: InjectionToken<CdkVirtualScrollable>;\n\n/** A strategy that dictates which items should be rendered in the viewport. */\nexport declare interface VirtualScrollStrategy {\n    /** Emits when the index of the first element visible in the viewport changes. */\n    scrolledIndexChange: Observable<number>;\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport: CdkVirtualScrollViewport): void;\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach(): void;\n    /** Called when the viewport is scrolled (debounced using requestAnimationFrame). */\n    onContentScrolled(): void;\n    /** Called when the length of the data changes. */\n    onDataLengthChanged(): void;\n    /** Called when the range of items rendered in the DOM has changed. */\n    onContentRendered(): void;\n    /** Called when the offset of the rendered items changed. */\n    onRenderedOffsetChanged(): void;\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index: number, behavior: ScrollBehavior): void;\n}\n\nexport declare type _Without<T> = {\n    [P in keyof T]?: never;\n};\n\nexport declare type _XAxis = _XOR<_XOR<_Left, _Right>, _XOR<_Start, _End>>;\n\nexport declare type _XOR<T, U> = (_Without<T> & U) | (_Without<U> & T);\n\nexport declare type _YAxis = _XOR<_Top, _Bottom>;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/stepper/index.d.ts",
      "node_modules/@angular/cdk/stepper/index.d.ts"
    ],
    "content": "import { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i5 from '@angular/cdk/bidi';\nimport { InjectionToken } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplateRef } from '@angular/core';\n\n/**\n * Simplified representation of an \"AbstractControl\" from @angular/forms.\n * Used to avoid having to bring in @angular/forms for a single optional interface.\n * @docs-private\n */\ndeclare interface AbstractControlLike {\n    asyncValidator: ((control: any) => any) | null;\n    dirty: boolean;\n    disabled: boolean;\n    enabled: boolean;\n    errors: {\n        [key: string]: any;\n    } | null;\n    invalid: boolean;\n    parent: any;\n    pending: boolean;\n    pristine: boolean;\n    root: AbstractControlLike;\n    status: string;\n    readonly statusChanges: Observable<any>;\n    touched: boolean;\n    untouched: boolean;\n    updateOn: any;\n    valid: boolean;\n    validator: ((control: any) => any) | null;\n    value: any;\n    readonly valueChanges: Observable<any>;\n    clearAsyncValidators(): void;\n    clearValidators(): void;\n    disable(opts?: any): void;\n    enable(opts?: any): void;\n    get(path: (string | number)[] | string): AbstractControlLike | null;\n    getError(errorCode: string, path?: (string | number)[] | string): any;\n    hasError(errorCode: string, path?: (string | number)[] | string): boolean;\n    markAllAsTouched(): void;\n    markAsDirty(opts?: any): void;\n    markAsPending(opts?: any): void;\n    markAsPristine(opts?: any): void;\n    markAsTouched(opts?: any): void;\n    markAsUntouched(opts?: any): void;\n    patchValue(value: any, options?: Object): void;\n    reset(value?: any, options?: Object): void;\n    setAsyncValidators(newValidator: (control: any) => any | ((control: any) => any)[] | null): void;\n    setErrors(errors: {\n        [key: string]: any;\n    } | null, opts?: any): void;\n    setParent(parent: any): void;\n    setValidators(newValidator: (control: any) => any | ((control: any) => any)[] | null): void;\n    setValue(value: any, options?: Object): void;\n    updateValueAndValidity(opts?: any): void;\n    patchValue(value: any, options?: any): void;\n    reset(formState?: any, options?: any): void;\n    setValue(value: any, options?: any): void;\n}\n\nexport declare class CdkStep implements OnChanges {\n    _stepper: CdkStepper;\n    private _stepperOptions;\n    _displayDefaultIndicatorType: boolean;\n    /** Template for step label if it exists. */\n    stepLabel: CdkStepLabel;\n    /** Template for step content. */\n    content: TemplateRef<any>;\n    /** The top level abstract control of the step. */\n    stepControl: AbstractControlLike;\n    /** Whether user has attempted to move away from the step. */\n    interacted: boolean;\n    /** Emits when the user has attempted to move away from the step. */\n    readonly interactedStream: EventEmitter<CdkStep>;\n    /** Plain text label of the step. */\n    label: string;\n    /** Error message to display when there's an error. */\n    errorMessage: string;\n    /** Aria label for the tab. */\n    ariaLabel: string;\n    /**\n     * Reference to the element that the tab is labelled by.\n     * Will be cleared if `aria-label` is set at the same time.\n     */\n    ariaLabelledby: string;\n    /** State of the step. */\n    state: StepState;\n    /** Whether the user can return to this step once it has been marked as completed. */\n    get editable(): boolean;\n    set editable(value: BooleanInput);\n    private _editable;\n    /** Whether the completion of step is optional. */\n    get optional(): boolean;\n    set optional(value: BooleanInput);\n    private _optional;\n    /** Whether step is marked as completed. */\n    get completed(): boolean;\n    set completed(value: BooleanInput);\n    _completedOverride: boolean | null;\n    private _getDefaultCompleted;\n    /** Whether step has an error. */\n    get hasError(): boolean;\n    set hasError(value: BooleanInput);\n    private _customError;\n    private _getDefaultError;\n    constructor(_stepper: CdkStepper, stepperOptions?: StepperOptions);\n    /** Selects this step component. */\n    select(): void;\n    /** Resets the step to its initial state. Note that this includes resetting form data. */\n    reset(): void;\n    ngOnChanges(): void;\n    _markAsInteracted(): void;\n    /** Determines whether the error state can be shown. */\n    _showError(): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkStep, [null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkStep, \"cdk-step\", [\"cdkStep\"], { \"stepControl\": \"stepControl\"; \"label\": \"label\"; \"errorMessage\": \"errorMessage\"; \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"state\": \"state\"; \"editable\": \"editable\"; \"optional\": \"optional\"; \"completed\": \"completed\"; \"hasError\": \"hasError\"; }, { \"interactedStream\": \"interacted\"; }, [\"stepLabel\"], [\"*\"], false>;\n}\n\nexport declare class CdkStepHeader implements FocusableOption {\n    _elementRef: ElementRef<HTMLElement>;\n    constructor(_elementRef: ElementRef<HTMLElement>);\n    /** Focuses the step header. */\n    focus(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkStepHeader, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkStepHeader, \"[cdkStepHeader]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class CdkStepLabel {\n    template: TemplateRef<any>;\n    constructor(/** @docs-private */ template: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkStepLabel, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkStepLabel, \"[cdkStepLabel]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class CdkStepper implements AfterContentInit, AfterViewInit, OnDestroy {\n    private _dir;\n    private _changeDetectorRef;\n    private _elementRef;\n    /** Emits when the component is destroyed. */\n    protected readonly _destroyed: Subject<void>;\n    /** Used for managing keyboard focus. */\n    private _keyManager;\n    /** Full list of steps inside the stepper, including inside nested steppers. */\n    _steps: QueryList<CdkStep>;\n    /** Steps that belong to the current stepper, excluding ones from nested steppers. */\n    readonly steps: QueryList<CdkStep>;\n    /** The list of step headers of the steps in the stepper. */\n    _stepHeader: QueryList<CdkStepHeader>;\n    /** List of step headers sorted based on their DOM order. */\n    private _sortedHeaders;\n    /** Whether the validity of previous steps should be checked or not. */\n    get linear(): boolean;\n    set linear(value: BooleanInput);\n    private _linear;\n    /** The index of the selected step. */\n    get selectedIndex(): number;\n    set selectedIndex(index: NumberInput);\n    private _selectedIndex;\n    /** The step that is selected. */\n    get selected(): CdkStep | undefined;\n    set selected(step: CdkStep | undefined);\n    /** Event emitted when the selected step has changed. */\n    readonly selectionChange: EventEmitter<StepperSelectionEvent>;\n    /** Used to track unique ID for each stepper component. */\n    _groupId: number;\n    /** Orientation of the stepper. */\n    get orientation(): StepperOrientation;\n    set orientation(value: StepperOrientation);\n    private _orientation;\n    constructor(_dir: Directionality, _changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef<HTMLElement>);\n    ngAfterContentInit(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /** Selects and focuses the next step in list. */\n    next(): void;\n    /** Selects and focuses the previous step in list. */\n    previous(): void;\n    /** Resets the stepper to its initial state. Note that this includes clearing form data. */\n    reset(): void;\n    /** Returns a unique id for each step label element. */\n    _getStepLabelId(i: number): string;\n    /** Returns unique id for each step content element. */\n    _getStepContentId(i: number): string;\n    /** Marks the component to be change detected. */\n    _stateChanged(): void;\n    /** Returns position state of the step with the given index. */\n    _getAnimationDirection(index: number): StepContentPositionState;\n    /** Returns the type of icon to be displayed. */\n    _getIndicatorType(index: number, state?: StepState): StepState;\n    private _getDefaultIndicatorLogic;\n    private _getGuidelineLogic;\n    private _isCurrentStep;\n    /** Returns the index of the currently-focused step header. */\n    _getFocusIndex(): number | null;\n    private _updateSelectedItemIndex;\n    _onKeydown(event: KeyboardEvent): void;\n    private _anyControlsInvalidOrPending;\n    private _layoutDirection;\n    /** Checks whether the stepper contains the focused element. */\n    private _containsFocus;\n    /** Checks whether the passed-in index is a valid step index. */\n    private _isValidIndex;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkStepper, [{ optional: true; }, null, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkStepper, \"[cdkStepper]\", [\"cdkStepper\"], { \"linear\": \"linear\"; \"selectedIndex\": \"selectedIndex\"; \"selected\": \"selected\"; \"orientation\": \"orientation\"; }, { \"selectionChange\": \"selectionChange\"; }, [\"_steps\", \"_stepHeader\"], never, false>;\n}\n\nexport declare class CdkStepperModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkStepperModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkStepperModule, [typeof i1.CdkStep, typeof i1.CdkStepper, typeof i2.CdkStepHeader, typeof i3.CdkStepLabel, typeof i4.CdkStepperNext, typeof i4.CdkStepperPrevious], [typeof i5.BidiModule], [typeof i1.CdkStep, typeof i1.CdkStepper, typeof i2.CdkStepHeader, typeof i3.CdkStepLabel, typeof i4.CdkStepperNext, typeof i4.CdkStepperPrevious]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<CdkStepperModule>;\n}\n\n/** Button that moves to the next step in a stepper workflow. */\nexport declare class CdkStepperNext {\n    _stepper: CdkStepper;\n    /** Type of the next button. Defaults to \"submit\" if not specified. */\n    type: string;\n    constructor(_stepper: CdkStepper);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkStepperNext, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkStepperNext, \"button[cdkStepperNext]\", never, { \"type\": \"type\"; }, {}, never, never, false>;\n}\n\n/** Button that moves to the previous step in a stepper workflow. */\nexport declare class CdkStepperPrevious {\n    _stepper: CdkStepper;\n    /** Type of the previous button. Defaults to \"button\" if not specified. */\n    type: string;\n    constructor(_stepper: CdkStepper);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkStepperPrevious, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkStepperPrevious, \"button[cdkStepperPrevious]\", never, { \"type\": \"type\"; }, {}, never, never, false>;\n}\n\ndeclare namespace i1 {\n    export {\n        StepContentPositionState,\n        StepperOrientation,\n        StepperSelectionEvent,\n        StepState,\n        STEP_STATE,\n        STEPPER_GLOBAL_OPTIONS,\n        StepperOptions,\n        CdkStep,\n        CdkStepper\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        CdkStepHeader\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        CdkStepLabel\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        CdkStepperNext,\n        CdkStepperPrevious\n    }\n}\n\n/** Enum to represent the different states of the steps. */\nexport declare const STEP_STATE: {\n    NUMBER: string;\n    EDIT: string;\n    DONE: string;\n    ERROR: string;\n};\n\n/**\n * Position state of the content of each step in stepper that is used for transitioning\n * the content into correct position upon step selection change.\n */\nexport declare type StepContentPositionState = 'previous' | 'current' | 'next';\n\n/** InjectionToken that can be used to specify the global stepper options. */\nexport declare const STEPPER_GLOBAL_OPTIONS: InjectionToken<StepperOptions>;\n\n/** Configurable options for stepper. */\nexport declare interface StepperOptions {\n    /**\n     * Whether the stepper should display an error state or not.\n     * Default behavior is assumed to be false.\n     */\n    showError?: boolean;\n    /**\n     * Whether the stepper should display the default indicator type\n     * or not.\n     * Default behavior is assumed to be true.\n     */\n    displayDefaultIndicatorType?: boolean;\n}\n\n/** Possible orientation of a stepper. */\nexport declare type StepperOrientation = 'horizontal' | 'vertical';\n\n/** Change event emitted on selection changes. */\nexport declare class StepperSelectionEvent {\n    /** Index of the step now selected. */\n    selectedIndex: number;\n    /** Index of the step previously selected. */\n    previouslySelectedIndex: number;\n    /** The step instance now selected. */\n    selectedStep: CdkStep;\n    /** The step instance previously selected. */\n    previouslySelectedStep: CdkStep;\n}\n\n/** The state of each step. */\nexport declare type StepState = 'number' | 'edit' | 'done' | 'error' | string;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/table/index.d.ts",
      "node_modules/@angular/cdk/table/index.d.ts"
    ],
    "content": "import { AfterContentChecked } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { CollectionViewer } from '@angular/cdk/collections';\nimport { DataSource } from '@angular/cdk/collections';\nimport { Direction } from '@angular/cdk/bidi';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i5 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { IterableChanges } from '@angular/core';\nimport { IterableDiffer } from '@angular/core';\nimport { IterableDiffers } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { TemplateRef } from '@angular/core';\nimport { TrackByFunction } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { _ViewRepeater } from '@angular/cdk/collections';\n\n/** Base class for the cells. Adds a CSS classname that identifies the column it renders in. */\nexport declare class BaseCdkCell {\n    constructor(columnDef: CdkColumnDef, elementRef: ElementRef);\n}\n\n/**\n * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs\n * for changes and notifying the table.\n */\nexport declare abstract class BaseRowDef implements OnChanges {\n    /** @docs-private */ template: TemplateRef<any>;\n    protected _differs: IterableDiffers;\n    /** The columns to be displayed on this row. */\n    columns: Iterable<string>;\n    /** Differ used to check if any changes were made to the columns. */\n    protected _columnsDiffer: IterableDiffer<any>;\n    constructor(\n    /** @docs-private */ template: TemplateRef<any>, _differs: IterableDiffers);\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Returns the difference between the current columns and the columns from the last diff, or null\n     * if there is no difference.\n     */\n    getColumnsDiff(): IterableChanges<any> | null;\n    /** Gets this row def's relevant cell template from the provided column def. */\n    extractCellTemplate(column: CdkColumnDef): TemplateRef<any>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<BaseRowDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<BaseRowDef, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * Interface for a mixin to provide a directive with a function that checks if the sticky input has\n * been changed since the last time the function was called. Essentially adds a dirty-check to the\n * sticky value.\n * @docs-private\n */\nexport declare interface CanStick {\n    /** Whether sticky positioning should be applied. */\n    sticky: boolean;\n    /** Whether the sticky input has changed since it was last checked. */\n    _hasStickyChanged: boolean;\n    /** Whether the sticky value has changed since this was last called. */\n    hasStickyChanged(): boolean;\n    /** Resets the dirty check for cases where the sticky state has been used without checking. */\n    resetStickyChanged(): void;\n}\n\n/** @docs-private */\nexport declare type CanStickCtor = Constructor<CanStick>;\n\n/**\n * The row template that can be used by the mat-table. Should not be used outside of the\n * material library.\n */\nexport declare const CDK_ROW_TEMPLATE = \"<ng-container cdkCellOutlet></ng-container>\";\n\n/**\n * Used to provide a table to some of the sub-components without causing a circular dependency.\n * @docs-private\n */\nexport declare const CDK_TABLE: InjectionToken<any>;\n\n/**\n * The table template that can be used by the mat-table. Should not be used outside of the\n * material library.\n * @docs-private\n */\nexport declare const CDK_TABLE_TEMPLATE = \"\\n  <ng-content select=\\\"caption\\\"></ng-content>\\n  <ng-content select=\\\"colgroup, col\\\"></ng-content>\\n  <ng-container headerRowOutlet></ng-container>\\n  <ng-container rowOutlet></ng-container>\\n  <ng-container noDataRowOutlet></ng-container>\\n  <ng-container footerRowOutlet></ng-container>\\n\";\n\n/** Cell template container that adds the right classes and role. */\nexport declare class CdkCell extends BaseCdkCell {\n    constructor(columnDef: CdkColumnDef, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkCell, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkCell, \"cdk-cell, td[cdk-cell]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Cell definition for a CDK table.\n * Captures the template of a column's data row cell as well as cell-specific properties.\n */\nexport declare class CdkCellDef implements CellDef {\n    template: TemplateRef<any>;\n    constructor(/** @docs-private */ template: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkCellDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkCellDef, \"[cdkCellDef]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Outlet for rendering cells inside of a row or header row.\n * @docs-private\n */\nexport declare class CdkCellOutlet implements OnDestroy {\n    _viewContainer: ViewContainerRef;\n    /** The ordered list of cells to render within this outlet's view container */\n    cells: CdkCellDef[];\n    /** The data context to be provided to each cell */\n    context: any;\n    /**\n     * Static property containing the latest constructed instance of this class.\n     * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using\n     * createEmbeddedView. After one of these components are created, this property will provide\n     * a handle to provide that component's cells and context. After init, the CdkCellOutlet will\n     * construct the cells with the provided context.\n     */\n    static mostRecentCellOutlet: CdkCellOutlet | null;\n    constructor(_viewContainer: ViewContainerRef);\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkCellOutlet, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkCellOutlet, \"[cdkCellOutlet]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Context provided to the row cells when `multiTemplateDataRows` is true. This context is the same\n * as CdkCellOutletRowContext except that the single `index` value is replaced by `dataIndex` and\n * `renderIndex`.\n */\nexport declare interface CdkCellOutletMultiRowContext<T> {\n    /** Data for the row that this cell is located within. */\n    $implicit?: T;\n    /** Index of the data object in the provided data array. */\n    dataIndex?: number;\n    /** Index location of the rendered row that this cell is located within. */\n    renderIndex?: number;\n    /** Length of the number of total rows. */\n    count?: number;\n    /** True if this cell is contained in the first row. */\n    first?: boolean;\n    /** True if this cell is contained in the last row. */\n    last?: boolean;\n    /** True if this cell is contained in a row with an even-numbered index. */\n    even?: boolean;\n    /** True if this cell is contained in a row with an odd-numbered index. */\n    odd?: boolean;\n}\n\n/** Context provided to the row cells when `multiTemplateDataRows` is false */\nexport declare interface CdkCellOutletRowContext<T> {\n    /** Data for the row that this cell is located within. */\n    $implicit?: T;\n    /** Index of the data object in the provided data array. */\n    index?: number;\n    /** Length of the number of total rows. */\n    count?: number;\n    /** True if this cell is contained in the first row. */\n    first?: boolean;\n    /** True if this cell is contained in the last row. */\n    last?: boolean;\n    /** True if this cell is contained in a row with an even-numbered index. */\n    even?: boolean;\n    /** True if this cell is contained in a row with an odd-numbered index. */\n    odd?: boolean;\n}\n\n/**\n * Column definition for the CDK table.\n * Defines a set of cells available for a table column.\n */\nexport declare class CdkColumnDef extends _CdkColumnDefBase implements CanStick {\n    _table?: any;\n    /** Unique name for this column. */\n    get name(): string;\n    set name(name: string);\n    protected _name: string;\n    /**\n     * Whether this column should be sticky positioned on the end of the row. Should make sure\n     * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value\n     * has been changed.\n     */\n    get stickyEnd(): boolean;\n    set stickyEnd(v: BooleanInput);\n    _stickyEnd: boolean;\n    /** @docs-private */\n    cell: CdkCellDef;\n    /** @docs-private */\n    headerCell: CdkHeaderCellDef;\n    /** @docs-private */\n    footerCell: CdkFooterCellDef;\n    /**\n     * Transformed version of the column name that can be used as part of a CSS classname. Excludes\n     * all non-alphanumeric characters and the special characters '-' and '_'. Any characters that\n     * do not match are replaced by the '-' character.\n     */\n    cssClassFriendlyName: string;\n    /**\n     * Class name for cells in this column.\n     * @docs-private\n     */\n    _columnCssClassName: string[];\n    constructor(_table?: any);\n    /**\n     * Overridable method that sets the css classes that will be added to every cell in this\n     * column.\n     * In the future, columnCssClassName will change from type string[] to string and this\n     * will set a single string value.\n     * @docs-private\n     */\n    protected _updateColumnCssClassName(): void;\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    protected _setNameInput(value: string): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkColumnDef, [{ optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkColumnDef, \"[cdkColumnDef]\", never, { \"sticky\": \"sticky\"; \"name\": \"cdkColumnDef\"; \"stickyEnd\": \"stickyEnd\"; }, {}, [\"cell\", \"headerCell\", \"footerCell\"], never, false>;\n}\n\n/** @docs-private */\ndeclare class CdkColumnDefBase {\n}\n\ndeclare const _CdkColumnDefBase: CanStickCtor & typeof CdkColumnDefBase;\n\n/** Footer cell template container that adds the right classes and role. */\nexport declare class CdkFooterCell extends BaseCdkCell {\n    constructor(columnDef: CdkColumnDef, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterCell, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFooterCell, \"cdk-footer-cell, td[cdk-footer-cell]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Footer cell definition for a CDK table.\n * Captures the template of a column's footer cell and as well as cell-specific properties.\n */\nexport declare class CdkFooterCellDef implements CellDef {\n    template: TemplateRef<any>;\n    constructor(/** @docs-private */ template: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterCellDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFooterCellDef, \"[cdkFooterCellDef]\", never, {}, {}, never, never, false>;\n}\n\n/** Footer template container that contains the cell outlet. Adds the right class and role. */\nexport declare class CdkFooterRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterRow, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkFooterRow, \"cdk-footer-row, tr[cdk-footer-row]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Footer row definition for the CDK table.\n * Captures the footer row's template and other footer properties such as the columns to display.\n */\nexport declare class CdkFooterRowDef extends _CdkFooterRowDefBase implements CanStick, OnChanges {\n    _table?: any;\n    constructor(template: TemplateRef<any>, _differs: IterableDiffers, _table?: any);\n    ngOnChanges(changes: SimpleChanges): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterRowDef, [null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFooterRowDef, \"[cdkFooterRowDef]\", never, { \"columns\": \"cdkFooterRowDef\"; \"sticky\": \"cdkFooterRowDefSticky\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare class CdkFooterRowDefBase extends BaseRowDef {\n}\n\ndeclare const _CdkFooterRowDefBase: CanStickCtor & typeof CdkFooterRowDefBase;\n\n/** Header cell template container that adds the right classes and role. */\nexport declare class CdkHeaderCell extends BaseCdkCell {\n    constructor(columnDef: CdkColumnDef, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderCell, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkHeaderCell, \"cdk-header-cell, th[cdk-header-cell]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Header cell definition for a CDK table.\n * Captures the template of a column's header cell and as well as cell-specific properties.\n */\nexport declare class CdkHeaderCellDef implements CellDef {\n    template: TemplateRef<any>;\n    constructor(/** @docs-private */ template: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderCellDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkHeaderCellDef, \"[cdkHeaderCellDef]\", never, {}, {}, never, never, false>;\n}\n\n/** Header template container that contains the cell outlet. Adds the right class and role. */\nexport declare class CdkHeaderRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderRow, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkHeaderRow, \"cdk-header-row, tr[cdk-header-row]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Header row definition for the CDK table.\n * Captures the header row's template and other header properties such as the columns to display.\n */\nexport declare class CdkHeaderRowDef extends _CdkHeaderRowDefBase implements CanStick, OnChanges {\n    _table?: any;\n    constructor(template: TemplateRef<any>, _differs: IterableDiffers, _table?: any);\n    ngOnChanges(changes: SimpleChanges): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderRowDef, [null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkHeaderRowDef, \"[cdkHeaderRowDef]\", never, { \"columns\": \"cdkHeaderRowDef\"; \"sticky\": \"cdkHeaderRowDefSticky\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare class CdkHeaderRowDefBase extends BaseRowDef {\n}\n\ndeclare const _CdkHeaderRowDefBase: CanStickCtor & typeof CdkHeaderRowDefBase;\n\n/** Row that can be used to display a message when no data is shown in the table. */\nexport declare class CdkNoDataRow {\n    templateRef: TemplateRef<any>;\n    _contentClassName: string;\n    constructor(templateRef: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkNoDataRow, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkNoDataRow, \"ng-template[cdkNoDataRow]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Enables the recycle view repeater strategy, which reduces rendering latency. Not compatible with\n * tables that animate rows.\n */\nexport declare class CdkRecycleRows {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkRecycleRows, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkRecycleRows, \"cdk-table[recycleRows], table[cdk-table][recycleRows]\", never, {}, {}, never, never, false>;\n}\n\n/** Data row template container that contains the cell outlet. Adds the right class and role. */\nexport declare class CdkRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkRow, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkRow, \"cdk-row, tr[cdk-row]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Data row definition for the CDK table.\n * Captures the header row's template and other row properties such as the columns to display and\n * a when predicate that describes when this row should be used.\n */\nexport declare class CdkRowDef<T> extends BaseRowDef {\n    _table?: any;\n    /**\n     * Function that should return true if this row template should be used for the provided index\n     * and row data. If left undefined, this row will be considered the default row template to use\n     * when no other when functions return true for the data.\n     * For every row, there must be at least one when function that passes or an undefined to default.\n     */\n    when: (index: number, rowData: T) => boolean;\n    constructor(template: TemplateRef<any>, _differs: IterableDiffers, _table?: any);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkRowDef<any>, [null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkRowDef<any>, \"[cdkRowDef]\", never, { \"columns\": \"cdkRowDefColumns\"; \"when\": \"cdkRowDefWhen\"; }, {}, never, never, false>;\n}\n\n/**\n * A data table that can render a header row, data rows, and a footer row.\n * Uses the dataSource input to determine the data to be rendered. The data can be provided either\n * as a data array, an Observable stream that emits the data array to render, or a DataSource with a\n * connect function that will return an Observable stream that emits the data array to render.\n */\nexport declare class CdkTable<T> implements AfterContentChecked, CollectionViewer, OnDestroy, OnInit {\n    protected readonly _differs: IterableDiffers;\n    protected readonly _changeDetectorRef: ChangeDetectorRef;\n    protected readonly _elementRef: ElementRef;\n    protected readonly _dir: Directionality;\n    private _platform;\n    protected readonly _viewRepeater: _ViewRepeater<T, RenderRow<T>, RowContext<T>>;\n    protected readonly _coalescedStyleScheduler: _CoalescedStyleScheduler;\n    private readonly _viewportRuler;\n    /**\n     * @deprecated `_stickyPositioningListener` parameter to become required.\n     * @breaking-change 13.0.0\n     */\n    protected readonly _stickyPositioningListener: StickyPositioningListener;\n    /**\n     * @deprecated `_ngZone` parameter to become required.\n     * @breaking-change 14.0.0\n     */\n    protected readonly _ngZone?: NgZone | undefined;\n    private _document;\n    /** Latest data provided by the data source. */\n    protected _data: readonly T[];\n    /** Subject that emits when the component has been destroyed. */\n    private readonly _onDestroy;\n    /** List of the rendered rows as identified by their `RenderRow` object. */\n    private _renderRows;\n    /** Subscription that listens for the data provided by the data source. */\n    private _renderChangeSubscription;\n    /**\n     * Map of all the user's defined columns (header, data, and footer cell template) identified by\n     * name. Collection populated by the column definitions gathered by `ContentChildren` as well as\n     * any custom column definitions added to `_customColumnDefs`.\n     */\n    private _columnDefsByName;\n    /**\n     * Set of all row definitions that can be used by this table. Populated by the rows gathered by\n     * using `ContentChildren` as well as any custom row definitions added to `_customRowDefs`.\n     */\n    private _rowDefs;\n    /**\n     * Set of all header row definitions that can be used by this table. Populated by the rows\n     * gathered by using `ContentChildren` as well as any custom row definitions added to\n     * `_customHeaderRowDefs`.\n     */\n    private _headerRowDefs;\n    /**\n     * Set of all row definitions that can be used by this table. Populated by the rows gathered by\n     * using `ContentChildren` as well as any custom row definitions added to\n     * `_customFooterRowDefs`.\n     */\n    private _footerRowDefs;\n    /** Differ used to find the changes in the data provided by the data source. */\n    private _dataDiffer;\n    /** Stores the row definition that does not have a when predicate. */\n    private _defaultRowDef;\n    /**\n     * Column definitions that were defined outside of the direct content children of the table.\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n     * column definitions as *its* content child.\n     */\n    private _customColumnDefs;\n    /**\n     * Data row definitions that were defined outside of the direct content children of the table.\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n     * built-in data rows as *its* content child.\n     */\n    private _customRowDefs;\n    /**\n     * Header row definitions that were defined outside of the direct content children of the table.\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n     * built-in header rows as *its* content child.\n     */\n    private _customHeaderRowDefs;\n    /**\n     * Footer row definitions that were defined outside of the direct content children of the table.\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has a\n     * built-in footer row as *its* content child.\n     */\n    private _customFooterRowDefs;\n    /** No data row that was defined outside of the direct content children of the table. */\n    private _customNoDataRow;\n    /**\n     * Whether the header row definition has been changed. Triggers an update to the header row after\n     * content is checked. Initialized as true so that the table renders the initial set of rows.\n     */\n    private _headerRowDefChanged;\n    /**\n     * Whether the footer row definition has been changed. Triggers an update to the footer row after\n     * content is checked. Initialized as true so that the table renders the initial set of rows.\n     */\n    private _footerRowDefChanged;\n    /**\n     * Whether the sticky column styles need to be updated. Set to `true` when the visible columns\n     * change.\n     */\n    private _stickyColumnStylesNeedReset;\n    /**\n     * Whether the sticky styler should recalculate cell widths when applying sticky styles. If\n     * `false`, cached values will be used instead. This is only applicable to tables with\n     * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.\n     */\n    private _forceRecalculateCellWidths;\n    /**\n     * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing\n     * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with\n     * the cached `RenderRow` objects when possible, the row identity is preserved when the data\n     * and row template matches, which allows the `IterableDiffer` to check rows by reference\n     * and understand which rows are added/moved/removed.\n     *\n     * Implemented as a map of maps where the first key is the `data: T` object and the second is the\n     * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that\n     * contains an array of created pairs. The array is necessary to handle cases where the data\n     * array contains multiple duplicate data objects and each instantiated `RenderRow` must be\n     * stored.\n     */\n    private _cachedRenderRowsMap;\n    /** Whether the table is applied to a native `<table>`. */\n    protected _isNativeHtmlTable: boolean;\n    /**\n     * Utility class that is responsible for applying the appropriate sticky positioning styles to\n     * the table's rows and cells.\n     */\n    private _stickyStyler;\n    /**\n     * CSS class added to any row or cell that has sticky positioning applied. May be overridden by\n     * table subclasses.\n     */\n    protected stickyCssClass: string;\n    /**\n     * Whether to manually add position: sticky to all sticky cell elements. Not needed if\n     * the position is set in a selector associated with the value of stickyCssClass. May be\n     * overridden by table subclasses\n     */\n    protected needsPositionStickyOnElement: boolean;\n    /** Whether the no data row is currently showing anything. */\n    private _isShowingNoDataRow;\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data\n     * relative to the function to know if a row should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    get trackBy(): TrackByFunction<T>;\n    set trackBy(fn: TrackByFunction<T>);\n    private _trackByFn;\n    /**\n     * The table's source of data, which can be provided in three ways (in order of complexity):\n     *   - Simple data array (each object represents one table row)\n     *   - Stream that emits a data array each time the array changes\n     *   - `DataSource` object that implements the connect/disconnect interface.\n     *\n     * If a data array is provided, the table must be notified when the array's objects are\n     * added, removed, or moved. This can be done by calling the `renderRows()` function which will\n     * render the diff since the last table render. If the data array reference is changed, the table\n     * will automatically trigger an update to the rows.\n     *\n     * When providing an Observable stream, the table will trigger an update automatically when the\n     * stream emits a new array of data.\n     *\n     * Finally, when providing a `DataSource` object, the table will use the Observable stream\n     * provided by the connect function and trigger updates when that stream emits new data array\n     * values. During the table's ngOnDestroy or when the data source is removed from the table, the\n     * table will call the DataSource's `disconnect` function (may be useful for cleaning up any\n     * subscriptions registered during the connect process).\n     */\n    get dataSource(): CdkTableDataSourceInput<T>;\n    set dataSource(dataSource: CdkTableDataSourceInput<T>);\n    private _dataSource;\n    /**\n     * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'\n     * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each\n     * dataobject will render the first row that evaluates its when predicate to true, in the order\n     * defined in the table, or otherwise the default row which does not have a when predicate.\n     */\n    get multiTemplateDataRows(): boolean;\n    set multiTemplateDataRows(v: BooleanInput);\n    _multiTemplateDataRows: boolean;\n    /**\n     * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths\n     * and optimize rendering sticky styles for native tables. No-op for flex tables.\n     */\n    get fixedLayout(): boolean;\n    set fixedLayout(v: BooleanInput);\n    private _fixedLayout;\n    /**\n     * Emits when the table completes rendering a set of data rows based on the latest data from the\n     * data source, even if the set of rows is empty.\n     */\n    readonly contentChanged: EventEmitter<void>;\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     *\n     * @docs-private\n     */\n    readonly viewChange: BehaviorSubject<{\n        start: number;\n        end: number;\n    }>;\n    _rowOutlet: DataRowOutlet;\n    _headerRowOutlet: HeaderRowOutlet;\n    _footerRowOutlet: FooterRowOutlet;\n    _noDataRowOutlet: NoDataRowOutlet;\n    /**\n     * The column definitions provided by the user that contain what the header, data, and footer\n     * cells should render for each column.\n     */\n    _contentColumnDefs: QueryList<CdkColumnDef>;\n    /** Set of data row definitions that were provided to the table as content children. */\n    _contentRowDefs: QueryList<CdkRowDef<T>>;\n    /** Set of header row definitions that were provided to the table as content children. */\n    _contentHeaderRowDefs: QueryList<CdkHeaderRowDef>;\n    /** Set of footer row definitions that were provided to the table as content children. */\n    _contentFooterRowDefs: QueryList<CdkFooterRowDef>;\n    /** Row definition that will only be rendered if there's no data in the table. */\n    _noDataRow: CdkNoDataRow;\n    constructor(_differs: IterableDiffers, _changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef, role: string, _dir: Directionality, _document: any, _platform: Platform, _viewRepeater: _ViewRepeater<T, RenderRow<T>, RowContext<T>>, _coalescedStyleScheduler: _CoalescedStyleScheduler, _viewportRuler: ViewportRuler, \n    /**\n     * @deprecated `_stickyPositioningListener` parameter to become required.\n     * @breaking-change 13.0.0\n     */\n    _stickyPositioningListener: StickyPositioningListener, \n    /**\n     * @deprecated `_ngZone` parameter to become required.\n     * @breaking-change 14.0.0\n     */\n    _ngZone?: NgZone | undefined);\n    ngOnInit(): void;\n    ngAfterContentChecked(): void;\n    ngOnDestroy(): void;\n    /**\n     * Renders rows based on the table's latest set of data, which was either provided directly as an\n     * input or retrieved through an Observable stream (directly or from a DataSource).\n     * Checks for differences in the data since the last diff to perform only the necessary\n     * changes (add/remove/move rows).\n     *\n     * If the table's data source is a DataSource or Observable, this will be invoked automatically\n     * each time the provided Observable stream emits a new data array. Otherwise if your data is\n     * an array, this function will need to be called to render any changes.\n     */\n    renderRows(): void;\n    /** Adds a column definition that was not included as part of the content children. */\n    addColumnDef(columnDef: CdkColumnDef): void;\n    /** Removes a column definition that was not included as part of the content children. */\n    removeColumnDef(columnDef: CdkColumnDef): void;\n    /** Adds a row definition that was not included as part of the content children. */\n    addRowDef(rowDef: CdkRowDef<T>): void;\n    /** Removes a row definition that was not included as part of the content children. */\n    removeRowDef(rowDef: CdkRowDef<T>): void;\n    /** Adds a header row definition that was not included as part of the content children. */\n    addHeaderRowDef(headerRowDef: CdkHeaderRowDef): void;\n    /** Removes a header row definition that was not included as part of the content children. */\n    removeHeaderRowDef(headerRowDef: CdkHeaderRowDef): void;\n    /** Adds a footer row definition that was not included as part of the content children. */\n    addFooterRowDef(footerRowDef: CdkFooterRowDef): void;\n    /** Removes a footer row definition that was not included as part of the content children. */\n    removeFooterRowDef(footerRowDef: CdkFooterRowDef): void;\n    /** Sets a no data row definition that was not included as a part of the content children. */\n    setNoDataRow(noDataRow: CdkNoDataRow | null): void;\n    /**\n     * Updates the header sticky styles. First resets all applied styles with respect to the cells\n     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is\n     * automatically called when the header row changes its displayed set of columns, or if its\n     * sticky input changes. May be called manually for cases where the cell content changes outside\n     * of these events.\n     */\n    updateStickyHeaderRowStyles(): void;\n    /**\n     * Updates the footer sticky styles. First resets all applied styles with respect to the cells\n     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is\n     * automatically called when the footer row changes its displayed set of columns, or if its\n     * sticky input changes. May be called manually for cases where the cell content changes outside\n     * of these events.\n     */\n    updateStickyFooterRowStyles(): void;\n    /**\n     * Updates the column sticky styles. First resets all applied styles with respect to the cells\n     * sticking to the left and right. Then sticky styles are added for the left and right according\n     * to the column definitions for each cell in each row. This is automatically called when\n     * the data source provides a new set of data or when a column definition changes its sticky\n     * input. May be called manually for cases where the cell content changes outside of these events.\n     */\n    updateStickyColumnStyles(): void;\n    /**\n     * Get the list of RenderRow objects to render according to the current list of data and defined\n     * row definitions. If the previous list already contained a particular pair, it should be reused\n     * so that the differ equates their references.\n     */\n    private _getAllRenderRows;\n    /**\n     * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that\n     * should be rendered for this data. Reuses the cached RenderRow objects if they match the same\n     * `(T, CdkRowDef)` pair.\n     */\n    private _getRenderRowsForData;\n    /** Update the map containing the content's column definitions. */\n    private _cacheColumnDefs;\n    /** Update the list of all available row definitions that can be used. */\n    private _cacheRowDefs;\n    /**\n     * Check if the header, data, or footer rows have changed what columns they want to display or\n     * whether the sticky states have changed for the header or footer. If there is a diff, then\n     * re-render that section.\n     */\n    private _renderUpdatedColumns;\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the row outlet. Otherwise start listening for new data.\n     */\n    private _switchDataSource;\n    /** Set up a subscription for the data provided by the data source. */\n    private _observeRenderChanges;\n    /**\n     * Clears any existing content in the header row outlet and creates a new embedded view\n     * in the outlet using the header row definition.\n     */\n    private _forceRenderHeaderRows;\n    /**\n     * Clears any existing content in the footer row outlet and creates a new embedded view\n     * in the outlet using the footer row definition.\n     */\n    private _forceRenderFooterRows;\n    /** Adds the sticky column styles for the rows according to the columns' stick states. */\n    private _addStickyColumnStyles;\n    /** Gets the list of rows that have been rendered in the row outlet. */\n    _getRenderedRows(rowOutlet: RowOutlet): HTMLElement[];\n    /**\n     * Get the matching row definitions that should be used for this row data. If there is only\n     * one row definition, it is returned. Otherwise, find the row definitions that has a when\n     * predicate that returns true with the data. If none return true, return the default row\n     * definition.\n     */\n    _getRowDefs(data: T, dataIndex: number): CdkRowDef<T>[];\n    private _getEmbeddedViewArgs;\n    /**\n     * Creates a new row template in the outlet and fills it with the set of cell templates.\n     * Optionally takes a context to provide to the row and cells, as well as an optional index\n     * of where to place the new row template in the outlet.\n     */\n    private _renderRow;\n    private _renderCellTemplateForItem;\n    /**\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\n     * e.g. first/last/even/odd.\n     */\n    private _updateRowIndexContext;\n    /** Gets the column definitions for the provided row def. */\n    private _getCellTemplates;\n    /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */\n    private _applyNativeTableSections;\n    /**\n     * Forces a re-render of the data rows. Should be called in cases where there has been an input\n     * change that affects the evaluation of which rows should be rendered, e.g. toggling\n     * `multiTemplateDataRows` or adding/removing row definitions.\n     */\n    private _forceRenderDataRows;\n    /**\n     * Checks if there has been a change in sticky states since last check and applies the correct\n     * sticky styles. Since checking resets the \"dirty\" state, this should only be performed once\n     * during a change detection and after the inputs are settled (after content check).\n     */\n    private _checkStickyStates;\n    /**\n     * Creates the sticky styler that will be used for sticky rows and columns. Listens\n     * for directionality changes and provides the latest direction to the styler. Re-applies column\n     * stickiness when directionality changes.\n     */\n    private _setupStickyStyler;\n    /** Filters definitions that belong to this table from a QueryList. */\n    private _getOwnDefs;\n    /** Creates or removes the no data row, depending on whether any data is being shown. */\n    private _updateNoDataRow;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTable<any>, [null, null, null, { attribute: \"role\"; }, { optional: true; }, null, null, null, null, null, { optional: true; skipSelf: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTable<any>, \"cdk-table, table[cdk-table]\", [\"cdkTable\"], { \"trackBy\": \"trackBy\"; \"dataSource\": \"dataSource\"; \"multiTemplateDataRows\": \"multiTemplateDataRows\"; \"fixedLayout\": \"fixedLayout\"; }, { \"contentChanged\": \"contentChanged\"; }, [\"_noDataRow\", \"_contentColumnDefs\", \"_contentRowDefs\", \"_contentHeaderRowDefs\", \"_contentFooterRowDefs\"], [\"caption\", \"colgroup, col\"], false>;\n}\n\n/** Possible types that can be set as the data source for a `CdkTable`. */\nexport declare type CdkTableDataSourceInput<T> = readonly T[] | DataSource<T> | Observable<readonly T[]>;\n\nexport declare class CdkTableModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTableModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkTableModule, [typeof i1.CdkTable, typeof i2.CdkRowDef, typeof i3.CdkCellDef, typeof i2.CdkCellOutlet, typeof i3.CdkHeaderCellDef, typeof i3.CdkFooterCellDef, typeof i3.CdkColumnDef, typeof i3.CdkCell, typeof i2.CdkRow, typeof i3.CdkHeaderCell, typeof i3.CdkFooterCell, typeof i2.CdkHeaderRow, typeof i2.CdkHeaderRowDef, typeof i2.CdkFooterRow, typeof i2.CdkFooterRowDef, typeof i1.DataRowOutlet, typeof i1.HeaderRowOutlet, typeof i1.FooterRowOutlet, typeof i4.CdkTextColumn, typeof i2.CdkNoDataRow, typeof i1.CdkRecycleRows, typeof i1.NoDataRowOutlet], [typeof i5.ScrollingModule], [typeof i1.CdkTable, typeof i2.CdkRowDef, typeof i3.CdkCellDef, typeof i2.CdkCellOutlet, typeof i3.CdkHeaderCellDef, typeof i3.CdkFooterCellDef, typeof i3.CdkColumnDef, typeof i3.CdkCell, typeof i2.CdkRow, typeof i3.CdkHeaderCell, typeof i3.CdkFooterCell, typeof i2.CdkHeaderRow, typeof i2.CdkHeaderRowDef, typeof i2.CdkFooterRow, typeof i2.CdkFooterRowDef, typeof i1.DataRowOutlet, typeof i1.HeaderRowOutlet, typeof i1.FooterRowOutlet, typeof i4.CdkTextColumn, typeof i2.CdkNoDataRow, typeof i1.CdkRecycleRows, typeof i1.NoDataRowOutlet]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<CdkTableModule>;\n}\n\n/**\n * Column that simply shows text content for the header and row cells. Assumes that the table\n * is using the native table implementation (`<table>`).\n *\n * By default, the name of this column will be the header text and data property accessor.\n * The header text can be overridden with the `headerText` input. Cell values can be overridden with\n * the `dataAccessor` input. Change the text justification to the start or end using the `justify`\n * input.\n */\nexport declare class CdkTextColumn<T> implements OnDestroy, OnInit {\n    private _table;\n    private _options;\n    /** Column name that should be used to reference this column. */\n    get name(): string;\n    set name(name: string);\n    _name: string;\n    /**\n     * Text label that should be used for the column header. If this property is not\n     * set, the header text will default to the column name with its first letter capitalized.\n     */\n    headerText: string;\n    /**\n     * Accessor function to retrieve the data rendered for each cell. If this\n     * property is not set, the data cells will render the value found in the data's property matching\n     * the column's name. For example, if the column is named `id`, then the rendered value will be\n     * value defined by the data's `id` property.\n     */\n    dataAccessor: (data: T, name: string) => string;\n    /** Alignment of the cell values. */\n    justify: 'start' | 'end' | 'center';\n    /** @docs-private */\n    columnDef: CdkColumnDef;\n    /**\n     * The column cell is provided to the column during `ngOnInit` with a static query.\n     * Normally, this will be retrieved by the column using `ContentChild`, but that assumes the\n     * column definition was provided in the same view as the table, which is not the case with this\n     * component.\n     * @docs-private\n     */\n    cell: CdkCellDef;\n    /**\n     * The column headerCell is provided to the column during `ngOnInit` with a static query.\n     * Normally, this will be retrieved by the column using `ContentChild`, but that assumes the\n     * column definition was provided in the same view as the table, which is not the case with this\n     * component.\n     * @docs-private\n     */\n    headerCell: CdkHeaderCellDef;\n    constructor(_table: CdkTable<T>, _options: TextColumnOptions<T>);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Creates a default header text. Use the options' header text transformation function if one\n     * has been provided. Otherwise simply capitalize the column name.\n     */\n    _createDefaultHeaderText(): string;\n    /** Synchronizes the column definition name with the text column name. */\n    private _syncColumnDefName;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTextColumn<any>, [{ optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTextColumn<any>, \"cdk-text-column\", never, { \"name\": \"name\"; \"headerText\": \"headerText\"; \"dataAccessor\": \"dataAccessor\"; \"justify\": \"justify\"; }, {}, never, never, false>;\n}\n\n/** Base interface for a cell definition. Captures a column's cell template definition. */\nexport declare interface CellDef {\n    template: TemplateRef<any>;\n}\n\n/** Injection token used to provide a coalesced style scheduler. */\nexport declare const _COALESCED_STYLE_SCHEDULER: InjectionToken<_CoalescedStyleScheduler>;\n\n/**\n * Allows grouping up CSSDom mutations after the current execution context.\n * This can significantly improve performance when separate consecutive functions are\n * reading from the CSSDom and then mutating it.\n *\n * @docs-private\n */\nexport declare class _CoalescedStyleScheduler implements OnDestroy {\n    private readonly _ngZone;\n    private _currentSchedule;\n    private readonly _destroyed;\n    constructor(_ngZone: NgZone);\n    /**\n     * Schedules the specified task to run at the end of the current VM turn.\n     */\n    schedule(task: () => unknown): void;\n    /**\n     * Schedules the specified task to run after other scheduled tasks at the end of the current\n     * VM turn.\n     */\n    scheduleEnd(task: () => unknown): void;\n    /** Prevent any further tasks from running. */\n    ngOnDestroy(): void;\n    private _createScheduleIfNeeded;\n    private _getScheduleObservable;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_CoalescedStyleScheduler, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<_CoalescedStyleScheduler>;\n}\n\n\n/** @docs-private */\nexport declare type Constructor<T> = new (...args: any[]) => T;\n\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert data rows.\n * @docs-private\n */\nexport declare class DataRowOutlet implements RowOutlet {\n    viewContainer: ViewContainerRef;\n    elementRef: ElementRef;\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<DataRowOutlet, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<DataRowOutlet, \"[rowOutlet]\", never, {}, {}, never, never, false>;\n}\n\nexport { DataSource }\n\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert the footer.\n * @docs-private\n */\nexport declare class FooterRowOutlet implements RowOutlet {\n    viewContainer: ViewContainerRef;\n    elementRef: ElementRef;\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<FooterRowOutlet, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<FooterRowOutlet, \"[footerRowOutlet]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert the header.\n * @docs-private\n */\nexport declare class HeaderRowOutlet implements RowOutlet {\n    viewContainer: ViewContainerRef;\n    elementRef: ElementRef;\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderRowOutlet, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<HeaderRowOutlet, \"[headerRowOutlet]\", never, {}, {}, never, never, false>;\n}\n\ndeclare namespace i1 {\n    export {\n        CdkRecycleRows,\n        RowOutlet,\n        CdkTableDataSourceInput,\n        DataRowOutlet,\n        HeaderRowOutlet,\n        FooterRowOutlet,\n        NoDataRowOutlet,\n        CDK_TABLE_TEMPLATE,\n        RowContext,\n        RenderRow,\n        CdkTable\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        CDK_ROW_TEMPLATE,\n        BaseRowDef,\n        CdkHeaderRowDef,\n        CdkFooterRowDef,\n        CdkRowDef,\n        CdkCellOutletRowContext,\n        CdkCellOutletMultiRowContext,\n        CdkCellOutlet,\n        CdkHeaderRow,\n        CdkFooterRow,\n        CdkRow,\n        CdkNoDataRow\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        CellDef,\n        CdkCellDef,\n        CdkHeaderCellDef,\n        CdkFooterCellDef,\n        CdkColumnDef,\n        BaseCdkCell,\n        CdkHeaderCell,\n        CdkFooterCell,\n        CdkCell\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        CdkTextColumn\n    }\n}\n\n/**\n * Mixin to provide a directive with a function that checks if the sticky input has been\n * changed since the last time the function was called. Essentially adds a dirty-check to the\n * sticky value.\n * @docs-private\n */\nexport declare function mixinHasStickyInput<T extends Constructor<{}>>(base: T): CanStickCtor & T;\n\n/**\n * Provides a handle for the table to grab the view\n * container's ng-container to insert the no data row.\n * @docs-private\n */\nexport declare class NoDataRowOutlet implements RowOutlet {\n    viewContainer: ViewContainerRef;\n    elementRef: ElementRef;\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<NoDataRowOutlet, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NoDataRowOutlet, \"[noDataRowOutlet]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Set of properties that represents the identity of a single rendered row.\n *\n * When the table needs to determine the list of rows to render, it will do so by iterating through\n * each data object and evaluating its list of row templates to display (when multiTemplateDataRows\n * is false, there is only one template per data object). For each pair of data object and row\n * template, a `RenderRow` is added to the list of rows to render. If the data object and row\n * template pair has already been rendered, the previously used `RenderRow` is added; else a new\n * `RenderRow` is * created. Once the list is complete and all data objects have been iterated\n * through, a diff is performed to determine the changes that need to be made to the rendered rows.\n *\n * @docs-private\n */\nexport declare interface RenderRow<T> {\n    data: T;\n    dataIndex: number;\n    rowDef: CdkRowDef<T>;\n}\n\n/**\n * Interface used to conveniently type the possible context interfaces for the render row.\n * @docs-private\n */\nexport declare interface RowContext<T> extends CdkCellOutletMultiRowContext<T>, CdkCellOutletRowContext<T> {\n}\n\n/** Interface used to provide an outlet for rows to be inserted into. */\nexport declare interface RowOutlet {\n    viewContainer: ViewContainerRef;\n}\n\n/**\n * @docs-private\n */\nexport declare class _Schedule {\n    tasks: (() => unknown)[];\n    endTasks: (() => unknown)[];\n}\n\n/**\n * List of all possible directions that can be used for sticky positioning.\n * @docs-private\n */\nexport declare const STICKY_DIRECTIONS: StickyDirection[];\n\n/** The injection token used to specify the StickyPositioningListener. */\nexport declare const STICKY_POSITIONING_LISTENER: InjectionToken<StickyPositioningListener>;\n\nexport declare type StickyDirection = 'top' | 'bottom' | 'left' | 'right';\n\nexport declare type StickyOffset = number | null | undefined;\n\n/**\n * If provided, CdkTable will call the methods below when it updates the size/\n * position/etc of its sticky rows and columns.\n */\nexport declare interface StickyPositioningListener {\n    /** Called when CdkTable updates its sticky start columns. */\n    stickyColumnsUpdated(update: StickyUpdate): void;\n    /** Called when CdkTable updates its sticky end columns. */\n    stickyEndColumnsUpdated(update: StickyUpdate): void;\n    /** Called when CdkTable updates its sticky header rows. */\n    stickyHeaderRowsUpdated(update: StickyUpdate): void;\n    /** Called when CdkTable updates its sticky footer rows. */\n    stickyFooterRowsUpdated(update: StickyUpdate): void;\n}\n\nexport declare type StickySize = number | null | undefined;\n\n/**\n * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.\n * @docs-private\n */\nexport declare class StickyStyler {\n    private _isNativeHtmlTable;\n    private _stickCellCss;\n    direction: Direction;\n    private _coalescedStyleScheduler;\n    private _isBrowser;\n    private readonly _needsPositionStickyOnElement;\n    private readonly _positionListener?;\n    private _cachedCellWidths;\n    private readonly _borderCellCss;\n    /**\n     * @param _isNativeHtmlTable Whether the sticky logic should be based on a table\n     *     that uses the native `<table>` element.\n     * @param _stickCellCss The CSS class that will be applied to every row/cell that has\n     *     sticky positioning applied.\n     * @param direction The directionality context of the table (ltr/rtl); affects column positioning\n     *     by reversing left/right positions.\n     * @param _isBrowser Whether the table is currently being rendered on the server or the client.\n     * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells\n     *     using inline styles. If false, it is assumed that position: sticky is included in\n     *     the component stylesheet for _stickCellCss.\n     * @param _positionListener A listener that is notified of changes to sticky rows/columns\n     *     and their dimensions.\n     */\n    constructor(_isNativeHtmlTable: boolean, _stickCellCss: string, direction: Direction, _coalescedStyleScheduler: _CoalescedStyleScheduler, _isBrowser?: boolean, _needsPositionStickyOnElement?: boolean, _positionListener?: StickyPositioningListener | undefined);\n    /**\n     * Clears the sticky positioning styles from the row and its cells by resetting the `position`\n     * style, setting the zIndex to 0, and unsetting each provided sticky direction.\n     * @param rows The list of rows that should be cleared from sticking in the provided directions\n     * @param stickyDirections The directions that should no longer be set as sticky on the rows.\n     */\n    clearStickyPositioning(rows: HTMLElement[], stickyDirections: StickyDirection[]): void;\n    /**\n     * Applies sticky left and right positions to the cells of each row according to the sticky\n     * states of the rendered column definitions.\n     * @param rows The rows that should have its set of cells stuck according to the sticky states.\n     * @param stickyStartStates A list of boolean states where each state represents whether the cell\n     *     in this index position should be stuck to the start of the row.\n     * @param stickyEndStates A list of boolean states where each state represents whether the cell\n     *     in this index position should be stuck to the end of the row.\n     * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each\n     *     column cell. If `false` cached widths will be used instead.\n     */\n    updateStickyColumns(rows: HTMLElement[], stickyStartStates: boolean[], stickyEndStates: boolean[], recalculateCellWidths?: boolean): void;\n    /**\n     * Applies sticky positioning to the row's cells if using the native table layout, and to the\n     * row itself otherwise.\n     * @param rowsToStick The list of rows that should be stuck according to their corresponding\n     *     sticky state and to the provided top or bottom position.\n     * @param stickyStates A list of boolean states where each state represents whether the row\n     *     should be stuck in the particular top or bottom position.\n     * @param position The position direction in which the row should be stuck if that row should be\n     *     sticky.\n     *\n     */\n    stickRows(rowsToStick: HTMLElement[], stickyStates: boolean[], position: 'top' | 'bottom'): void;\n    /**\n     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick\n     * footer rows is to apply sticky styling to the tfoot container. This should only be done if\n     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from\n     * the tfoot element.\n     */\n    updateStickyFooterContainer(tableElement: Element, stickyStates: boolean[]): void;\n    /**\n     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating\n     * the zIndex, removing each of the provided sticky directions, and removing the\n     * sticky position if there are no more directions.\n     */\n    _removeStickyStyle(element: HTMLElement, stickyDirections: StickyDirection[]): void;\n    /**\n     * Adds the sticky styling to the element by adding the sticky style class, changing position\n     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky\n     * direction and value.\n     */\n    _addStickyStyle(element: HTMLElement, dir: StickyDirection, dirValue: number, isBorderElement: boolean): void;\n    /**\n     * Calculate what the z-index should be for the element, depending on what directions (top,\n     * bottom, left, right) have been set. It should be true that elements with a top direction\n     * should have the highest index since these are elements like a table header. If any of those\n     * elements are also sticky in another direction, then they should appear above other elements\n     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements\n     * (e.g. footer rows) should then be next in the ordering such that they are below the header\n     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)\n     * should minimally increment so that they are above non-sticky elements but below top and bottom\n     * elements.\n     */\n    _getCalculatedZIndex(element: HTMLElement): string;\n    /** Gets the widths for each cell in the provided row. */\n    _getCellWidths(row: HTMLElement, recalculateCellWidths?: boolean): number[];\n    /**\n     * Determines the left and right positions of each sticky column cell, which will be the\n     * accumulation of all sticky column cell widths to the left and right, respectively.\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\n     */\n    _getStickyStartColumnPositions(widths: number[], stickyStates: boolean[]): number[];\n    /**\n     * Determines the left and right positions of each sticky column cell, which will be the\n     * accumulation of all sticky column cell widths to the left and right, respectively.\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\n     */\n    _getStickyEndColumnPositions(widths: number[], stickyStates: boolean[]): number[];\n}\n\nexport declare interface StickyUpdate {\n    elements?: readonly (HTMLElement[] | undefined)[];\n    offsets?: StickyOffset[];\n    sizes: StickySize[];\n}\n\n/** Injection token that can be used to specify the text column options. */\nexport declare const TEXT_COLUMN_OPTIONS: InjectionToken<TextColumnOptions<any>>;\n\n/** Configurable options for `CdkTextColumn`. */\nexport declare interface TextColumnOptions<T> {\n    /**\n     * Default function that provides the header text based on the column name if a header\n     * text is not provided.\n     */\n    defaultHeaderTextTransform?: (name: string) => string;\n    /** Default data accessor to use if one is not provided. */\n    defaultDataAccessor?: (data: T, name: string) => string;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/testing/index.d.ts",
      "node_modules/@angular/cdk/testing/index.d.ts"
    ],
    "content": "/** An async function that returns a promise when called. */\nexport declare type AsyncFactoryFn<T> = () => Promise<T>;\n\n/** An async function that takes an item and an option value and returns a boolean promise. */\nexport declare type AsyncOptionPredicate<T, O> = (item: T, option: O) => Promise<boolean>;\n\n/** An async function that takes an item and returns a boolean promise */\nexport declare type AsyncPredicate<T> = (item: T) => Promise<boolean>;\n\n\n/** Represents the status of auto change detection. */\nexport declare interface AutoChangeDetectionStatus {\n    /** Whether auto change detection is disabled. */\n    isDisabled: boolean;\n    /**\n     * An optional callback, if present it indicates that change detection should be run immediately,\n     * while handling the status change. The callback should then be called as soon as change\n     * detection is done.\n     */\n    onDetectChangesNow?: () => void;\n}\n\n/** A set of criteria that can be used to filter a list of `ComponentHarness` instances. */\nexport declare interface BaseHarnessFilters {\n    /** Only find instances whose host element matches the given selector. */\n    selector?: string;\n    /** Only find instances that are nested under an element with the given selector. */\n    ancestor?: string;\n}\n\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\nexport declare abstract class ComponentHarness {\n    protected readonly locatorFactory: LocatorFactory;\n    constructor(locatorFactory: LocatorFactory);\n    /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n    host(): Promise<TestElement>;\n    /**\n     * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n     * locators for elements that a component creates outside of its own root element. (e.g. by\n     * appending to document.body).\n     */\n    protected documentRootLocatorFactory(): LocatorFactory;\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n     *   each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n     */\n    protected locatorFor<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>>;\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n     *   result types for each query or null.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorForOptional('span')()` gets `null`.\n     */\n    protected locatorForOptional<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T> | null>;\n    /**\n     * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n     * or elements under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for all\n     *   elements and harnesses matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If an element matches more than\n     *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n     *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n     *   for that element. The type that the `Promise` resolves to is an array where each element is\n     *   the union of all result types for each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n     * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n     *     DivHarness, // for #d1\n     *     TestElement, // for #d1\n     *     DivHarness, // for #d2\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('div', '#d1')()` gets `[\n     *     TestElement, // for #d1\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n     *     DivHarness, // for #d1\n     *     IdIsD1Harness, // for #d1\n     *     DivHarness // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('span')()` gets `[]`.\n     */\n    protected locatorForAll<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>[]>;\n    /**\n     * Flushes change detection and async tasks in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    protected forceStabilize(): Promise<void>;\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    protected waitForTasksOutsideAngular(): Promise<void>;\n}\n\n/** Constructor for a ComponentHarness subclass. */\nexport declare interface ComponentHarnessConstructor<T extends ComponentHarness> {\n    new (locatorFactory: LocatorFactory): T;\n    /**\n     * `ComponentHarness` subclasses must specify a static `hostSelector` property that is used to\n     * find the host element for the corresponding component. This property should match the selector\n     * for the Angular component.\n     */\n    hostSelector: string;\n}\n\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\nexport declare abstract class ContentContainerComponentHarness<S extends string = string> extends ComponentHarness implements HarnessLoader {\n    getChildLoader(selector: S): Promise<HarnessLoader>;\n    getAllChildLoaders(selector: S): Promise<HarnessLoader[]>;\n    getHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T>;\n    getHarnessOrNull<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T | null>;\n    getAllHarnesses<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T[]>;\n    hasHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<boolean>;\n    /**\n     * Gets the root harness loader from which to start\n     * searching for content contained by this harness.\n     */\n    protected getRootHarnessLoader(): Promise<HarnessLoader>;\n}\n\n\n/**\n * Dimensions for element size and its position relative to the viewport.\n */\nexport declare interface ElementDimensions {\n    top: number;\n    left: number;\n    width: number;\n    height: number;\n}\n\n/** Data that can be attached to a custom event dispatched from a `TestElement`. */\nexport declare type EventData = string | number | boolean | undefined | null | EventData[] | {\n    [key: string]: EventData;\n};\n\n\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\nexport declare function getNoKeysSpecifiedError(): Error;\n\n\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\nexport declare function _getTextWithExcludedElements(element: Element, excludeSelector: string): string;\n\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\nexport declare function handleAutoChangeDetectionStatus(handler: (status: AutoChangeDetectionStatus) => void): void;\n\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\nexport declare abstract class HarnessEnvironment<E> implements HarnessLoader, LocatorFactory {\n    protected rawRootElement: E;\n    get rootElement(): TestElement;\n    set rootElement(element: TestElement);\n    private _rootElement;\n    protected constructor(rawRootElement: E);\n    documentRootLocatorFactory(): LocatorFactory;\n    locatorFor<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>>;\n    locatorForOptional<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T> | null>;\n    locatorForAll<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>[]>;\n    rootHarnessLoader(): Promise<HarnessLoader>;\n    harnessLoaderFor(selector: string): Promise<HarnessLoader>;\n    harnessLoaderForOptional(selector: string): Promise<HarnessLoader | null>;\n    harnessLoaderForAll(selector: string): Promise<HarnessLoader[]>;\n    getHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T>;\n    getHarnessOrNull<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T | null>;\n    getAllHarnesses<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T[]>;\n    hasHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<boolean>;\n    getChildLoader(selector: string): Promise<HarnessLoader>;\n    getAllChildLoaders(selector: string): Promise<HarnessLoader[]>;\n    /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n    protected createComponentHarness<T extends ComponentHarness>(harnessType: ComponentHarnessConstructor<T>, element: E): T;\n    abstract forceStabilize(): Promise<void>;\n    abstract waitForTasksOutsideAngular(): Promise<void>;\n    /** Gets the root element for the document. */\n    protected abstract getDocumentRoot(): E;\n    /** Creates a `TestElement` from a raw element. */\n    protected abstract createTestElement(element: E): TestElement;\n    /** Creates a `HarnessLoader` rooted at the given raw element. */\n    protected abstract createEnvironment(element: E): HarnessEnvironment<E>;\n    /**\n     * Gets a list of all elements matching the given selector under this environment's root element.\n     */\n    protected abstract getAllRawElements(selector: string): Promise<E[]>;\n    /**\n     * Matches the given raw elements with the given list of element and harness queries to produce a\n     * list of matched harnesses and test elements.\n     */\n    private _getAllHarnessesAndTestElements;\n    /**\n     * Check whether the given query matches the given element, if it does return the matched\n     * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n     * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n     * to skip verification and optimize performance.\n     */\n    private _getQueryResultForElement;\n}\n\n/**\n * Interface used to load ComponentHarness objects. This interface is used by test authors to\n * instantiate `ComponentHarness`es.\n */\nexport declare interface HarnessLoader {\n    /**\n     * Searches for an element with the given selector under the current instances's root element,\n     * and returns a `HarnessLoader` rooted at the matching element. If multiple elements match the\n     * selector, the first is used. If no elements match, an error is thrown.\n     * @param selector The selector for the root element of the new `HarnessLoader`\n     * @return A `HarnessLoader` rooted at the element matching the given selector.\n     * @throws If a matching element can't be found.\n     */\n    getChildLoader(selector: string): Promise<HarnessLoader>;\n    /**\n     * Searches for all elements with the given selector under the current instances's root element,\n     * and returns an array of `HarnessLoader`s, one for each matching element, rooted at that\n     * element.\n     * @param selector The selector for the root element of the new `HarnessLoader`\n     * @return A list of `HarnessLoader`s, one for each matching element, rooted at that element.\n     */\n    getAllChildLoaders(selector: string): Promise<HarnessLoader[]>;\n    /**\n     * Searches for an instance of the component corresponding to the given harness type under the\n     * `HarnessLoader`'s root element, and returns a `ComponentHarness` for that instance. If multiple\n     * matching components are found, a harness for the first one is returned. If no matching\n     * component is found, an error is thrown.\n     * @param query A query for a harness to create\n     * @return An instance of the given harness type\n     * @throws If a matching component instance can't be found.\n     */\n    getHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T>;\n    /**\n     * Searches for an instance of the component corresponding to the given harness type under the\n     * `HarnessLoader`'s root element, and returns a `ComponentHarness` for that instance. If multiple\n     * matching components are found, a harness for the first one is returned. If no matching\n     * component is found, null is returned.\n     * @param query A query for a harness to create\n     * @return An instance of the given harness type (or null if not found).\n     */\n    getHarnessOrNull<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T | null>;\n    /**\n     * Searches for all instances of the component corresponding to the given harness type under the\n     * `HarnessLoader`'s root element, and returns a list `ComponentHarness` for each instance.\n     * @param query A query for a harness to create\n     * @return A list instances of the given harness type.\n     */\n    getAllHarnesses<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T[]>;\n    /**\n     * Searches for an instance of the component corresponding to the given harness type under the\n     * `HarnessLoader`'s root element, and returns a boolean indicating if any were found.\n     * @param query A query for a harness to create\n     * @return A boolean indicating if an instance was found.\n     */\n    hasHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<boolean>;\n}\n\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\nexport declare class HarnessPredicate<T extends ComponentHarness> {\n    harnessType: ComponentHarnessConstructor<T>;\n    private _predicates;\n    private _descriptions;\n    private _ancestor;\n    constructor(harnessType: ComponentHarnessConstructor<T>, options: BaseHarnessFilters);\n    /**\n     * Checks if the specified nullable string value matches the given pattern.\n     * @param value The nullable string value to check, or a Promise resolving to the\n     *   nullable string value.\n     * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n     *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n     *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n     * @return Whether the value matches the pattern.\n     */\n    static stringMatches(value: string | null | Promise<string | null>, pattern: string | RegExp | null): Promise<boolean>;\n    /**\n     * Adds a predicate function to be run against candidate harnesses.\n     * @param description A description of this predicate that may be used in error messages.\n     * @param predicate An async predicate function.\n     * @return this (for method chaining).\n     */\n    add(description: string, predicate: AsyncPredicate<T>): this;\n    /**\n     * Adds a predicate function that depends on an option value to be run against candidate\n     * harnesses. If the option value is undefined, the predicate will be ignored.\n     * @param name The name of the option (may be used in error messages).\n     * @param option The option value.\n     * @param predicate The predicate function to run if the option value is not undefined.\n     * @return this (for method chaining).\n     */\n    addOption<O>(name: string, option: O | undefined, predicate: AsyncOptionPredicate<T, O>): this;\n    /**\n     * Filters a list of harnesses on this predicate.\n     * @param harnesses The list of harnesses to filter.\n     * @return A list of harnesses that satisfy this predicate.\n     */\n    filter(harnesses: T[]): Promise<T[]>;\n    /**\n     * Evaluates whether the given harness satisfies this predicate.\n     * @param harness The harness to check\n     * @return A promise that resolves to true if the harness satisfies this predicate,\n     *   and resolves to false otherwise.\n     */\n    evaluate(harness: T): Promise<boolean>;\n    /** Gets a description of this predicate for use in error messages. */\n    getDescription(): string;\n    /** Gets the selector used to find candidate elements. */\n    getSelector(): string;\n    /** Adds base options common to all harness types. */\n    private _addBaseOptions;\n}\n\n/**\n * A query for a `ComponentHarness`, which is expressed as either a `ComponentHarnessConstructor` or\n * a `HarnessPredicate`.\n */\nexport declare type HarnessQuery<T extends ComponentHarness> = ComponentHarnessConstructor<T> | HarnessPredicate<T>;\n\n/**\n * Interface used to create asynchronous locator functions used find elements and component\n * harnesses. This interface is used by `ComponentHarness` authors to create locator functions for\n * their `ComponentHarness` subclass.\n */\nexport declare interface LocatorFactory {\n    /** Gets a locator factory rooted at the document root. */\n    documentRootLocatorFactory(): LocatorFactory;\n    /** The root element of this `LocatorFactory` as a `TestElement`. */\n    rootElement: TestElement;\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the root element of this `LocatorFactory`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n     *   each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await lf.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await lf.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await lf.locatorFor('span')()` throws because the `Promise` rejects.\n     */\n    locatorFor<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>>;\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the root element of this `LocatorFactory`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n     *   result types for each query or null.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await lf.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await lf.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await lf.locatorForOptional('span')()` gets `null`.\n     */\n    locatorForOptional<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T> | null>;\n    /**\n     * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n     * or elements under the root element of this `LocatorFactory`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for all\n     *   elements and harnesses matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If an element matches more than\n     *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n     *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n     *   for that element. The type that the `Promise` resolves to is an array where each element is\n     *   the union of all result types for each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n     * - `await lf.locatorForAll(DivHarness, 'div')()` gets `[\n     *     DivHarness, // for #d1\n     *     TestElement, // for #d1\n     *     DivHarness, // for #d2\n     *     TestElement // for #d2\n     *   ]`\n     * - `await lf.locatorForAll('div', '#d1')()` gets `[\n     *     TestElement, // for #d1\n     *     TestElement // for #d2\n     *   ]`\n     * - `await lf.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n     *     DivHarness, // for #d1\n     *     IdIsD1Harness, // for #d1\n     *     DivHarness // for #d2\n     *   ]`\n     * - `await lf.locatorForAll('span')()` gets `[]`.\n     */\n    locatorForAll<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>[]>;\n    /** @return A `HarnessLoader` rooted at the root element of this `LocatorFactory`. */\n    rootHarnessLoader(): Promise<HarnessLoader>;\n    /**\n     * Gets a `HarnessLoader` instance for an element under the root of this `LocatorFactory`.\n     * @param selector The selector for the root element.\n     * @return A `HarnessLoader` rooted at the first element matching the given selector.\n     * @throws If no matching element is found for the given selector.\n     */\n    harnessLoaderFor(selector: string): Promise<HarnessLoader>;\n    /**\n     * Gets a `HarnessLoader` instance for an element under the root of this `LocatorFactory`\n     * @param selector The selector for the root element.\n     * @return A `HarnessLoader` rooted at the first element matching the given selector, or null if\n     *     no matching element is found.\n     */\n    harnessLoaderForOptional(selector: string): Promise<HarnessLoader | null>;\n    /**\n     * Gets a list of `HarnessLoader` instances, one for each matching element.\n     * @param selector The selector for the root element.\n     * @return A list of `HarnessLoader`, one rooted at each element matching the given selector.\n     */\n    harnessLoaderForAll(selector: string): Promise<HarnessLoader[]>;\n    /**\n     * Flushes change detection and async tasks captured in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    forceStabilize(): Promise<void>;\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    waitForTasksOutsideAngular(): Promise<void>;\n}\n\n/**\n * The result type obtained when searching using a particular list of queries. This type depends on\n * the particular items being queried.\n * - If one of the queries is for a `ComponentHarnessConstructor<C1>`, it means that the result\n *   might be a harness of type `C1`\n * - If one of the queries is for a `HarnessPredicate<C2>`, it means that the result might be a\n *   harness of type `C2`\n * - If one of the queries is for a `string`, it means that the result might be a `TestElement`.\n *\n * Since we don't know for sure which query will match, the result type if the union of the types\n * for all possible results.\n *\n * e.g.\n * The type:\n * `LocatorFnResult&lt;[\n *   ComponentHarnessConstructor&lt;MyHarness&gt;,\n *   HarnessPredicate&lt;MyOtherHarness&gt;,\n *   string\n * ]&gt;`\n * is equivalent to:\n * `MyHarness | MyOtherHarness | TestElement`.\n */\nexport declare type LocatorFnResult<T extends (HarnessQuery<any> | string)[]> = {\n    [I in keyof T]: T[I] extends new (...args: any[]) => infer C ? C : T[I] extends {\n        harnessType: new (...args: any[]) => infer C;\n    } ? C : T[I] extends string ? TestElement : never;\n}[number];\n\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\nexport declare function manualChangeDetection<T>(fn: () => Promise<T>): Promise<T>;\n\n/** Modifier keys that may be held while typing. */\nexport declare interface ModifierKeys {\n    control?: boolean;\n    alt?: boolean;\n    shift?: boolean;\n    meta?: boolean;\n}\n\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nexport declare function parallel<T1, T2, T3, T4, T5>(values: () => [\nT1 | PromiseLike<T1>,\nT2 | PromiseLike<T2>,\nT3 | PromiseLike<T3>,\nT4 | PromiseLike<T4>,\nT5 | PromiseLike<T5>\n]): Promise<[T1, T2, T3, T4, T5]>;\n\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nexport declare function parallel<T1, T2, T3, T4>(values: () => [\nT1 | PromiseLike<T1>,\nT2 | PromiseLike<T2>,\nT3 | PromiseLike<T3>,\nT4 | PromiseLike<T4>\n]): Promise<[T1, T2, T3, T4]>;\n\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nexport declare function parallel<T1, T2, T3>(values: () => [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;\n\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nexport declare function parallel<T1, T2>(values: () => [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;\n\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nexport declare function parallel<T>(values: () => (T | PromiseLike<T>)[]): Promise<T[]>;\n\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\nexport declare function stopHandlingAutoChangeDetectionStatus(): void;\n\n/**\n * This acts as a common interface for DOM elements across both unit and e2e tests. It is the\n * interface through which the ComponentHarness interacts with the component's DOM.\n */\nexport declare interface TestElement {\n    /** Blur the element. */\n    blur(): Promise<void>;\n    /** Clear the element's input (for input and textarea elements only). */\n    clear(): Promise<void>;\n    /**\n     * Click the element at the default location for the current environment. If you need to guarantee\n     * the element is clicked at a specific location, consider using `click('center')` or\n     * `click(x, y)` instead.\n     */\n    click(modifiers?: ModifierKeys): Promise<void>;\n    /** Click the element at the element's center. */\n    click(location: 'center', modifiers?: ModifierKeys): Promise<void>;\n    /**\n     * Click the element at the specified coordinates relative to the top-left of the element.\n     * @param relativeX Coordinate within the element, along the X-axis at which to click.\n     * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n     * @param modifiers Modifier keys held while clicking\n     */\n    click(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n    /**\n     * Right clicks on the element at the specified coordinates relative to the top-left of it.\n     * @param relativeX Coordinate within the element, along the X-axis at which to click.\n     * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n     * @param modifiers Modifier keys held while clicking\n     */\n    rightClick(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n    /** Focus the element. */\n    focus(): Promise<void>;\n    /** Get the computed value of the given CSS property for the element. */\n    getCssValue(property: string): Promise<string>;\n    /** Hovers the mouse over the element. */\n    hover(): Promise<void>;\n    /** Moves the mouse away from the element. */\n    mouseAway(): Promise<void>;\n    /**\n     * Sends the given string to the input as a series of key presses. Also fires input events\n     * and attempts to add the string to the Element's value. Note that some environments cannot\n     * reproduce native browser behavior for keyboard shortcuts such as Tab, Ctrl + A, etc.\n     * @throws An error if no keys have been specified.\n     */\n    sendKeys(...keys: (string | TestKey)[]): Promise<void>;\n    /**\n     * Sends the given string to the input as a series of key presses. Also fires input\n     * events and attempts to add the string to the Element's value.\n     * @throws An error if no keys have been specified.\n     */\n    sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise<void>;\n    /**\n     * Gets the text from the element.\n     * @param options Options that affect what text is included.\n     */\n    text(options?: TextOptions): Promise<string>;\n    /** Gets the value for the given attribute from the element. */\n    getAttribute(name: string): Promise<string | null>;\n    /** Checks whether the element has the given class. */\n    hasClass(name: string): Promise<boolean>;\n    /** Gets the dimensions of the element. */\n    getDimensions(): Promise<ElementDimensions>;\n    /** Gets the value of a property of an element. */\n    getProperty<T = any>(name: string): Promise<T>;\n    /** Checks whether this element matches the given selector. */\n    matchesSelector(selector: string): Promise<boolean>;\n    /** Checks whether the element is focused. */\n    isFocused(): Promise<boolean>;\n    /** Sets the value of a property of an input. */\n    setInputValue(value: string): Promise<void>;\n    /** Selects the options at the specified indexes inside of a native `select` element. */\n    selectOptions(...optionIndexes: number[]): Promise<void>;\n    /**\n     * Dispatches an event with a particular name.\n     * @param name Name of the event to be dispatched.\n     */\n    dispatchEvent(name: string, data?: Record<string, EventData>): Promise<void>;\n}\n\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\nexport declare enum TestKey {\n    BACKSPACE = 0,\n    TAB = 1,\n    ENTER = 2,\n    SHIFT = 3,\n    CONTROL = 4,\n    ALT = 5,\n    ESCAPE = 6,\n    PAGE_UP = 7,\n    PAGE_DOWN = 8,\n    END = 9,\n    HOME = 10,\n    LEFT_ARROW = 11,\n    UP_ARROW = 12,\n    RIGHT_ARROW = 13,\n    DOWN_ARROW = 14,\n    INSERT = 15,\n    DELETE = 16,\n    F1 = 17,\n    F2 = 18,\n    F3 = 19,\n    F4 = 20,\n    F5 = 21,\n    F6 = 22,\n    F7 = 23,\n    F8 = 24,\n    F9 = 25,\n    F10 = 26,\n    F11 = 27,\n    F12 = 28,\n    META = 29\n}\n\nexport declare interface TextOptions {\n    /** Optional selector for elements to exclude. */\n    exclude?: string;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/testing/selenium-webdriver/index.d.ts",
      "node_modules/@angular/cdk/testing/selenium-webdriver/index.d.ts"
    ],
    "content": "import { ElementDimensions } from '@angular/cdk/testing';\nimport { EventData } from '@angular/cdk/testing';\nimport { HarnessEnvironment } from '@angular/cdk/testing';\nimport { HarnessLoader } from '@angular/cdk/testing';\nimport { ModifierKeys } from '@angular/cdk/testing';\nimport { TestElement } from '@angular/cdk/testing';\nimport { TestKey } from '@angular/cdk/testing';\nimport { TextOptions } from '@angular/cdk/testing';\nimport * as webdriver from 'selenium-webdriver';\n\n/** A `TestElement` implementation for WebDriver. */\nexport declare class SeleniumWebDriverElement implements TestElement {\n    readonly element: () => webdriver.WebElement;\n    private _stabilize;\n    constructor(element: () => webdriver.WebElement, _stabilize: () => Promise<void>);\n    /** Blur the element. */\n    blur(): Promise<void>;\n    /** Clear the element's input (for input and textarea elements only). */\n    clear(): Promise<void>;\n    /**\n     * Click the element at the default location for the current environment. If you need to guarantee\n     * the element is clicked at a specific location, consider using `click('center')` or\n     * `click(x, y)` instead.\n     */\n    click(modifiers?: ModifierKeys): Promise<void>;\n    /** Click the element at the element's center. */\n    click(location: 'center', modifiers?: ModifierKeys): Promise<void>;\n    /**\n     * Click the element at the specified coordinates relative to the top-left of the element.\n     * @param relativeX Coordinate within the element, along the X-axis at which to click.\n     * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n     * @param modifiers Modifier keys held while clicking\n     */\n    click(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n    /**\n     * Right clicks on the element at the specified coordinates relative to the top-left of it.\n     * @param relativeX Coordinate within the element, along the X-axis at which to click.\n     * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n     * @param modifiers Modifier keys held while clicking\n     */\n    rightClick(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n    /** Focus the element. */\n    focus(): Promise<void>;\n    /** Get the computed value of the given CSS property for the element. */\n    getCssValue(property: string): Promise<string>;\n    /** Hovers the mouse over the element. */\n    hover(): Promise<void>;\n    /** Moves the mouse away from the element. */\n    mouseAway(): Promise<void>;\n    /**\n     * Sends the given string to the input as a series of key presses. Also fires input events\n     * and attempts to add the string to the Element's value.\n     */\n    sendKeys(...keys: (string | TestKey)[]): Promise<void>;\n    /**\n     * Sends the given string to the input as a series of key presses. Also fires input events\n     * and attempts to add the string to the Element's value.\n     */\n    sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise<void>;\n    /**\n     * Gets the text from the element.\n     * @param options Options that affect what text is included.\n     */\n    text(options?: TextOptions): Promise<string>;\n    /** Gets the value for the given attribute from the element. */\n    getAttribute(name: string): Promise<string | null>;\n    /** Checks whether the element has the given class. */\n    hasClass(name: string): Promise<boolean>;\n    /** Gets the dimensions of the element. */\n    getDimensions(): Promise<ElementDimensions>;\n    /** Gets the value of a property of an element. */\n    getProperty<T = any>(name: string): Promise<T>;\n    /** Sets the value of a property of an input. */\n    setInputValue(newValue: string): Promise<void>;\n    /** Selects the options at the specified indexes inside of a native `select` element. */\n    selectOptions(...optionIndexes: number[]): Promise<void>;\n    /** Checks whether this element matches the given selector. */\n    matchesSelector(selector: string): Promise<boolean>;\n    /** Checks whether the element is focused. */\n    isFocused(): Promise<boolean>;\n    /**\n     * Dispatches an event with a particular name.\n     * @param name Name of the event to be dispatched.\n     */\n    dispatchEvent(name: string, data?: Record<string, EventData>): Promise<void>;\n    /** Gets the webdriver action sequence. */\n    private _actions;\n    /** Executes a function in the browser. */\n    private _executeScript;\n    /** Dispatches all the events that are part of a click event sequence. */\n    private _dispatchClickEventSequence;\n}\n\n/** A `HarnessEnvironment` implementation for WebDriver. */\nexport declare class SeleniumWebDriverHarnessEnvironment extends HarnessEnvironment<() => webdriver.WebElement> {\n    /** The options for this environment. */\n    private _options;\n    /** Environment stabilization callback passed to the created test elements. */\n    private _stabilizeCallback;\n    protected constructor(rawRootElement: () => webdriver.WebElement, options?: WebDriverHarnessEnvironmentOptions);\n    /** Gets the ElementFinder corresponding to the given TestElement. */\n    static getNativeElement(el: TestElement): webdriver.WebElement;\n    /** Creates a `HarnessLoader` rooted at the document root. */\n    static loader(driver: webdriver.WebDriver, options?: WebDriverHarnessEnvironmentOptions): HarnessLoader;\n    /**\n     * Flushes change detection and async tasks captured in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    forceStabilize(): Promise<void>;\n    /** @docs-private */\n    waitForTasksOutsideAngular(): Promise<void>;\n    /** Gets the root element for the document. */\n    protected getDocumentRoot(): () => webdriver.WebElement;\n    /** Creates a `TestElement` from a raw element. */\n    protected createTestElement(element: () => webdriver.WebElement): TestElement;\n    /** Creates a `HarnessLoader` rooted at the given raw element. */\n    protected createEnvironment(element: () => webdriver.WebElement): HarnessEnvironment<() => webdriver.WebElement>;\n    /**\n     * Gets a list of all elements matching the given selector under this environment's root element.\n     */\n    protected getAllRawElements(selector: string): Promise<(() => webdriver.WebElement)[]>;\n}\n\n/** Waits for angular to be ready after the page load. */\nexport declare function waitForAngularReady(wd: webdriver.WebDriver): Promise<void>;\n\n/** Options to configure the environment. */\nexport declare interface WebDriverHarnessEnvironmentOptions {\n    /** The query function used to find DOM elements. */\n    queryFn: (selector: string, root: () => webdriver.WebElement) => Promise<webdriver.WebElement[]>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/testing/testbed/index.d.ts",
      "node_modules/@angular/cdk/testing/testbed/index.d.ts"
    ],
    "content": "import { ComponentFixture } from '@angular/core/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { ElementDimensions } from '@angular/cdk/testing';\nimport { EventData } from '@angular/cdk/testing';\nimport { HarnessEnvironment } from '@angular/cdk/testing';\nimport { HarnessLoader } from '@angular/cdk/testing';\nimport { ModifierKeys } from '@angular/cdk/testing';\nimport { TestElement } from '@angular/cdk/testing';\nimport { TestKey } from '@angular/cdk/testing';\nimport { TextOptions } from '@angular/cdk/testing';\n\n/** A `HarnessEnvironment` implementation for Angular's Testbed. */\nexport declare class TestbedHarnessEnvironment extends HarnessEnvironment<Element> {\n    private _fixture;\n    /** Whether the environment has been destroyed. */\n    private _destroyed;\n    /** Observable that emits whenever the test task state changes. */\n    private _taskState;\n    /** The options for this environment. */\n    private _options;\n    /** Environment stabilization callback passed to the created test elements. */\n    private _stabilizeCallback;\n    protected constructor(rawRootElement: Element, _fixture: ComponentFixture<unknown>, options?: TestbedHarnessEnvironmentOptions);\n    /** Creates a `HarnessLoader` rooted at the given fixture's root element. */\n    static loader(fixture: ComponentFixture<unknown>, options?: TestbedHarnessEnvironmentOptions): HarnessLoader;\n    /**\n     * Creates a `HarnessLoader` at the document root. This can be used if harnesses are\n     * located outside of a fixture (e.g. overlays appended to the document body).\n     */\n    static documentRootLoader(fixture: ComponentFixture<unknown>, options?: TestbedHarnessEnvironmentOptions): HarnessLoader;\n    /** Gets the native DOM element corresponding to the given TestElement. */\n    static getNativeElement(el: TestElement): Element;\n    /**\n     * Creates an instance of the given harness type, using the fixture's root element as the\n     * harness's host element. This method should be used when creating a harness for the root element\n     * of a fixture, as components do not have the correct selector when they are created as the root\n     * of the fixture.\n     */\n    static harnessForFixture<T extends ComponentHarness>(fixture: ComponentFixture<unknown>, harnessType: ComponentHarnessConstructor<T>, options?: TestbedHarnessEnvironmentOptions): Promise<T>;\n    /**\n     * Flushes change detection and async tasks captured in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    forceStabilize(): Promise<void>;\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    waitForTasksOutsideAngular(): Promise<void>;\n    /** Gets the root element for the document. */\n    protected getDocumentRoot(): Element;\n    /** Creates a `TestElement` from a raw element. */\n    protected createTestElement(element: Element): TestElement;\n    /** Creates a `HarnessLoader` rooted at the given raw element. */\n    protected createEnvironment(element: Element): HarnessEnvironment<Element>;\n    /**\n     * Gets a list of all elements matching the given selector under this environment's root element.\n     */\n    protected getAllRawElements(selector: string): Promise<Element[]>;\n}\n\n/** Options to configure the environment. */\nexport declare interface TestbedHarnessEnvironmentOptions {\n    /** The query function used to find DOM elements. */\n    queryFn: (selector: string, root: Element) => Iterable<Element> | ArrayLike<Element>;\n}\n\n/** A `TestElement` implementation for unit tests. */\nexport declare class UnitTestElement implements TestElement {\n    readonly element: Element;\n    private _stabilize;\n    constructor(element: Element, _stabilize: () => Promise<void>);\n    /** Blur the element. */\n    blur(): Promise<void>;\n    /** Clear the element's input (for input and textarea elements only). */\n    clear(): Promise<void>;\n    /**\n     * Click the element at the default location for the current environment. If you need to guarantee\n     * the element is clicked at a specific location, consider using `click('center')` or\n     * `click(x, y)` instead.\n     */\n    click(modifiers?: ModifierKeys): Promise<void>;\n    /** Click the element at the element's center. */\n    click(location: 'center', modifiers?: ModifierKeys): Promise<void>;\n    /**\n     * Click the element at the specified coordinates relative to the top-left of the element.\n     * @param relativeX Coordinate within the element, along the X-axis at which to click.\n     * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n     * @param modifiers Modifier keys held while clicking\n     */\n    click(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n    /**\n     * Right clicks on the element at the specified coordinates relative to the top-left of it.\n     * @param relativeX Coordinate within the element, along the X-axis at which to click.\n     * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n     * @param modifiers Modifier keys held while clicking\n     */\n    rightClick(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n    /** Focus the element. */\n    focus(): Promise<void>;\n    /** Get the computed value of the given CSS property for the element. */\n    getCssValue(property: string): Promise<string>;\n    /** Hovers the mouse over the element. */\n    hover(): Promise<void>;\n    /** Moves the mouse away from the element. */\n    mouseAway(): Promise<void>;\n    /**\n     * Sends the given string to the input as a series of key presses. Also fires input events\n     * and attempts to add the string to the Element's value. Note that this cannot\n     * reproduce native browser behavior for keyboard shortcuts such as Tab, Ctrl + A, etc.\n     */\n    sendKeys(...keys: (string | TestKey)[]): Promise<void>;\n    /**\n     * Sends the given string to the input as a series of key presses. Also fires input events\n     * and attempts to add the string to the Element's value.\n     */\n    sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise<void>;\n    /**\n     * Gets the text from the element.\n     * @param options Options that affect what text is included.\n     */\n    text(options?: TextOptions): Promise<string>;\n    /** Gets the value for the given attribute from the element. */\n    getAttribute(name: string): Promise<string | null>;\n    /** Checks whether the element has the given class. */\n    hasClass(name: string): Promise<boolean>;\n    /** Gets the dimensions of the element. */\n    getDimensions(): Promise<ElementDimensions>;\n    /** Gets the value of a property of an element. */\n    getProperty<T = any>(name: string): Promise<T>;\n    /** Sets the value of a property of an input. */\n    setInputValue(value: string): Promise<void>;\n    /** Selects the options at the specified indexes inside of a native `select` element. */\n    selectOptions(...optionIndexes: number[]): Promise<void>;\n    /** Checks whether this element matches the given selector. */\n    matchesSelector(selector: string): Promise<boolean>;\n    /** Checks whether the element is focused. */\n    isFocused(): Promise<boolean>;\n    /**\n     * Dispatches an event with a particular name.\n     * @param name Name of the event to be dispatched.\n     */\n    dispatchEvent(name: string, data?: Record<string, EventData>): Promise<void>;\n    /**\n     * Dispatches a pointer event on the current element if the browser supports it.\n     * @param name Name of the pointer event to be dispatched.\n     * @param clientX Coordinate of the user's pointer along the X axis.\n     * @param clientY Coordinate of the user's pointer along the Y axis.\n     * @param button Mouse button that should be pressed when dispatching the event.\n     */\n    private _dispatchPointerEventIfSupported;\n    /**\n     * Dispatches all the events that are part of a mouse event sequence\n     * and then emits a given primary event at the end, if speciifed.\n     */\n    private _dispatchMouseEventSequence;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/text-field/index.d.ts",
      "node_modules/@angular/cdk/text-field/index.d.ts"
    ],
    "content": "import { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\n\n/** An event that is emitted when the autofill state of an input changes. */\nexport declare type AutofillEvent = {\n    /** The element whose autofill state changes. */\n    target: Element;\n    /** Whether the element is currently autofilled. */\n    isAutofilled: boolean;\n};\n\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nexport declare class AutofillMonitor implements OnDestroy {\n    private _platform;\n    private _ngZone;\n    private _monitoredElements;\n    constructor(_platform: Platform, _ngZone: NgZone);\n    /**\n     * Monitor for changes in the autofill state of the given input element.\n     * @param element The element to monitor.\n     * @return A stream of autofill state changes.\n     */\n    monitor(element: Element): Observable<AutofillEvent>;\n    /**\n     * Monitor for changes in the autofill state of the given input element.\n     * @param element The element to monitor.\n     * @return A stream of autofill state changes.\n     */\n    monitor(element: ElementRef<Element>): Observable<AutofillEvent>;\n    /**\n     * Stop monitoring the autofill state of the given input element.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: Element): void;\n    /**\n     * Stop monitoring the autofill state of the given input element.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: ElementRef<Element>): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<AutofillMonitor, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<AutofillMonitor>;\n}\n\n/** A directive that can be used to monitor the autofill state of an input. */\nexport declare class CdkAutofill implements OnDestroy, OnInit {\n    private _elementRef;\n    private _autofillMonitor;\n    /** Emits when the autofill state of the element changes. */\n    readonly cdkAutofill: EventEmitter<AutofillEvent>;\n    constructor(_elementRef: ElementRef<HTMLElement>, _autofillMonitor: AutofillMonitor);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkAutofill, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkAutofill, \"[cdkAutofill]\", never, {}, { \"cdkAutofill\": \"cdkAutofill\"; }, never, never, false>;\n}\n\n/** Directive to automatically resize a textarea to fit its content. */\nexport declare class CdkTextareaAutosize implements AfterViewInit, DoCheck, OnDestroy {\n    private _elementRef;\n    private _platform;\n    private _ngZone;\n    /** Keep track of the previous textarea value to avoid resizing when the value hasn't changed. */\n    private _previousValue?;\n    private _initialHeight;\n    private readonly _destroyed;\n    private _minRows;\n    private _maxRows;\n    private _enabled;\n    /**\n     * Value of minRows as of last resize. If the minRows has decreased, the\n     * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n     * does not have the same problem because it does not affect the textarea's scrollHeight.\n     */\n    private _previousMinRows;\n    private _textareaElement;\n    /** Minimum amount of rows in the textarea. */\n    get minRows(): number;\n    set minRows(value: NumberInput);\n    /** Maximum amount of rows in the textarea. */\n    get maxRows(): number;\n    set maxRows(value: NumberInput);\n    /** Whether autosizing is enabled or not */\n    get enabled(): boolean;\n    set enabled(value: BooleanInput);\n    get placeholder(): string;\n    set placeholder(value: string);\n    /** Cached height of a textarea with a single row. */\n    private _cachedLineHeight;\n    /** Cached height of a textarea with only the placeholder. */\n    private _cachedPlaceholderHeight?;\n    /** Used to reference correct document/window */\n    protected _document?: Document;\n    private _hasFocus;\n    private _isViewInited;\n    constructor(_elementRef: ElementRef<HTMLElement>, _platform: Platform, _ngZone: NgZone, \n    /** @breaking-change 11.0.0 make document required */\n    document?: any);\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    _setMinHeight(): void;\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    _setMaxHeight(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     */\n    private _cacheTextareaLineHeight;\n    private _measureScrollHeight;\n    private _cacheTextareaPlaceholderHeight;\n    /** Handles `focus` and `blur` events. */\n    private _handleFocusEvent;\n    ngDoCheck(): void;\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    resizeToFitContent(force?: boolean): void;\n    /**\n     * Resets the textarea to its original size\n     */\n    reset(): void;\n    _noopInputHandler(): void;\n    /** Access injected document if available or fallback to global document reference */\n    private _getDocument;\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    private _getWindow;\n    /**\n     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n     * prevent it from scrolling to the caret position. We need to re-set the selection\n     * in order for it to scroll to the proper position.\n     */\n    private _scrollToCaretPosition;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTextareaAutosize, [null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTextareaAutosize, \"textarea[cdkTextareaAutosize]\", [\"cdkTextareaAutosize\"], { \"minRows\": \"cdkAutosizeMinRows\"; \"maxRows\": \"cdkAutosizeMaxRows\"; \"enabled\": \"cdkTextareaAutosize\"; \"placeholder\": \"placeholder\"; }, {}, never, never, false>;\n}\n\ndeclare namespace i1 {\n    export {\n        AutofillEvent,\n        AutofillMonitor,\n        CdkAutofill\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        CdkTextareaAutosize\n    }\n}\n\nexport declare class TextFieldModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<TextFieldModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<TextFieldModule, [typeof i1.CdkAutofill, typeof i2.CdkTextareaAutosize], never, [typeof i1.CdkAutofill, typeof i2.CdkTextareaAutosize]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<TextFieldModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/cdk/tree/index.d.ts",
      "node_modules/@angular/cdk/tree/index.d.ts"
    ],
    "content": "import { AfterContentChecked } from '@angular/core';\nimport { AfterContentInit } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { CollectionViewer } from '@angular/cdk/collections';\nimport { DataSource } from '@angular/cdk/collections';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { IterableDiffer } from '@angular/core';\nimport { IterableDiffers } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { Subject } from 'rxjs';\nimport { TemplateRef } from '@angular/core';\nimport { TrackByFunction } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/** Base tree control. It has basic toggle/expand/collapse operations on a single data node. */\nexport declare abstract class BaseTreeControl<T, K = T> implements TreeControl<T, K> {\n    /** Gets a list of descendent data nodes of a subtree rooted at given data node recursively. */\n    abstract getDescendants(dataNode: T): T[];\n    /** Expands all data nodes in the tree. */\n    abstract expandAll(): void;\n    /** Saved data node for `expandAll` action. */\n    dataNodes: T[];\n    /** A selection model with multi-selection to track expansion status. */\n    expansionModel: SelectionModel<K>;\n    /**\n     * Returns the identifier by which a dataNode should be tracked, should its\n     * reference change.\n     *\n     * Similar to trackBy for *ngFor\n     */\n    trackBy?: (dataNode: T) => K;\n    /** Get depth of a given data node, return the level number. This is for flat tree node. */\n    getLevel: (dataNode: T) => number;\n    /**\n     * Whether the data node is expandable. Returns true if expandable.\n     * This is for flat tree node.\n     */\n    isExpandable: (dataNode: T) => boolean;\n    /** Gets a stream that emits whenever the given data node's children change. */\n    getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;\n    /** Toggles one single data node's expanded/collapsed state. */\n    toggle(dataNode: T): void;\n    /** Expands one single data node. */\n    expand(dataNode: T): void;\n    /** Collapses one single data node. */\n    collapse(dataNode: T): void;\n    /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n    isExpanded(dataNode: T): boolean;\n    /** Toggles a subtree rooted at `node` recursively. */\n    toggleDescendants(dataNode: T): void;\n    /** Collapse all dataNodes in the tree. */\n    collapseAll(): void;\n    /** Expands a subtree rooted at given data node recursively. */\n    expandDescendants(dataNode: T): void;\n    /** Collapses a subtree rooted at given data node recursively. */\n    collapseDescendants(dataNode: T): void;\n    protected _trackByValue(value: T | K): K;\n}\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport declare const CDK_TREE_NODE_OUTLET_NODE: InjectionToken<{}>;\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\nexport declare class CdkNestedTreeNode<T, K = T> extends CdkTreeNode<T, K> implements AfterContentInit, OnDestroy, OnInit {\n    protected _differs: IterableDiffers;\n    /** Differ used to find the changes in the data provided by the data source. */\n    private _dataDiffer;\n    /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n    protected _children: T[];\n    /** The children node placeholder. */\n    nodeOutlet: QueryList<CdkTreeNodeOutlet>;\n    constructor(elementRef: ElementRef<HTMLElement>, tree: CdkTree<T, K>, _differs: IterableDiffers);\n    ngAfterContentInit(): void;\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Add children dataNodes to the NodeOutlet */\n    protected updateChildrenNodes(children?: T[]): void;\n    /** Clear the children dataNodes. */\n    protected _clear(): void;\n    /** Gets the outlet for the current node. */\n    private _getNodeOutlet;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkNestedTreeNode<any, any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkNestedTreeNode<any, any>, \"cdk-nested-tree-node\", [\"cdkNestedTreeNode\"], { \"role\": \"role\"; \"disabled\": \"disabled\"; \"tabIndex\": \"tabIndex\"; }, {}, [\"nodeOutlet\"], never, false>;\n}\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\nexport declare class CdkTree<T, K = T> implements AfterContentChecked, CollectionViewer, OnDestroy, OnInit {\n    private _differs;\n    private _changeDetectorRef;\n    /** Subject that emits when the component has been destroyed. */\n    private readonly _onDestroy;\n    /** Differ used to find the changes in the data provided by the data source. */\n    private _dataDiffer;\n    /** Stores the node definition that does not have a when predicate. */\n    private _defaultNodeDef;\n    /** Data subscription */\n    private _dataSubscription;\n    /** Level of nodes */\n    private _levels;\n    /**\n     * Provides a stream containing the latest data array to render. Influenced by the tree's\n     * stream of view window (what dataNodes are currently on screen).\n     * Data source can be an observable of data array, or a data array to render.\n     */\n    get dataSource(): DataSource<T> | Observable<T[]> | T[];\n    set dataSource(dataSource: DataSource<T> | Observable<T[]> | T[]);\n    private _dataSource;\n    /** The tree controller */\n    treeControl: TreeControl<T, K>;\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n     * relative to the function to know if a node should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    trackBy: TrackByFunction<T>;\n    _nodeOutlet: CdkTreeNodeOutlet;\n    /** The tree node template for the tree */\n    _nodeDefs: QueryList<CdkTreeNodeDef<T>>;\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n    readonly viewChange: BehaviorSubject<{\n        start: number;\n        end: number;\n    }>;\n    constructor(_differs: IterableDiffers, _changeDetectorRef: ChangeDetectorRef);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    ngAfterContentChecked(): void;\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     */\n    private _switchDataSource;\n    /** Set up a subscription for the data provided by the data source. */\n    private _observeRenderChanges;\n    /** Check for changes made in the data and render each change (node added/removed/moved). */\n    renderNodeChanges(data: readonly T[], dataDiffer?: IterableDiffer<T>, viewContainer?: ViewContainerRef, parentData?: T): void;\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     */\n    _getNodeDef(data: T, i: number): CdkTreeNodeDef<T>;\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     */\n    insertNode(nodeData: T, index: number, viewContainer?: ViewContainerRef, parentData?: T): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTree<any, any>, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTree<any, any>, \"cdk-tree\", [\"cdkTree\"], { \"dataSource\": \"dataSource\"; \"treeControl\": \"treeControl\"; \"trackBy\": \"trackBy\"; }, {}, [\"_nodeDefs\"], never, false>;\n}\n\nexport declare class CdkTreeModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkTreeModule, [typeof i1.CdkNestedTreeNode, typeof i2.CdkTreeNodeDef, typeof i3.CdkTreeNodePadding, typeof i4.CdkTreeNodeToggle, typeof i5.CdkTree, typeof i5.CdkTreeNode, typeof i6.CdkTreeNodeOutlet], never, [typeof i1.CdkNestedTreeNode, typeof i2.CdkTreeNodeDef, typeof i3.CdkTreeNodePadding, typeof i4.CdkTreeNodeToggle, typeof i5.CdkTree, typeof i5.CdkTreeNode, typeof i6.CdkTreeNodeOutlet]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<CdkTreeModule>;\n}\n\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\nexport declare class CdkTreeNode<T, K = T> implements FocusableOption, OnDestroy, OnInit {\n    protected _elementRef: ElementRef<HTMLElement>;\n    protected _tree: CdkTree<T, K>;\n    /**\n     * The role of the tree node.\n     * @deprecated The correct role is 'treeitem', 'group' should not be used. This input will be\n     *   removed in a future version.\n     * @breaking-change 12.0.0 Remove this input\n     */\n    get role(): 'treeitem' | 'group';\n    set role(_role: 'treeitem' | 'group');\n    /**\n     * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n     * in `CdkTree` and set the data to it.\n     */\n    static mostRecentTreeNode: CdkTreeNode<any> | null;\n    /** Subject that emits when the component has been destroyed. */\n    protected readonly _destroyed: Subject<void>;\n    /** Emits when the node's data has changed. */\n    readonly _dataChanges: Subject<void>;\n    private _parentNodeAriaLevel;\n    /** The tree node's data. */\n    get data(): T;\n    set data(value: T);\n    protected _data: T;\n    get isExpanded(): boolean;\n    get level(): number;\n    constructor(_elementRef: ElementRef<HTMLElement>, _tree: CdkTree<T, K>);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Focuses the menu item. Implements for FocusableOption. */\n    focus(): void;\n    protected _setRoleFromData(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNode<any, any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNode<any, any>, \"cdk-tree-node\", [\"cdkTreeNode\"], { \"role\": \"role\"; }, {}, never, never, false>;\n}\n\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nexport declare class CdkTreeNodeDef<T> {\n    template: TemplateRef<any>;\n    /**\n     * Function that should return true if this node template should be used for the provided node\n     * data and index. If left undefined, this node will be considered the default node template to\n     * use when no other when functions return true for the data.\n     * For every node, there must be at least one when function that passes or an undefined to\n     * default.\n     */\n    when: (index: number, nodeData: T) => boolean;\n    /** @docs-private */\n    constructor(template: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeDef<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeDef<any>, \"[cdkTreeNodeDef]\", never, { \"when\": \"cdkTreeNodeDefWhen\"; }, {}, never, never, false>;\n}\n\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nexport declare class CdkTreeNodeOutlet {\n    viewContainer: ViewContainerRef;\n    _node?: any;\n    constructor(viewContainer: ViewContainerRef, _node?: any);\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeOutlet, [null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeOutlet, \"[cdkTreeNodeOutlet]\", never, {}, {}, never, never, false>;\n}\n\n/** Context provided to the tree node component. */\nexport declare class CdkTreeNodeOutletContext<T> {\n    /** Data for the node. */\n    $implicit: T;\n    /** Depth of the node. */\n    level: number;\n    /** Index location of the node. */\n    index?: number;\n    /** Length of the number of total dataNodes. */\n    count?: number;\n    constructor(data: T);\n}\n\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\nexport declare class CdkTreeNodePadding<T, K = T> implements OnDestroy {\n    private _treeNode;\n    private _tree;\n    private _element;\n    private _dir;\n    /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n    private _currentPadding;\n    /** Subject that emits when the component has been destroyed. */\n    private readonly _destroyed;\n    /** CSS units used for the indentation value. */\n    indentUnits: string;\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level(): number;\n    set level(value: NumberInput);\n    _level: number;\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     */\n    get indent(): number | string;\n    set indent(indent: number | string);\n    _indent: number;\n    constructor(_treeNode: CdkTreeNode<T, K>, _tree: CdkTree<T, K>, _element: ElementRef<HTMLElement>, _dir: Directionality);\n    ngOnDestroy(): void;\n    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n    _paddingIndent(): string | null;\n    _setPadding(forceChange?: boolean): void;\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    protected _setLevelInput(value: NumberInput): void;\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    protected _setIndentInput(indent: number | string): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodePadding<any, any>, [null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodePadding<any, any>, \"[cdkTreeNodePadding]\", never, { \"level\": \"cdkTreeNodePadding\"; \"indent\": \"cdkTreeNodePaddingIndent\"; }, {}, never, never, false>;\n}\n\n/**\n * Node toggle to expand/collapse the node.\n */\nexport declare class CdkTreeNodeToggle<T, K = T> {\n    protected _tree: CdkTree<T, K>;\n    protected _treeNode: CdkTreeNode<T, K>;\n    /** Whether expand/collapse the node recursively. */\n    get recursive(): boolean;\n    set recursive(value: BooleanInput);\n    protected _recursive: boolean;\n    constructor(_tree: CdkTree<T, K>, _treeNode: CdkTreeNode<T, K>);\n    _toggle(event: Event): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeToggle<any, any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeToggle<any, any>, \"[cdkTreeNodeToggle]\", never, { \"recursive\": \"cdkTreeNodeToggleRecursive\"; }, {}, never, never, false>;\n}\n\n/** Flat tree control. Able to expand/collapse a subtree recursively for flattened tree. */\nexport declare class FlatTreeControl<T, K = T> extends BaseTreeControl<T, K> {\n    getLevel: (dataNode: T) => number;\n    isExpandable: (dataNode: T) => boolean;\n    options?: FlatTreeControlOptions<T, K> | undefined;\n    /** Construct with flat tree data node functions getLevel and isExpandable. */\n    constructor(getLevel: (dataNode: T) => number, isExpandable: (dataNode: T) => boolean, options?: FlatTreeControlOptions<T, K> | undefined);\n    /**\n     * Gets a list of the data node's subtree of descendent data nodes.\n     *\n     * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n     * with correct levels.\n     */\n    getDescendants(dataNode: T): T[];\n    /**\n     * Expands all data nodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n     * data nodes of the tree.\n     */\n    expandAll(): void;\n}\n\n/** Optional set of configuration that can be provided to the FlatTreeControl. */\nexport declare interface FlatTreeControlOptions<T, K> {\n    trackBy?: (dataNode: T) => K;\n}\n\n/**\n * Returns an error to be thrown when tree control did not implement functions for flat/nested node.\n * @docs-private\n */\nexport declare function getTreeControlFunctionsMissingError(): Error;\n\n/**\n * Returns an error to be thrown when there are tree control.\n * @docs-private\n */\nexport declare function getTreeControlMissingError(): Error;\n\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nexport declare function getTreeMissingMatchingNodeDefError(): Error;\n\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nexport declare function getTreeMultipleDefaultNodeDefsError(): Error;\n\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nexport declare function getTreeNoValidDataSourceError(): Error;\n\ndeclare namespace i1 {\n    export {\n        CdkNestedTreeNode\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        CdkTreeNodeOutletContext,\n        CdkTreeNodeDef\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        CdkTreeNodePadding\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        CdkTreeNodeToggle\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        CdkTree,\n        CdkTreeNode\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        CDK_TREE_NODE_OUTLET_NODE,\n        CdkTreeNodeOutlet\n    }\n}\n\n/** Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type. */\nexport declare class NestedTreeControl<T, K = T> extends BaseTreeControl<T, K> {\n    getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;\n    options?: NestedTreeControlOptions<T, K> | undefined;\n    /** Construct with nested tree function getChildren. */\n    constructor(getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null, options?: NestedTreeControlOptions<T, K> | undefined);\n    /**\n     * Expands all dataNodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n     * data nodes of the tree.\n     */\n    expandAll(): void;\n    /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n    getDescendants(dataNode: T): T[];\n    /** A helper function to get descendants recursively. */\n    protected _getDescendants(descendants: T[], dataNode: T): void;\n}\n\n/** Optional set of configuration that can be provided to the NestedTreeControl. */\nexport declare interface NestedTreeControlOptions<T, K> {\n    trackBy?: (dataNode: T) => K;\n}\n\n/**\n * Tree control interface. User can implement TreeControl to expand/collapse dataNodes in the tree.\n * The CDKTree will use this TreeControl to expand/collapse a node.\n * User can also use it outside the `<cdk-tree>` to control the expansion status of the tree.\n */\nexport declare interface TreeControl<T, K = T> {\n    /** The saved tree nodes data for `expandAll` action. */\n    dataNodes: T[];\n    /** The expansion model */\n    expansionModel: SelectionModel<K>;\n    /** Whether the data node is expanded or collapsed. Return true if it's expanded. */\n    isExpanded(dataNode: T): boolean;\n    /** Get all descendants of a data node */\n    getDescendants(dataNode: T): any[];\n    /** Expand or collapse data node */\n    toggle(dataNode: T): void;\n    /** Expand one data node */\n    expand(dataNode: T): void;\n    /** Collapse one data node */\n    collapse(dataNode: T): void;\n    /** Expand all the dataNodes in the tree */\n    expandAll(): void;\n    /** Collapse all the dataNodes in the tree */\n    collapseAll(): void;\n    /** Toggle a data node by expand/collapse it and all its descendants */\n    toggleDescendants(dataNode: T): void;\n    /** Expand a data node and all its descendants */\n    expandDescendants(dataNode: T): void;\n    /** Collapse a data node and all its descendants */\n    collapseDescendants(dataNode: T): void;\n    /** Get depth of a given data node, return the level number. This is for flat tree node. */\n    readonly getLevel: (dataNode: T) => number;\n    /**\n     * Whether the data node is expandable. Returns true if expandable.\n     * This is for flat tree node.\n     */\n    readonly isExpandable: (dataNode: T) => boolean;\n    /** Gets a stream that emits whenever the given data node's children change. */\n    readonly getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/autocomplete/index.d.ts",
      "node_modules/@angular/material/autocomplete/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i4 from '@angular/cdk/overlay';\nimport * as i5 from '@angular/material/core';\nimport * as i6 from '@angular/common';\nimport * as i7 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { MatFormField } from '@angular/material/form-field';\nimport { MatOptgroup } from '@angular/material/core';\nimport { _MatOptgroupBase } from '@angular/material/core';\nimport { MatOption } from '@angular/material/core';\nimport { _MatOptionBase } from '@angular/material/core';\nimport { MatOptionSelectionChange } from '@angular/material/core';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { SimpleChanges } from '@angular/core';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport declare function getMatAutocompleteMissingPanelError(): Error;\n\ndeclare namespace i1 {\n    export {\n        MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n        MatAutocompleteSelectedEvent,\n        MatAutocompleteActivatedEvent,\n        MatAutocompleteDefaultOptions,\n        MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,\n        _MatAutocompleteBase,\n        MatAutocomplete\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n        getMatAutocompleteMissingPanelError,\n        MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n        MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER,\n        MAT_AUTOCOMPLETE_VALUE_ACCESSOR,\n        _MatAutocompleteTriggerBase,\n        MatAutocompleteTrigger\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        _MatAutocompleteOriginBase,\n        MatAutocompleteOrigin\n    }\n}\n\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nexport declare const MAT_AUTOCOMPLETE_DEFAULT_OPTIONS: InjectionToken<MatAutocompleteDefaultOptions>;\n\n/** @docs-private */\nexport declare function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY(): MatAutocompleteDefaultOptions;\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\nexport declare function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/** @docs-private */\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY;\n};\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport declare const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any;\n\nexport declare class MatAutocomplete extends _MatAutocompleteBase {\n    /** Reference to all option groups within the autocomplete. */\n    optionGroups: QueryList<MatOptgroup>;\n    /** Reference to all options within the autocomplete. */\n    options: QueryList<MatOption>;\n    protected _visibleClass: string;\n    protected _hiddenClass: string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatAutocomplete, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatAutocomplete, \"mat-autocomplete\", [\"matAutocomplete\"], { \"disableRipple\": \"disableRipple\"; }, {}, [\"optionGroups\", \"options\"], [\"*\"], false>;\n}\n\n/** Event object that is emitted when an autocomplete option is activated. */\nexport declare interface MatAutocompleteActivatedEvent {\n    /** Reference to the autocomplete panel that emitted the event. */\n    source: _MatAutocompleteBase;\n    /** Option that was selected. */\n    option: _MatOptionBase | null;\n}\n\n/** Base class with all of the `MatAutocomplete` functionality. */\nexport declare abstract class _MatAutocompleteBase extends _MatAutocompleteMixinBase implements AfterContentInit, CanDisableRipple, OnDestroy {\n    private _changeDetectorRef;\n    private _elementRef;\n    private _activeOptionChanges;\n    /** Class to apply to the panel when it's visible. */\n    protected abstract _visibleClass: string;\n    /** Class to apply to the panel when it's hidden. */\n    protected abstract _hiddenClass: string;\n    /** Manages active item in option list based on key events. */\n    _keyManager: ActiveDescendantKeyManager<_MatOptionBase>;\n    /** Whether the autocomplete panel should be visible, depending on option length. */\n    showPanel: boolean;\n    /** Whether the autocomplete panel is open. */\n    get isOpen(): boolean;\n    _isOpen: boolean;\n    /** @docs-private */\n    template: TemplateRef<any>;\n    /** Element for the panel containing the autocomplete options. */\n    panel: ElementRef;\n    /** Reference to all options within the autocomplete. */\n    abstract options: QueryList<_MatOptionBase>;\n    /** Reference to all option groups within the autocomplete. */\n    abstract optionGroups: QueryList<_MatOptgroupBase>;\n    /** Aria label of the autocomplete. */\n    ariaLabel: string;\n    /** Input that can be used to specify the `aria-labelledby` attribute. */\n    ariaLabelledby: string;\n    /** Function that maps an option's control value to its display value in the trigger. */\n    displayWith: ((value: any) => string) | null;\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    get autoActiveFirstOption(): boolean;\n    set autoActiveFirstOption(value: BooleanInput);\n    private _autoActiveFirstOption;\n    /** Whether the active option should be selected as the user is navigating. */\n    get autoSelectActiveOption(): boolean;\n    set autoSelectActiveOption(value: BooleanInput);\n    private _autoSelectActiveOption;\n    /**\n     * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n     * match the width of its host.\n     */\n    panelWidth: string | number;\n    /** Event that is emitted whenever an option from the list is selected. */\n    readonly optionSelected: EventEmitter<MatAutocompleteSelectedEvent>;\n    /** Event that is emitted when the autocomplete panel is opened. */\n    readonly opened: EventEmitter<void>;\n    /** Event that is emitted when the autocomplete panel is closed. */\n    readonly closed: EventEmitter<void>;\n    /** Emits whenever an option is activated. */\n    readonly optionActivated: EventEmitter<MatAutocompleteActivatedEvent>;\n    /**\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    set classList(value: string | string[]);\n    _classList: {\n        [key: string]: boolean;\n    };\n    /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n    id: string;\n    /**\n     * Tells any descendant `mat-optgroup` to use the inert a11y pattern.\n     * @docs-private\n     */\n    readonly inertGroups: boolean;\n    constructor(_changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef<HTMLElement>, defaults: MatAutocompleteDefaultOptions, platform?: Platform);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\n     * above or below the fold, as they are not actually being focused when active.\n     */\n    _setScrollTop(scrollTop: number): void;\n    /** Returns the panel's scrollTop. */\n    _getScrollTop(): number;\n    /** Panel should hide itself when the option list is empty. */\n    _setVisibility(): void;\n    /** Emits the `select` event. */\n    _emitSelectEvent(option: _MatOptionBase): void;\n    /** Gets the aria-labelledby for the autocomplete panel. */\n    _getPanelAriaLabelledby(labelId: string | null): string | null;\n    /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n    private _setVisibilityClasses;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatAutocompleteBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatAutocompleteBase, never, never, { \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"displayWith\": \"displayWith\"; \"autoActiveFirstOption\": \"autoActiveFirstOption\"; \"autoSelectActiveOption\": \"autoSelectActiveOption\"; \"panelWidth\": \"panelWidth\"; \"classList\": \"class\"; }, { \"optionSelected\": \"optionSelected\"; \"opened\": \"opened\"; \"closed\": \"closed\"; \"optionActivated\": \"optionActivated\"; }, never, never, false>;\n}\n\n/** Default `mat-autocomplete` options that can be overridden. */\nexport declare interface MatAutocompleteDefaultOptions {\n    /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n    autoActiveFirstOption?: boolean;\n    /** Whether the active option should be selected as the user is navigating. */\n    autoSelectActiveOption?: boolean;\n    /** Class or list of classes to be applied to the autocomplete's overlay panel. */\n    overlayPanelClass?: string | string[];\n}\n\n/** @docs-private */\ndeclare const _MatAutocompleteMixinBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (): {};\n};\n\nexport declare class MatAutocompleteModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatAutocompleteModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatAutocompleteModule, [typeof i1.MatAutocomplete, typeof i2.MatAutocompleteTrigger, typeof i3.MatAutocompleteOrigin], [typeof i4.OverlayModule, typeof i5.MatOptionModule, typeof i5.MatCommonModule, typeof i6.CommonModule], [typeof i1.MatAutocomplete, typeof i2.MatAutocompleteTrigger, typeof i3.MatAutocompleteOrigin, typeof i7.CdkScrollableModule, typeof i5.MatOptionModule, typeof i5.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatAutocompleteModule>;\n}\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\nexport declare class MatAutocompleteOrigin extends _MatAutocompleteOriginBase {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatAutocompleteOrigin, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatAutocompleteOrigin, \"[matAutocompleteOrigin]\", [\"matAutocompleteOrigin\"], {}, {}, never, never, false>;\n}\n\n/** Base class containing all of the functionality for `MatAutocompleteOrigin`. */\nexport declare abstract class _MatAutocompleteOriginBase {\n    /** Reference to the element on which the directive is applied. */\n    elementRef: ElementRef<HTMLElement>;\n    constructor(\n    /** Reference to the element on which the directive is applied. */\n    elementRef: ElementRef<HTMLElement>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatAutocompleteOriginBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatAutocompleteOriginBase, never, never, {}, {}, never, never, false>;\n}\n\n/** Event object that is emitted when an autocomplete option is selected. */\nexport declare class MatAutocompleteSelectedEvent {\n    /** Reference to the autocomplete panel that emitted the event. */\n    source: _MatAutocompleteBase;\n    /** Option that was selected. */\n    option: _MatOptionBase;\n    constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    source: _MatAutocompleteBase, \n    /** Option that was selected. */\n    option: _MatOptionBase);\n}\n\nexport declare class MatAutocompleteTrigger extends _MatAutocompleteTriggerBase {\n    protected _aboveClass: string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatAutocompleteTrigger, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatAutocompleteTrigger, \"input[matAutocomplete], textarea[matAutocomplete]\", [\"matAutocompleteTrigger\"], {}, {}, never, never, false>;\n}\n\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\nexport declare abstract class _MatAutocompleteTriggerBase implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy {\n    private _element;\n    private _overlay;\n    private _viewContainerRef;\n    private _zone;\n    private _changeDetectorRef;\n    private _dir;\n    private _formField;\n    private _document;\n    private _viewportRuler;\n    private _defaults?;\n    private _overlayRef;\n    private _portal;\n    private _componentDestroyed;\n    private _autocompleteDisabled;\n    private _scrollStrategy;\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n    private _previousValue;\n    /** Strategy that is used to position the panel. */\n    private _positionStrategy;\n    /** Whether or not the label state is being overridden. */\n    private _manuallyFloatingLabel;\n    /** The subscription for closing actions (some are bound to document). */\n    private _closingActionsSubscription;\n    /** Subscription to viewport size changes. */\n    private _viewportSubscription;\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     */\n    private _canOpenOnNextFocus;\n    /** Value inside the input before we auto-selected an option. */\n    private _valueBeforeAutoSelection;\n    /**\n     * Current option that we have auto-selected as the user is navigating,\n     * but which hasn't been propagated to the model value yet.\n     */\n    private _pendingAutoselectedOption;\n    /** Stream of keyboard events that can close the panel. */\n    private readonly _closeKeyEventStream;\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     */\n    private _windowBlurHandler;\n    /** `View -> model callback called when value changes` */\n    _onChange: (value: any) => void;\n    /** `View -> model callback called when autocomplete has been touched` */\n    _onTouched: () => void;\n    /** The autocomplete panel to be attached to this trigger. */\n    autocomplete: _MatAutocompleteBase;\n    /**\n     * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n     * will render the panel underneath the trigger if there is enough space for it to fit in\n     * the viewport, otherwise the panel will be shown above it. If the position is set to\n     * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n     * whether it fits completely in the viewport.\n     */\n    position: 'auto' | 'above' | 'below';\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     */\n    connectedTo: _MatAutocompleteOriginBase;\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * @docs-private\n     */\n    autocompleteAttribute: string;\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    get autocompleteDisabled(): boolean;\n    set autocompleteDisabled(value: BooleanInput);\n    constructor(_element: ElementRef<HTMLInputElement>, _overlay: Overlay, _viewContainerRef: ViewContainerRef, _zone: NgZone, _changeDetectorRef: ChangeDetectorRef, scrollStrategy: any, _dir: Directionality, _formField: MatFormField, _document: any, _viewportRuler: ViewportRuler, _defaults?: MatAutocompleteDefaultOptions | undefined);\n    /** Class to apply to the panel when it's above the input. */\n    protected abstract _aboveClass: string;\n    ngAfterViewInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Whether or not the autocomplete panel is open. */\n    get panelOpen(): boolean;\n    private _overlayAttached;\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void;\n    /** Closes the autocomplete suggestion panel. */\n    closePanel(): void;\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition(): void;\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions(): Observable<MatOptionSelectionChange | null>;\n    /** Stream of changes to the selection state of the autocomplete options. */\n    readonly optionSelections: Observable<MatOptionSelectionChange>;\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption(): _MatOptionBase | null;\n    /** Stream of clicks outside of the autocomplete panel. */\n    private _getOutsideClickStream;\n    writeValue(value: any): void;\n    registerOnChange(fn: (value: any) => {}): void;\n    registerOnTouched(fn: () => {}): void;\n    setDisabledState(isDisabled: boolean): void;\n    _handleKeydown(event: KeyboardEvent): void;\n    _handleInput(event: KeyboardEvent): void;\n    _handleFocus(): void;\n    _handleClick(): void;\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @param shouldAnimate Whether the label should be animated when it is floated.\n     */\n    private _floatLabel;\n    /** If the label has been manually elevated, return it to its normal state. */\n    private _resetLabel;\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private _subscribeToClosingActions;\n    /** Destroys the autocomplete suggestion panel. */\n    private _destroyPanel;\n    private _assignOptionValue;\n    private _updateNativeInputValue;\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    private _setValueAndClose;\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     */\n    private _clearPreviousSelectedOption;\n    private _attachOverlay;\n    private _getOverlayConfig;\n    private _getOverlayPosition;\n    /** Sets the positions on a position strategy based on the directive's input state. */\n    private _setStrategyPositions;\n    private _getConnectedElement;\n    private _getPanelWidth;\n    /** Returns the width of the input element, so the panel width can match it. */\n    private _getHostWidth;\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     */\n    private _resetActiveItem;\n    /** Determines whether the panel can be opened. */\n    private _canOpen;\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    private _getWindow;\n    /** Scrolls to a particular option in the list. */\n    private _scrollToOption;\n    /** Handles keyboard events coming from the overlay panel. */\n    private _handleOverlayEvents;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatAutocompleteTriggerBase, [null, null, null, null, null, null, { optional: true; }, { optional: true; host: true; }, { optional: true; }, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatAutocompleteTriggerBase, never, never, { \"autocomplete\": \"matAutocomplete\"; \"position\": \"matAutocompletePosition\"; \"connectedTo\": \"matAutocompleteConnectedTo\"; \"autocompleteAttribute\": \"autocomplete\"; \"autocompleteDisabled\": \"matAutocompleteDisabled\"; }, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/autocomplete/testing/index.d.ts",
      "node_modules/@angular/material/autocomplete/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatOptgroupHarness } from '@angular/material/core/testing';\nimport { MatOptionHarness } from '@angular/material/core/testing';\nimport { OptgroupHarnessFilters } from '@angular/material/core/testing';\nimport { OptionHarnessFilters } from '@angular/material/core/testing';\n\n/** A set of criteria that can be used to filter a list of `MatAutocompleteHarness` instances. */\nexport declare interface AutocompleteHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose associated input element matches the given value. */\n    value?: string | RegExp;\n}\n\n/** Harness for interacting with a standard mat-autocomplete in tests. */\nexport declare class MatAutocompleteHarness extends _MatAutocompleteHarnessBase<typeof MatOptionHarness, MatOptionHarness, OptionHarnessFilters, typeof MatOptgroupHarness, MatOptgroupHarness, OptgroupHarnessFilters> {\n    protected _prefix: string;\n    protected _optionClass: typeof MatOptionHarness;\n    protected _optionGroupClass: typeof MatOptgroupHarness;\n    /** The selector for the host element of a `MatAutocomplete` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatAutocompleteHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which autocomplete instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: AutocompleteHarnessFilters): HarnessPredicate<MatAutocompleteHarness>;\n}\n\nexport declare abstract class _MatAutocompleteHarnessBase<OptionType extends ComponentHarnessConstructor<Option> & {\n    with: (options?: OptionFilters) => HarnessPredicate<Option>;\n}, Option extends ComponentHarness & {\n    click(): Promise<void>;\n}, OptionFilters extends BaseHarnessFilters, OptionGroupType extends ComponentHarnessConstructor<OptionGroup> & {\n    with: (options?: OptionGroupFilters) => HarnessPredicate<OptionGroup>;\n}, OptionGroup extends ComponentHarness, OptionGroupFilters extends BaseHarnessFilters> extends ComponentHarness {\n    private _documentRootLocator;\n    protected abstract _prefix: string;\n    protected abstract _optionClass: OptionType;\n    protected abstract _optionGroupClass: OptionGroupType;\n    /** Gets the value of the autocomplete input. */\n    getValue(): Promise<string>;\n    /** Whether the autocomplete input is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Focuses the autocomplete input. */\n    focus(): Promise<void>;\n    /** Blurs the autocomplete input. */\n    blur(): Promise<void>;\n    /** Whether the autocomplete input is focused. */\n    isFocused(): Promise<boolean>;\n    /** Enters text into the autocomplete. */\n    enterText(value: string): Promise<void>;\n    /** Clears the input value. */\n    clear(): Promise<void>;\n    /** Gets the options inside the autocomplete panel. */\n    getOptions(filters?: Omit<OptionFilters, 'ancestor'>): Promise<Option[]>;\n    /** Gets the option groups inside the autocomplete panel. */\n    getOptionGroups(filters?: Omit<OptionGroupFilters, 'ancestor'>): Promise<OptionGroup[]>;\n    /** Selects the first option matching the given filters. */\n    selectOption(filters: OptionFilters): Promise<void>;\n    /** Whether the autocomplete is open. */\n    isOpen(): Promise<boolean>;\n    /** Gets the panel associated with this autocomplete trigger. */\n    private _getPanel;\n    /** Gets the selector that can be used to find the autocomplete trigger's panel. */\n    private _getPanelSelector;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/badge/index.d.ts",
      "node_modules/@angular/material/badge/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AriaDescriber } from '@angular/cdk/a11y';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisable } from '@angular/material/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/cdk/a11y';\nimport * as i3 from '@angular/material/core';\nimport { NgZone } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\n\ndeclare namespace i1 {\n    export {\n        MatBadgePosition,\n        MatBadgeSize,\n        MatBadge\n    }\n}\n\n/** Directive to display a text badge. */\nexport declare class MatBadge extends _MatBadgeBase implements OnInit, OnDestroy, CanDisable {\n    private _ngZone;\n    private _elementRef;\n    private _ariaDescriber;\n    private _renderer;\n    private _animationMode?;\n    /** The color of the badge. Can be `primary`, `accent`, or `warn`. */\n    get color(): ThemePalette;\n    set color(value: ThemePalette);\n    private _color;\n    /** Whether the badge should overlap its contents or not */\n    get overlap(): boolean;\n    set overlap(val: BooleanInput);\n    private _overlap;\n    /**\n     * Position the badge should reside.\n     * Accepts any combination of 'above'|'below' and 'before'|'after'\n     */\n    position: MatBadgePosition;\n    /** The content for the badge */\n    get content(): string | number | undefined | null;\n    set content(newContent: string | number | undefined | null);\n    private _content;\n    /** Message used to describe the decorated element via aria-describedby */\n    get description(): string;\n    set description(newDescription: string);\n    private _description;\n    /** Size of the badge. Can be 'small', 'medium', or 'large'. */\n    size: MatBadgeSize;\n    /** Whether the badge is hidden. */\n    get hidden(): boolean;\n    set hidden(val: BooleanInput);\n    private _hidden;\n    /** Unique id for the badge */\n    _id: number;\n    /** Visible badge element. */\n    private _badgeElement;\n    /** Whether the OnInit lifecycle hook has run yet */\n    private _isInitialized;\n    constructor(_ngZone: NgZone, _elementRef: ElementRef<HTMLElement>, _ariaDescriber: AriaDescriber, _renderer: Renderer2, _animationMode?: string | undefined);\n    /** Whether the badge is above the host or not */\n    isAbove(): boolean;\n    /** Whether the badge is after the host or not */\n    isAfter(): boolean;\n    /**\n     * Gets the element into which the badge's content is being rendered. Undefined if the element\n     * hasn't been created (e.g. if the badge doesn't have content).\n     */\n    getBadgeElement(): HTMLElement | undefined;\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Creates the badge element */\n    private _createBadgeElement;\n    /** Update the text content of the badge element in the DOM, creating the element if necessary. */\n    private _updateRenderedContent;\n    /** Updates the host element's aria description via AriaDescriber. */\n    private _updateHostAriaDescription;\n    /** Adds css theme class given the color to the component host */\n    private _setColor;\n    /** Clears any existing badges that might be left over from server-side rendering. */\n    private _clearExistingBadges;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatBadge, [null, null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatBadge, \"[matBadge]\", never, { \"disabled\": \"matBadgeDisabled\"; \"color\": \"matBadgeColor\"; \"overlap\": \"matBadgeOverlap\"; \"position\": \"matBadgePosition\"; \"content\": \"matBadge\"; \"description\": \"matBadgeDescription\"; \"size\": \"matBadgeSize\"; \"hidden\": \"matBadgeHidden\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatBadgeBase: _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (): {};\n};\n\nexport declare class MatBadgeModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatBadgeModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatBadgeModule, [typeof i1.MatBadge], [typeof i2.A11yModule, typeof i3.MatCommonModule], [typeof i1.MatBadge, typeof i3.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatBadgeModule>;\n}\n\n/** Allowed position options for matBadgePosition */\nexport declare type MatBadgePosition = 'above after' | 'above before' | 'below before' | 'below after' | 'before' | 'after' | 'above' | 'below';\n\n/** Allowed size options for matBadgeSize */\nexport declare type MatBadgeSize = 'small' | 'medium' | 'large';\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/badge/testing/index.d.ts",
      "node_modules/@angular/material/badge/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatBadgePosition } from '@angular/material/badge';\nimport { MatBadgeSize } from '@angular/material/badge';\n\nexport declare interface BadgeHarnessFilters extends BaseHarnessFilters {\n    text?: string | RegExp;\n}\n\n/** Harness for interacting with a standard Material badge in tests. */\nexport declare class MatBadgeHarness extends ComponentHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a badge with specific attributes.\n     * @param options Options for narrowing the search:\n     *   - `text` finds a badge host with a particular text.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: BadgeHarnessFilters): HarnessPredicate<MatBadgeHarness>;\n    private _badgeElement;\n    /** Gets a promise for the badge text. */\n    getText(): Promise<string>;\n    /** Gets whether the badge is overlapping the content. */\n    isOverlapping(): Promise<boolean>;\n    /** Gets the position of the badge. */\n    getPosition(): Promise<MatBadgePosition>;\n    /** Gets the size of the badge. */\n    getSize(): Promise<MatBadgeSize>;\n    /** Gets whether the badge is hidden. */\n    isHidden(): Promise<boolean>;\n    /** Gets whether the badge is disabled. */\n    isDisabled(): Promise<boolean>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/bottom-sheet/index.d.ts",
      "node_modules/@angular/material/bottom-sheet/index.d.ts"
    ],
    "content": "import { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { BreakpointObserver } from '@angular/cdk/layout';\nimport { CdkDialogContainer } from '@angular/cdk/dialog';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ComponentType } from '@angular/cdk/portal';\nimport { DialogConfig } from '@angular/cdk/dialog';\nimport { DialogRef } from '@angular/cdk/dialog';\nimport { Direction } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/cdk/dialog';\nimport * as i3 from '@angular/material/core';\nimport * as i4 from '@angular/cdk/portal';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { InteractivityChecker } from '@angular/cdk/a11y';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/** Options for where to set focus to automatically on dialog open */\nexport declare type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\ndeclare namespace i1 {\n    export {\n        MatBottomSheetContainer\n    }\n}\n\n/** Injection token that can be used to access the data that was passed in to a bottom sheet. */\nexport declare const MAT_BOTTOM_SHEET_DATA: InjectionToken<any>;\n\n/** Injection token that can be used to specify default bottom sheet options. */\nexport declare const MAT_BOTTOM_SHEET_DEFAULT_OPTIONS: InjectionToken<MatBottomSheetConfig<any>>;\n\n/**\n * Service to trigger Material Design bottom sheets.\n */\nexport declare class MatBottomSheet implements OnDestroy {\n    private _overlay;\n    private _parentBottomSheet;\n    private _defaultOptions?;\n    private _bottomSheetRefAtThisLevel;\n    private _dialog;\n    /** Reference to the currently opened bottom sheet. */\n    get _openedBottomSheetRef(): MatBottomSheetRef<any> | null;\n    set _openedBottomSheetRef(value: MatBottomSheetRef<any> | null);\n    constructor(_overlay: Overlay, injector: Injector, _parentBottomSheet: MatBottomSheet, _defaultOptions?: MatBottomSheetConfig<any> | undefined);\n    /**\n     * Opens a bottom sheet containing the given component.\n     * @param component Type of the component to load into the bottom sheet.\n     * @param config Extra configuration options.\n     * @returns Reference to the newly-opened bottom sheet.\n     */\n    open<T, D = any, R = any>(component: ComponentType<T>, config?: MatBottomSheetConfig<D>): MatBottomSheetRef<T, R>;\n    /**\n     * Opens a bottom sheet containing the given template.\n     * @param template TemplateRef to instantiate as the bottom sheet content.\n     * @param config Extra configuration options.\n     * @returns Reference to the newly-opened bottom sheet.\n     */\n    open<T, D = any, R = any>(template: TemplateRef<T>, config?: MatBottomSheetConfig<D>): MatBottomSheetRef<T, R>;\n    /**\n     * Dismisses the currently-visible bottom sheet.\n     * @param result Data to pass to the bottom sheet instance.\n     */\n    dismiss<R = any>(result?: R): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatBottomSheet, [null, null, { optional: true; skipSelf: true; }, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatBottomSheet>;\n}\n\n/** Animations used by the Material bottom sheet. */\nexport declare const matBottomSheetAnimations: {\n    readonly bottomSheetState: AnimationTriggerMetadata;\n};\n\n/**\n * Configuration used when opening a bottom sheet.\n */\nexport declare class MatBottomSheetConfig<D = any> {\n    /** The view container to place the overlay for the bottom sheet into. */\n    viewContainerRef?: ViewContainerRef;\n    /** Extra CSS classes to be added to the bottom sheet container. */\n    panelClass?: string | string[];\n    /** Text layout direction for the bottom sheet. */\n    direction?: Direction;\n    /** Data being injected into the child component. */\n    data?: D | null;\n    /** Whether the bottom sheet has a backdrop. */\n    hasBackdrop?: boolean;\n    /** Custom class for the backdrop. */\n    backdropClass?: string;\n    /** Whether the user can use escape or clicking outside to close the bottom sheet. */\n    disableClose?: boolean;\n    /** Aria label to assign to the bottom sheet element. */\n    ariaLabel?: string | null;\n    /** Whether this is a modal bottom sheet. Used to set the `aria-modal` attribute. */\n    ariaModal?: boolean;\n    /**\n     * Whether the bottom sheet should close when the user goes backwards/forwards in history.\n     * Note that this usually doesn't include clicking on links (unless the user is using\n     * the `HashLocationStrategy`).\n     */\n    closeOnNavigation?: boolean;\n    /**\n     * Where the bottom sheet should focus on open.\n     * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n     * AutoFocusTarget instead.\n     */\n    autoFocus?: AutoFocusTarget | string | boolean;\n    /**\n     * Whether the bottom sheet should restore focus to the\n     * previously-focused element, after it's closed.\n     */\n    restoreFocus?: boolean;\n    /** Scroll strategy to be used for the bottom sheet. */\n    scrollStrategy?: ScrollStrategy;\n}\n\n/**\n * Internal component that wraps user-provided bottom sheet content.\n * @docs-private\n */\nexport declare class MatBottomSheetContainer extends CdkDialogContainer implements OnDestroy {\n    private _changeDetectorRef;\n    private _breakpointSubscription;\n    /** The state of the bottom sheet animations. */\n    _animationState: 'void' | 'visible' | 'hidden';\n    /** Emits whenever the state of the animation changes. */\n    _animationStateChanged: EventEmitter<AnimationEvent_2>;\n    /** Whether the component has been destroyed. */\n    private _destroyed;\n    constructor(elementRef: ElementRef, focusTrapFactory: FocusTrapFactory, document: any, config: DialogConfig, checker: InteractivityChecker, ngZone: NgZone, overlayRef: OverlayRef, breakpointObserver: BreakpointObserver, _changeDetectorRef: ChangeDetectorRef, focusMonitor?: FocusMonitor);\n    /** Begin animation of bottom sheet entrance into view. */\n    enter(): void;\n    /** Begin animation of the bottom sheet exiting from view. */\n    exit(): void;\n    ngOnDestroy(): void;\n    _onAnimationDone(event: AnimationEvent_2): void;\n    _onAnimationStart(event: AnimationEvent_2): void;\n    protected _captureInitialFocus(): void;\n    private _toggleClass;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatBottomSheetContainer, [null, null, { optional: true; }, null, null, null, null, null, null, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatBottomSheetContainer, \"mat-bottom-sheet-container\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatBottomSheetModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatBottomSheetModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatBottomSheetModule, [typeof i1.MatBottomSheetContainer], [typeof i2.DialogModule, typeof i3.MatCommonModule, typeof i4.PortalModule], [typeof i1.MatBottomSheetContainer, typeof i3.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatBottomSheetModule>;\n}\n\n/**\n * Reference to a bottom sheet dispatched from the bottom sheet service.\n */\nexport declare class MatBottomSheetRef<T = any, R = any> {\n    private _ref;\n    /** Instance of the component making up the content of the bottom sheet. */\n    get instance(): T;\n    /**\n     * Instance of the component into which the bottom sheet content is projected.\n     * @docs-private\n     */\n    containerInstance: MatBottomSheetContainer;\n    /** Whether the user is allowed to close the bottom sheet. */\n    disableClose: boolean | undefined;\n    /** Subject for notifying the user that the bottom sheet has opened and appeared. */\n    private readonly _afterOpened;\n    /** Result to be passed down to the `afterDismissed` stream. */\n    private _result;\n    /** Handle to the timeout that's running as a fallback in case the exit animation doesn't fire. */\n    private _closeFallbackTimeout;\n    constructor(_ref: DialogRef<R, T>, config: MatBottomSheetConfig, containerInstance: MatBottomSheetContainer);\n    /**\n     * Dismisses the bottom sheet.\n     * @param result Data to be passed back to the bottom sheet opener.\n     */\n    dismiss(result?: R): void;\n    /** Gets an observable that is notified when the bottom sheet is finished closing. */\n    afterDismissed(): Observable<R | undefined>;\n    /** Gets an observable that is notified when the bottom sheet has opened and appeared. */\n    afterOpened(): Observable<void>;\n    /**\n     * Gets an observable that emits when the overlay's backdrop has been clicked.\n     */\n    backdropClick(): Observable<MouseEvent>;\n    /**\n     * Gets an observable that emits when keydown events are targeted on the overlay.\n     */\n    keydownEvents(): Observable<KeyboardEvent>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/bottom-sheet/testing/index.d.ts",
      "node_modules/@angular/material/bottom-sheet/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\nexport declare interface BottomSheetHarnessFilters extends BaseHarnessFilters {\n}\n\n/** Harness for interacting with a standard MatBottomSheet in tests. */\nexport declare class MatBottomSheetHarness extends ContentContainerComponentHarness<string> {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a bottom sheet with\n     * specific attributes.\n     * @param options Options for narrowing the search.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: BottomSheetHarnessFilters): HarnessPredicate<MatBottomSheetHarness>;\n    /** Gets the value of the bottom sheet's \"aria-label\" attribute. */\n    getAriaLabel(): Promise<string | null>;\n    /**\n     * Dismisses the bottom sheet by pressing escape. Note that this method cannot\n     * be used if \"disableClose\" has been set to true via the config.\n     */\n    dismiss(): Promise<void>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/button-toggle/index.d.ts",
      "node_modules/@angular/material/button-toggle/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { QueryList } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        ToggleType,\n        MatButtonToggleAppearance,\n        MatButtonToggleDefaultOptions,\n        MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,\n        MAT_BUTTON_TOGGLE_GROUP,\n        MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,\n        MatButtonToggleChange,\n        MatButtonToggleGroup,\n        MatButtonToggle\n    }\n}\n\n/**\n * Injection token that can be used to configure the\n * default options for all button toggles within an app.\n */\nexport declare const MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS: InjectionToken<MatButtonToggleDefaultOptions>;\n\n/**\n * Injection token that can be used to reference instances of `MatButtonToggleGroup`.\n * It serves as alternative token to the actual `MatButtonToggleGroup` class which\n * could cause unnecessary retention of the class and its component metadata.\n */\nexport declare const MAT_BUTTON_TOGGLE_GROUP: InjectionToken<MatButtonToggleGroup>;\n\n/**\n * Provider Expression that allows mat-button-toggle-group to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nexport declare const MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR: any;\n\n/** Single button inside of a toggle group. */\nexport declare class MatButtonToggle extends _MatButtonToggleBase implements OnInit, AfterViewInit, CanDisableRipple, OnDestroy {\n    private _changeDetectorRef;\n    private _elementRef;\n    private _focusMonitor;\n    private _checked;\n    /**\n     * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n     * take precedence so this may be omitted.\n     */\n    ariaLabel: string;\n    /**\n     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n     */\n    ariaLabelledby: string | null;\n    /** Underlying native `button` element. */\n    _buttonElement: ElementRef<HTMLButtonElement>;\n    /** The parent button toggle group (exclusive selection). Optional. */\n    buttonToggleGroup: MatButtonToggleGroup;\n    /** Unique ID for the underlying `button` element. */\n    get buttonId(): string;\n    /** The unique ID for this button toggle. */\n    id: string;\n    /** HTML's 'name' attribute used to group radios for unique selection. */\n    name: string;\n    /** MatButtonToggleGroup reads this to assign its own value. */\n    value: any;\n    /** Tabindex for the toggle. */\n    tabIndex: number | null;\n    /** The appearance style of the button. */\n    get appearance(): MatButtonToggleAppearance;\n    set appearance(value: MatButtonToggleAppearance);\n    private _appearance;\n    /** Whether the button is checked. */\n    get checked(): boolean;\n    set checked(value: BooleanInput);\n    /** Whether the button is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Event emitted when the group value changes. */\n    readonly change: EventEmitter<MatButtonToggleChange>;\n    constructor(toggleGroup: MatButtonToggleGroup, _changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef<HTMLElement>, _focusMonitor: FocusMonitor, defaultTabIndex: string, defaultOptions?: MatButtonToggleDefaultOptions);\n    ngOnInit(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /** Focuses the button. */\n    focus(options?: FocusOptions): void;\n    /** Checks the button toggle due to an interaction with the underlying native button. */\n    _onButtonClick(): void;\n    /**\n     * Marks the button toggle as needing checking for change detection.\n     * This method is exposed because the parent button toggle group will directly\n     * update bound properties of the radio button.\n     */\n    _markForCheck(): void;\n    /** Gets the name that should be assigned to the inner DOM node. */\n    _getButtonName(): string | null;\n    /** Whether the toggle is in single selection mode. */\n    private _isSingleSelector;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatButtonToggle, [{ optional: true; }, null, null, null, { attribute: \"tabindex\"; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatButtonToggle, \"mat-button-toggle\", [\"matButtonToggle\"], { \"disableRipple\": \"disableRipple\"; \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"id\": \"id\"; \"name\": \"name\"; \"value\": \"value\"; \"tabIndex\": \"tabIndex\"; \"appearance\": \"appearance\"; \"checked\": \"checked\"; \"disabled\": \"disabled\"; }, { \"change\": \"change\"; }, never, [\"*\"], false>;\n}\n\n/** Possible appearance styles for the button toggle. */\nexport declare type MatButtonToggleAppearance = 'legacy' | 'standard';\n\n/** @docs-private */\ndeclare const _MatButtonToggleBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (): {};\n};\n\n/** Change event object emitted by MatButtonToggle. */\nexport declare class MatButtonToggleChange {\n    /** The MatButtonToggle that emits the event. */\n    source: MatButtonToggle;\n    /** The value assigned to the MatButtonToggle. */\n    value: any;\n    constructor(\n    /** The MatButtonToggle that emits the event. */\n    source: MatButtonToggle, \n    /** The value assigned to the MatButtonToggle. */\n    value: any);\n}\n\n/**\n * Represents the default options for the button toggle that can be configured\n * using the `MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS` injection token.\n */\nexport declare interface MatButtonToggleDefaultOptions {\n    /**\n     * Default appearance to be used by button toggles. Can be overridden by explicitly\n     * setting an appearance on a button toggle or group.\n     */\n    appearance?: MatButtonToggleAppearance;\n}\n\n/** Exclusive selection button toggle group that behaves like a radio-button group. */\nexport declare class MatButtonToggleGroup implements ControlValueAccessor, OnInit, AfterContentInit {\n    private _changeDetector;\n    private _vertical;\n    private _multiple;\n    private _disabled;\n    private _selectionModel;\n    /**\n     * Reference to the raw value that the consumer tried to assign. The real\n     * value will exclude any values from this one that don't correspond to a\n     * toggle. Useful for the cases where the value is assigned before the toggles\n     * have been initialized or at the same that they're being swapped out.\n     */\n    private _rawValue;\n    /**\n     * The method to be called in order to update ngModel.\n     * Now `ngModel` binding is not supported in multiple selection mode.\n     */\n    _controlValueAccessorChangeFn: (value: any) => void;\n    /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\n    _onTouched: () => any;\n    /** Child button toggle buttons. */\n    _buttonToggles: QueryList<MatButtonToggle>;\n    /** The appearance for all the buttons in the group. */\n    appearance: MatButtonToggleAppearance;\n    /** `name` attribute for the underlying `input` element. */\n    get name(): string;\n    set name(value: string);\n    private _name;\n    /** Whether the toggle group is vertical. */\n    get vertical(): boolean;\n    set vertical(value: BooleanInput);\n    /** Value of the toggle group. */\n    get value(): any;\n    set value(newValue: any);\n    /**\n     * Event that emits whenever the value of the group changes.\n     * Used to facilitate two-way data binding.\n     * @docs-private\n     */\n    readonly valueChange: EventEmitter<any>;\n    /** Selected button toggles in the group. */\n    get selected(): MatButtonToggle | MatButtonToggle[];\n    /** Whether multiple button toggles can be selected. */\n    get multiple(): boolean;\n    set multiple(value: BooleanInput);\n    /** Whether multiple button toggle group is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    /** Event emitted when the group's value changes. */\n    readonly change: EventEmitter<MatButtonToggleChange>;\n    constructor(_changeDetector: ChangeDetectorRef, defaultOptions?: MatButtonToggleDefaultOptions);\n    ngOnInit(): void;\n    ngAfterContentInit(): void;\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param value Value to be set to the model.\n     */\n    writeValue(value: any): void;\n    registerOnChange(fn: (value: any) => void): void;\n    registerOnTouched(fn: any): void;\n    setDisabledState(isDisabled: boolean): void;\n    /** Dispatch change event with current selection and group value. */\n    _emitChangeEvent(toggle: MatButtonToggle): void;\n    /**\n     * Syncs a button toggle's selected state with the model value.\n     * @param toggle Toggle to be synced.\n     * @param select Whether the toggle should be selected.\n     * @param isUserInput Whether the change was a result of a user interaction.\n     * @param deferEvents Whether to defer emitting the change events.\n     */\n    _syncButtonToggle(toggle: MatButtonToggle, select: boolean, isUserInput?: boolean, deferEvents?: boolean): void;\n    /** Checks whether a button toggle is selected. */\n    _isSelected(toggle: MatButtonToggle): boolean;\n    /** Determines whether a button toggle should be checked on init. */\n    _isPrechecked(toggle: MatButtonToggle): boolean;\n    /** Updates the selection state of the toggles in the group based on a value. */\n    private _setSelectionByValue;\n    /** Clears the selected toggles. */\n    private _clearSelection;\n    /** Selects a value if there's a toggle that corresponds to it. */\n    private _selectValue;\n    /** Syncs up the group's value with the model and emits the change event. */\n    private _updateModelValue;\n    /** Marks all of the child button toggles to be checked. */\n    private _markButtonsForCheck;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatButtonToggleGroup, [null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatButtonToggleGroup, \"mat-button-toggle-group\", [\"matButtonToggleGroup\"], { \"appearance\": \"appearance\"; \"name\": \"name\"; \"vertical\": \"vertical\"; \"value\": \"value\"; \"multiple\": \"multiple\"; \"disabled\": \"disabled\"; }, { \"valueChange\": \"valueChange\"; \"change\": \"change\"; }, [\"_buttonToggles\"], never, false>;\n}\n\nexport declare class MatButtonToggleModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatButtonToggleModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatButtonToggleModule, [typeof i1.MatButtonToggleGroup, typeof i1.MatButtonToggle], [typeof i2.MatCommonModule, typeof i2.MatRippleModule], [typeof i2.MatCommonModule, typeof i1.MatButtonToggleGroup, typeof i1.MatButtonToggle]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatButtonToggleModule>;\n}\n\n/**\n * @deprecated No longer used.\n * @breaking-change 11.0.0\n */\nexport declare type ToggleType = 'checkbox' | 'radio';\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/button-toggle/testing/index.d.ts",
      "node_modules/@angular/material/button-toggle/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatButtonToggleAppearance } from '@angular/material/button-toggle';\n\n/** Criteria that can be used to filter a list of `MatButtonToggleGroupHarness` instances. */\nexport declare interface ButtonToggleGroupHarnessFilters extends BaseHarnessFilters {\n}\n\n/** Criteria that can be used to filter a list of `MatButtonToggleHarness` instances. */\nexport declare interface ButtonToggleHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n    /** Only find instances whose name matches the given value. */\n    name?: string | RegExp;\n    /** Only find instances that are checked. */\n    checked?: boolean;\n}\n\n/** Harness for interacting with a standard mat-button-toggle in tests. */\nexport declare class MatButtonToggleGroupHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatButton` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatButtonToggleGroupHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which button toggle instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ButtonToggleGroupHarnessFilters): HarnessPredicate<MatButtonToggleGroupHarness>;\n    /**\n     * Gets the button toggles that are inside the group.\n     * @param filter Optionally filters which toggles are included.\n     */\n    getToggles(filter?: ButtonToggleHarnessFilters): Promise<MatButtonToggleHarness[]>;\n    /** Gets whether the button toggle group is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets whether the button toggle group is laid out vertically. */\n    isVertical(): Promise<boolean>;\n    /** Gets the appearance that the group is using. */\n    getAppearance(): Promise<MatButtonToggleAppearance>;\n}\n\n/** Harness for interacting with a standard mat-button-toggle in tests. */\nexport declare class MatButtonToggleHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatButton` instance. */\n    static hostSelector: string;\n    private _label;\n    private _button;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatButtonToggleHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which button toggle instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ButtonToggleHarnessFilters): HarnessPredicate<MatButtonToggleHarness>;\n    /** Gets a boolean promise indicating if the button toggle is checked. */\n    isChecked(): Promise<boolean>;\n    /** Gets a boolean promise indicating if the button toggle is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets a promise for the button toggle's name. */\n    getName(): Promise<string | null>;\n    /** Gets a promise for the button toggle's aria-label. */\n    getAriaLabel(): Promise<string | null>;\n    /** Gets a promise for the button toggles's aria-labelledby. */\n    getAriaLabelledby(): Promise<string | null>;\n    /** Gets a promise for the button toggle's text. */\n    getText(): Promise<string>;\n    /** Gets the appearance that the button toggle is using. */\n    getAppearance(): Promise<MatButtonToggleAppearance>;\n    /** Focuses the toggle. */\n    focus(): Promise<void>;\n    /** Blurs the toggle. */\n    blur(): Promise<void>;\n    /** Whether the toggle is focused. */\n    isFocused(): Promise<boolean>;\n    /** Toggle the checked state of the buttons toggle. */\n    toggle(): Promise<void>;\n    /**\n     * Puts the button toggle in a checked state by toggling it if it's\n     * currently unchecked, or doing nothing if it is already checked.\n     */\n    check(): Promise<void>;\n    /**\n     * Puts the button toggle in an unchecked state by toggling it if it's\n     * currently checked, or doing nothing if it's already unchecked.\n     */\n    uncheck(): Promise<void>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/button/index.d.ts",
      "node_modules/@angular/material/button/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewInit } from '@angular/core';\nimport { CanColor } from '@angular/material/core';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport { MatRipple } from '@angular/material/core';\nimport { NgZone } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        MatButton,\n        MatAnchor\n    }\n}\n\n/**\n * Material design anchor button.\n */\nexport declare class MatAnchor extends MatButton implements AfterViewInit, OnDestroy {\n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    private _ngZone?;\n    /** Tabindex of the button. */\n    tabIndex: number;\n    constructor(focusMonitor: FocusMonitor, elementRef: ElementRef, animationMode: string, \n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    _ngZone?: NgZone | undefined);\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    _haltDisabledEvents: (event: Event) => void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatAnchor, [null, null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatAnchor, \"a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]\", [\"matButton\", \"matAnchor\"], { \"disabled\": \"disabled\"; \"disableRipple\": \"disableRipple\"; \"color\": \"color\"; \"tabIndex\": \"tabIndex\"; }, {}, never, [\"*\"], false>;\n}\n\n/**\n * Material design button.\n */\nexport declare class MatButton extends _MatButtonBase implements AfterViewInit, OnDestroy, CanDisable, CanColor, CanDisableRipple, FocusableOption {\n    private _focusMonitor;\n    _animationMode: string;\n    /** Whether the button is round. */\n    readonly isRoundButton: boolean;\n    /** Whether the button is icon button. */\n    readonly isIconButton: boolean;\n    /** Reference to the MatRipple instance of the button. */\n    ripple: MatRipple;\n    constructor(elementRef: ElementRef, _focusMonitor: FocusMonitor, _animationMode: string);\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /** Focuses the button. */\n    focus(origin?: FocusOrigin, options?: FocusOptions): void;\n    _getHostElement(): any;\n    _isRippleDisabled(): boolean;\n    /** Gets whether the button has one of the given attributes. */\n    _hasHostAttributes(...attributes: string[]): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatButton, [null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatButton, \"button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]\", [\"matButton\"], { \"disabled\": \"disabled\"; \"disableRipple\": \"disableRipple\"; \"color\": \"color\"; }, {}, never, [\"*\"], false>;\n}\n\ndeclare const _MatButtonBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\nexport declare class MatButtonModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatButtonModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatButtonModule, [typeof i1.MatButton, typeof i1.MatAnchor], [typeof i2.MatRippleModule, typeof i2.MatCommonModule], [typeof i1.MatButton, typeof i1.MatAnchor, typeof i2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatButtonModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/button/testing/index.d.ts",
      "node_modules/@angular/material/button/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of `MatButtonHarness` instances. */\nexport declare interface ButtonHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n}\n\n/** Harness for interacting with a standard mat-button in tests. */\nexport declare class MatButtonHarness extends ContentContainerComponentHarness {\n    /** The selector for the host element of a `MatButton` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatButtonHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which button instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ButtonHarnessFilters): HarnessPredicate<MatButtonHarness>;\n    /**\n     * Clicks the button at the given position relative to its top-left.\n     * @param relativeX The relative x position of the click.\n     * @param relativeY The relative y position of the click.\n     */\n    click(relativeX: number, relativeY: number): Promise<void>;\n    /** Clicks the button at its center. */\n    click(location: 'center'): Promise<void>;\n    /** Clicks the button. */\n    click(): Promise<void>;\n    /** Whether the button is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets the button's label text. */\n    getText(): Promise<string>;\n    /** Focuses the button. */\n    focus(): Promise<void>;\n    /** Blurs the button. */\n    blur(): Promise<void>;\n    /** Whether the button is focused. */\n    isFocused(): Promise<boolean>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/card/index.d.ts",
      "node_modules/@angular/material/card/index.d.ts"
    ],
    "content": "import * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\n\ndeclare namespace i1 {\n    export {\n        MatCardContent,\n        MatCardTitle,\n        MatCardSubtitle,\n        MatCardActions,\n        MatCardFooter,\n        MatCardImage,\n        MatCardSmImage,\n        MatCardMdImage,\n        MatCardLgImage,\n        MatCardXlImage,\n        MatCardAvatar,\n        MatCard,\n        MatCardHeader,\n        MatCardTitleGroup\n    }\n}\n\n/**\n * A basic content container component that adds the styles of a Material design card.\n *\n * While this component can be used alone, it also provides a number\n * of preset styles for common card sections, including:\n * - mat-card-title\n * - mat-card-subtitle\n * - mat-card-content\n * - mat-card-actions\n * - mat-card-footer\n */\nexport declare class MatCard {\n    _animationMode?: string | undefined;\n    constructor(_animationMode?: string | undefined);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCard, [{ optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatCard, \"mat-card\", [\"matCard\"], {}, {}, never, [\"*\", \"mat-card-footer\"], false>;\n}\n\n/**\n * Action section of a card, needed as it's used as a selector in the API.\n * @docs-private\n */\nexport declare class MatCardActions {\n    /** Position of the actions inside the card. */\n    align: 'start' | 'end';\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardActions, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardActions, \"mat-card-actions\", [\"matCardActions\"], { \"align\": \"align\"; }, {}, never, never, false>;\n}\n\n/**\n * Avatar image used in a card, needed to add the mat- CSS styling.\n * @docs-private\n */\nexport declare class MatCardAvatar {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardAvatar, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardAvatar, \"[mat-card-avatar], [matCardAvatar]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Content of a card, needed as it's used as a selector in the API.\n * @docs-private\n */\nexport declare class MatCardContent {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardContent, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardContent, \"mat-card-content, [mat-card-content], [matCardContent]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Footer of a card, needed as it's used as a selector in the API.\n * @docs-private\n */\nexport declare class MatCardFooter {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardFooter, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardFooter, \"mat-card-footer\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Component intended to be used within the `<mat-card>` component. It adds styles for a\n * preset header section (i.e. a title, subtitle, and avatar layout).\n * @docs-private\n */\nexport declare class MatCardHeader {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardHeader, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatCardHeader, \"mat-card-header\", never, {}, {}, never, [\"[mat-card-avatar], [matCardAvatar]\", \"mat-card-title, mat-card-subtitle,\\n      [mat-card-title], [mat-card-subtitle],\\n      [matCardTitle], [matCardSubtitle]\", \"*\"], false>;\n}\n\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * @docs-private\n */\nexport declare class MatCardImage {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardImage, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardImage, \"[mat-card-image], [matCardImage]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * @docs-private\n */\nexport declare class MatCardLgImage {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardLgImage, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardLgImage, \"[mat-card-lg-image], [matCardImageLarge]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * @docs-private\n */\nexport declare class MatCardMdImage {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardMdImage, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardMdImage, \"[mat-card-md-image], [matCardImageMedium]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatCardModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatCardModule, [typeof i1.MatCard, typeof i1.MatCardHeader, typeof i1.MatCardTitleGroup, typeof i1.MatCardContent, typeof i1.MatCardTitle, typeof i1.MatCardSubtitle, typeof i1.MatCardActions, typeof i1.MatCardFooter, typeof i1.MatCardSmImage, typeof i1.MatCardMdImage, typeof i1.MatCardLgImage, typeof i1.MatCardImage, typeof i1.MatCardXlImage, typeof i1.MatCardAvatar], [typeof i2.MatCommonModule], [typeof i1.MatCard, typeof i1.MatCardHeader, typeof i1.MatCardTitleGroup, typeof i1.MatCardContent, typeof i1.MatCardTitle, typeof i1.MatCardSubtitle, typeof i1.MatCardActions, typeof i1.MatCardFooter, typeof i1.MatCardSmImage, typeof i1.MatCardMdImage, typeof i1.MatCardLgImage, typeof i1.MatCardImage, typeof i1.MatCardXlImage, typeof i1.MatCardAvatar, typeof i2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatCardModule>;\n}\n\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * @docs-private\n */\nexport declare class MatCardSmImage {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardSmImage, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardSmImage, \"[mat-card-sm-image], [matCardImageSmall]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Sub-title of a card, needed as it's used as a selector in the API.\n * @docs-private\n */\nexport declare class MatCardSubtitle {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardSubtitle, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardSubtitle, \"mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Title of a card, needed as it's used as a selector in the API.\n * @docs-private\n */\nexport declare class MatCardTitle {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardTitle, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardTitle, \"mat-card-title, [mat-card-title], [matCardTitle]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Component intended to be used within the `<mat-card>` component. It adds styles for a preset\n * layout that groups an image with a title section.\n * @docs-private\n */\nexport declare class MatCardTitleGroup {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardTitleGroup, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatCardTitleGroup, \"mat-card-title-group\", never, {}, {}, never, [\"mat-card-title, mat-card-subtitle,\\n      [mat-card-title], [mat-card-subtitle],\\n      [matCardTitle], [matCardSubtitle]\", \"img\", \"*\"], false>;\n}\n\n/**\n * Large image used in a card, needed to add the mat- CSS styling.\n * @docs-private\n */\nexport declare class MatCardXlImage {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCardXlImage, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCardXlImage, \"[mat-card-xl-image], [matCardImageXLarge]\", never, {}, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/card/testing/index.d.ts",
      "node_modules/@angular/material/card/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of `MatCardHarness` instances. */\nexport declare interface CardHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n    /** Only find instances whose title matches the given value. */\n    title?: string | RegExp;\n    /** Only find instances whose subtitle matches the given value. */\n    subtitle?: string | RegExp;\n}\n\n/** Harness for interacting with a standard mat-card in tests. */\nexport declare class MatCardHarness extends ContentContainerComponentHarness<MatCardSection> {\n    /** The selector for the host element of a `MatCard` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatCardHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which card instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: CardHarnessFilters): HarnessPredicate<MatCardHarness>;\n    private _title;\n    private _subtitle;\n    /** Gets all of the card's content as text. */\n    getText(): Promise<string>;\n    /** Gets the cards's title text. */\n    getTitleText(): Promise<string>;\n    /** Gets the cards's subtitle text. */\n    getSubtitleText(): Promise<string>;\n}\n\n/** Selectors for different sections of the mat-card that can container user content. */\nexport declare const enum MatCardSection {\n    HEADER = \".mat-card-header\",\n    CONTENT = \".mat-card-content\",\n    ACTIONS = \".mat-card-actions\",\n    FOOTER = \".mat-card-footer\"\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/checkbox/index.d.ts",
      "node_modules/@angular/material/checkbox/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { CheckboxRequiredValidator } from '@angular/forms';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/material/core';\nimport * as i4 from '@angular/cdk/observers';\nimport { InjectionToken } from '@angular/core';\nimport { MatRipple } from '@angular/material/core';\nimport { NgZone } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { Provider } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\n\ndeclare namespace i1 {\n    export {\n        MAT_CHECKBOX_REQUIRED_VALIDATOR,\n        MatCheckboxRequiredValidator\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR,\n        TransitionCheckState,\n        MatCheckboxChange,\n        _MatCheckboxBase,\n        MatCheckbox\n    }\n}\n\n/**\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nexport declare const MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR: any;\n\n/** Injection token to be used to override the default options for `mat-checkbox`. */\nexport declare const MAT_CHECKBOX_DEFAULT_OPTIONS: InjectionToken<MatCheckboxDefaultOptions>;\n\n/** @docs-private */\nexport declare function MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY(): MatCheckboxDefaultOptions;\n\nexport declare const MAT_CHECKBOX_REQUIRED_VALIDATOR: Provider;\n\n/**\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\n * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\n * so there is no need to provide them yourself. However, if you want to omit a label and still\n * have the checkbox be accessible, you may supply an [aria-label] input.\n * See: https://material.io/design/components/selection-controls.html\n */\nexport declare class MatCheckbox extends _MatCheckboxBase<MatCheckboxChange> implements AfterViewInit, OnDestroy {\n    private _focusMonitor;\n    protected _animationClasses: {\n        uncheckedToChecked: string;\n        uncheckedToIndeterminate: string;\n        checkedToUnchecked: string;\n        checkedToIndeterminate: string;\n        indeterminateToChecked: string;\n        indeterminateToUnchecked: string;\n    };\n    constructor(elementRef: ElementRef<HTMLElement>, changeDetectorRef: ChangeDetectorRef, _focusMonitor: FocusMonitor, ngZone: NgZone, tabIndex: string, animationMode?: string, options?: MatCheckboxDefaultOptions);\n    protected _createChangeEvent(isChecked: boolean): MatCheckboxChange;\n    protected _getAnimationTargetElement(): any;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Event handler for checkbox input element.\n     * Toggles checked state if element is not disabled.\n     * Do not toggle on (change) event since IE doesn't fire change event when\n     *   indeterminate checkbox is clicked.\n     * @param event\n     */\n    _onInputClick(event: Event): void;\n    /** Focuses the checkbox. */\n    focus(origin?: FocusOrigin, options?: FocusOptions): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCheckbox, [null, null, null, null, { attribute: \"tabindex\"; }, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatCheckbox, \"mat-checkbox\", [\"matCheckbox\"], { \"disableRipple\": \"disableRipple\"; \"color\": \"color\"; \"tabIndex\": \"tabIndex\"; }, {}, never, [\"*\"], false>;\n}\n\nexport declare abstract class _MatCheckboxBase<E> extends _MatCheckboxMixinBase implements AfterViewInit, ControlValueAccessor, CanColor, CanDisable, HasTabIndex, CanDisableRipple, FocusableOption {\n    protected _changeDetectorRef: ChangeDetectorRef;\n    protected _ngZone: NgZone;\n    _animationMode?: string | undefined;\n    protected _options?: MatCheckboxDefaultOptions | undefined;\n    /** Focuses the checkbox. */\n    abstract focus(origin?: FocusOrigin): void;\n    /** Creates the change event that will be emitted by the checkbox. */\n    protected abstract _createChangeEvent(isChecked: boolean): E;\n    /** Gets the element on which to add the animation CSS classes. */\n    protected abstract _getAnimationTargetElement(): HTMLElement | null;\n    /** CSS classes to add when transitioning between the different checkbox states. */\n    protected abstract _animationClasses: {\n        uncheckedToChecked: string;\n        uncheckedToIndeterminate: string;\n        checkedToUnchecked: string;\n        checkedToIndeterminate: string;\n        indeterminateToChecked: string;\n        indeterminateToUnchecked: string;\n    };\n    /**\n     * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n     * take precedence so this may be omitted.\n     */\n    ariaLabel: string;\n    /**\n     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n     */\n    ariaLabelledby: string | null;\n    /** The 'aria-describedby' attribute is read after the element's label and field type. */\n    ariaDescribedby: string;\n    private _uniqueId;\n    /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\n    id: string;\n    /** Returns the unique id for the visual hidden input. */\n    get inputId(): string;\n    /** Whether the checkbox is required. */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    private _required;\n    /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\n    labelPosition: 'before' | 'after';\n    /** Name value will be applied to the input element if present */\n    name: string | null;\n    /** Event emitted when the checkbox's `checked` value changes. */\n    readonly change: EventEmitter<E>;\n    /** Event emitted when the checkbox's `indeterminate` value changes. */\n    readonly indeterminateChange: EventEmitter<boolean>;\n    /** The value attribute of the native input element */\n    value: string;\n    /** The native `<input type=\"checkbox\">` element */\n    _inputElement: ElementRef<HTMLInputElement>;\n    /** The native `<label>` element */\n    _labelElement: ElementRef<HTMLInputElement>;\n    /** Reference to the ripple instance of the checkbox. */\n    ripple: MatRipple;\n    /**\n     * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n     * @docs-private\n     */\n    _onTouched: () => any;\n    private _currentAnimationClass;\n    private _currentCheckState;\n    private _controlValueAccessorChangeFn;\n    constructor(idPrefix: string, elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, _ngZone: NgZone, tabIndex: string, _animationMode?: string | undefined, _options?: MatCheckboxDefaultOptions | undefined);\n    ngAfterViewInit(): void;\n    /** Whether the checkbox is checked. */\n    get checked(): boolean;\n    set checked(value: BooleanInput);\n    private _checked;\n    /**\n     * Whether the checkbox is disabled. This fully overrides the implementation provided by\n     * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.\n     */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /**\n     * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n     * set to false.\n     */\n    get indeterminate(): boolean;\n    set indeterminate(value: BooleanInput);\n    private _indeterminate;\n    _isRippleDisabled(): boolean;\n    /** Method being called whenever the label text changes. */\n    _onLabelTextChange(): void;\n    writeValue(value: any): void;\n    registerOnChange(fn: (value: any) => void): void;\n    registerOnTouched(fn: any): void;\n    setDisabledState(isDisabled: boolean): void;\n    _getAriaChecked(): 'true' | 'false' | 'mixed';\n    private _transitionCheckState;\n    private _emitChangeEvent;\n    /** Toggles the `checked` state of the checkbox. */\n    toggle(): void;\n    protected _handleInputClick(): void;\n    _onInteractionEvent(event: Event): void;\n    _onBlur(): void;\n    private _getAnimationClassForCheckStateTransition;\n    /**\n     * Syncs the indeterminate value with the checkbox DOM node.\n     *\n     * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a\n     * property is supported on an element boils down to `if (propName in element)`. Domino's\n     * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during\n     * server-side rendering.\n     */\n    private _syncIndeterminate;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatCheckboxBase<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatCheckboxBase<any>, never, never, { \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"ariaDescribedby\": \"aria-describedby\"; \"id\": \"id\"; \"required\": \"required\"; \"labelPosition\": \"labelPosition\"; \"name\": \"name\"; \"value\": \"value\"; \"checked\": \"checked\"; \"disabled\": \"disabled\"; \"indeterminate\": \"indeterminate\"; }, { \"change\": \"change\"; \"indeterminateChange\": \"indeterminateChange\"; }, never, never, false>;\n}\n\n/** Change event object emitted by MatCheckbox. */\nexport declare class MatCheckboxChange {\n    /** The source MatCheckbox of the event. */\n    source: MatCheckbox;\n    /** The new `checked` value of the checkbox. */\n    checked: boolean;\n}\n\n/**\n * Checkbox click action when user click on input element.\n * noop: Do not toggle checked or indeterminate.\n * check: Only toggle checked status, ignore indeterminate.\n * check-indeterminate: Toggle checked status, set indeterminate to false. Default behavior.\n * undefined: Same as `check-indeterminate`.\n */\nexport declare type MatCheckboxClickAction = 'noop' | 'check' | 'check-indeterminate' | undefined;\n\n/** Default `mat-checkbox` options that can be overridden. */\nexport declare interface MatCheckboxDefaultOptions {\n    /** Default theme color palette to be used for checkboxes. */\n    color?: ThemePalette;\n    /** Default checkbox click action for checkboxes. */\n    clickAction?: MatCheckboxClickAction;\n}\n\n/** @docs-private */\ndeclare const _MatCheckboxMixinBase: _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & _Constructor<CanColor> & _AbstractConstructor<CanColor> & _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\nexport declare class MatCheckboxModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCheckboxModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatCheckboxModule, [typeof i2.MatCheckbox], [typeof i3.MatRippleModule, typeof i3.MatCommonModule, typeof i4.ObserversModule, typeof _MatCheckboxRequiredValidatorModule], [typeof i2.MatCheckbox, typeof i3.MatCommonModule, typeof _MatCheckboxRequiredValidatorModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatCheckboxModule>;\n}\n\n/**\n * Validator for Material checkbox's required attribute in template-driven checkbox.\n * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not\n * work with `mat-checkbox`.\n */\nexport declare class MatCheckboxRequiredValidator extends CheckboxRequiredValidator {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCheckboxRequiredValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCheckboxRequiredValidator, \"mat-checkbox[required][formControlName],             mat-checkbox[required][formControl], mat-checkbox[required][ngModel]\", never, {}, {}, never, never, false>;\n}\n\n/** This module is used by both original and MDC-based checkbox implementations. */\nexport declare class _MatCheckboxRequiredValidatorModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatCheckboxRequiredValidatorModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<_MatCheckboxRequiredValidatorModule, [typeof i1.MatCheckboxRequiredValidator], never, [typeof i1.MatCheckboxRequiredValidator]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<_MatCheckboxRequiredValidatorModule>;\n}\n\n/**\n * Represents the different states that require custom transitions between them.\n * @docs-private\n */\nexport declare const enum TransitionCheckState {\n    /** The initial state of the component before any user interaction. */\n    Init = 0,\n    /** The state representing the component when it's becoming checked. */\n    Checked = 1,\n    /** The state representing the component when it's becoming unchecked. */\n    Unchecked = 2,\n    /** The state representing the component when it's becoming indeterminate. */\n    Indeterminate = 3\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/checkbox/testing/index.d.ts",
      "node_modules/@angular/material/checkbox/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of `MatCheckboxHarness` instances. */\nexport declare interface CheckboxHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose label matches the given value. */\n    label?: string | RegExp;\n    /** Only find instances whose name attribute is the given value. */\n    name?: string;\n    /** Only find instances with the given checked value. */\n    checked?: boolean;\n}\n\n/** Harness for interacting with a standard mat-checkbox in tests. */\nexport declare class MatCheckboxHarness extends _MatCheckboxHarnessBase {\n    /** The selector for the host element of a `MatCheckbox` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatCheckboxHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which checkbox instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: CheckboxHarnessFilters): HarnessPredicate<MatCheckboxHarness>;\n    protected _input: AsyncFactoryFn<TestElement>;\n    protected _label: AsyncFactoryFn<TestElement>;\n    private _inputContainer;\n    toggle(): Promise<void>;\n}\n\nexport declare abstract class _MatCheckboxHarnessBase extends ComponentHarness {\n    protected abstract _input: AsyncFactoryFn<TestElement>;\n    protected abstract _label: AsyncFactoryFn<TestElement>;\n    /** Whether the checkbox is checked. */\n    isChecked(): Promise<boolean>;\n    /** Whether the checkbox is in an indeterminate state. */\n    isIndeterminate(): Promise<boolean>;\n    /** Whether the checkbox is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the checkbox is required. */\n    isRequired(): Promise<boolean>;\n    /** Whether the checkbox is valid. */\n    isValid(): Promise<boolean>;\n    /** Gets the checkbox's name. */\n    getName(): Promise<string | null>;\n    /** Gets the checkbox's value. */\n    getValue(): Promise<string | null>;\n    /** Gets the checkbox's aria-label. */\n    getAriaLabel(): Promise<string | null>;\n    /** Gets the checkbox's aria-labelledby. */\n    getAriaLabelledby(): Promise<string | null>;\n    /** Gets the checkbox's label text. */\n    getLabelText(): Promise<string>;\n    /** Focuses the checkbox. */\n    focus(): Promise<void>;\n    /** Blurs the checkbox. */\n    blur(): Promise<void>;\n    /** Whether the checkbox is focused. */\n    isFocused(): Promise<boolean>;\n    /**\n     * Toggles the checked state of the checkbox.\n     *\n     * Note: This attempts to toggle the checkbox as a user would, by clicking it. Therefore if you\n     * are using `MAT_CHECKBOX_DEFAULT_OPTIONS` to change the behavior on click, calling this method\n     * might not have the expected result.\n     */\n    abstract toggle(): Promise<void>;\n    /**\n     * Puts the checkbox in a checked state by toggling it if it is currently unchecked, or doing\n     * nothing if it is already checked.\n     *\n     * Note: This attempts to check the checkbox as a user would, by clicking it. Therefore if you\n     * are using `MAT_CHECKBOX_DEFAULT_OPTIONS` to change the behavior on click, calling this method\n     * might not have the expected result.\n     */\n    check(): Promise<void>;\n    /**\n     * Puts the checkbox in an unchecked state by toggling it if it is currently checked, or doing\n     * nothing if it is already unchecked.\n     *\n     * Note: This attempts to uncheck the checkbox as a user would, by clicking it. Therefore if you\n     * are using `MAT_CHECKBOX_DEFAULT_OPTIONS` to change the behavior on click, calling this method\n     * might not have the expected result.\n     */\n    uncheck(): Promise<void>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/chips/index.d.ts",
      "node_modules/@angular/material/chips/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { CanUpdateErrorState } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { ErrorStateMatcher } from '@angular/material/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { FormGroupDirective } from '@angular/forms';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i4 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { NgControl } from '@angular/forms';\nimport { NgForm } from '@angular/forms';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { RippleConfig } from '@angular/material/core';\nimport { RippleGlobalOptions } from '@angular/material/core';\nimport { RippleTarget } from '@angular/material/core';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { Subject } from 'rxjs';\n\ndeclare namespace i1 {\n    export {\n        MatChipListChange,\n        MatChipList\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatChipEvent,\n        MatChipSelectionChange,\n        MAT_CHIP_REMOVE,\n        MAT_CHIP_AVATAR,\n        MAT_CHIP_TRAILING_ICON,\n        MatChipAvatar,\n        MatChipTrailingIcon,\n        MatChip,\n        MatChipRemove\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MatChipInputEvent,\n        MatChipInput\n    }\n}\n\n/**\n * Injection token that can be used to reference instances of `MatChipAvatar`. It serves as\n * alternative token to the actual `MatChipAvatar` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_CHIP_AVATAR: InjectionToken<MatChipAvatar>;\n\n/**\n * Injection token that can be used to reference instances of `MatChipRemove`. It serves as\n * alternative token to the actual `MatChipRemove` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_CHIP_REMOVE: InjectionToken<MatChipRemove>;\n\n/**\n * Injection token that can be used to reference instances of `MatChipTrailingIcon`. It serves as\n * alternative token to the actual `MatChipTrailingIcon` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_CHIP_TRAILING_ICON: InjectionToken<MatChipTrailingIcon>;\n\n/** Injection token to be used to override the default options for the chips module. */\nexport declare const MAT_CHIPS_DEFAULT_OPTIONS: InjectionToken<MatChipsDefaultOptions>;\n\n/** Material Design styled chip directive. Used inside the MatChipList component. */\nexport declare class MatChip extends _MatChipMixinBase implements FocusableOption, OnDestroy, CanColor, CanDisableRipple, RippleTarget, HasTabIndex, CanDisable {\n    private _ngZone;\n    private _changeDetectorRef;\n    /** Reference to the RippleRenderer for the chip. */\n    private _chipRipple;\n    /**\n     * Reference to the element that acts as the chip's ripple target. This element is\n     * dynamically added as a child node of the chip. The chip itself cannot be used as the\n     * ripple target because it must be the host of the focus indicator.\n     */\n    private _chipRippleTarget;\n    /**\n     * Ripple configuration for ripples that are launched on pointer down. The ripple config\n     * is set to the global ripple options since we don't have any configurable options for\n     * the chip ripples.\n     * @docs-private\n     */\n    rippleConfig: RippleConfig & RippleGlobalOptions;\n    /**\n     * Whether ripples are disabled on interaction\n     * @docs-private\n     */\n    get rippleDisabled(): boolean;\n    /** Whether the chip has focus. */\n    _hasFocus: boolean;\n    /** Whether animations for the chip are enabled. */\n    _animationsDisabled: boolean;\n    /** Whether the chip list is selectable */\n    chipListSelectable: boolean;\n    /** Whether the chip list is in multi-selection mode. */\n    _chipListMultiple: boolean;\n    /** Whether the chip list as a whole is disabled. */\n    _chipListDisabled: boolean;\n    /** The chip avatar */\n    avatar: MatChipAvatar;\n    /** The chip's trailing icon. */\n    trailingIcon: MatChipTrailingIcon;\n    /** The chip's remove toggler. */\n    removeIcon: MatChipRemove;\n    /** ARIA role that should be applied to the chip. */\n    role: string;\n    /** Whether the chip is selected. */\n    get selected(): boolean;\n    set selected(value: BooleanInput);\n    protected _selected: boolean;\n    /** The value of the chip. Defaults to the content inside `<mat-chip>` tags. */\n    get value(): any;\n    set value(value: any);\n    protected _value: any;\n    /**\n     * Whether or not the chip is selectable. When a chip is not selectable,\n     * changes to its selected state are always ignored. By default a chip is\n     * selectable, and it becomes non-selectable if its parent chip list is\n     * not selectable.\n     */\n    get selectable(): boolean;\n    set selectable(value: BooleanInput);\n    protected _selectable: boolean;\n    /** Whether the chip is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    protected _disabled: boolean;\n    /**\n     * Determines whether or not the chip displays the remove styling and emits (removed) events.\n     */\n    get removable(): boolean;\n    set removable(value: BooleanInput);\n    protected _removable: boolean;\n    /** Emits when the chip is focused. */\n    readonly _onFocus: Subject<MatChipEvent>;\n    /** Emits when the chip is blurred. */\n    readonly _onBlur: Subject<MatChipEvent>;\n    /** Emitted when the chip is selected or deselected. */\n    readonly selectionChange: EventEmitter<MatChipSelectionChange>;\n    /** Emitted when the chip is destroyed. */\n    readonly destroyed: EventEmitter<MatChipEvent>;\n    /** Emitted when a chip is to be removed. */\n    readonly removed: EventEmitter<MatChipEvent>;\n    /** The ARIA selected applied to the chip. */\n    get ariaSelected(): string | null;\n    constructor(elementRef: ElementRef<HTMLElement>, _ngZone: NgZone, platform: Platform, globalRippleOptions: RippleGlobalOptions | null, _changeDetectorRef: ChangeDetectorRef, _document: any, animationMode?: string, tabIndex?: string);\n    _addHostClassName(): void;\n    ngOnDestroy(): void;\n    /** Selects the chip. */\n    select(): void;\n    /** Deselects the chip. */\n    deselect(): void;\n    /** Select this chip and emit selected event */\n    selectViaInteraction(): void;\n    /** Toggles the current selected state of this chip. */\n    toggleSelected(isUserInput?: boolean): boolean;\n    /** Allows for programmatic focusing of the chip. */\n    focus(): void;\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     */\n    remove(): void;\n    /** Handles click events on the chip. */\n    _handleClick(event: Event): void;\n    /** Handle custom key presses. */\n    _handleKeydown(event: KeyboardEvent): void;\n    _blur(): void;\n    private _dispatchSelectionChange;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatChip, [null, null, null, { optional: true; }, null, null, { optional: true; }, { attribute: \"tabindex\"; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatChip, \"mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\", [\"matChip\"], { \"color\": \"color\"; \"disableRipple\": \"disableRipple\"; \"tabIndex\": \"tabIndex\"; \"role\": \"role\"; \"selected\": \"selected\"; \"value\": \"value\"; \"selectable\": \"selectable\"; \"disabled\": \"disabled\"; \"removable\": \"removable\"; }, { \"selectionChange\": \"selectionChange\"; \"destroyed\": \"destroyed\"; \"removed\": \"removed\"; }, [\"avatar\", \"trailingIcon\", \"removeIcon\"], never, false>;\n}\n\n/**\n * Dummy directive to add CSS class to chip avatar.\n * @docs-private\n */\nexport declare class MatChipAvatar {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatChipAvatar, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatChipAvatar, \"mat-chip-avatar, [matChipAvatar]\", never, {}, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare abstract class MatChipBase {\n    _elementRef: ElementRef;\n    abstract disabled: boolean;\n    constructor(_elementRef: ElementRef);\n}\n\n/** Represents an event fired on an individual `mat-chip`. */\nexport declare interface MatChipEvent {\n    /** The chip the event was fired on. */\n    chip: MatChip;\n}\n\n/**\n * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n * May be placed inside or outside of an `<mat-chip-list>`.\n */\nexport declare class MatChipInput implements MatChipTextControl, OnChanges, OnDestroy, AfterContentInit {\n    protected _elementRef: ElementRef<HTMLInputElement>;\n    private _defaultOptions;\n    /** Used to prevent focus moving to chips while user is holding backspace */\n    private _focusLastChipOnBackspace;\n    /** Whether the control is focused. */\n    focused: boolean;\n    _chipList: MatChipList;\n    /** Register input for chip list */\n    set chipList(value: MatChipList);\n    /**\n     * Whether or not the chipEnd event will be emitted when the input is blurred.\n     */\n    get addOnBlur(): boolean;\n    set addOnBlur(value: BooleanInput);\n    _addOnBlur: boolean;\n    /**\n     * The list of key codes that will trigger a chipEnd event.\n     *\n     * Defaults to `[ENTER]`.\n     */\n    separatorKeyCodes: readonly number[] | ReadonlySet<number>;\n    /** Emitted when a chip is to be added. */\n    readonly chipEnd: EventEmitter<MatChipInputEvent>;\n    /** The input's placeholder text. */\n    placeholder: string;\n    /** Unique id for the input. */\n    id: string;\n    /** Whether the input is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Whether the input is empty. */\n    get empty(): boolean;\n    /** The native input element to which this directive is attached. */\n    readonly inputElement: HTMLInputElement;\n    constructor(_elementRef: ElementRef<HTMLInputElement>, _defaultOptions: MatChipsDefaultOptions);\n    ngOnChanges(): void;\n    ngOnDestroy(): void;\n    ngAfterContentInit(): void;\n    /** Utility method to make host definition/tests more clear. */\n    _keydown(event?: KeyboardEvent): void;\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     */\n    _keyup(event: KeyboardEvent): void;\n    /** Checks to see if the blur should emit the (chipEnd) event. */\n    _blur(): void;\n    _focus(): void;\n    /** Checks to see if the (chipEnd) event needs to be emitted. */\n    _emitChipEnd(event?: KeyboardEvent): void;\n    _onInput(): void;\n    /** Focuses the input. */\n    focus(options?: FocusOptions): void;\n    /** Clears the input */\n    clear(): void;\n    /** Checks whether a keycode is one of the configured separators. */\n    private _isSeparatorKey;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatChipInput, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatChipInput, \"input[matChipInputFor]\", [\"matChipInput\", \"matChipInputFor\"], { \"chipList\": \"matChipInputFor\"; \"addOnBlur\": \"matChipInputAddOnBlur\"; \"separatorKeyCodes\": \"matChipInputSeparatorKeyCodes\"; \"placeholder\": \"placeholder\"; \"id\": \"id\"; \"disabled\": \"disabled\"; }, { \"chipEnd\": \"matChipInputTokenEnd\"; }, never, never, false>;\n}\n\n/** Represents an input event on a `matChipInput`. */\nexport declare interface MatChipInputEvent {\n    /**\n     * The native `<input>` element that the event is being fired for.\n     * @deprecated Use `MatChipInputEvent#chipInput.inputElement` instead.\n     * @breaking-change 13.0.0 This property will be removed.\n     */\n    input: HTMLInputElement;\n    /** The value of the input. */\n    value: string;\n    /** Reference to the chip input that emitted the event. */\n    chipInput: MatChipInput;\n}\n\n/**\n * A material design chips component (named ChipList for its similarity to the List component).\n */\nexport declare class MatChipList extends _MatChipListBase implements MatFormFieldControl<any>, ControlValueAccessor, AfterContentInit, DoCheck, OnInit, OnDestroy, CanUpdateErrorState {\n    protected _elementRef: ElementRef<HTMLElement>;\n    private _changeDetectorRef;\n    private _dir;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    readonly controlType: string;\n    /**\n     * When a chip is destroyed, we store the index of the destroyed chip until the chips\n     * query list notifies about the update. This is necessary because we cannot determine an\n     * appropriate chip that should receive focus until the array of chips updated completely.\n     */\n    private _lastDestroyedChipIndex;\n    /** Subject that emits when the component has been destroyed. */\n    private readonly _destroyed;\n    /** Subscription to focus changes in the chips. */\n    private _chipFocusSubscription;\n    /** Subscription to blur changes in the chips. */\n    private _chipBlurSubscription;\n    /** Subscription to selection changes in chips. */\n    private _chipSelectionSubscription;\n    /** Subscription to remove changes in chips. */\n    private _chipRemoveSubscription;\n    /** The chip input to add more chips */\n    protected _chipInput: MatChipTextControl;\n    /** Uid of the chip list */\n    _uid: string;\n    /** Tab index for the chip list. */\n    _tabIndex: number;\n    /**\n     * User defined tab index.\n     * When it is not null, use user defined tab index. Otherwise use _tabIndex\n     */\n    _userTabIndex: number | null;\n    /** The FocusKeyManager which handles focus. */\n    _keyManager: FocusKeyManager<MatChip>;\n    /** Function when touched */\n    _onTouched: () => void;\n    /** Function when changed */\n    _onChange: (value: any) => void;\n    _selectionModel: SelectionModel<MatChip>;\n    /** The array of selected chips inside chip list. */\n    get selected(): MatChip[] | MatChip;\n    /** The ARIA role applied to the chip list. */\n    get role(): string | null;\n    set role(role: string | null);\n    private _explicitRole?;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    userAriaDescribedBy: string;\n    /** An object used to control when error messages are shown. */\n    errorStateMatcher: ErrorStateMatcher;\n    /** Whether the user should be allowed to select multiple chips. */\n    get multiple(): boolean;\n    set multiple(value: BooleanInput);\n    private _multiple;\n    /**\n     * A function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     */\n    get compareWith(): (o1: any, o2: any) => boolean;\n    set compareWith(fn: (o1: any, o2: any) => boolean);\n    private _compareWith;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value(): any;\n    set value(value: any);\n    protected _value: any;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id(): string;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    protected _required: boolean | undefined;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get placeholder(): string;\n    set placeholder(value: string);\n    protected _placeholder: string;\n    /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n    get focused(): boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty(): boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat(): boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    protected _disabled: boolean;\n    /** Orientation of the chip list. */\n    ariaOrientation: 'horizontal' | 'vertical';\n    /**\n     * Whether or not this chip list is selectable. When a chip list is not selectable,\n     * the selected states for all the chips inside the chip list are always ignored.\n     */\n    get selectable(): boolean;\n    set selectable(value: BooleanInput);\n    protected _selectable: boolean;\n    set tabIndex(value: number);\n    /** Combined stream of all of the child chips' selection change events. */\n    get chipSelectionChanges(): Observable<MatChipSelectionChange>;\n    /** Combined stream of all of the child chips' focus change events. */\n    get chipFocusChanges(): Observable<MatChipEvent>;\n    /** Combined stream of all of the child chips' blur change events. */\n    get chipBlurChanges(): Observable<MatChipEvent>;\n    /** Combined stream of all of the child chips' remove change events. */\n    get chipRemoveChanges(): Observable<MatChipEvent>;\n    /** Event emitted when the selected chip list value has been changed by the user. */\n    readonly change: EventEmitter<MatChipListChange>;\n    /**\n     * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n     * to facilitate the two-way binding for the `value` input.\n     * @docs-private\n     */\n    readonly valueChange: EventEmitter<any>;\n    /** The chips contained within this chip list. */\n    chips: QueryList<MatChip>;\n    constructor(_elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, _dir: Directionality, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, _defaultErrorStateMatcher: ErrorStateMatcher, ngControl: NgControl);\n    ngAfterContentInit(): void;\n    ngOnInit(): void;\n    ngDoCheck(): void;\n    ngOnDestroy(): void;\n    /** Associates an HTML input element with this chip list. */\n    registerInput(inputElement: MatChipTextControl): void;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids: string[]): void;\n    writeValue(value: any): void;\n    registerOnChange(fn: (value: any) => void): void;\n    registerOnTouched(fn: () => void): void;\n    setDisabledState(isDisabled: boolean): void;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick(event: MouseEvent): void;\n    /**\n     * Focuses the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     */\n    focus(options?: FocusOptions): void;\n    /** Attempt to focus an input if we have one. */\n    _focusInput(options?: FocusOptions): void;\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     */\n    _keydown(event: KeyboardEvent): void;\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     */\n    protected _updateTabIndex(): void;\n    /**\n     * If the amount of chips changed, we need to update the\n     * key manager state and focus the next closest chip.\n     */\n    protected _updateFocusForDestroyedChips(): void;\n    /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param index The index to be checked.\n     * @returns True if the index is valid for our list of chips.\n     */\n    private _isValidIndex;\n    _setSelectionByValue(value: any, isUserInput?: boolean): void;\n    /**\n     * Finds and selects the chip based on its value.\n     * @returns Chip that has the corresponding value.\n     */\n    private _selectValue;\n    private _initializeSelection;\n    /**\n     * Deselects every chip in the list.\n     * @param skip Chip that should not be deselected.\n     */\n    private _clearSelection;\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     */\n    private _sortValues;\n    /** Emits change event to set the model value. */\n    private _propagateChanges;\n    /** When blurred, mark the field as touched when focus moved outside the chip list. */\n    _blur(): void;\n    /** Mark the field as touched */\n    _markAsTouched(): void;\n    /**\n     * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the\n     * user to tab out of it. This prevents the list from capturing focus and redirecting\n     * it back to the first chip, creating a focus trap, if it user tries to tab away.\n     */\n    _allowFocusEscape(): void;\n    private _resetChips;\n    private _dropSubscriptions;\n    /** Listens to user-generated selection events on each chip. */\n    private _listenToChipsSelection;\n    /** Listens to user-generated selection events on each chip. */\n    private _listenToChipsFocus;\n    private _listenToChipsRemoved;\n    /** Checks whether an event comes from inside a chip element. */\n    private _originatesFromChip;\n    /** Checks whether any of the chips is focused. */\n    private _hasFocusedChip;\n    /** Syncs the list's state with the individual chips. */\n    private _syncChipsState;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatChipList, [null, null, { optional: true; }, { optional: true; }, { optional: true; }, null, { optional: true; self: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatChipList, \"mat-chip-list\", [\"matChipList\"], { \"role\": \"role\"; \"userAriaDescribedBy\": \"aria-describedby\"; \"errorStateMatcher\": \"errorStateMatcher\"; \"multiple\": \"multiple\"; \"compareWith\": \"compareWith\"; \"value\": \"value\"; \"required\": \"required\"; \"placeholder\": \"placeholder\"; \"disabled\": \"disabled\"; \"ariaOrientation\": \"aria-orientation\"; \"selectable\": \"selectable\"; \"tabIndex\": \"tabIndex\"; }, { \"change\": \"change\"; \"valueChange\": \"valueChange\"; }, [\"chips\"], [\"*\"], false>;\n}\n\n/** @docs-private */\ndeclare const _MatChipListBase: _Constructor<CanUpdateErrorState> & _AbstractConstructor<CanUpdateErrorState> & {\n    new (_defaultErrorStateMatcher: ErrorStateMatcher, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, ngControl: NgControl): {\n        /**\n         * Emits whenever the component state changes and should cause the parent\n         * form-field to update. Implemented as part of `MatFormFieldControl`.\n         * @docs-private\n         */\n        readonly stateChanges: Subject<void>;\n        _defaultErrorStateMatcher: ErrorStateMatcher;\n        _parentForm: NgForm;\n        _parentFormGroup: FormGroupDirective;\n        /**\n         * Form control bound to the component.\n         * Implemented as part of `MatFormFieldControl`.\n         * @docs-private\n         */\n        ngControl: NgControl;\n    };\n};\n\n/** Change event object that is emitted when the chip list value has changed. */\nexport declare class MatChipListChange {\n    /** Chip list that emitted the event. */\n    source: MatChipList;\n    /** Value of the chip list when the event was emitted. */\n    value: any;\n    constructor(\n    /** Chip list that emitted the event. */\n    source: MatChipList, \n    /** Value of the chip list when the event was emitted. */\n    value: any);\n}\n\ndeclare const _MatChipMixinBase: _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & _Constructor<CanColor> & _AbstractConstructor<CanColor> & _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & typeof MatChipBase;\n\n/**\n * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n *     `<mat-chip>\n *       <mat-icon matChipRemove>cancel</mat-icon>\n *     </mat-chip>`\n *\n * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n * styles to properly center the icon within the chip.\n */\nexport declare class MatChipRemove {\n    protected _parentChip: MatChip;\n    constructor(_parentChip: MatChip, elementRef: ElementRef<HTMLElement>);\n    /** Calls the parent chip's public `remove()` method if applicable. */\n    _handleClick(event: Event): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatChipRemove, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatChipRemove, \"[matChipRemove]\", never, {}, {}, never, never, false>;\n}\n\n/** Default options, for the chips module, that can be overridden. */\nexport declare interface MatChipsDefaultOptions {\n    /** The list of key codes that will trigger a chipEnd event. */\n    separatorKeyCodes: readonly number[] | ReadonlySet<number>;\n}\n\n/** Event object emitted by MatChip when selected or deselected. */\nexport declare class MatChipSelectionChange {\n    /** Reference to the chip that emitted the event. */\n    source: MatChip;\n    /** Whether the chip that emitted the event is selected. */\n    selected: boolean;\n    /** Whether the selection change was a result of a user interaction. */\n    isUserInput: boolean;\n    constructor(\n    /** Reference to the chip that emitted the event. */\n    source: MatChip, \n    /** Whether the chip that emitted the event is selected. */\n    selected: boolean, \n    /** Whether the selection change was a result of a user interaction. */\n    isUserInput?: boolean);\n}\n\nexport declare class MatChipsModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatChipsModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatChipsModule, [typeof i1.MatChipList, typeof i2.MatChip, typeof i3.MatChipInput, typeof i2.MatChipRemove, typeof i2.MatChipAvatar, typeof i2.MatChipTrailingIcon], [typeof i4.MatCommonModule], [typeof i1.MatChipList, typeof i2.MatChip, typeof i3.MatChipInput, typeof i2.MatChipRemove, typeof i2.MatChipAvatar, typeof i2.MatChipTrailingIcon]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatChipsModule>;\n}\n\n\n/** Interface for a text control that is used to drive interaction with a mat-chip-list. */\ndeclare interface MatChipTextControl {\n    /** Unique identifier for the text control. */\n    id: string;\n    /** The text control's placeholder text. */\n    placeholder: string;\n    /** Whether the text control has browser focus. */\n    focused: boolean;\n    /** Whether the text control is empty. */\n    empty: boolean;\n    /** Focuses the text control. */\n    focus(options?: FocusOptions): void;\n}\n\n/**\n * Dummy directive to add CSS class to chip trailing icon.\n * @docs-private\n */\nexport declare class MatChipTrailingIcon {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatChipTrailingIcon, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatChipTrailingIcon, \"mat-chip-trailing-icon, [matChipTrailingIcon]\", never, {}, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/chips/testing/index.d.ts",
      "node_modules/@angular/material/chips/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { TestKey } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of `MatChipAvatarHarness` instances. */\nexport declare interface ChipAvatarHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of chip instances. */\nexport declare interface ChipHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n    /**\n     * Only find chip instances whose selected state matches the given value.\n     * @deprecated Use `MatChipOptionHarness` together with `ChipOptionHarnessFilters`.\n     * @breaking-change 12.0.0\n     */\n    selected?: boolean;\n}\n\n/** A set of criteria that can be used to filter a list of `MatChipListInputHarness` instances. */\nexport declare interface ChipInputHarnessFilters extends BaseHarnessFilters {\n    /** Filters based on the value of the input. */\n    value?: string | RegExp;\n    /** Filters based on the placeholder text of the input. */\n    placeholder?: string | RegExp;\n}\n\n/** A set of criteria that can be used to filter selectable chip list instances. */\nexport declare interface ChipListboxHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter chip list instances. */\nexport declare interface ChipListHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of selectable chip instances. */\nexport declare interface ChipOptionHarnessFilters extends ChipHarnessFilters {\n    /** Only find chip instances whose selected state matches the given value. */\n    selected?: boolean;\n}\n\n/** A set of criteria that can be used to filter a list of `MatChipRemoveHarness` instances. */\nexport declare interface ChipRemoveHarnessFilters extends BaseHarnessFilters {\n}\n\n/** Harness for interacting with a standard Material chip avatar in tests. */\ndeclare class MatChipAvatarHarness extends ComponentHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatChipAvatarHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ChipAvatarHarnessFilters): HarnessPredicate<MatChipAvatarHarness>;\n}\n\n/** Harness for interacting with a standard selectable Angular Material chip in tests. */\nexport declare class MatChipHarness extends ContentContainerComponentHarness {\n    /** The selector for the host element of a `MatChip` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatChipHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which chip instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ChipHarnessFilters): HarnessPredicate<MatChipHarness>;\n    /** Gets the text of the chip. */\n    getText(): Promise<string>;\n    /**\n     * Whether the chip is selected.\n     * @deprecated Use `MatChipOptionHarness.isSelected` instead.\n     * @breaking-change 12.0.0\n     */\n    isSelected(): Promise<boolean>;\n    /** Whether the chip is disabled. */\n    isDisabled(): Promise<boolean>;\n    /**\n     * Selects the given chip. Only applies if it's selectable.\n     * @deprecated Use `MatChipOptionHarness.select` instead.\n     * @breaking-change 12.0.0\n     */\n    select(): Promise<void>;\n    /**\n     * Deselects the given chip. Only applies if it's selectable.\n     * @deprecated Use `MatChipOptionHarness.deselect` instead.\n     * @breaking-change 12.0.0\n     */\n    deselect(): Promise<void>;\n    /**\n     * Toggles the selected state of the given chip. Only applies if it's selectable.\n     * @deprecated Use `MatChipOptionHarness.toggle` instead.\n     * @breaking-change 12.0.0\n     */\n    toggle(): Promise<void>;\n    /** Removes the given chip. Only applies if it's removable. */\n    remove(): Promise<void>;\n    /**\n     * Gets the remove button inside of a chip.\n     * @param filter Optionally filters which remove buttons are included.\n     */\n    getRemoveButton(filter?: ChipRemoveHarnessFilters): Promise<MatChipRemoveHarness>;\n    /**\n     * Gets the avatar inside a chip.\n     * @param filter Optionally filters which avatars are included.\n     */\n    getAvatar(filter?: ChipAvatarHarnessFilters): Promise<MatChipAvatarHarness | null>;\n}\n\n/** Harness for interacting with a standard Material chip inputs in tests. */\nexport declare class MatChipInputHarness extends ComponentHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatChipInputHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ChipInputHarnessFilters): HarnessPredicate<MatChipInputHarness>;\n    /** Whether the input is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the input is required. */\n    isRequired(): Promise<boolean>;\n    /** Gets the value of the input. */\n    getValue(): Promise<string>;\n    /** Gets the placeholder of the input. */\n    getPlaceholder(): Promise<string>;\n    /**\n     * Focuses the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    focus(): Promise<void>;\n    /**\n     * Blurs the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    blur(): Promise<void>;\n    /** Whether the input is focused. */\n    isFocused(): Promise<boolean>;\n    /**\n     * Sets the value of the input. The value will be set by simulating\n     * keypresses that correspond to the given value.\n     */\n    setValue(newValue: string): Promise<void>;\n    /** Sends a chip separator key to the input element. */\n    sendSeparatorKey(key: TestKey | string): Promise<void>;\n}\n\n/** Harness for interacting with a standard selectable chip list in tests. */\nexport declare class MatChipListboxHarness extends _MatChipListHarnessBase {\n    /** The selector for the host element of a `MatChipList` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatChipListHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which chip list instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ChipListboxHarnessFilters): HarnessPredicate<MatChipListboxHarness>;\n    /**\n     * Gets the list of chips inside the chip list.\n     * @param filter Optionally filters which chips are included.\n     */\n    getChips(filter?: ChipOptionHarnessFilters): Promise<MatChipOptionHarness[]>;\n    /**\n     * Selects a chip inside the chip list.\n     * @param filter An optional filter to apply to the child chips.\n     *    All the chips matching the filter will be selected.\n     */\n    selectChips(filter?: ChipOptionHarnessFilters): Promise<void>;\n}\n\n/** Harness for interacting with a standard chip list in tests. */\nexport declare class MatChipListHarness extends _MatChipListHarnessBase {\n    /** The selector for the host element of a `MatChipList` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatChipListHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which chip list instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ChipListHarnessFilters): HarnessPredicate<MatChipListHarness>;\n    /**\n     * Gets the list of chips inside the chip list.\n     * @param filter Optionally filters which chips are included.\n     */\n    getChips(filter?: ChipHarnessFilters): Promise<MatChipHarness[]>;\n    /**\n     * Selects a chip inside the chip list.\n     * @param filter An optional filter to apply to the child chips.\n     *    All the chips matching the filter will be selected.\n     * @deprecated Use `MatChipListboxHarness.selectChips` instead.\n     * @breaking-change 12.0.0\n     */\n    selectChips(filter?: ChipHarnessFilters): Promise<void>;\n    /**\n     * Gets the `MatChipInput` inside the chip list.\n     * @param filter Optionally filters which chip input is included.\n     */\n    getInput(filter?: ChipInputHarnessFilters): Promise<MatChipInputHarness>;\n}\n\n/** Base class for chip list harnesses. */\ndeclare abstract class _MatChipListHarnessBase extends ComponentHarness {\n    /** Gets whether the chip list is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets whether the chip list is required. */\n    isRequired(): Promise<boolean>;\n    /** Gets whether the chip list is invalid. */\n    isInvalid(): Promise<boolean>;\n    /** Gets whether the chip list is in multi selection mode. */\n    isMultiple(): Promise<boolean>;\n    /** Gets whether the orientation of the chip list. */\n    getOrientation(): Promise<'horizontal' | 'vertical'>;\n}\n\nexport declare class MatChipOptionHarness extends MatChipHarness {\n    /** The selector for the host element of a selectable chip instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatChipOptionHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which chip instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ChipOptionHarnessFilters): HarnessPredicate<MatChipOptionHarness>;\n    /** Whether the chip is selected. */\n    isSelected(): Promise<boolean>;\n    /** Selects the given chip. Only applies if it's selectable. */\n    select(): Promise<void>;\n    /** Deselects the given chip. Only applies if it's selectable. */\n    deselect(): Promise<void>;\n    /** Toggles the selected state of the given chip. */\n    toggle(): Promise<void>;\n}\n\n/** Harness for interacting with a standard Material chip remove button in tests. */\nexport declare class MatChipRemoveHarness extends ComponentHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatChipRemoveHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ChipRemoveHarnessFilters): HarnessPredicate<MatChipRemoveHarness>;\n    /** Clicks the remove button. */\n    click(): Promise<void>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/core/index.d.ts",
      "node_modules/@angular/material/core/index.d.ts"
    ],
    "content": "import { _AbstractConstructor as _AbstractConstructor_2 } from '@angular/material/core';\nimport { AbstractControl } from '@angular/forms';\nimport { AfterViewChecked } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor as _Constructor_2 } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusOptions as FocusOptions_2 } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { FormGroupDirective } from '@angular/forms';\nimport { HighContrastModeDetector } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i1 from '@angular/cdk/bidi';\nimport * as i4 from '@angular/common';\nimport { InjectionToken } from '@angular/core';\nimport { NgControl } from '@angular/forms';\nimport { NgForm } from '@angular/forms';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { Version } from '@angular/core';\n\n/**\n * This is a permissive type for abstract class constructors.\n * @docs-private\n */\nexport declare type _AbstractConstructor<T = object> = abstract new (...args: any[]) => T;\n\n\n/** @docs-private */\nexport declare class AnimationCurves {\n    static STANDARD_CURVE: string;\n    static DECELERATION_CURVE: string;\n    static ACCELERATION_CURVE: string;\n    static SHARP_CURVE: string;\n}\n\n/** @docs-private */\nexport declare class AnimationDurations {\n    static COMPLEX: string;\n    static ENTERING: string;\n    static EXITING: string;\n}\n\n/** @docs-private */\nexport declare interface CanColor {\n    /** Theme color palette for the component. */\n    color: ThemePalette;\n    /** Default color to fall back to if no value is set. */\n    defaultColor: ThemePalette | undefined;\n}\n\ndeclare type CanColorCtor = _Constructor<CanColor> & _AbstractConstructor<CanColor>;\n\n/** @docs-private */\nexport declare interface CanDisable {\n    /** Whether the component is disabled. */\n    disabled: boolean;\n}\n\ndeclare type CanDisableCtor = _Constructor<CanDisable> & _AbstractConstructor<CanDisable>;\n\n/** @docs-private */\nexport declare interface CanDisableRipple {\n    /** Whether ripples are disabled. */\n    disableRipple: boolean;\n}\n\ndeclare type CanDisableRippleCtor = _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple>;\n\n/** @docs-private */\nexport declare interface CanUpdateErrorState {\n    /** Updates the error state based on the provided error state matcher. */\n    updateErrorState(): void;\n    /** Whether the component is in an error state. */\n    errorState: boolean;\n    /** An object used to control the error state of the component. */\n    errorStateMatcher: ErrorStateMatcher;\n}\n\ndeclare type CanUpdateErrorStateCtor = _Constructor<CanUpdateErrorState> & _AbstractConstructor<CanUpdateErrorState>;\n\n\n/** @docs-private */\nexport declare type _Constructor<T> = new (...args: any[]) => T;\n\n/**\n * Counts the amount of option group labels that precede the specified option.\n * @param optionIndex Index of the option at which to start counting.\n * @param options Flat list of all of the options.\n * @param optionGroups Flat list of all of the option groups.\n * @docs-private\n */\nexport declare function _countGroupLabelsBeforeOption(optionIndex: number, options: QueryList<MatOption>, optionGroups: QueryList<MatOptgroup>): number;\n\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\nexport declare abstract class DateAdapter<D, L = any> {\n    /** The locale to use for all dates. */\n    protected locale: L;\n    protected readonly _localeChanges: Subject<void>;\n    /** A stream that emits when the locale changes. */\n    readonly localeChanges: Observable<void>;\n    /**\n     * Gets the year component of the given date.\n     * @param date The date to extract the year from.\n     * @returns The year component.\n     */\n    abstract getYear(date: D): number;\n    /**\n     * Gets the month component of the given date.\n     * @param date The date to extract the month from.\n     * @returns The month component (0-indexed, 0 = January).\n     */\n    abstract getMonth(date: D): number;\n    /**\n     * Gets the date of the month component of the given date.\n     * @param date The date to extract the date of the month from.\n     * @returns The month component (1-indexed, 1 = first of month).\n     */\n    abstract getDate(date: D): number;\n    /**\n     * Gets the day of the week component of the given date.\n     * @param date The date to extract the day of the week from.\n     * @returns The month component (0-indexed, 0 = Sunday).\n     */\n    abstract getDayOfWeek(date: D): number;\n    /**\n     * Gets a list of names for the months.\n     * @param style The naming style (e.g. long = 'January', short = 'Jan', narrow = 'J').\n     * @returns An ordered list of all month names, starting with January.\n     */\n    abstract getMonthNames(style: 'long' | 'short' | 'narrow'): string[];\n    /**\n     * Gets a list of names for the dates of the month.\n     * @returns An ordered list of all date of the month names, starting with '1'.\n     */\n    abstract getDateNames(): string[];\n    /**\n     * Gets a list of names for the days of the week.\n     * @param style The naming style (e.g. long = 'Sunday', short = 'Sun', narrow = 'S').\n     * @returns An ordered list of all weekday names, starting with Sunday.\n     */\n    abstract getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];\n    /**\n     * Gets the name for the year of the given date.\n     * @param date The date to get the year name for.\n     * @returns The name of the given year (e.g. '2017').\n     */\n    abstract getYearName(date: D): string;\n    /**\n     * Gets the first day of the week.\n     * @returns The first day of the week (0-indexed, 0 = Sunday).\n     */\n    abstract getFirstDayOfWeek(): number;\n    /**\n     * Gets the number of days in the month of the given date.\n     * @param date The date whose month should be checked.\n     * @returns The number of days in the month of the given date.\n     */\n    abstract getNumDaysInMonth(date: D): number;\n    /**\n     * Clones the given date.\n     * @param date The date to clone\n     * @returns A new date equal to the given date.\n     */\n    abstract clone(date: D): D;\n    /**\n     * Creates a date with the given year, month, and date. Does not allow over/under-flow of the\n     * month and date.\n     * @param year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\n     * @param month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\n     * @param date The date of month of the date. Must be an integer 1 - length of the given month.\n     * @returns The new date, or null if invalid.\n     */\n    abstract createDate(year: number, month: number, date: number): D;\n    /**\n     * Gets today's date.\n     * @returns Today's date.\n     */\n    abstract today(): D;\n    /**\n     * Parses a date from a user-provided value.\n     * @param value The value to parse.\n     * @param parseFormat The expected format of the value being parsed\n     *     (type is implementation-dependent).\n     * @returns The parsed date.\n     */\n    abstract parse(value: any, parseFormat: any): D | null;\n    /**\n     * Formats a date as a string according to the given format.\n     * @param date The value to format.\n     * @param displayFormat The format to use to display the date as a string.\n     * @returns The formatted date string.\n     */\n    abstract format(date: D, displayFormat: any): string;\n    /**\n     * Adds the given number of years to the date. Years are counted as if flipping 12 pages on the\n     * calendar for each year and then finding the closest date in the new month. For example when\n     * adding 1 year to Feb 29, 2016, the resulting date will be Feb 28, 2017.\n     * @param date The date to add years to.\n     * @param years The number of years to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of years added.\n     */\n    abstract addCalendarYears(date: D, years: number): D;\n    /**\n     * Adds the given number of months to the date. Months are counted as if flipping a page on the\n     * calendar for each month and then finding the closest date in the new month. For example when\n     * adding 1 month to Jan 31, 2017, the resulting date will be Feb 28, 2017.\n     * @param date The date to add months to.\n     * @param months The number of months to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of months added.\n     */\n    abstract addCalendarMonths(date: D, months: number): D;\n    /**\n     * Adds the given number of days to the date. Days are counted as if moving one cell on the\n     * calendar for each day.\n     * @param date The date to add days to.\n     * @param days The number of days to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of days added.\n     */\n    abstract addCalendarDays(date: D, days: number): D;\n    /**\n     * Gets the RFC 3339 compatible string (https://tools.ietf.org/html/rfc3339) for the given date.\n     * This method is used to generate date strings that are compatible with native HTML attributes\n     * such as the `min` or `max` attribute of an `<input>`.\n     * @param date The date to get the ISO date string for.\n     * @returns The ISO date string date string.\n     */\n    abstract toIso8601(date: D): string;\n    /**\n     * Checks whether the given object is considered a date instance by this DateAdapter.\n     * @param obj The object to check\n     * @returns Whether the object is a date instance.\n     */\n    abstract isDateInstance(obj: any): boolean;\n    /**\n     * Checks whether the given date is valid.\n     * @param date The date to check.\n     * @returns Whether the date is valid.\n     */\n    abstract isValid(date: D): boolean;\n    /**\n     * Gets date instance that is not valid.\n     * @returns An invalid date.\n     */\n    abstract invalid(): D;\n    /**\n     * Given a potential date object, returns that same date object if it is\n     * a valid date, or `null` if it's not a valid date.\n     * @param obj The object to check.\n     * @returns A date or `null`.\n     */\n    getValidDateOrNull(obj: unknown): D | null;\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of its `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value: any): D | null;\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale: L): void;\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first: D, second: D): number;\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first: D | null, second: D | null): boolean;\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date: D, min?: D | null, max?: D | null): D;\n}\n\n/**\n * Default ripple animation configuration for ripples without an explicit\n * animation config specified.\n */\nexport declare const defaultRippleAnimationConfig: {\n    enterDuration: number;\n    exitDuration: number;\n};\n\n/** Provider that defines how form controls behave with regards to displaying error messages. */\nexport declare class ErrorStateMatcher {\n    isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ErrorStateMatcher, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ErrorStateMatcher>;\n}\n\n/**\n * Determines the position to which to scroll a panel in order for an option to be into view.\n * @param optionOffset Offset of the option from the top of the panel.\n * @param optionHeight Height of the options.\n * @param currentScrollPosition Current scroll position of the panel.\n * @param panelHeight Height of the panel.\n * @docs-private\n */\nexport declare function _getOptionScrollPosition(optionOffset: number, optionHeight: number, currentScrollPosition: number, panelHeight: number): number;\n\n/** Object that can be used to configure the sanity checks granularly. */\nexport declare interface GranularSanityChecks {\n    doctype: boolean;\n    theme: boolean;\n    version: boolean;\n}\n\n/** @docs-private */\ndeclare interface HasElementRef {\n    _elementRef: ElementRef;\n}\n\n/** @docs-private */\ndeclare interface HasErrorState {\n    _parentFormGroup: FormGroupDirective;\n    _parentForm: NgForm;\n    _defaultErrorStateMatcher: ErrorStateMatcher;\n    ngControl: NgControl;\n    stateChanges: Subject<void>;\n}\n\n/**\n * Mixin that adds an initialized property to a directive which, when subscribed to, will emit a\n * value once markInitialized has been called, which should be done during the ngOnInit function.\n * If the subscription is made after it has already been marked as initialized, then it will trigger\n * an emit immediately.\n * @docs-private\n */\nexport declare interface HasInitialized {\n    /** Stream that emits once during the directive/component's ngOnInit. */\n    initialized: Observable<void>;\n    /**\n     * Sets the state as initialized and must be called during ngOnInit to notify subscribers that\n     * the directive has been initialized.\n     * @docs-private\n     */\n    _markInitialized: () => void;\n}\n\ndeclare type HasInitializedCtor = _Constructor<HasInitialized>;\n\n/** @docs-private */\nexport declare interface HasTabIndex {\n    /** Tabindex of the component. */\n    tabIndex: number;\n    /** Tabindex to which to fall back to if no value is set. */\n    defaultTabIndex: number;\n}\n\ndeclare type HasTabIndexCtor = _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex>;\n\ndeclare namespace i1_2 {\n    export {\n        MATERIAL_SANITY_CHECKS_FACTORY,\n        MATERIAL_SANITY_CHECKS,\n        SanityChecks,\n        GranularSanityChecks,\n        MatCommonModule\n    }\n}\n\ndeclare namespace i1_3 {\n    export {\n        _countGroupLabelsBeforeOption,\n        _getOptionScrollPosition,\n        MatOptionSelectionChange,\n        _MatOptionBase,\n        MatOption\n    }\n}\n\ndeclare namespace i1_4 {\n    export {\n        RippleGlobalOptions,\n        MAT_RIPPLE_GLOBAL_OPTIONS,\n        MatRipple\n    }\n}\n\ndeclare namespace i1_5 {\n    export {\n        MatPseudoCheckboxState,\n        MatPseudoCheckbox\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        _MatOptgroupBase,\n        MAT_OPTGROUP,\n        MatOptgroup\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MatRippleModule,\n        RippleGlobalOptions,\n        MAT_RIPPLE_GLOBAL_OPTIONS,\n        MatRipple,\n        RippleState,\n        RippleConfig,\n        RippleAnimationConfig,\n        RippleRef,\n        RippleTarget,\n        defaultRippleAnimationConfig,\n        RippleRenderer\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        MatPseudoCheckboxModule\n    }\n}\n\nexport declare const MAT_DATE_FORMATS: InjectionToken<MatDateFormats>;\n\n/** InjectionToken for datepicker that can be used to override default locale code. */\nexport declare const MAT_DATE_LOCALE: InjectionToken<{}>;\n\n/** @docs-private */\nexport declare function MAT_DATE_LOCALE_FACTORY(): {};\n\nexport declare const MAT_NATIVE_DATE_FORMATS: MatDateFormats;\n\n/**\n * Injection token that can be used to reference instances of `MatOptgroup`. It serves as\n * alternative token to the actual `MatOptgroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport declare const MAT_OPTGROUP: InjectionToken<MatOptgroup>;\n\n/**\n * Injection token used to provide the parent component to options.\n */\nexport declare const MAT_OPTION_PARENT_COMPONENT: InjectionToken<MatOptionParentComponent>;\n\n/** Injection token that can be used to specify the global ripple options. */\nexport declare const MAT_RIPPLE_GLOBAL_OPTIONS: InjectionToken<RippleGlobalOptions>;\n\n/**\n * Module that captures anything that should be loaded and/or run for *all* Angular Material\n * components. This includes Bidi, etc.\n *\n * This module should be imported to each top-level component module (e.g., MatTabsModule).\n */\nexport declare class MatCommonModule {\n    private _sanityChecks;\n    private _document;\n    /** Whether we've done the global sanity checks (e.g. a theme is loaded, there is a doctype). */\n    private _hasDoneGlobalChecks;\n    constructor(highContrastModeDetector: HighContrastModeDetector, _sanityChecks: SanityChecks, _document: Document);\n    /** Gets whether a specific sanity check is enabled. */\n    private _checkIsEnabled;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCommonModule, [null, { optional: true; }, null]>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatCommonModule, never, [typeof i1.BidiModule], [typeof i1.BidiModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatCommonModule>;\n}\n\nexport declare type MatDateFormats = {\n    parse: {\n        dateInput: any;\n    };\n    display: {\n        dateInput: any;\n        monthLabel?: any;\n        monthYearLabel: any;\n        dateA11yLabel: any;\n        monthYearA11yLabel: any;\n    };\n};\n\n/** Injection token that configures whether the Material sanity checks are enabled. */\nexport declare const MATERIAL_SANITY_CHECKS: InjectionToken<SanityChecks>;\n\n/** @docs-private */\ndeclare function MATERIAL_SANITY_CHECKS_FACTORY(): SanityChecks;\n\n/**\n * Shared directive to count lines inside a text area, such as a list item.\n * Line elements can be extracted with a @ContentChildren(MatLine) query, then\n * counted by checking the query list's length.\n */\nexport declare class MatLine {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatLine, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatLine, \"[mat-line], [matLine]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatLineModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatLineModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatLineModule, [typeof MatLine], [typeof i1_2.MatCommonModule], [typeof MatLine, typeof i1_2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatLineModule>;\n}\n\nexport declare class MatNativeDateModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatNativeDateModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatNativeDateModule, never, [typeof NativeDateModule], never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatNativeDateModule>;\n}\n\n/**\n * Component that is used to group instances of `mat-option`.\n */\nexport declare class MatOptgroup extends _MatOptgroupBase {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatOptgroup, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatOptgroup, \"mat-optgroup\", [\"matOptgroup\"], { \"disabled\": \"disabled\"; }, {}, never, [\"*\", \"mat-option, ng-container\"], false>;\n}\n\nexport declare class _MatOptgroupBase extends _MatOptgroupMixinBase implements CanDisable {\n    /** Label for the option group. */\n    label: string;\n    /** Unique id for the underlying label. */\n    _labelId: string;\n    /** Whether the group is in inert a11y mode. */\n    _inert: boolean;\n    constructor(parent?: MatOptionParentComponent);\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatOptgroupBase, [{ optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatOptgroupBase, never, never, { \"label\": \"label\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatOptgroupMixinBase: _Constructor_2<CanDisable> & _AbstractConstructor_2<CanDisable> & {\n    new (): {};\n};\n\n/**\n * Single option inside of a `<mat-select>` element.\n */\nexport declare class MatOption<T = any> extends _MatOptionBase<T> {\n    constructor(element: ElementRef<HTMLElement>, changeDetectorRef: ChangeDetectorRef, parent: MatOptionParentComponent, group: MatOptgroup);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatOption<any>, [null, null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatOption<any>, \"mat-option\", [\"matOption\"], {}, {}, never, [\"*\"], false>;\n}\n\nexport declare class _MatOptionBase<T = any> implements FocusableOption, AfterViewChecked, OnDestroy {\n    private _element;\n    private _changeDetectorRef;\n    private _parent;\n    readonly group: _MatOptgroupBase;\n    private _selected;\n    private _active;\n    private _disabled;\n    private _mostRecentViewValue;\n    /** Whether the wrapping component is in multiple selection mode. */\n    get multiple(): boolean | undefined;\n    /** Whether or not the option is currently selected. */\n    get selected(): boolean;\n    /** The form value of the option. */\n    value: T;\n    /** The unique ID of the option. */\n    id: string;\n    /** Whether the option is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    /** Whether ripples for the option are disabled. */\n    get disableRipple(): boolean;\n    /** Event emitted when the option is selected or deselected. */\n    readonly onSelectionChange: EventEmitter<MatOptionSelectionChange<T>>;\n    /** Emits when the state of the option changes and any parents have to be notified. */\n    readonly _stateChanges: Subject<void>;\n    constructor(_element: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, _parent: MatOptionParentComponent, group: _MatOptgroupBase);\n    /**\n     * Whether or not the option is currently active and ready to be selected.\n     * An active option displays styles as if it is focused, but the\n     * focus is actually retained somewhere else. This comes in handy\n     * for components like autocomplete where focus must remain on the input.\n     */\n    get active(): boolean;\n    /**\n     * The displayed value of the option. It is necessary to show the selected option in the\n     * select's trigger.\n     */\n    get viewValue(): string;\n    /** Selects the option. */\n    select(): void;\n    /** Deselects the option. */\n    deselect(): void;\n    /** Sets focus onto this option. */\n    focus(_origin?: FocusOrigin, options?: FocusOptions_2): void;\n    /**\n     * This method sets display styles on the option to make it appear\n     * active. This is used by the ActiveDescendantKeyManager so key\n     * events will display the proper options as active on arrow key events.\n     */\n    setActiveStyles(): void;\n    /**\n     * This method removes display styles on the option that made it appear\n     * active. This is used by the ActiveDescendantKeyManager so key\n     * events will display the proper options as active on arrow key events.\n     */\n    setInactiveStyles(): void;\n    /** Gets the label to be used when determining whether the option should be focused. */\n    getLabel(): string;\n    /** Ensures the option is selected when activated from the keyboard. */\n    _handleKeydown(event: KeyboardEvent): void;\n    /**\n     * `Selects the option while indicating the selection came from the user. Used to\n     * determine if the select's view -> model callback should be invoked.`\n     */\n    _selectViaInteraction(): void;\n    /**\n     * Gets the `aria-selected` value for the option. We explicitly omit the `aria-selected`\n     * attribute from single-selection, unselected options. Including the `aria-selected=\"false\"`\n     * attributes adds a significant amount of noise to screen-reader users without providing useful\n     * information.\n     */\n    _getAriaSelected(): boolean | null;\n    /** Returns the correct tabindex for the option depending on disabled state. */\n    _getTabIndex(): string;\n    /** Gets the host DOM element. */\n    _getHostElement(): HTMLElement;\n    ngAfterViewChecked(): void;\n    ngOnDestroy(): void;\n    /** Emits the selection change event. */\n    private _emitSelectionChangeEvent;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatOptionBase<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatOptionBase<any>, never, never, { \"value\": \"value\"; \"id\": \"id\"; \"disabled\": \"disabled\"; }, { \"onSelectionChange\": \"onSelectionChange\"; }, never, never, false>;\n}\n\nexport declare class MatOptionModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatOptionModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatOptionModule, [typeof i1_3.MatOption, typeof i2.MatOptgroup], [typeof i3.MatRippleModule, typeof i4.CommonModule, typeof i1_2.MatCommonModule, typeof i6.MatPseudoCheckboxModule], [typeof i1_3.MatOption, typeof i2.MatOptgroup]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatOptionModule>;\n}\n\n/**\n * Describes a parent component that manages a list of options.\n * Contains properties that the options can inherit.\n * @docs-private\n */\nexport declare interface MatOptionParentComponent {\n    disableRipple?: boolean;\n    multiple?: boolean;\n    inertGroups?: boolean;\n}\n\n/** Event object emitted by MatOption when selected or deselected. */\nexport declare class MatOptionSelectionChange<T = any> {\n    /** Reference to the option that emitted the event. */\n    source: _MatOptionBase<T>;\n    /** Whether the change in the option's value was a result of a user action. */\n    isUserInput: boolean;\n    constructor(\n    /** Reference to the option that emitted the event. */\n    source: _MatOptionBase<T>, \n    /** Whether the change in the option's value was a result of a user action. */\n    isUserInput?: boolean);\n}\n\n/**\n * Component that shows a simplified checkbox without including any kind of \"real\" checkbox.\n * Meant to be used when the checkbox is purely decorative and a large number of them will be\n * included, such as for the options in a multi-select. Uses no SVGs or complex animations.\n * Note that theming is meant to be handled by the parent element, e.g.\n * `mat-primary .mat-pseudo-checkbox`.\n *\n * Note that this component will be completely invisible to screen-reader users. This is *not*\n * interchangeable with `<mat-checkbox>` and should *not* be used if the user would directly\n * interact with the checkbox. The pseudo-checkbox should only be used as an implementation detail\n * of more complex components that appropriately handle selected / checked state.\n * @docs-private\n */\nexport declare class MatPseudoCheckbox {\n    _animationMode?: string | undefined;\n    /** Display state of the checkbox. */\n    state: MatPseudoCheckboxState;\n    /** Whether the checkbox is disabled. */\n    disabled: boolean;\n    constructor(_animationMode?: string | undefined);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPseudoCheckbox, [{ optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatPseudoCheckbox, \"mat-pseudo-checkbox\", never, { \"state\": \"state\"; \"disabled\": \"disabled\"; }, {}, never, never, false>;\n}\n\nexport declare class MatPseudoCheckboxModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPseudoCheckboxModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatPseudoCheckboxModule, [typeof i1_5.MatPseudoCheckbox], [typeof i1_2.MatCommonModule], [typeof i1_5.MatPseudoCheckbox]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatPseudoCheckboxModule>;\n}\n\n/**\n * Possible states for a pseudo checkbox.\n * @docs-private\n */\nexport declare type MatPseudoCheckboxState = 'unchecked' | 'checked' | 'indeterminate';\n\nexport declare class MatRipple implements OnInit, OnDestroy, RippleTarget {\n    private _elementRef;\n    private _animationMode?;\n    /** Custom color for all ripples. */\n    color: string;\n    /** Whether the ripples should be visible outside the component's bounds. */\n    unbounded: boolean;\n    /**\n     * Whether the ripple always originates from the center of the host element's bounds, rather\n     * than originating from the location of the click event.\n     */\n    centered: boolean;\n    /**\n     * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\n     * will be the distance from the center of the ripple to the furthest corner of the host element's\n     * bounding rectangle.\n     */\n    radius: number;\n    /**\n     * Configuration for the ripple animation. Allows modifying the enter and exit animation\n     * duration of the ripples. The animation durations will be overwritten if the\n     * `NoopAnimationsModule` is being used.\n     */\n    animation: RippleAnimationConfig;\n    /**\n     * Whether click events will not trigger the ripple. Ripples can be still launched manually\n     * by using the `launch()` method.\n     */\n    get disabled(): boolean;\n    set disabled(value: boolean);\n    private _disabled;\n    /**\n     * The element that triggers the ripple when click events are received.\n     * Defaults to the directive's host element.\n     */\n    get trigger(): HTMLElement;\n    set trigger(trigger: HTMLElement);\n    private _trigger;\n    /** Renderer for the ripple DOM manipulations. */\n    private _rippleRenderer;\n    /** Options that are set globally for all ripples. */\n    private _globalOptions;\n    /** Whether ripple directive is initialized and the input bindings are set. */\n    private _isInitialized;\n    constructor(_elementRef: ElementRef<HTMLElement>, ngZone: NgZone, platform: Platform, globalOptions?: RippleGlobalOptions, _animationMode?: string | undefined);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Fades out all currently showing ripple elements. */\n    fadeOutAll(): void;\n    /** Fades out all currently showing non-persistent ripple elements. */\n    fadeOutAllNonPersistent(): void;\n    /**\n     * Ripple configuration from the directive's input values.\n     * @docs-private Implemented as part of RippleTarget\n     */\n    get rippleConfig(): RippleConfig;\n    /**\n     * Whether ripples on pointer-down are disabled or not.\n     * @docs-private Implemented as part of RippleTarget\n     */\n    get rippleDisabled(): boolean;\n    /** Sets up the trigger event listeners if ripples are enabled. */\n    private _setupTriggerEventsIfEnabled;\n    /**\n     * Launches a manual ripple using the specified ripple configuration.\n     * @param config Configuration for the manual ripple.\n     */\n    launch(config: RippleConfig): RippleRef;\n    /**\n     * Launches a manual ripple at the specified coordinates relative to the viewport.\n     * @param x Coordinate along the X axis at which to fade-in the ripple. Coordinate\n     *   should be relative to the viewport.\n     * @param y Coordinate along the Y axis at which to fade-in the ripple. Coordinate\n     *   should be relative to the viewport.\n     * @param config Optional ripple configuration for the manual ripple.\n     */\n    launch(x: number, y: number, config?: RippleConfig): RippleRef;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRipple, [null, null, null, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatRipple, \"[mat-ripple], [matRipple]\", [\"matRipple\"], { \"color\": \"matRippleColor\"; \"unbounded\": \"matRippleUnbounded\"; \"centered\": \"matRippleCentered\"; \"radius\": \"matRippleRadius\"; \"animation\": \"matRippleAnimation\"; \"disabled\": \"matRippleDisabled\"; \"trigger\": \"matRippleTrigger\"; }, {}, never, never, false>;\n}\n\nexport declare class MatRippleModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRippleModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatRippleModule, [typeof i1_4.MatRipple], [typeof i1_2.MatCommonModule], [typeof i1_4.MatRipple, typeof i1_2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatRippleModule>;\n}\n\n/** Mixin to augment a directive with a `color` property. */\nexport declare function mixinColor<T extends _AbstractConstructor<HasElementRef>>(base: T, defaultColor?: ThemePalette): CanColorCtor & T;\n\n/** Mixin to augment a directive with a `disabled` property. */\nexport declare function mixinDisabled<T extends _AbstractConstructor<{}>>(base: T): CanDisableCtor & T;\n\n/** Mixin to augment a directive with a `disableRipple` property. */\nexport declare function mixinDisableRipple<T extends _AbstractConstructor<{}>>(base: T): CanDisableRippleCtor & T;\n\n/**\n * Mixin to augment a directive with updateErrorState method.\n * For component with `errorState` and need to update `errorState`.\n */\nexport declare function mixinErrorState<T extends _AbstractConstructor<HasErrorState>>(base: T): CanUpdateErrorStateCtor & T;\n\n/** Mixin to augment a directive with an initialized property that will emits when ngOnInit ends. */\nexport declare function mixinInitialized<T extends _Constructor<{}>>(base: T): HasInitializedCtor & T;\n\n/** Mixin to augment a directive with a `tabIndex` property. */\nexport declare function mixinTabIndex<T extends _AbstractConstructor<CanDisable>>(base: T, defaultTabIndex?: number): HasTabIndexCtor & T;\n\n/** Adapts the native JS Date for use with cdk-based components that work with dates. */\nexport declare class NativeDateAdapter extends DateAdapter<Date> {\n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    useUtcForDisplay: boolean;\n    constructor(matDateLocale: string, \n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    _platform?: Platform);\n    getYear(date: Date): number;\n    getMonth(date: Date): number;\n    getDate(date: Date): number;\n    getDayOfWeek(date: Date): number;\n    getMonthNames(style: 'long' | 'short' | 'narrow'): string[];\n    getDateNames(): string[];\n    getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];\n    getYearName(date: Date): string;\n    getFirstDayOfWeek(): number;\n    getNumDaysInMonth(date: Date): number;\n    clone(date: Date): Date;\n    createDate(year: number, month: number, date: number): Date;\n    today(): Date;\n    parse(value: any, parseFormat?: any): Date | null;\n    format(date: Date, displayFormat: Object): string;\n    addCalendarYears(date: Date, years: number): Date;\n    addCalendarMonths(date: Date, months: number): Date;\n    addCalendarDays(date: Date, days: number): Date;\n    toIso8601(date: Date): string;\n    /**\n     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\n     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\n     * invalid date for all other values.\n     */\n    deserialize(value: any): Date | null;\n    isDateInstance(obj: any): boolean;\n    isValid(date: Date): boolean;\n    invalid(): Date;\n    /** Creates a date but allows the month and date to overflow. */\n    private _createDateWithOverflow;\n    /**\n     * Pads a number to make it two digits.\n     * @param n The number to pad.\n     * @returns The padded number.\n     */\n    private _2digit;\n    /**\n     * When converting Date object to string, javascript built-in functions may return wrong\n     * results because it applies its internal DST rules. The DST rules around the world change\n     * very frequently, and the current valid rule is not always valid in previous years though.\n     * We work around this problem building a new Date object which has its internal UTC\n     * representation with the local date and time.\n     * @param dtf Intl.DateTimeFormat object, containing the desired string format. It must have\n     *    timeZone set to 'utc' to work fine.\n     * @param date Date from which we want to get the string representation according to dtf\n     * @returns A Date object with its UTC representation based on the passed in date info\n     */\n    private _format;\n    static ɵfac: i0.ɵɵFactoryDeclaration<NativeDateAdapter, [{ optional: true; }, null]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<NativeDateAdapter>;\n}\n\nexport declare class NativeDateModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<NativeDateModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<NativeDateModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<NativeDateModule>;\n}\n\n/**\n * Interface that describes the configuration for the animation of a ripple.\n * There are two animation phases with different durations for the ripples.\n */\nexport declare interface RippleAnimationConfig {\n    /** Duration in milliseconds for the enter animation (expansion from point of contact). */\n    enterDuration?: number;\n    /** Duration in milliseconds for the exit animation (fade-out). */\n    exitDuration?: number;\n}\n\nexport declare type RippleConfig = {\n    color?: string;\n    centered?: boolean;\n    radius?: number;\n    persistent?: boolean;\n    animation?: RippleAnimationConfig;\n    terminateOnPointerUp?: boolean;\n};\n\n/** Configurable options for `matRipple`. */\nexport declare interface RippleGlobalOptions {\n    /**\n     * Whether ripples should be disabled. Ripples can be still launched manually by using\n     * the `launch()` method. Therefore focus indicators will still show up.\n     */\n    disabled?: boolean;\n    /**\n     * Default configuration for the animation duration of the ripples. There are two phases with\n     * different durations for the ripples: `enter` and `leave`. The durations will be overwritten\n     * by the value of `matRippleAnimation` or if the `NoopAnimationsModule` is included.\n     */\n    animation?: RippleAnimationConfig;\n    /**\n     * Whether ripples should start fading out immediately after the mouse or touch is released. By\n     * default, ripples will wait for the enter animation to complete and for mouse or touch release.\n     */\n    terminateOnPointerUp?: boolean;\n}\n\n/**\n * Reference to a previously launched ripple element.\n */\nexport declare class RippleRef {\n    private _renderer;\n    /** Reference to the ripple HTML element. */\n    element: HTMLElement;\n    /** Ripple configuration used for the ripple. */\n    config: RippleConfig;\n    _animationForciblyDisabledThroughCss: boolean;\n    /** Current state of the ripple. */\n    state: RippleState;\n    constructor(_renderer: {\n        fadeOutRipple(ref: RippleRef): void;\n    }, \n    /** Reference to the ripple HTML element. */\n    element: HTMLElement, \n    /** Ripple configuration used for the ripple. */\n    config: RippleConfig, _animationForciblyDisabledThroughCss?: boolean);\n    /** Fades out the ripple element. */\n    fadeOut(): void;\n}\n\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * @docs-private\n */\nexport declare class RippleRenderer implements EventListenerObject {\n    private _target;\n    private _ngZone;\n    /** Element where the ripples are being added to. */\n    private _containerElement;\n    /** Element which triggers the ripple elements on mouse events. */\n    private _triggerElement;\n    /** Whether the pointer is currently down or not. */\n    private _isPointerDown;\n    /**\n     * Map of currently active ripple references.\n     * The ripple reference is mapped to its element event listeners.\n     * The reason why `| null` is used is that event listeners are added only\n     * when the condition is truthy (see the `_startFadeOutTransition` method).\n     */\n    private _activeRipples;\n    /** Latest non-persistent ripple that was triggered. */\n    private _mostRecentTransientRipple;\n    /** Time in milliseconds when the last touchstart event happened. */\n    private _lastTouchStartEvent;\n    /** Whether pointer-up event listeners have been registered. */\n    private _pointerUpEventsRegistered;\n    /**\n     * Cached dimensions of the ripple container. Set when the first\n     * ripple is shown and cleared once no more ripples are visible.\n     */\n    private _containerRect;\n    constructor(_target: RippleTarget, _ngZone: NgZone, elementOrElementRef: HTMLElement | ElementRef<HTMLElement>, platform: Platform);\n    /**\n     * Fades in a ripple at the given coordinates.\n     * @param x Coordinate within the element, along the X axis at which to start the ripple.\n     * @param y Coordinate within the element, along the Y axis at which to start the ripple.\n     * @param config Extra ripple options.\n     */\n    fadeInRipple(x: number, y: number, config?: RippleConfig): RippleRef;\n    /** Fades out a ripple reference. */\n    fadeOutRipple(rippleRef: RippleRef): void;\n    /** Fades out all currently active ripples. */\n    fadeOutAll(): void;\n    /** Fades out all currently active non-persistent ripples. */\n    fadeOutAllNonPersistent(): void;\n    /** Sets up the trigger event listeners */\n    setupTriggerEvents(elementOrElementRef: HTMLElement | ElementRef<HTMLElement>): void;\n    /**\n     * Handles all registered events.\n     * @docs-private\n     */\n    handleEvent(event: Event): void;\n    /** Method that will be called if the fade-in or fade-in transition completed. */\n    private _finishRippleTransition;\n    /**\n     * Starts the fade-out transition of the given ripple if it's not persistent and the pointer\n     * is not held down anymore.\n     */\n    private _startFadeOutTransition;\n    /** Destroys the given ripple by removing it from the DOM and updating its state. */\n    private _destroyRipple;\n    /** Function being called whenever the trigger is being pressed using mouse. */\n    private _onMousedown;\n    /** Function being called whenever the trigger is being pressed using touch. */\n    private _onTouchStart;\n    /** Function being called whenever the trigger is being released. */\n    private _onPointerUp;\n    /** Registers event listeners for a given list of events. */\n    private _registerEvents;\n    private _getActiveRipples;\n    /** Removes previously registered event listeners from the trigger element. */\n    _removeTriggerEvents(): void;\n}\n\n\n/** Possible states for a ripple element. */\nexport declare const enum RippleState {\n    FADING_IN = 0,\n    VISIBLE = 1,\n    FADING_OUT = 2,\n    HIDDEN = 3\n}\n\n/**\n * Interface that describes the target for launching ripples.\n * It defines the ripple configuration and disabled state for interaction ripples.\n * @docs-private\n */\nexport declare interface RippleTarget {\n    /** Configuration for ripples that are launched on pointer down. */\n    rippleConfig: RippleConfig;\n    /** Whether ripples on pointer down should be disabled. */\n    rippleDisabled: boolean;\n}\n\n/**\n * Possible sanity checks that can be enabled. If set to\n * true/false, all checks will be enabled/disabled.\n */\nexport declare type SanityChecks = boolean | GranularSanityChecks;\n\n/**\n * Helper that takes a query list of lines and sets the correct class on the host.\n * @docs-private\n */\nexport declare function setLines(lines: QueryList<unknown>, element: ElementRef<HTMLElement>, prefix?: string): void;\n\n/** Error state matcher that matches when a control is invalid and dirty. */\nexport declare class ShowOnDirtyErrorStateMatcher implements ErrorStateMatcher {\n    isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ShowOnDirtyErrorStateMatcher, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<ShowOnDirtyErrorStateMatcher>;\n}\n\n/** Possible color palette values. */\nexport declare type ThemePalette = 'primary' | 'accent' | 'warn' | undefined;\n\n/** Current version of Angular Material. */\nexport declare const VERSION: Version;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/core/testing/index.d.ts",
      "node_modules/@angular/material/core/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a `mat-optgroup` in tests. */\nexport declare class MatOptgroupHarness extends ComponentHarness {\n    /** Selector used to locate option group instances. */\n    static hostSelector: string;\n    private _label;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatOptgroupHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which option instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: OptgroupHarnessFilters): HarnessPredicate<MatOptgroupHarness>;\n    /** Gets the option group's label text. */\n    getLabelText(): Promise<string>;\n    /** Gets whether the option group is disabled. */\n    isDisabled(): Promise<boolean>;\n    /**\n     * Gets the options that are inside the group.\n     * @param filter Optionally filters which options are included.\n     */\n    getOptions(filter?: OptionHarnessFilters): Promise<MatOptionHarness[]>;\n}\n\n/** Harness for interacting with a `mat-option` in tests. */\nexport declare class MatOptionHarness extends ComponentHarness {\n    /** Selector used to locate option instances. */\n    static hostSelector: string;\n    /** Element containing the option's text. */\n    private _text;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatOptionsHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which option instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: OptionHarnessFilters): HarnessPredicate<MatOptionHarness>;\n    /** Clicks the option. */\n    click(): Promise<void>;\n    /** Gets the option's label text. */\n    getText(): Promise<string>;\n    /** Gets whether the option is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets whether the option is selected. */\n    isSelected(): Promise<boolean>;\n    /** Gets whether the option is active. */\n    isActive(): Promise<boolean>;\n    /** Gets whether the option is in multiple selection mode. */\n    isMultiple(): Promise<boolean>;\n}\n\nexport declare interface OptgroupHarnessFilters extends BaseHarnessFilters {\n    labelText?: string | RegExp;\n}\n\nexport declare interface OptionHarnessFilters extends BaseHarnessFilters {\n    text?: string | RegExp;\n    isSelected?: boolean;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/datepicker/index.d.ts",
      "node_modules/@angular/material/datepicker/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AbstractControl } from '@angular/forms';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewChecked } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { CanUpdateErrorState } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ComponentType } from '@angular/cdk/portal';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlContainer } from '@angular/forms';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { DateAdapter } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { ErrorStateMatcher } from '@angular/material/core';\nimport { EventEmitter } from '@angular/core';\nimport { FactoryProvider } from '@angular/core';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { FormGroupDirective } from '@angular/forms';\nimport * as i0 from '@angular/core';\nimport * as i14 from '@angular/common';\nimport * as i15 from '@angular/material/button';\nimport * as i16 from '@angular/cdk/overlay';\nimport * as i17 from '@angular/cdk/a11y';\nimport * as i18 from '@angular/cdk/portal';\nimport * as i19 from '@angular/material/core';\nimport * as i20 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { MatButton } from '@angular/material/button';\nimport { MatDateFormats } from '@angular/material/core';\nimport { MatFormField } from '@angular/material/form-field';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { NgControl } from '@angular/forms';\nimport { NgForm } from '@angular/forms';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { Portal } from '@angular/cdk/portal';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\nimport { ValidationErrors } from '@angular/forms';\nimport { Validator } from '@angular/forms';\nimport { ValidatorFn } from '@angular/forms';\nimport { ViewContainerRef } from '@angular/core';\n\n/** Function that can be used to filter out dates from a calendar. */\nexport declare type DateFilterFn<D> = (date: D | null) => boolean;\n\n/** Possible positions for the datepicker dropdown along the X axis. */\nexport declare type DatepickerDropdownPositionX = 'start' | 'end';\n\n/** Possible positions for the datepicker dropdown along the Y axis. */\nexport declare type DatepickerDropdownPositionY = 'above' | 'below';\n\n/** A class representing a range of dates. */\nexport declare class DateRange<D> {\n    /** The start date of the range. */\n    readonly start: D | null;\n    /** The end date of the range. */\n    readonly end: D | null;\n    /**\n     * Ensures that objects with a `start` and `end` property can't be assigned to a variable that\n     * expects a `DateRange`\n     */\n    private _disableStructuralEquivalency;\n    constructor(\n    /** The start date of the range. */\n    start: D | null, \n    /** The end date of the range. */\n    end: D | null);\n}\n\n/**\n * Event emitted by the date selection model when its selection changes.\n * @docs-private\n */\nexport declare interface DateSelectionModelChange<S> {\n    /** New value for the selection. */\n    selection: S;\n    /** Object that triggered the change. */\n    source: unknown;\n    /** Previous value */\n    oldValue?: S;\n}\n\n/** Provides the default date range selection behavior. */\nexport declare class DefaultMatCalendarRangeStrategy<D> implements MatDateRangeSelectionStrategy<D> {\n    private _dateAdapter;\n    constructor(_dateAdapter: DateAdapter<D>);\n    selectionFinished(date: D, currentRange: DateRange<D>): DateRange<D>;\n    createPreview(activeDate: D | null, currentRange: DateRange<D>): DateRange<D>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultMatCalendarRangeStrategy<any>, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<DefaultMatCalendarRangeStrategy<any>>;\n}\n\n/**\n * Conditionally picks the date type, if a DateRange is passed in.\n * @docs-private\n */\nexport declare type ExtractDateTypeFromSelection<T> = T extends DateRange<infer D> ? D : NonNullable<T>;\n\n/**\n * When the multi-year view is first opened, the active year will be in view.\n * So we compute how many years are between the active year and the *slot* where our\n * \"startingYear\" will render when paged into view.\n */\ndeclare function getActiveOffset<D>(dateAdapter: DateAdapter<D>, activeDate: D, minDate: D | null, maxDate: D | null): number;\n\ndeclare namespace i1 {\n    export {\n        MatCalendarView,\n        MatCalendarHeader,\n        MatCalendar\n    }\n}\n\ndeclare namespace i10 {\n    export {\n        MatDateRangeInput\n    }\n}\n\ndeclare namespace i11 {\n    export {\n        MatDateRangeInputParent,\n        MAT_DATE_RANGE_INPUT_PARENT,\n        MatStartDate,\n        MatEndDate\n    }\n}\n\ndeclare namespace i12 {\n    export {\n        MatDateRangePickerInput,\n        MatDateRangePicker\n    }\n}\n\ndeclare namespace i13 {\n    export {\n        MatDatepickerApply,\n        MatDatepickerCancel,\n        MatDatepickerActions\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatCalendarCellCssClasses,\n        MatCalendarCellClassFunction,\n        MatCalendarCell,\n        MatCalendarUserEvent,\n        MatCalendarBody\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MatDatepicker\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,\n        MAT_DATEPICKER_SCROLL_STRATEGY,\n        DatepickerDropdownPositionX,\n        DatepickerDropdownPositionY,\n        MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,\n        MatDatepickerContent,\n        MatDatepickerControl,\n        MatDatepickerPanel,\n        MatDatepickerBase\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        MAT_DATEPICKER_VALUE_ACCESSOR,\n        MAT_DATEPICKER_VALIDATORS,\n        MatDatepickerInput\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        MatDatepickerToggleIcon,\n        MatDatepickerToggle\n    }\n}\n\ndeclare namespace i7 {\n    export {\n        MatMonthView\n    }\n}\n\ndeclare namespace i8 {\n    export {\n        MatYearView\n    }\n}\n\ndeclare namespace i9 {\n    export {\n        isSameMultiYearView,\n        getActiveOffset,\n        yearsPerPage,\n        yearsPerRow,\n        MatMultiYearView\n    }\n}\n\ndeclare function isSameMultiYearView<D>(dateAdapter: DateAdapter<D>, date1: D, date2: D, minDate: D | null, maxDate: D | null): boolean;\n\n/**\n * Used to provide the date range input wrapper component\n * to the parts without circular dependencies.\n */\ndeclare const MAT_DATE_RANGE_INPUT_PARENT: InjectionToken<MatDateRangeInputParent<unknown>>;\n\n/** Injection token used to customize the date range selection behavior. */\nexport declare const MAT_DATE_RANGE_SELECTION_STRATEGY: InjectionToken<MatDateRangeSelectionStrategy<any>>;\n\n/** Injection token that determines the scroll handling while the calendar is open. */\nexport declare const MAT_DATEPICKER_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\nexport declare function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/** @docs-private */\nexport declare const MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY;\n};\n\n/** @docs-private */\nexport declare const MAT_DATEPICKER_VALIDATORS: any;\n\n/** @docs-private */\nexport declare const MAT_DATEPICKER_VALUE_ACCESSOR: any;\n\n/** @docs-private */\nexport declare function MAT_RANGE_DATE_SELECTION_MODEL_FACTORY(parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>): MatSingleDateSelectionModel<unknown>;\n\n/**\n * Used to provide a range selection model to a component.\n * @docs-private\n */\nexport declare const MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider;\n\n/** @docs-private */\nexport declare function MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY(parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>): MatSingleDateSelectionModel<unknown>;\n\n/**\n * Used to provide a single selection model to a component.\n * @docs-private\n */\nexport declare const MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider;\n\n/** A calendar that is used as part of the datepicker. */\nexport declare class MatCalendar<D> implements AfterContentInit, AfterViewChecked, OnDestroy, OnChanges {\n    private _dateAdapter;\n    private _dateFormats;\n    private _changeDetectorRef;\n    /** An input indicating the type of the header component, if set. */\n    headerComponent: ComponentType<any>;\n    /** A portal containing the header component type for this calendar. */\n    _calendarHeaderPortal: Portal<any>;\n    private _intlChanges;\n    /**\n     * Used for scheduling that focus should be moved to the active cell on the next tick.\n     * We need to schedule it, rather than do it immediately, because we have to wait\n     * for Angular to re-evaluate the view children.\n     */\n    private _moveFocusOnNextTick;\n    /** A date representing the period (month or year) to start the calendar in. */\n    get startAt(): D | null;\n    set startAt(value: D | null);\n    private _startAt;\n    /** Whether the calendar should be started in month or year view. */\n    startView: MatCalendarView;\n    /** The currently selected date. */\n    get selected(): DateRange<D> | D | null;\n    set selected(value: DateRange<D> | D | null);\n    private _selected;\n    /** The minimum selectable date. */\n    get minDate(): D | null;\n    set minDate(value: D | null);\n    private _minDate;\n    /** The maximum selectable date. */\n    get maxDate(): D | null;\n    set maxDate(value: D | null);\n    private _maxDate;\n    /** Function used to filter which dates are selectable. */\n    dateFilter: (date: D) => boolean;\n    /** Function that can be used to add custom CSS classes to dates. */\n    dateClass: MatCalendarCellClassFunction<D>;\n    /** Start of the comparison range. */\n    comparisonStart: D | null;\n    /** End of the comparison range. */\n    comparisonEnd: D | null;\n    /** Emits when the currently selected date changes. */\n    readonly selectedChange: EventEmitter<D | null>;\n    /**\n     * Emits the year chosen in multiyear view.\n     * This doesn't imply a change on the selected date.\n     */\n    readonly yearSelected: EventEmitter<D>;\n    /**\n     * Emits the month chosen in year view.\n     * This doesn't imply a change on the selected date.\n     */\n    readonly monthSelected: EventEmitter<D>;\n    /**\n     * Emits when the current view changes.\n     */\n    readonly viewChanged: EventEmitter<MatCalendarView>;\n    /** Emits when any date is selected. */\n    readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>>;\n    /** Reference to the current month view component. */\n    monthView: MatMonthView<D>;\n    /** Reference to the current year view component. */\n    yearView: MatYearView<D>;\n    /** Reference to the current multi-year view component. */\n    multiYearView: MatMultiYearView<D>;\n    /**\n     * The current active date. This determines which time period is shown and which date is\n     * highlighted when using keyboard navigation.\n     */\n    get activeDate(): D;\n    set activeDate(value: D);\n    private _clampedActiveDate;\n    /** Whether the calendar is in month view. */\n    get currentView(): MatCalendarView;\n    set currentView(value: MatCalendarView);\n    private _currentView;\n    /**\n     * Emits whenever there is a state change that the header may need to respond to.\n     */\n    readonly stateChanges: Subject<void>;\n    constructor(_intl: MatDatepickerIntl, _dateAdapter: DateAdapter<D>, _dateFormats: MatDateFormats, _changeDetectorRef: ChangeDetectorRef);\n    ngAfterContentInit(): void;\n    ngAfterViewChecked(): void;\n    ngOnDestroy(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    /** Focuses the active date. */\n    focusActiveCell(): void;\n    /** Updates today's date after an update of the active date */\n    updateTodaysDate(): void;\n    /** Handles date selection in the month view. */\n    _dateSelected(event: MatCalendarUserEvent<D | null>): void;\n    /** Handles year selection in the multiyear view. */\n    _yearSelectedInMultiYearView(normalizedYear: D): void;\n    /** Handles month selection in the year view. */\n    _monthSelectedInYearView(normalizedMonth: D): void;\n    /** Handles year/month selection in the multi-year/year views. */\n    _goToDateInView(date: D, view: 'month' | 'year' | 'multi-year'): void;\n    /** Returns the component instance that corresponds to the current calendar view. */\n    private _getCurrentViewComponent;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendar<any>, [null, { optional: true; }, { optional: true; }, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendar<any>, \"mat-calendar\", [\"matCalendar\"], { \"headerComponent\": \"headerComponent\"; \"startAt\": \"startAt\"; \"startView\": \"startView\"; \"selected\": \"selected\"; \"minDate\": \"minDate\"; \"maxDate\": \"maxDate\"; \"dateFilter\": \"dateFilter\"; \"dateClass\": \"dateClass\"; \"comparisonStart\": \"comparisonStart\"; \"comparisonEnd\": \"comparisonEnd\"; }, { \"selectedChange\": \"selectedChange\"; \"yearSelected\": \"yearSelected\"; \"monthSelected\": \"monthSelected\"; \"viewChanged\": \"viewChanged\"; \"_userSelection\": \"_userSelection\"; }, never, never, false>;\n}\n\n/**\n * An internal component used to display calendar data in a table.\n * @docs-private\n */\nexport declare class MatCalendarBody implements OnChanges, OnDestroy, AfterViewChecked {\n    private _elementRef;\n    private _ngZone;\n    /**\n     * Used to skip the next focus event when rendering the preview range.\n     * We need a flag like this, because some browsers fire focus events asynchronously.\n     */\n    private _skipNextFocus;\n    /**\n     * Used to focus the active cell after change detection has run.\n     */\n    private _focusActiveCellAfterViewChecked;\n    /** The label for the table. (e.g. \"Jan 2017\"). */\n    label: string;\n    /** The cells to display in the table. */\n    rows: MatCalendarCell[][];\n    /** The value in the table that corresponds to today. */\n    todayValue: number;\n    /** Start value of the selected date range. */\n    startValue: number;\n    /** End value of the selected date range. */\n    endValue: number;\n    /** The minimum number of free cells needed to fit the label in the first row. */\n    labelMinRequiredCells: number;\n    /** The number of columns in the table. */\n    numCols: number;\n    /** The cell number of the active cell in the table. */\n    activeCell: number;\n    ngAfterViewChecked(): void;\n    /** Whether a range is being selected. */\n    isRange: boolean;\n    /**\n     * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\n     * maintained even as the table resizes.\n     */\n    cellAspectRatio: number;\n    /** Start of the comparison range. */\n    comparisonStart: number | null;\n    /** End of the comparison range. */\n    comparisonEnd: number | null;\n    /** Start of the preview range. */\n    previewStart: number | null;\n    /** End of the preview range. */\n    previewEnd: number | null;\n    /** Emits when a new value is selected. */\n    readonly selectedValueChange: EventEmitter<MatCalendarUserEvent<number>>;\n    /** Emits when the preview has changed as a result of a user action. */\n    readonly previewChange: EventEmitter<MatCalendarUserEvent<MatCalendarCell<any> | null>>;\n    readonly activeDateChange: EventEmitter<MatCalendarUserEvent<number>>;\n    /** The number of blank cells to put at the beginning for the first row. */\n    _firstRowOffset: number;\n    /** Padding for the individual date cells. */\n    _cellPadding: string;\n    /** Width of an individual cell. */\n    _cellWidth: string;\n    constructor(_elementRef: ElementRef<HTMLElement>, _ngZone: NgZone);\n    /** Called when a cell is clicked. */\n    _cellClicked(cell: MatCalendarCell, event: MouseEvent): void;\n    _emitActiveDateChange(cell: MatCalendarCell, event: FocusEvent): void;\n    /** Returns whether a cell should be marked as selected. */\n    _isSelected(value: number): boolean;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Returns whether a cell is active. */\n    _isActiveCell(rowIndex: number, colIndex: number): boolean;\n    /**\n     * Focuses the active cell after the microtask queue is empty.\n     *\n     * Adding a 0ms setTimeout seems to fix Voiceover losing focus when pressing PageUp/PageDown\n     * (issue #24330).\n     *\n     * Determined a 0ms by gradually increasing duration from 0 and testing two use cases with screen\n     * reader enabled:\n     *\n     * 1. Pressing PageUp/PageDown repeatedly with pausing between each key press.\n     * 2. Pressing and holding the PageDown key with repeated keys enabled.\n     *\n     * Test 1 worked roughly 95-99% of the time with 0ms and got a little bit better as the duration\n     * increased. Test 2 got slightly better until the duration was long enough to interfere with\n     * repeated keys. If the repeated key speed was faster than the timeout duration, then pressing\n     * and holding pagedown caused the entire page to scroll.\n     *\n     * Since repeated key speed can verify across machines, determined that any duration could\n     * potentially interfere with repeated keys. 0ms would be best because it almost entirely\n     * eliminates the focus being lost in Voiceover (#24330) without causing unintended side effects.\n     * Adding delay also complicates writing tests.\n     */\n    _focusActiveCell(movePreview?: boolean): void;\n    /** Focuses the active cell after change detection has run and the microtask queue is empty. */\n    _scheduleFocusActiveCellAfterViewChecked(): void;\n    /** Gets whether a value is the start of the main range. */\n    _isRangeStart(value: number): boolean;\n    /** Gets whether a value is the end of the main range. */\n    _isRangeEnd(value: number): boolean;\n    /** Gets whether a value is within the currently-selected range. */\n    _isInRange(value: number): boolean;\n    /** Gets whether a value is the start of the comparison range. */\n    _isComparisonStart(value: number): boolean;\n    /** Whether the cell is a start bridge cell between the main and comparison ranges. */\n    _isComparisonBridgeStart(value: number, rowIndex: number, colIndex: number): boolean;\n    /** Whether the cell is an end bridge cell between the main and comparison ranges. */\n    _isComparisonBridgeEnd(value: number, rowIndex: number, colIndex: number): boolean;\n    /** Gets whether a value is the end of the comparison range. */\n    _isComparisonEnd(value: number): boolean;\n    /** Gets whether a value is within the current comparison range. */\n    _isInComparisonRange(value: number): boolean;\n    /**\n     * Gets whether a value is the same as the start and end of the comparison range.\n     * For context, the functions that we use to determine whether something is the start/end of\n     * a range don't allow for the start and end to be on the same day, because we'd have to use\n     * much more specific CSS selectors to style them correctly in all scenarios. This is fine for\n     * the regular range, because when it happens, the selected styles take over and still show where\n     * the range would've been, however we don't have these selected styles for a comparison range.\n     * This function is used to apply a class that serves the same purpose as the one for selected\n     * dates, but it only applies in the context of a comparison range.\n     */\n    _isComparisonIdentical(value: number): boolean;\n    /** Gets whether a value is the start of the preview range. */\n    _isPreviewStart(value: number): boolean;\n    /** Gets whether a value is the end of the preview range. */\n    _isPreviewEnd(value: number): boolean;\n    /** Gets whether a value is inside the preview range. */\n    _isInPreview(value: number): boolean;\n    /**\n     * Event handler for when the user enters an element\n     * inside the calendar body (e.g. by hovering in or focus).\n     */\n    private _enterHandler;\n    /**\n     * Event handler for when the user's pointer leaves an element\n     * inside the calendar body (e.g. by hovering out or blurring).\n     */\n    private _leaveHandler;\n    /** Finds the MatCalendarCell that corresponds to a DOM node. */\n    private _getCellFromElement;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendarBody, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendarBody, \"[mat-calendar-body]\", [\"matCalendarBody\"], { \"label\": \"label\"; \"rows\": \"rows\"; \"todayValue\": \"todayValue\"; \"startValue\": \"startValue\"; \"endValue\": \"endValue\"; \"labelMinRequiredCells\": \"labelMinRequiredCells\"; \"numCols\": \"numCols\"; \"activeCell\": \"activeCell\"; \"isRange\": \"isRange\"; \"cellAspectRatio\": \"cellAspectRatio\"; \"comparisonStart\": \"comparisonStart\"; \"comparisonEnd\": \"comparisonEnd\"; \"previewStart\": \"previewStart\"; \"previewEnd\": \"previewEnd\"; }, { \"selectedValueChange\": \"selectedValueChange\"; \"previewChange\": \"previewChange\"; \"activeDateChange\": \"activeDateChange\"; }, never, never, false>;\n}\n\n/**\n * An internal class that represents the data corresponding to a single calendar cell.\n * @docs-private\n */\nexport declare class MatCalendarCell<D = any> {\n    value: number;\n    displayValue: string;\n    ariaLabel: string;\n    enabled: boolean;\n    cssClasses: MatCalendarCellCssClasses;\n    compareValue: number;\n    rawValue?: D | undefined;\n    constructor(value: number, displayValue: string, ariaLabel: string, enabled: boolean, cssClasses?: MatCalendarCellCssClasses, compareValue?: number, rawValue?: D | undefined);\n}\n\n/** Function that can generate the extra classes that should be added to a calendar cell. */\nexport declare type MatCalendarCellClassFunction<D> = (date: D, view: 'month' | 'year' | 'multi-year') => MatCalendarCellCssClasses;\n\n/** Extra CSS classes that can be associated with a calendar cell. */\nexport declare type MatCalendarCellCssClasses = string | string[] | Set<string> | {\n    [key: string]: any;\n};\n\n/** Default header for MatCalendar */\nexport declare class MatCalendarHeader<D> {\n    private _intl;\n    calendar: MatCalendar<D>;\n    private _dateAdapter;\n    private _dateFormats;\n    _buttonDescriptionId: string;\n    constructor(_intl: MatDatepickerIntl, calendar: MatCalendar<D>, _dateAdapter: DateAdapter<D>, _dateFormats: MatDateFormats, changeDetectorRef: ChangeDetectorRef);\n    /** The label for the current calendar view. */\n    get periodButtonText(): string;\n    get periodButtonLabel(): string;\n    /** The label for the previous button. */\n    get prevButtonLabel(): string;\n    /** The label for the next button. */\n    get nextButtonLabel(): string;\n    /** Handles user clicks on the period label. */\n    currentPeriodClicked(): void;\n    /** Handles user clicks on the previous button. */\n    previousClicked(): void;\n    /** Handles user clicks on the next button. */\n    nextClicked(): void;\n    /** Whether the previous period button is enabled. */\n    previousEnabled(): boolean;\n    /** Whether the next period button is enabled. */\n    nextEnabled(): boolean;\n    /** Whether the two dates represent the same view in the current view mode (month or year). */\n    private _isSameView;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendarHeader<any>, [null, null, { optional: true; }, { optional: true; }, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendarHeader<any>, \"mat-calendar-header\", [\"matCalendarHeader\"], {}, {}, never, [\"*\"], false>;\n}\n\n/** Event emitted when a date inside the calendar is triggered as a result of a user action. */\nexport declare interface MatCalendarUserEvent<D> {\n    value: D;\n    event: Event;\n}\n\n/**\n * Possible views for the calendar.\n * @docs-private\n */\nexport declare type MatCalendarView = 'month' | 'year' | 'multi-year';\n\n/** Component responsible for managing the datepicker popup/dialog. */\nexport declare class MatDatepicker<D> extends MatDatepickerBase<MatDatepickerControl<D>, D | null, D> {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepicker<any>, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepicker<any>, \"mat-datepicker\", [\"matDatepicker\"], {}, {}, never, never, false>;\n}\n\n/**\n * Container that can be used to project a row of action buttons\n * to the bottom of a datepicker or date range picker.\n */\nexport declare class MatDatepickerActions implements AfterViewInit, OnDestroy {\n    private _datepicker;\n    private _viewContainerRef;\n    _template: TemplateRef<unknown>;\n    private _portal;\n    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>, _viewContainerRef: ViewContainerRef);\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerActions, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerActions, \"mat-datepicker-actions, mat-date-range-picker-actions\", never, {}, {}, never, [\"*\"], false>;\n}\n\n/**\n * Animations used by the Material datepicker.\n * @docs-private\n */\nexport declare const matDatepickerAnimations: {\n    readonly transformPanel: AnimationTriggerMetadata;\n    readonly fadeInCalendar: AnimationTriggerMetadata;\n};\n\n/** Button that will close the datepicker and assign the current selection to the data model. */\nexport declare class MatDatepickerApply {\n    private _datepicker;\n    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>);\n    _applySelection(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerApply, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerApply, \"[matDatepickerApply], [matDateRangePickerApply]\", never, {}, {}, never, never, false>;\n}\n\n/** Base class for a datepicker. */\ndeclare abstract class MatDatepickerBase<C extends MatDatepickerControl<D>, S, D = ExtractDateTypeFromSelection<S>> implements MatDatepickerPanel<C, S, D>, OnDestroy, OnChanges {\n    private _overlay;\n    private _ngZone;\n    private _viewContainerRef;\n    private _dateAdapter;\n    private _dir;\n    private _model;\n    private _scrollStrategy;\n    private _inputStateChanges;\n    private _document;\n    /** An input indicating the type of the custom header component for the calendar, if set. */\n    calendarHeaderComponent: ComponentType<any>;\n    /** The date to open the calendar to initially. */\n    get startAt(): D | null;\n    set startAt(value: D | null);\n    private _startAt;\n    /** The view that the calendar should start in. */\n    startView: 'month' | 'year' | 'multi-year';\n    /** Color palette to use on the datepicker's calendar. */\n    get color(): ThemePalette;\n    set color(value: ThemePalette);\n    _color: ThemePalette;\n    /**\n     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\n     * than a dropdown and elements have more padding to allow for bigger touch targets.\n     */\n    get touchUi(): boolean;\n    set touchUi(value: BooleanInput);\n    private _touchUi;\n    /** Whether the datepicker pop-up should be disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Preferred position of the datepicker in the X axis. */\n    xPosition: DatepickerDropdownPositionX;\n    /** Preferred position of the datepicker in the Y axis. */\n    yPosition: DatepickerDropdownPositionY;\n    /**\n     * Whether to restore focus to the previously-focused element when the calendar is closed.\n     * Note that automatic focus restoration is an accessibility feature and it is recommended that\n     * you provide your own equivalent, if you decide to turn it off.\n     */\n    get restoreFocus(): boolean;\n    set restoreFocus(value: BooleanInput);\n    private _restoreFocus;\n    /**\n     * Emits selected year in multiyear view.\n     * This doesn't imply a change on the selected date.\n     */\n    readonly yearSelected: EventEmitter<D>;\n    /**\n     * Emits selected month in year view.\n     * This doesn't imply a change on the selected date.\n     */\n    readonly monthSelected: EventEmitter<D>;\n    /**\n     * Emits when the current view changes.\n     */\n    readonly viewChanged: EventEmitter<MatCalendarView>;\n    /** Function that can be used to add custom CSS classes to dates. */\n    dateClass: MatCalendarCellClassFunction<D>;\n    /** Emits when the datepicker has been opened. */\n    readonly openedStream: EventEmitter<void>;\n    /** Emits when the datepicker has been closed. */\n    readonly closedStream: EventEmitter<void>;\n    /**\n     * Classes to be passed to the date picker panel.\n     * Supports string and string array values, similar to `ngClass`.\n     */\n    get panelClass(): string | string[];\n    set panelClass(value: string | string[]);\n    private _panelClass;\n    /** Whether the calendar is open. */\n    get opened(): boolean;\n    set opened(value: BooleanInput);\n    private _opened;\n    /** The id for the datepicker calendar. */\n    id: string;\n    /** The minimum selectable date. */\n    _getMinDate(): D | null;\n    /** The maximum selectable date. */\n    _getMaxDate(): D | null;\n    _getDateFilter(): DateFilterFn<D>;\n    /** A reference to the overlay into which we've rendered the calendar. */\n    private _overlayRef;\n    /** Reference to the component instance rendered in the overlay. */\n    private _componentRef;\n    /** The element that was focused before the datepicker was opened. */\n    private _focusedElementBeforeOpen;\n    /** Unique class that will be added to the backdrop so that the test harnesses can look it up. */\n    private _backdropHarnessClass;\n    /** Currently-registered actions portal. */\n    private _actionsPortal;\n    /** The input element this datepicker is associated with. */\n    datepickerInput: C;\n    /** Emits when the datepicker's state changes. */\n    readonly stateChanges: Subject<void>;\n    constructor(_overlay: Overlay, _ngZone: NgZone, _viewContainerRef: ViewContainerRef, scrollStrategy: any, _dateAdapter: DateAdapter<D>, _dir: Directionality, _model: MatDateSelectionModel<S, D>);\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Selects the given date */\n    select(date: D): void;\n    /** Emits the selected year in multiyear view */\n    _selectYear(normalizedYear: D): void;\n    /** Emits selected month in year view */\n    _selectMonth(normalizedMonth: D): void;\n    /** Emits changed view */\n    _viewChanged(view: MatCalendarView): void;\n    /**\n     * Register an input with this datepicker.\n     * @param input The datepicker input to register with this datepicker.\n     * @returns Selection model that the input should hook itself up to.\n     */\n    registerInput(input: C): MatDateSelectionModel<S, D>;\n    /**\n     * Registers a portal containing action buttons with the datepicker.\n     * @param portal Portal to be registered.\n     */\n    registerActions(portal: TemplatePortal): void;\n    /**\n     * Removes a portal containing action buttons from the datepicker.\n     * @param portal Portal to be removed.\n     */\n    removeActions(portal: TemplatePortal): void;\n    /** Open the calendar. */\n    open(): void;\n    /** Close the calendar. */\n    close(): void;\n    /** Applies the current pending selection on the overlay to the model. */\n    _applyPendingSelection(): void;\n    /** Forwards relevant values from the datepicker to the datepicker content inside the overlay. */\n    protected _forwardContentValues(instance: MatDatepickerContent<S, D>): void;\n    /** Opens the overlay with the calendar. */\n    private _openOverlay;\n    /** Destroys the current overlay. */\n    private _destroyOverlay;\n    /** Gets a position strategy that will open the calendar as a dropdown. */\n    private _getDialogStrategy;\n    /** Gets a position strategy that will open the calendar as a dropdown. */\n    private _getDropdownStrategy;\n    /** Sets the positions of the datepicker in dropdown mode based on the current configuration. */\n    private _setConnectedPositions;\n    /** Gets an observable that will emit when the overlay is supposed to be closed. */\n    private _getCloseStream;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerBase<any, any, any>, [null, null, null, null, { optional: true; }, { optional: true; }, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerBase<any, any, any>, never, never, { \"calendarHeaderComponent\": \"calendarHeaderComponent\"; \"startAt\": \"startAt\"; \"startView\": \"startView\"; \"color\": \"color\"; \"touchUi\": \"touchUi\"; \"disabled\": \"disabled\"; \"xPosition\": \"xPosition\"; \"yPosition\": \"yPosition\"; \"restoreFocus\": \"restoreFocus\"; \"dateClass\": \"dateClass\"; \"panelClass\": \"panelClass\"; \"opened\": \"opened\"; }, { \"yearSelected\": \"yearSelected\"; \"monthSelected\": \"monthSelected\"; \"viewChanged\": \"viewChanged\"; \"openedStream\": \"opened\"; \"closedStream\": \"closed\"; }, never, never, false>;\n}\n\n/** Button that will close the datepicker and discard the current selection. */\nexport declare class MatDatepickerCancel {\n    _datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>;\n    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerCancel, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerCancel, \"[matDatepickerCancel], [matDateRangePickerCancel]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Component used as the content for the datepicker overlay. We use this instead of using\n * MatCalendar directly as the content so we can control the initial focus. This also gives us a\n * place to put additional features of the overlay that are not part of the calendar itself in the\n * future. (e.g. confirmation buttons).\n * @docs-private\n */\nexport declare class MatDatepickerContent<S, D = ExtractDateTypeFromSelection<S>> extends _MatDatepickerContentBase implements OnInit, AfterViewInit, OnDestroy, CanColor {\n    private _changeDetectorRef;\n    private _globalModel;\n    private _dateAdapter;\n    private _rangeSelectionStrategy;\n    private _subscriptions;\n    private _model;\n    /** Reference to the internal calendar component. */\n    _calendar: MatCalendar<D>;\n    /** Reference to the datepicker that created the overlay. */\n    datepicker: MatDatepickerBase<any, S, D>;\n    /** Start of the comparison range. */\n    comparisonStart: D | null;\n    /** End of the comparison range. */\n    comparisonEnd: D | null;\n    /** Whether the datepicker is above or below the input. */\n    _isAbove: boolean;\n    /** Current state of the animation. */\n    _animationState: 'enter-dropdown' | 'enter-dialog' | 'void';\n    /** Emits when an animation has finished. */\n    readonly _animationDone: Subject<void>;\n    /** Text for the close button. */\n    _closeButtonText: string;\n    /** Whether the close button currently has focus. */\n    _closeButtonFocused: boolean;\n    /** Portal with projected action buttons. */\n    _actionsPortal: TemplatePortal | null;\n    /** Id of the label for the `role=\"dialog\"` element. */\n    _dialogLabelId: string | null;\n    constructor(elementRef: ElementRef, _changeDetectorRef: ChangeDetectorRef, _globalModel: MatDateSelectionModel<S, D>, _dateAdapter: DateAdapter<D>, _rangeSelectionStrategy: MatDateRangeSelectionStrategy<D>, intl: MatDatepickerIntl);\n    ngOnInit(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    _handleUserSelection(event: MatCalendarUserEvent<D | null>): void;\n    _startExitAnimation(): void;\n    _getSelected(): D | DateRange<D> | null;\n    /** Applies the current pending selection to the global model. */\n    _applyPendingSelection(): void;\n    /**\n     * Assigns a new portal containing the datepicker actions.\n     * @param portal Portal with the actions to be assigned.\n     * @param forceRerender Whether a re-render of the portal should be triggered. This isn't\n     * necessary if the portal is assigned during initialization, but it may be required if it's\n     * added at a later point.\n     */\n    _assignActions(portal: TemplatePortal<any> | null, forceRerender: boolean): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerContent<any, any>, [null, null, null, null, { optional: true; }, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerContent<any, any>, \"mat-datepicker-content\", [\"matDatepickerContent\"], { \"color\": \"color\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatDatepickerContentBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\n/** Form control that can be associated with a datepicker. */\ndeclare interface MatDatepickerControl<D> {\n    getStartValue(): D | null;\n    getThemePalette(): ThemePalette;\n    min: D | null;\n    max: D | null;\n    disabled: boolean;\n    dateFilter: DateFilterFn<D>;\n    getConnectedOverlayOrigin(): ElementRef;\n    getOverlayLabelId(): string | null;\n    stateChanges: Observable<void>;\n}\n\n/** Directive used to connect an input to a MatDatepicker. */\nexport declare class MatDatepickerInput<D> extends MatDatepickerInputBase<D | null, D> implements MatDatepickerControl<D | null>, OnDestroy {\n    private _formField?;\n    private _closedSubscription;\n    /** The datepicker that this input is associated with. */\n    set matDatepicker(datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>);\n    _datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>;\n    /** The minimum valid date. */\n    get min(): D | null;\n    set min(value: D | null);\n    private _min;\n    /** The maximum valid date. */\n    get max(): D | null;\n    set max(value: D | null);\n    private _max;\n    /** Function that can be used to filter out dates within the datepicker. */\n    get dateFilter(): DateFilterFn<D | null>;\n    set dateFilter(value: DateFilterFn<D | null>);\n    private _dateFilter;\n    /** The combined form control validator for this input. */\n    protected _validator: ValidatorFn | null;\n    constructor(elementRef: ElementRef<HTMLInputElement>, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats, _formField?: MatFormField | undefined);\n    /**\n     * Gets the element that the datepicker popup should be connected to.\n     * @return The element to connect the popup to.\n     */\n    getConnectedOverlayOrigin(): ElementRef;\n    /** Gets the ID of an element that should be used a description for the calendar overlay. */\n    getOverlayLabelId(): string | null;\n    /** Returns the palette used by the input's form field, if any. */\n    getThemePalette(): ThemePalette;\n    /** Gets the value at which the calendar should start. */\n    getStartValue(): D | null;\n    ngOnDestroy(): void;\n    /** Opens the associated datepicker. */\n    protected _openPopup(): void;\n    protected _getValueFromModel(modelValue: D | null): D | null;\n    protected _assignValueToModel(value: D | null): void;\n    /** Gets the input's minimum date. */\n    _getMinDate(): D | null;\n    /** Gets the input's maximum date. */\n    _getMaxDate(): D | null;\n    /** Gets the input's date filtering function. */\n    protected _getDateFilter(): DateFilterFn<D | null>;\n    protected _shouldHandleChangeEvent(event: DateSelectionModelChange<D>): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerInput<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerInput<any>, \"input[matDatepicker]\", [\"matDatepickerInput\"], { \"matDatepicker\": \"matDatepicker\"; \"min\": \"min\"; \"max\": \"max\"; \"dateFilter\": \"matDatepickerFilter\"; }, {}, never, never, false>;\n}\n\n/** Base class for datepicker inputs. */\ndeclare abstract class MatDatepickerInputBase<S, D = ExtractDateTypeFromSelection<S>> implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy, Validator {\n    protected _elementRef: ElementRef<HTMLInputElement>;\n    _dateAdapter: DateAdapter<D>;\n    private _dateFormats;\n    /** Whether the component has been initialized. */\n    private _isInitialized;\n    /** The value of the input. */\n    get value(): D | null;\n    set value(value: any);\n    protected _model: MatDateSelectionModel<S, D> | undefined;\n    /** Whether the datepicker-input is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Emits when a `change` event is fired on this `<input>`. */\n    readonly dateChange: EventEmitter<MatDatepickerInputEvent<D, S>>;\n    /** Emits when an `input` event is fired on this `<input>`. */\n    readonly dateInput: EventEmitter<MatDatepickerInputEvent<D, S>>;\n    /** Emits when the internal state has changed */\n    readonly stateChanges: Subject<void>;\n    _onTouched: () => void;\n    _validatorOnChange: () => void;\n    private _cvaOnChange;\n    private _valueChangesSubscription;\n    private _localeSubscription;\n    /**\n     * Since the value is kept on the model which is assigned in an Input,\n     * we might get a value before we have a model. This property keeps track\n     * of the value until we have somewhere to assign it.\n     */\n    private _pendingValue;\n    /** The form control validator for whether the input parses. */\n    private _parseValidator;\n    /** The form control validator for the date filter. */\n    private _filterValidator;\n    /** The form control validator for the min date. */\n    private _minValidator;\n    /** The form control validator for the max date. */\n    private _maxValidator;\n    /** Gets the base validator functions. */\n    protected _getValidators(): ValidatorFn[];\n    /** Gets the minimum date for the input. Used for validation. */\n    abstract _getMinDate(): D | null;\n    /** Gets the maximum date for the input. Used for validation. */\n    abstract _getMaxDate(): D | null;\n    /** Gets the date filter function. Used for validation. */\n    protected abstract _getDateFilter(): DateFilterFn<D> | undefined;\n    /** Registers a date selection model with the input. */\n    _registerModel(model: MatDateSelectionModel<S, D>): void;\n    /** Opens the popup associated with the input. */\n    protected abstract _openPopup(): void;\n    /** Assigns a value to the input's model. */\n    protected abstract _assignValueToModel(model: D | null): void;\n    /** Converts a value from the model into a native value for the input. */\n    protected abstract _getValueFromModel(modelValue: S): D | null;\n    /** Combined form control validator for this input. */\n    protected abstract _validator: ValidatorFn | null;\n    /** Predicate that determines whether the input should handle a particular change event. */\n    protected abstract _shouldHandleChangeEvent(event: DateSelectionModelChange<S>): boolean;\n    /** Whether the last value set on the input was valid. */\n    protected _lastValueValid: boolean;\n    constructor(_elementRef: ElementRef<HTMLInputElement>, _dateAdapter: DateAdapter<D>, _dateFormats: MatDateFormats);\n    ngAfterViewInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** @docs-private */\n    registerOnValidatorChange(fn: () => void): void;\n    /** @docs-private */\n    validate(c: AbstractControl): ValidationErrors | null;\n    writeValue(value: D): void;\n    registerOnChange(fn: (value: any) => void): void;\n    registerOnTouched(fn: () => void): void;\n    setDisabledState(isDisabled: boolean): void;\n    _onKeydown(event: KeyboardEvent): void;\n    _onInput(value: string): void;\n    _onChange(): void;\n    /** Handles blur events on the input. */\n    _onBlur(): void;\n    /** Formats a value and sets it on the input element. */\n    protected _formatValue(value: D | null): void;\n    /** Assigns a value to the model. */\n    private _assignValue;\n    /** Whether a value is considered valid. */\n    private _isValidValue;\n    /**\n     * Checks whether a parent control is disabled. This is in place so that it can be overridden\n     * by inputs extending this one which can be placed inside of a group that can be disabled.\n     */\n    protected _parentDisabled(): boolean;\n    /** Programmatically assigns a value to the input. */\n    protected _assignValueProgrammatically(value: D | null): void;\n    /** Gets whether a value matches the current date filter. */\n    _matchesFilter(value: D | null): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerInputBase<any, any>, [null, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerInputBase<any, any>, never, never, { \"value\": \"value\"; \"disabled\": \"disabled\"; }, { \"dateChange\": \"dateChange\"; \"dateInput\": \"dateInput\"; }, never, never, false>;\n}\n\n/**\n * An event used for datepicker input and change events. We don't always have access to a native\n * input or change event because the event may have been triggered by the user clicking on the\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\n */\nexport declare class MatDatepickerInputEvent<D, S = unknown> {\n    /** Reference to the datepicker input component that emitted the event. */\n    target: MatDatepickerInputBase<S, D>;\n    /** Reference to the native input element associated with the datepicker input. */\n    targetElement: HTMLElement;\n    /** The new value for the target datepicker input. */\n    value: D | null;\n    constructor(\n    /** Reference to the datepicker input component that emitted the event. */\n    target: MatDatepickerInputBase<S, D>, \n    /** Reference to the native input element associated with the datepicker input. */\n    targetElement: HTMLElement);\n}\n\n/** Datepicker data that requires internationalization. */\nexport declare class MatDatepickerIntl {\n    /**\n     * Stream that emits whenever the labels here are changed. Use this to notify\n     * components if the labels have changed after initialization.\n     */\n    readonly changes: Subject<void>;\n    /** A label for the calendar popup (used by screen readers). */\n    calendarLabel: string;\n    /** A label for the button used to open the calendar popup (used by screen readers). */\n    openCalendarLabel: string;\n    /** Label for the button used to close the calendar popup. */\n    closeCalendarLabel: string;\n    /** A label for the previous month button (used by screen readers). */\n    prevMonthLabel: string;\n    /** A label for the next month button (used by screen readers). */\n    nextMonthLabel: string;\n    /** A label for the previous year button (used by screen readers). */\n    prevYearLabel: string;\n    /** A label for the next year button (used by screen readers). */\n    nextYearLabel: string;\n    /** A label for the previous multi-year button (used by screen readers). */\n    prevMultiYearLabel: string;\n    /** A label for the next multi-year button (used by screen readers). */\n    nextMultiYearLabel: string;\n    /** A label for the 'switch to month view' button (used by screen readers). */\n    switchToMonthViewLabel: string;\n    /** A label for the 'switch to year view' button (used by screen readers). */\n    switchToMultiYearViewLabel: string;\n    /** A label for the first date of a range of dates (used by screen readers). */\n    startDateLabel: string;\n    /** A label for the last date of a range of dates (used by screen readers). */\n    endDateLabel: string;\n    /** Formats a range of years (used for visuals). */\n    formatYearRange(start: string, end: string): string;\n    /** Formats a label for a range of years (used by screen readers). */\n    formatYearRangeLabel(start: string, end: string): string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerIntl, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatDatepickerIntl>;\n}\n\nexport declare class MatDatepickerModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatDatepickerModule, [typeof i1.MatCalendar, typeof i2.MatCalendarBody, typeof i3.MatDatepicker, typeof i4.MatDatepickerContent, typeof i5.MatDatepickerInput, typeof i6.MatDatepickerToggle, typeof i6.MatDatepickerToggleIcon, typeof i7.MatMonthView, typeof i8.MatYearView, typeof i9.MatMultiYearView, typeof i1.MatCalendarHeader, typeof i10.MatDateRangeInput, typeof i11.MatStartDate, typeof i11.MatEndDate, typeof i12.MatDateRangePicker, typeof i13.MatDatepickerActions, typeof i13.MatDatepickerCancel, typeof i13.MatDatepickerApply], [typeof i14.CommonModule, typeof i15.MatButtonModule, typeof i16.OverlayModule, typeof i17.A11yModule, typeof i18.PortalModule, typeof i19.MatCommonModule], [typeof i20.CdkScrollableModule, typeof i1.MatCalendar, typeof i2.MatCalendarBody, typeof i3.MatDatepicker, typeof i4.MatDatepickerContent, typeof i5.MatDatepickerInput, typeof i6.MatDatepickerToggle, typeof i6.MatDatepickerToggleIcon, typeof i7.MatMonthView, typeof i8.MatYearView, typeof i9.MatMultiYearView, typeof i1.MatCalendarHeader, typeof i10.MatDateRangeInput, typeof i11.MatStartDate, typeof i11.MatEndDate, typeof i12.MatDateRangePicker, typeof i13.MatDatepickerActions, typeof i13.MatDatepickerCancel, typeof i13.MatDatepickerApply]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatDatepickerModule>;\n}\n\n/** A datepicker that can be attached to a {@link MatDatepickerControl}. */\ndeclare interface MatDatepickerPanel<C extends MatDatepickerControl<D>, S, D = ExtractDateTypeFromSelection<S>> {\n    /** Stream that emits whenever the date picker is closed. */\n    closedStream: EventEmitter<void>;\n    /** Color palette to use on the datepicker's calendar. */\n    color: ThemePalette;\n    /** The input element the datepicker is associated with. */\n    datepickerInput: C;\n    /** Whether the datepicker pop-up should be disabled. */\n    disabled: boolean;\n    /** The id for the datepicker's calendar. */\n    id: string;\n    /** Whether the datepicker is open. */\n    opened: boolean;\n    /** Stream that emits whenever the date picker is opened. */\n    openedStream: EventEmitter<void>;\n    /** Emits when the datepicker's state changes. */\n    stateChanges: Subject<void>;\n    /** Opens the datepicker. */\n    open(): void;\n    /** Register an input with the datepicker. */\n    registerInput(input: C): MatDateSelectionModel<S, D>;\n}\n\nexport declare class MatDatepickerToggle<D> implements AfterContentInit, OnChanges, OnDestroy {\n    _intl: MatDatepickerIntl;\n    private _changeDetectorRef;\n    private _stateChanges;\n    /** Datepicker instance that the button will toggle. */\n    datepicker: MatDatepickerPanel<MatDatepickerControl<any>, D>;\n    /** Tabindex for the toggle. */\n    tabIndex: number | null;\n    /** Screen-reader label for the button. */\n    ariaLabel: string;\n    /** Whether the toggle button is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Whether ripples on the toggle should be disabled. */\n    disableRipple: boolean;\n    /** Custom icon set by the consumer. */\n    _customIcon: MatDatepickerToggleIcon;\n    /** Underlying button element. */\n    _button: MatButton;\n    constructor(_intl: MatDatepickerIntl, _changeDetectorRef: ChangeDetectorRef, defaultTabIndex: string);\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    ngAfterContentInit(): void;\n    _open(event: Event): void;\n    private _watchStateChanges;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerToggle<any>, [null, null, { attribute: \"tabindex\"; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerToggle<any>, \"mat-datepicker-toggle\", [\"matDatepickerToggle\"], { \"datepicker\": \"for\"; \"tabIndex\": \"tabIndex\"; \"ariaLabel\": \"aria-label\"; \"disabled\": \"disabled\"; \"disableRipple\": \"disableRipple\"; }, {}, [\"_customIcon\"], [\"[matDatepickerToggleIcon]\"], false>;\n}\n\n/** Can be used to override the icon of a `matDatepickerToggle`. */\nexport declare class MatDatepickerToggleIcon {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerToggleIcon, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerToggleIcon, \"[matDatepickerToggleIcon]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatDateRangeInput<D> implements MatFormFieldControl<DateRange<D>>, MatDatepickerControl<D>, MatDateRangeInputParent<D>, MatDateRangePickerInput<D>, AfterContentInit, OnChanges, OnDestroy {\n    private _changeDetectorRef;\n    private _elementRef;\n    private _dateAdapter;\n    private _formField?;\n    private _closedSubscription;\n    /** Current value of the range input. */\n    get value(): DateRange<D> | null;\n    /** Unique ID for the input. */\n    id: string;\n    /** Whether the control is focused. */\n    focused: boolean;\n    /** Whether the control's label should float. */\n    get shouldLabelFloat(): boolean;\n    /** Name of the form control. */\n    controlType: string;\n    /**\n     * Implemented as a part of `MatFormFieldControl`.\n     * Set the placeholder attribute on `matStartDate` and `matEndDate`.\n     * @docs-private\n     */\n    get placeholder(): string;\n    /** The range picker that this input is associated with. */\n    get rangePicker(): MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>;\n    set rangePicker(rangePicker: MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>);\n    private _rangePicker;\n    /** Whether the input is required. */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    private _required;\n    /** Function that can be used to filter out dates within the date range picker. */\n    get dateFilter(): DateFilterFn<D>;\n    set dateFilter(value: DateFilterFn<D>);\n    private _dateFilter;\n    /** The minimum valid date. */\n    get min(): D | null;\n    set min(value: D | null);\n    private _min;\n    /** The maximum valid date. */\n    get max(): D | null;\n    set max(value: D | null);\n    private _max;\n    /** Whether the input is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    _groupDisabled: boolean;\n    /** Whether the input is in an error state. */\n    get errorState(): boolean;\n    /** Whether the datepicker input is empty. */\n    get empty(): boolean;\n    /** Value for the `aria-describedby` attribute of the inputs. */\n    _ariaDescribedBy: string | null;\n    /** Date selection model currently registered with the input. */\n    private _model;\n    /** Separator text to be shown between the inputs. */\n    separator: string;\n    /** Start of the comparison range that should be shown in the calendar. */\n    comparisonStart: D | null;\n    /** End of the comparison range that should be shown in the calendar. */\n    comparisonEnd: D | null;\n    _startInput: MatStartDate<D>;\n    _endInput: MatEndDate<D>;\n    /**\n     * Implemented as a part of `MatFormFieldControl`.\n     * TODO(crisbeto): change type to `AbstractControlDirective` after #18206 lands.\n     * @docs-private\n     */\n    ngControl: NgControl | null;\n    /** Emits when the input's state has changed. */\n    readonly stateChanges: Subject<void>;\n    constructor(_changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef<HTMLElement>, control: ControlContainer, _dateAdapter: DateAdapter<D>, _formField?: MatFormField | undefined);\n    /**\n     * Implemented as a part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    setDescribedByIds(ids: string[]): void;\n    /**\n     * Implemented as a part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    onContainerClick(): void;\n    ngAfterContentInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Gets the date at which the calendar should start. */\n    getStartValue(): D | null;\n    /** Gets the input's theme palette. */\n    getThemePalette(): ThemePalette;\n    /** Gets the element to which the calendar overlay should be attached. */\n    getConnectedOverlayOrigin(): ElementRef;\n    /** Gets the ID of an element that should be used a description for the calendar overlay. */\n    getOverlayLabelId(): string | null;\n    /** Gets the value that is used to mirror the state input. */\n    _getInputMirrorValue(): string;\n    /** Whether the input placeholders should be hidden. */\n    _shouldHidePlaceholders(): boolean;\n    /** Handles the value in one of the child inputs changing. */\n    _handleChildValueChange(): void;\n    /** Opens the date range picker associated with the input. */\n    _openDatepicker(): void;\n    /** Whether the separate text should be hidden. */\n    _shouldHideSeparator(): boolean | \"\" | null;\n    /** Gets the value for the `aria-labelledby` attribute of the inputs. */\n    _getAriaLabelledby(): string | null;\n    /** Updates the focused state of the range input. */\n    _updateFocus(origin: FocusOrigin): void;\n    /** Re-runs the validators on the start/end inputs. */\n    private _revalidate;\n    /** Registers the current date selection model with the start/end inputs. */\n    private _registerModel;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateRangeInput<any>, [null, null, { optional: true; self: true; }, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDateRangeInput<any>, \"mat-date-range-input\", [\"matDateRangeInput\"], { \"rangePicker\": \"rangePicker\"; \"required\": \"required\"; \"dateFilter\": \"dateFilter\"; \"min\": \"min\"; \"max\": \"max\"; \"disabled\": \"disabled\"; \"separator\": \"separator\"; \"comparisonStart\": \"comparisonStart\"; \"comparisonEnd\": \"comparisonEnd\"; }, {}, [\"_startInput\", \"_endInput\"], [\"input[matStartDate]\", \"input[matEndDate]\"], false>;\n}\n\ndeclare const _MatDateRangeInputBase: _Constructor<CanUpdateErrorState> & _AbstractConstructor<CanUpdateErrorState> & typeof MatDateRangeInputPartBase;\n\n/** Parent component that should be wrapped around `MatStartDate` and `MatEndDate`. */\ndeclare interface MatDateRangeInputParent<D> {\n    id: string;\n    min: D | null;\n    max: D | null;\n    dateFilter: DateFilterFn<D>;\n    rangePicker: {\n        opened: boolean;\n        id: string;\n    };\n    _startInput: MatDateRangeInputPartBase<D>;\n    _endInput: MatDateRangeInputPartBase<D>;\n    _groupDisabled: boolean;\n    _handleChildValueChange(): void;\n    _openDatepicker(): void;\n}\n\n/**\n * Base class for the individual inputs that can be projected inside a `mat-date-range-input`.\n */\ndeclare abstract class MatDateRangeInputPartBase<D> extends MatDatepickerInputBase<DateRange<D>> implements OnInit, DoCheck {\n    _rangeInput: MatDateRangeInputParent<D>;\n    _elementRef: ElementRef<HTMLInputElement>;\n    _defaultErrorStateMatcher: ErrorStateMatcher;\n    private _injector;\n    _parentForm: NgForm;\n    _parentFormGroup: FormGroupDirective;\n    /**\n     * Form control bound to this input part.\n     * @docs-private\n     */\n    ngControl: NgControl;\n    /** @docs-private */\n    abstract updateErrorState(): void;\n    protected abstract _validator: ValidatorFn | null;\n    protected abstract _assignValueToModel(value: D | null): void;\n    protected abstract _getValueFromModel(modelValue: DateRange<D>): D | null;\n    protected readonly _dir: Directionality | null;\n    constructor(_rangeInput: MatDateRangeInputParent<D>, _elementRef: ElementRef<HTMLInputElement>, _defaultErrorStateMatcher: ErrorStateMatcher, _injector: Injector, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats);\n    ngOnInit(): void;\n    ngDoCheck(): void;\n    /** Gets whether the input is empty. */\n    isEmpty(): boolean;\n    /** Gets the placeholder of the input. */\n    _getPlaceholder(): string;\n    /** Focuses the input. */\n    focus(): void;\n    /** Handles `input` events on the input element. */\n    _onInput(value: string): void;\n    /** Opens the datepicker associated with the input. */\n    protected _openPopup(): void;\n    /** Gets the minimum date from the range input. */\n    _getMinDate(): D | null;\n    /** Gets the maximum date from the range input. */\n    _getMaxDate(): D | null;\n    /** Gets the date filter function from the range input. */\n    protected _getDateFilter(): DateFilterFn<D>;\n    protected _parentDisabled(): boolean;\n    protected _shouldHandleChangeEvent({ source }: DateSelectionModelChange<DateRange<D>>): boolean;\n    protected _assignValueProgrammatically(value: D | null): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateRangeInputPartBase<any>, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDateRangeInputPartBase<any>, never, never, {}, {}, never, never, false>;\n}\n\n/** Component responsible for managing the date range picker popup/dialog. */\nexport declare class MatDateRangePicker<D> extends MatDatepickerBase<MatDateRangePickerInput<D>, DateRange<D>, D> {\n    protected _forwardContentValues(instance: MatDatepickerContent<DateRange<D>, D>): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateRangePicker<any>, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDateRangePicker<any>, \"mat-date-range-picker\", [\"matDateRangePicker\"], {}, {}, never, never, false>;\n}\n\n/**\n * Input that can be associated with a date range picker.\n * @docs-private\n */\ndeclare interface MatDateRangePickerInput<D> extends MatDatepickerControl<D> {\n    comparisonStart: D | null;\n    comparisonEnd: D | null;\n}\n\n/** Object that can be provided in order to customize the date range selection behavior. */\nexport declare interface MatDateRangeSelectionStrategy<D> {\n    /**\n     * Called when the user has finished selecting a value.\n     * @param date Date that was selected. Will be null if the user cleared the selection.\n     * @param currentRange Range that is currently show in the calendar.\n     * @param event DOM event that triggered the selection. Currently only corresponds to a `click`\n     *    event, but it may get expanded in the future.\n     */\n    selectionFinished(date: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;\n    /**\n     * Called when the user has activated a new date (e.g. by hovering over\n     * it or moving focus) and the calendar tries to display a date range.\n     *\n     * @param activeDate Date that the user has activated. Will be null if the user moved\n     *    focus to an element that's no a calendar cell.\n     * @param currentRange Range that is currently shown in the calendar.\n     * @param event DOM event that caused the preview to be changed. Will be either a\n     *    `mouseenter`/`mouseleave` or `focus`/`blur` depending on how the user is navigating.\n     */\n    createPreview(activeDate: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;\n}\n\n/**\n * A selection model containing a date selection.\n * @docs-private\n */\nexport declare abstract class MatDateSelectionModel<S, D = ExtractDateTypeFromSelection<S>> implements OnDestroy {\n    /** The current selection. */\n    readonly selection: S;\n    protected _adapter: DateAdapter<D>;\n    private readonly _selectionChanged;\n    /** Emits when the selection has changed. */\n    selectionChanged: Observable<DateSelectionModelChange<S>>;\n    protected constructor(\n    /** The current selection. */\n    selection: S, _adapter: DateAdapter<D>);\n    /**\n     * Updates the current selection in the model.\n     * @param value New selection that should be assigned.\n     * @param source Object that triggered the selection change.\n     */\n    updateSelection(value: S, source: unknown): void;\n    ngOnDestroy(): void;\n    protected _isValidDateInstance(date: D): boolean;\n    /** Adds a date to the current selection. */\n    abstract add(date: D | null): void;\n    /** Checks whether the current selection is valid. */\n    abstract isValid(): boolean;\n    /** Checks whether the current selection is complete. */\n    abstract isComplete(): boolean;\n    /** Clones the selection model. */\n    abstract clone(): MatDateSelectionModel<S, D>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateSelectionModel<any, any>, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatDateSelectionModel<any, any>>;\n}\n\n/** Input for entering the end date in a `mat-date-range-input`. */\nexport declare class MatEndDate<D> extends _MatDateRangeInputBase<D> implements CanUpdateErrorState {\n    /** Validator that checks that the end date isn't before the start date. */\n    private _endValidator;\n    constructor(rangeInput: MatDateRangeInputParent<D>, elementRef: ElementRef<HTMLInputElement>, defaultErrorStateMatcher: ErrorStateMatcher, injector: Injector, parentForm: NgForm, parentFormGroup: FormGroupDirective, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats);\n    protected _validator: ValidatorFn | null;\n    protected _getValueFromModel(modelValue: DateRange<D>): D | null;\n    protected _shouldHandleChangeEvent(change: DateSelectionModelChange<DateRange<D>>): boolean;\n    protected _assignValueToModel(value: D | null): void;\n    _onKeydown(event: KeyboardEvent): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatEndDate<any>, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatEndDate<any>, \"input[matEndDate]\", never, { \"errorStateMatcher\": \"errorStateMatcher\"; }, { \"dateChange\": \"dateChange\"; \"dateInput\": \"dateInput\"; }, never, never, false>;\n}\n\n/**\n * An internal component used to display a single month in the datepicker.\n * @docs-private\n */\nexport declare class MatMonthView<D> implements AfterContentInit, OnChanges, OnDestroy {\n    readonly _changeDetectorRef: ChangeDetectorRef;\n    private _dateFormats;\n    _dateAdapter: DateAdapter<D>;\n    private _dir?;\n    private _rangeStrategy?;\n    private _rerenderSubscription;\n    /** Flag used to filter out space/enter keyup events that originated outside of the view. */\n    private _selectionKeyPressed;\n    /**\n     * The date to display in this month view (everything other than the month and year is ignored).\n     */\n    get activeDate(): D;\n    set activeDate(value: D);\n    private _activeDate;\n    /** The currently selected date. */\n    get selected(): DateRange<D> | D | null;\n    set selected(value: DateRange<D> | D | null);\n    private _selected;\n    /** The minimum selectable date. */\n    get minDate(): D | null;\n    set minDate(value: D | null);\n    private _minDate;\n    /** The maximum selectable date. */\n    get maxDate(): D | null;\n    set maxDate(value: D | null);\n    private _maxDate;\n    /** Function used to filter which dates are selectable. */\n    dateFilter: (date: D) => boolean;\n    /** Function that can be used to add custom CSS classes to dates. */\n    dateClass: MatCalendarCellClassFunction<D>;\n    /** Start of the comparison range. */\n    comparisonStart: D | null;\n    /** End of the comparison range. */\n    comparisonEnd: D | null;\n    /** Emits when a new date is selected. */\n    readonly selectedChange: EventEmitter<D | null>;\n    /** Emits when any date is selected. */\n    readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>>;\n    /** Emits when any date is activated. */\n    readonly activeDateChange: EventEmitter<D>;\n    /** The body of calendar table */\n    _matCalendarBody: MatCalendarBody;\n    /** The label for this month (e.g. \"January 2017\"). */\n    _monthLabel: string;\n    /** Grid of calendar cells representing the dates of the month. */\n    _weeks: MatCalendarCell[][];\n    /** The number of blank cells in the first row before the 1st of the month. */\n    _firstWeekOffset: number;\n    /** Start value of the currently-shown date range. */\n    _rangeStart: number | null;\n    /** End value of the currently-shown date range. */\n    _rangeEnd: number | null;\n    /** Start value of the currently-shown comparison date range. */\n    _comparisonRangeStart: number | null;\n    /** End value of the currently-shown comparison date range. */\n    _comparisonRangeEnd: number | null;\n    /** Start of the preview range. */\n    _previewStart: number | null;\n    /** End of the preview range. */\n    _previewEnd: number | null;\n    /** Whether the user is currently selecting a range of dates. */\n    _isRange: boolean;\n    /** The date of the month that today falls on. Null if today is in another month. */\n    _todayDate: number | null;\n    /** The names of the weekdays. */\n    _weekdays: {\n        long: string;\n        narrow: string;\n    }[];\n    constructor(_changeDetectorRef: ChangeDetectorRef, _dateFormats: MatDateFormats, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined, _rangeStrategy?: MatDateRangeSelectionStrategy<D> | undefined);\n    ngAfterContentInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Handles when a new date is selected. */\n    _dateSelected(event: MatCalendarUserEvent<number>): void;\n    /**\n     * Takes the index of a calendar body cell wrapped in in an event as argument. For the date that\n     * corresponds to the given cell, set `activeDate` to that date and fire `activeDateChange` with\n     * that date.\n     *\n     * This function is used to match each component's model of the active date with the calendar\n     * body cell that was focused. It updates its value of `activeDate` synchronously and updates the\n     * parent's value asynchronously via the `activeDateChange` event. The child component receives an\n     * updated value asynchronously via the `activeCell` Input.\n     */\n    _updateActiveDate(event: MatCalendarUserEvent<number>): void;\n    /** Handles keydown events on the calendar body when calendar is in month view. */\n    _handleCalendarBodyKeydown(event: KeyboardEvent): void;\n    /** Handles keyup events on the calendar body when calendar is in month view. */\n    _handleCalendarBodyKeyup(event: KeyboardEvent): void;\n    /** Initializes this month view. */\n    _init(): void;\n    /** Focuses the active cell after the microtask queue is empty. */\n    _focusActiveCell(movePreview?: boolean): void;\n    /** Focuses the active cell after change detection has run and the microtask queue is empty. */\n    _focusActiveCellAfterViewChecked(): void;\n    /** Called when the user has activated a new cell and the preview needs to be updated. */\n    _previewChanged({ event, value: cell }: MatCalendarUserEvent<MatCalendarCell<D> | null>): void;\n    /**\n     * Takes a day of the month and returns a new date in the same month and year as the currently\n     *  active date. The returned date will have the same day of the month as the argument date.\n     */\n    private _getDateFromDayOfMonth;\n    /** Initializes the weekdays. */\n    private _initWeekdays;\n    /** Creates MatCalendarCells for the dates in this month. */\n    private _createWeekCells;\n    /** Date filter for the month */\n    private _shouldEnableDate;\n    /**\n     * Gets the date in this month that the given Date falls on.\n     * Returns null if the given Date is in another month.\n     */\n    private _getDateInCurrentMonth;\n    /** Checks whether the 2 dates are non-null and fall within the same month of the same year. */\n    private _hasSameMonthAndYear;\n    /** Gets the value that will be used to one cell to another. */\n    private _getCellCompareValue;\n    /** Determines whether the user has the RTL layout direction. */\n    private _isRtl;\n    /** Sets the current range based on a model value. */\n    private _setRanges;\n    /** Gets whether a date can be selected in the month view. */\n    private _canSelect;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatMonthView<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatMonthView<any>, \"mat-month-view\", [\"matMonthView\"], { \"activeDate\": \"activeDate\"; \"selected\": \"selected\"; \"minDate\": \"minDate\"; \"maxDate\": \"maxDate\"; \"dateFilter\": \"dateFilter\"; \"dateClass\": \"dateClass\"; \"comparisonStart\": \"comparisonStart\"; \"comparisonEnd\": \"comparisonEnd\"; }, { \"selectedChange\": \"selectedChange\"; \"_userSelection\": \"_userSelection\"; \"activeDateChange\": \"activeDateChange\"; }, never, never, false>;\n}\n\n/**\n * An internal component used to display a year selector in the datepicker.\n * @docs-private\n */\nexport declare class MatMultiYearView<D> implements AfterContentInit, OnDestroy {\n    private _changeDetectorRef;\n    _dateAdapter: DateAdapter<D>;\n    private _dir?;\n    private _rerenderSubscription;\n    /** Flag used to filter out space/enter keyup events that originated outside of the view. */\n    private _selectionKeyPressed;\n    /** The date to display in this multi-year view (everything other than the year is ignored). */\n    get activeDate(): D;\n    set activeDate(value: D);\n    private _activeDate;\n    /** The currently selected date. */\n    get selected(): DateRange<D> | D | null;\n    set selected(value: DateRange<D> | D | null);\n    private _selected;\n    /** The minimum selectable date. */\n    get minDate(): D | null;\n    set minDate(value: D | null);\n    private _minDate;\n    /** The maximum selectable date. */\n    get maxDate(): D | null;\n    set maxDate(value: D | null);\n    private _maxDate;\n    /** A function used to filter which dates are selectable. */\n    dateFilter: (date: D) => boolean;\n    /** Function that can be used to add custom CSS classes to date cells. */\n    dateClass: MatCalendarCellClassFunction<D>;\n    /** Emits when a new year is selected. */\n    readonly selectedChange: EventEmitter<D>;\n    /** Emits the selected year. This doesn't imply a change on the selected date */\n    readonly yearSelected: EventEmitter<D>;\n    /** Emits when any date is activated. */\n    readonly activeDateChange: EventEmitter<D>;\n    /** The body of calendar table */\n    _matCalendarBody: MatCalendarBody;\n    /** Grid of calendar cells representing the currently displayed years. */\n    _years: MatCalendarCell[][];\n    /** The year that today falls on. */\n    _todayYear: number;\n    /** The year of the selected date. Null if the selected date is null. */\n    _selectedYear: number | null;\n    constructor(_changeDetectorRef: ChangeDetectorRef, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Initializes this multi-year view. */\n    _init(): void;\n    /** Handles when a new year is selected. */\n    _yearSelected(event: MatCalendarUserEvent<number>): void;\n    /**\n     * Takes the index of a calendar body cell wrapped in in an event as argument. For the date that\n     * corresponds to the given cell, set `activeDate` to that date and fire `activeDateChange` with\n     * that date.\n     *\n     * This function is used to match each component's model of the active date with the calendar\n     * body cell that was focused. It updates its value of `activeDate` synchronously and updates the\n     * parent's value asynchronously via the `activeDateChange` event. The child component receives an\n     * updated value asynchronously via the `activeCell` Input.\n     */\n    _updateActiveDate(event: MatCalendarUserEvent<number>): void;\n    /** Handles keydown events on the calendar body when calendar is in multi-year view. */\n    _handleCalendarBodyKeydown(event: KeyboardEvent): void;\n    /** Handles keyup events on the calendar body when calendar is in multi-year view. */\n    _handleCalendarBodyKeyup(event: KeyboardEvent): void;\n    _getActiveCell(): number;\n    /** Focuses the active cell after the microtask queue is empty. */\n    _focusActiveCell(): void;\n    /** Focuses the active cell after change detection has run and the microtask queue is empty. */\n    _focusActiveCellAfterViewChecked(): void;\n    /**\n     * Takes a year and returns a new date on the same day and month as the currently active date\n     *  The returned date will have the same year as the argument date.\n     */\n    private _getDateFromYear;\n    /** Creates an MatCalendarCell for the given year. */\n    private _createCellForYear;\n    /** Whether the given year is enabled. */\n    private _shouldEnableYear;\n    /** Determines whether the user has the RTL layout direction. */\n    private _isRtl;\n    /** Sets the currently-highlighted year based on a model value. */\n    private _setSelectedYear;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatMultiYearView<any>, [null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatMultiYearView<any>, \"mat-multi-year-view\", [\"matMultiYearView\"], { \"activeDate\": \"activeDate\"; \"selected\": \"selected\"; \"minDate\": \"minDate\"; \"maxDate\": \"maxDate\"; \"dateFilter\": \"dateFilter\"; \"dateClass\": \"dateClass\"; }, { \"selectedChange\": \"selectedChange\"; \"yearSelected\": \"yearSelected\"; \"activeDateChange\": \"activeDateChange\"; }, never, never, false>;\n}\n\n/**\n * A selection model that contains a date range.\n * @docs-private\n */\nexport declare class MatRangeDateSelectionModel<D> extends MatDateSelectionModel<DateRange<D>, D> {\n    constructor(adapter: DateAdapter<D>);\n    /**\n     * Adds a date to the current selection. In the case of a date range selection, the added date\n     * fills in the next `null` value in the range. If both the start and the end already have a date,\n     * the selection is reset so that the given date is the new `start` and the `end` is null.\n     */\n    add(date: D | null): void;\n    /** Checks whether the current selection is valid. */\n    isValid(): boolean;\n    /**\n     * Checks whether the current selection is complete. In the case of a date range selection, this\n     * is true if the current selection has a non-null `start` and `end`.\n     */\n    isComplete(): boolean;\n    /** Clones the selection model. */\n    clone(): MatRangeDateSelectionModel<D>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRangeDateSelectionModel<any>, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatRangeDateSelectionModel<any>>;\n}\n\n/**\n * A selection model that contains a single date.\n * @docs-private\n */\nexport declare class MatSingleDateSelectionModel<D> extends MatDateSelectionModel<D | null, D> {\n    constructor(adapter: DateAdapter<D>);\n    /**\n     * Adds a date to the current selection. In the case of a single date selection, the added date\n     * simply overwrites the previous selection\n     */\n    add(date: D | null): void;\n    /** Checks whether the current selection is valid. */\n    isValid(): boolean;\n    /**\n     * Checks whether the current selection is complete. In the case of a single date selection, this\n     * is true if the current selection is not null.\n     */\n    isComplete(): boolean;\n    /** Clones the selection model. */\n    clone(): MatSingleDateSelectionModel<D>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSingleDateSelectionModel<any>, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatSingleDateSelectionModel<any>>;\n}\n\n/** Input for entering the start date in a `mat-date-range-input`. */\nexport declare class MatStartDate<D> extends _MatDateRangeInputBase<D> implements CanUpdateErrorState {\n    /** Validator that checks that the start date isn't after the end date. */\n    private _startValidator;\n    constructor(rangeInput: MatDateRangeInputParent<D>, elementRef: ElementRef<HTMLInputElement>, defaultErrorStateMatcher: ErrorStateMatcher, injector: Injector, parentForm: NgForm, parentFormGroup: FormGroupDirective, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats);\n    protected _validator: ValidatorFn | null;\n    protected _getValueFromModel(modelValue: DateRange<D>): D | null;\n    protected _shouldHandleChangeEvent(change: DateSelectionModelChange<DateRange<D>>): boolean;\n    protected _assignValueToModel(value: D | null): void;\n    protected _formatValue(value: D | null): void;\n    /** Gets the value that should be used when mirroring the input's size. */\n    getMirrorValue(): string;\n    _onKeydown(event: KeyboardEvent): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStartDate<any>, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStartDate<any>, \"input[matStartDate]\", never, { \"errorStateMatcher\": \"errorStateMatcher\"; }, { \"dateChange\": \"dateChange\"; \"dateInput\": \"dateInput\"; }, never, never, false>;\n}\n\n/**\n * An internal component used to display a single year in the datepicker.\n * @docs-private\n */\nexport declare class MatYearView<D> implements AfterContentInit, OnDestroy {\n    readonly _changeDetectorRef: ChangeDetectorRef;\n    private _dateFormats;\n    _dateAdapter: DateAdapter<D>;\n    private _dir?;\n    private _rerenderSubscription;\n    /** Flag used to filter out space/enter keyup events that originated outside of the view. */\n    private _selectionKeyPressed;\n    /** The date to display in this year view (everything other than the year is ignored). */\n    get activeDate(): D;\n    set activeDate(value: D);\n    private _activeDate;\n    /** The currently selected date. */\n    get selected(): DateRange<D> | D | null;\n    set selected(value: DateRange<D> | D | null);\n    private _selected;\n    /** The minimum selectable date. */\n    get minDate(): D | null;\n    set minDate(value: D | null);\n    private _minDate;\n    /** The maximum selectable date. */\n    get maxDate(): D | null;\n    set maxDate(value: D | null);\n    private _maxDate;\n    /** A function used to filter which dates are selectable. */\n    dateFilter: (date: D) => boolean;\n    /** Function that can be used to add custom CSS classes to date cells. */\n    dateClass: MatCalendarCellClassFunction<D>;\n    /** Emits when a new month is selected. */\n    readonly selectedChange: EventEmitter<D>;\n    /** Emits the selected month. This doesn't imply a change on the selected date */\n    readonly monthSelected: EventEmitter<D>;\n    /** Emits when any date is activated. */\n    readonly activeDateChange: EventEmitter<D>;\n    /** The body of calendar table */\n    _matCalendarBody: MatCalendarBody;\n    /** Grid of calendar cells representing the months of the year. */\n    _months: MatCalendarCell[][];\n    /** The label for this year (e.g. \"2017\"). */\n    _yearLabel: string;\n    /** The month in this year that today falls on. Null if today is in a different year. */\n    _todayMonth: number | null;\n    /**\n     * The month in this year that the selected Date falls on.\n     * Null if the selected Date is in a different year.\n     */\n    _selectedMonth: number | null;\n    constructor(_changeDetectorRef: ChangeDetectorRef, _dateFormats: MatDateFormats, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Handles when a new month is selected. */\n    _monthSelected(event: MatCalendarUserEvent<number>): void;\n    /**\n     * Takes the index of a calendar body cell wrapped in in an event as argument. For the date that\n     * corresponds to the given cell, set `activeDate` to that date and fire `activeDateChange` with\n     * that date.\n     *\n     * This function is used to match each component's model of the active date with the calendar\n     * body cell that was focused. It updates its value of `activeDate` synchronously and updates the\n     * parent's value asynchronously via the `activeDateChange` event. The child component receives an\n     * updated value asynchronously via the `activeCell` Input.\n     */\n    _updateActiveDate(event: MatCalendarUserEvent<number>): void;\n    /** Handles keydown events on the calendar body when calendar is in year view. */\n    _handleCalendarBodyKeydown(event: KeyboardEvent): void;\n    /** Handles keyup events on the calendar body when calendar is in year view. */\n    _handleCalendarBodyKeyup(event: KeyboardEvent): void;\n    /** Initializes this year view. */\n    _init(): void;\n    /** Focuses the active cell after the microtask queue is empty. */\n    _focusActiveCell(): void;\n    /** Schedules the matCalendarBody to focus the active cell after change detection has run */\n    _focusActiveCellAfterViewChecked(): void;\n    /**\n     * Gets the month in this year that the given Date falls on.\n     * Returns null if the given Date is in another year.\n     */\n    private _getMonthInCurrentYear;\n    /**\n     * Takes a month and returns a new date in the same day and year as the currently active date.\n     *  The returned date will have the same month as the argument date.\n     */\n    private _getDateFromMonth;\n    /** Creates an MatCalendarCell for the given month. */\n    private _createCellForMonth;\n    /** Whether the given month is enabled. */\n    private _shouldEnableMonth;\n    /**\n     * Tests whether the combination month/year is after this.maxDate, considering\n     * just the month and year of this.maxDate\n     */\n    private _isYearAndMonthAfterMaxDate;\n    /**\n     * Tests whether the combination month/year is before this.minDate, considering\n     * just the month and year of this.minDate\n     */\n    private _isYearAndMonthBeforeMinDate;\n    /** Determines whether the user has the RTL layout direction. */\n    private _isRtl;\n    /** Sets the currently-selected month based on a model value. */\n    private _setSelectedMonth;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatYearView<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatYearView<any>, \"mat-year-view\", [\"matYearView\"], { \"activeDate\": \"activeDate\"; \"selected\": \"selected\"; \"minDate\": \"minDate\"; \"maxDate\": \"maxDate\"; \"dateFilter\": \"dateFilter\"; \"dateClass\": \"dateClass\"; }, { \"selectedChange\": \"selectedChange\"; \"monthSelected\": \"monthSelected\"; \"activeDateChange\": \"activeDateChange\"; }, never, never, false>;\n}\n\nexport declare const yearsPerPage = 24;\n\nexport declare const yearsPerRow = 4;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/datepicker/testing/index.d.ts",
      "node_modules/@angular/material/datepicker/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\n\n/** A set of criteria that can be used to filter a list of calendar cell instances. */\nexport declare interface CalendarCellHarnessFilters extends BaseHarnessFilters {\n    /** Filters based on the text of the cell. */\n    text?: string | RegExp;\n    /** Filters based on whether the cell is selected. */\n    selected?: boolean;\n    /** Filters based on whether the cell is activated using keyboard navigation */\n    active?: boolean;\n    /** Filters based on whether the cell is disabled. */\n    disabled?: boolean;\n    /** Filters based on whether the cell represents today's date. */\n    today?: boolean;\n    /** Filters based on whether the cell is inside of the main range. */\n    inRange?: boolean;\n    /** Filters based on whether the cell is inside of the comparison range. */\n    inComparisonRange?: boolean;\n    /** Filters based on whether the cell is inside of the preview range. */\n    inPreviewRange?: boolean;\n}\n\n/** A set of criteria that can be used to filter a list of calendar instances. */\nexport declare interface CalendarHarnessFilters extends BaseHarnessFilters {\n}\n\n/** Possible views of a `MatCalendarHarness`. */\nexport declare const enum CalendarView {\n    MONTH = 0,\n    YEAR = 1,\n    MULTI_YEAR = 2\n}\n\n/** A set of criteria that can be used to filter a list of datepicker input instances. */\nexport declare interface DatepickerInputHarnessFilters extends BaseHarnessFilters {\n    /** Filters based on the value of the input. */\n    value?: string | RegExp;\n    /** Filters based on the placeholder text of the input. */\n    placeholder?: string | RegExp;\n}\n\n/** A set of criteria that can be used to filter a list of datepicker toggle instances. */\nexport declare interface DatepickerToggleHarnessFilters extends BaseHarnessFilters {\n}\n\n/** Interface for a test harness that can open and close a calendar. */\ndeclare interface DatepickerTrigger {\n    isCalendarOpen(): Promise<boolean>;\n    openCalendar(): Promise<void>;\n    closeCalendar(): Promise<void>;\n    hasCalendar(): Promise<boolean>;\n    getCalendar(filter?: CalendarHarnessFilters): Promise<MatCalendarHarness>;\n}\n\n/** Base class for harnesses that can trigger a calendar. */\ndeclare abstract class DatepickerTriggerHarnessBase extends ComponentHarness implements DatepickerTrigger {\n    /** Whether the trigger is disabled. */\n    abstract isDisabled(): Promise<boolean>;\n    /** Whether the calendar associated with the trigger is open. */\n    abstract isCalendarOpen(): Promise<boolean>;\n    /** Opens the calendar associated with the trigger. */\n    protected abstract _openCalendar(): Promise<void>;\n    /** Opens the calendar if the trigger is enabled and it has a calendar. */\n    openCalendar(): Promise<void>;\n    /** Closes the calendar if it is open. */\n    closeCalendar(): Promise<void>;\n    /** Gets whether there is a calendar associated with the trigger. */\n    hasCalendar(): Promise<boolean>;\n    /**\n     * Gets the `MatCalendarHarness` that is associated with the trigger.\n     * @param filter Optionally filters which calendar is included.\n     */\n    getCalendar(filter?: CalendarHarnessFilters): Promise<MatCalendarHarness>;\n}\n\n/** A set of criteria that can be used to filter a list of date range input instances. */\nexport declare interface DateRangeInputHarnessFilters extends BaseHarnessFilters {\n    /** Filters based on the value of the input. */\n    value?: string | RegExp;\n}\n\n/** Harness for interacting with a standard Material calendar cell in tests. */\nexport declare class MatCalendarCellHarness extends ComponentHarness {\n    static hostSelector: string;\n    /** Reference to the inner content element inside the cell. */\n    private _content;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatCalendarCellHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which cell instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: CalendarCellHarnessFilters): HarnessPredicate<MatCalendarCellHarness>;\n    /** Gets the text of the calendar cell. */\n    getText(): Promise<string>;\n    /** Gets the aria-label of the calendar cell. */\n    getAriaLabel(): Promise<string>;\n    /** Whether the cell is selected. */\n    isSelected(): Promise<boolean>;\n    /** Whether the cell is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the cell is currently activated using keyboard navigation. */\n    isActive(): Promise<boolean>;\n    /** Whether the cell represents today's date. */\n    isToday(): Promise<boolean>;\n    /** Selects the calendar cell. Won't do anything if the cell is disabled. */\n    select(): Promise<void>;\n    /** Hovers over the calendar cell. */\n    hover(): Promise<void>;\n    /** Moves the mouse away from the calendar cell. */\n    mouseAway(): Promise<void>;\n    /** Focuses the calendar cell. */\n    focus(): Promise<void>;\n    /** Removes focus from the calendar cell. */\n    blur(): Promise<void>;\n    /** Whether the cell is the start of the main range. */\n    isRangeStart(): Promise<boolean>;\n    /** Whether the cell is the end of the main range. */\n    isRangeEnd(): Promise<boolean>;\n    /** Whether the cell is part of the main range. */\n    isInRange(): Promise<boolean>;\n    /** Whether the cell is the start of the comparison range. */\n    isComparisonRangeStart(): Promise<boolean>;\n    /** Whether the cell is the end of the comparison range. */\n    isComparisonRangeEnd(): Promise<boolean>;\n    /** Whether the cell is inside of the comparison range. */\n    isInComparisonRange(): Promise<boolean>;\n    /** Whether the cell is the start of the preview range. */\n    isPreviewRangeStart(): Promise<boolean>;\n    /** Whether the cell is the end of the preview range. */\n    isPreviewRangeEnd(): Promise<boolean>;\n    /** Whether the cell is inside of the preview range. */\n    isInPreviewRange(): Promise<boolean>;\n    /** Returns whether the cell has a particular CSS class-based state. */\n    private _hasState;\n}\n\n/** Harness for interacting with a standard Material calendar in tests. */\nexport declare class MatCalendarHarness extends ComponentHarness {\n    static hostSelector: string;\n    /** Queries for the calendar's period toggle button. */\n    private _periodButton;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatCalendarHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which calendar instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: CalendarHarnessFilters): HarnessPredicate<MatCalendarHarness>;\n    /**\n     * Gets a list of cells inside the calendar.\n     * @param filter Optionally filters which cells are included.\n     */\n    getCells(filter?: CalendarCellHarnessFilters): Promise<MatCalendarCellHarness[]>;\n    /** Gets the current view that is being shown inside the calendar. */\n    getCurrentView(): Promise<CalendarView>;\n    /** Gets the label of the current calendar view. */\n    getCurrentViewLabel(): Promise<string>;\n    /** Changes the calendar view by clicking on the view toggle button. */\n    changeView(): Promise<void>;\n    /** Goes to the next page of the current view (e.g. next month when inside the month view). */\n    next(): Promise<void>;\n    /**\n     * Goes to the previous page of the current view\n     * (e.g. previous month when inside the month view).\n     */\n    previous(): Promise<void>;\n    /**\n     * Selects a cell in the current calendar view.\n     * @param filter An optional filter to apply to the cells. The first cell matching the filter\n     *     will be selected.\n     */\n    selectCell(filter?: CalendarCellHarnessFilters): Promise<void>;\n}\n\n/** Harness for interacting with a standard Material datepicker inputs in tests. */\nexport declare class MatDatepickerInputHarness extends MatDatepickerInputHarnessBase implements DatepickerTrigger {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatDatepickerInputHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DatepickerInputHarnessFilters): HarnessPredicate<MatDatepickerInputHarness>;\n    /** Gets whether the calendar associated with the input is open. */\n    isCalendarOpen(): Promise<boolean>;\n    /** Opens the calendar associated with the input. */\n    openCalendar(): Promise<void>;\n    /** Closes the calendar associated with the input. */\n    closeCalendar(): Promise<void>;\n    /** Whether a calendar is associated with the input. */\n    hasCalendar(): Promise<boolean>;\n    /**\n     * Gets the `MatCalendarHarness` that is associated with the trigger.\n     * @param filter Optionally filters which calendar is included.\n     */\n    getCalendar(filter?: CalendarHarnessFilters): Promise<MatCalendarHarness>;\n}\n\n/** Base class for datepicker input harnesses. */\ndeclare abstract class MatDatepickerInputHarnessBase extends MatFormFieldControlHarness {\n    /** Whether the input is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the input is required. */\n    isRequired(): Promise<boolean>;\n    /** Gets the value of the input. */\n    getValue(): Promise<string>;\n    /**\n     * Sets the value of the input. The value will be set by simulating\n     * keypresses that correspond to the given value.\n     */\n    setValue(newValue: string): Promise<void>;\n    /** Gets the placeholder of the input. */\n    getPlaceholder(): Promise<string>;\n    /**\n     * Focuses the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    focus(): Promise<void>;\n    /**\n     * Blurs the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    blur(): Promise<void>;\n    /** Whether the input is focused. */\n    isFocused(): Promise<boolean>;\n    /** Gets the formatted minimum date for the input's value. */\n    getMin(): Promise<string | null>;\n    /** Gets the formatted maximum date for the input's value. */\n    getMax(): Promise<string | null>;\n}\n\n/** Harness for interacting with a standard Material datepicker toggle in tests. */\nexport declare class MatDatepickerToggleHarness extends DatepickerTriggerHarnessBase {\n    static hostSelector: string;\n    /** The clickable button inside the toggle. */\n    private _button;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatDatepickerToggleHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which datepicker toggle instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DatepickerToggleHarnessFilters): HarnessPredicate<MatDatepickerToggleHarness>;\n    /** Gets whether the calendar associated with the toggle is open. */\n    isCalendarOpen(): Promise<boolean>;\n    /** Whether the toggle is disabled. */\n    isDisabled(): Promise<boolean>;\n    protected _openCalendar(): Promise<void>;\n}\n\n/** Harness for interacting with a standard Material date range input in tests. */\nexport declare class MatDateRangeInputHarness extends DatepickerTriggerHarnessBase {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatDateRangeInputHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DateRangeInputHarnessFilters): HarnessPredicate<MatDateRangeInputHarness>;\n    /** Gets the combined value of the start and end inputs, including the separator. */\n    getValue(): Promise<string>;\n    /** Gets the inner start date input inside the range input. */\n    getStartInput(): Promise<MatStartDateHarness>;\n    /** Gets the inner start date input inside the range input. */\n    getEndInput(): Promise<MatEndDateHarness>;\n    /** Gets the separator text between the values of the two inputs. */\n    getSeparator(): Promise<string>;\n    /** Gets whether the range input is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets whether the range input is required. */\n    isRequired(): Promise<boolean>;\n    /** Opens the calendar associated with the input. */\n    isCalendarOpen(): Promise<boolean>;\n    protected _openCalendar(): Promise<void>;\n}\n\n/** Harness for interacting with a standard Material date range end input in tests. */\nexport declare class MatEndDateHarness extends MatDatepickerInputHarnessBase {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatEndDateHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DatepickerInputHarnessFilters): HarnessPredicate<MatEndDateHarness>;\n}\n\n/** Harness for interacting with a standard Material date range start input in tests. */\nexport declare class MatStartDateHarness extends MatDatepickerInputHarnessBase {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatStartDateHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DatepickerInputHarnessFilters): HarnessPredicate<MatStartDateHarness>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/dialog/index.d.ts",
      "node_modules/@angular/material/dialog/index.d.ts"
    ],
    "content": "import { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { CdkDialogContainer } from '@angular/cdk/dialog';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { ComponentType } from '@angular/cdk/portal';\nimport { DialogRef } from '@angular/cdk/dialog';\nimport { Direction } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/cdk/dialog';\nimport * as i4 from '@angular/cdk/overlay';\nimport * as i5 from '@angular/cdk/portal';\nimport * as i6 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { InteractivityChecker } from '@angular/cdk/a11y';\nimport { Location as Location_2 } from '@angular/common';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { OverlayContainer } from '@angular/cdk/overlay';\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplateRef } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/** Options for where to set focus to automatically on dialog open */\nexport declare type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\n/**\n * Closes the dialog with the specified interaction type. This is currently not part of\n * `MatDialogRef` as that would conflict with custom dialog ref mocks provided in tests.\n * More details. See: https://github.com/angular/components/pull/9257#issuecomment-651342226.\n */\nexport declare function _closeDialogVia<R>(ref: MatDialogRef<R>, interactionType: FocusOrigin, result?: R): void;\n\n/** Event that captures the state of dialog container animations. */\ndeclare interface DialogAnimationEvent {\n    state: 'opened' | 'opening' | 'closing' | 'closed';\n    totalTime: number;\n}\n\n/** Possible overrides for a dialog's position. */\nexport declare interface DialogPosition {\n    /** Override for the dialog's top position. */\n    top?: string;\n    /** Override for the dialog's bottom position. */\n    bottom?: string;\n    /** Override for the dialog's left position. */\n    left?: string;\n    /** Override for the dialog's right position. */\n    right?: string;\n}\n\n/** Valid ARIA roles for a dialog element. */\nexport declare type DialogRole = 'dialog' | 'alertdialog';\n\ndeclare namespace i1 {\n    export {\n        _MatDialogContainerBase,\n        MatDialogContainer\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatDialogClose,\n        MatDialogTitle,\n        MatDialogContent,\n        MatDialogActions\n    }\n}\n\n/** Injection token that can be used to access the data that was passed in to a dialog. */\nexport declare const MAT_DIALOG_DATA: InjectionToken<any>;\n\n/** Injection token that can be used to specify default dialog options. */\nexport declare const MAT_DIALOG_DEFAULT_OPTIONS: InjectionToken<MatDialogConfig<any>>;\n\n/** Injection token that determines the scroll handling while the dialog is open. */\nexport declare const MAT_DIALOG_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\nexport declare function MAT_DIALOG_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/** @docs-private */\nexport declare const MAT_DIALOG_SCROLL_STRATEGY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\nexport declare function MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/**\n * Service to open Material Design modal dialogs.\n */\nexport declare class MatDialog extends _MatDialogBase<MatDialogContainer> {\n    constructor(overlay: Overlay, injector: Injector, \n    /**\n     * @deprecated `_location` parameter to be removed.\n     * @breaking-change 10.0.0\n     */\n    _location: Location_2, defaultOptions: MatDialogConfig, scrollStrategy: any, parentDialog: MatDialog, \n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 15.0.0\n     */\n    overlayContainer: OverlayContainer, \n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    animationMode?: 'NoopAnimations' | 'BrowserAnimations');\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDialog, [null, null, { optional: true; }, { optional: true; }, null, { optional: true; skipSelf: true; }, null, { optional: true; }]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatDialog>;\n}\n\n/**\n * Container for the bottom action buttons in a dialog.\n * Stays fixed to the bottom when scrolling.\n */\nexport declare class MatDialogActions {\n    /**\n     * Horizontal alignment of action buttons.\n     */\n    align?: 'start' | 'center' | 'end';\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDialogActions, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDialogActions, \"[mat-dialog-actions], mat-dialog-actions, [matDialogActions]\", never, { \"align\": \"align\"; }, {}, never, never, false>;\n}\n\n/**\n * Animations used by MatDialog.\n * @docs-private\n */\nexport declare const matDialogAnimations: {\n    readonly dialogContainer: AnimationTriggerMetadata;\n};\n\n/**\n * Base class for dialog services. The base dialog service allows\n * for arbitrary dialog refs and dialog container components.\n */\nexport declare abstract class _MatDialogBase<C extends _MatDialogContainerBase> implements OnDestroy {\n    private _overlay;\n    private _defaultOptions;\n    private _parentDialog;\n    private _dialogRefConstructor;\n    private _dialogContainerType;\n    private _dialogDataToken;\n    private readonly _openDialogsAtThisLevel;\n    private readonly _afterAllClosedAtThisLevel;\n    private readonly _afterOpenedAtThisLevel;\n    private _scrollStrategy;\n    protected _idPrefix: string;\n    private _dialog;\n    /** Keeps track of the currently-open dialogs. */\n    get openDialogs(): MatDialogRef<any>[];\n    /** Stream that emits when a dialog has been opened. */\n    get afterOpened(): Subject<MatDialogRef<any>>;\n    private _getAfterAllClosed;\n    /**\n     * Stream that emits when all open dialog have finished closing.\n     * Will emit on subscribe if there are no open dialogs to begin with.\n     */\n    readonly afterAllClosed: Observable<void>;\n    constructor(_overlay: Overlay, injector: Injector, _defaultOptions: MatDialogConfig | undefined, _parentDialog: _MatDialogBase<C> | undefined, \n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 15.0.0\n     */\n    _overlayContainer: OverlayContainer, scrollStrategy: any, _dialogRefConstructor: Type<MatDialogRef<any>>, _dialogContainerType: Type<C>, _dialogDataToken: InjectionToken<any>, \n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    _animationMode?: 'NoopAnimations' | 'BrowserAnimations');\n    /**\n     * Opens a modal dialog containing the given component.\n     * @param component Type of the component to load into the dialog.\n     * @param config Extra configuration options.\n     * @returns Reference to the newly-opened dialog.\n     */\n    open<T, D = any, R = any>(component: ComponentType<T>, config?: MatDialogConfig<D>): MatDialogRef<T, R>;\n    /**\n     * Opens a modal dialog containing the given template.\n     * @param template TemplateRef to instantiate as the dialog content.\n     * @param config Extra configuration options.\n     * @returns Reference to the newly-opened dialog.\n     */\n    open<T, D = any, R = any>(template: TemplateRef<T>, config?: MatDialogConfig<D>): MatDialogRef<T, R>;\n    open<T, D = any, R = any>(template: ComponentType<T> | TemplateRef<T>, config?: MatDialogConfig<D>): MatDialogRef<T, R>;\n    /**\n     * Closes all of the currently-open dialogs.\n     */\n    closeAll(): void;\n    /**\n     * Finds an open dialog by its id.\n     * @param id ID to use when looking up the dialog.\n     */\n    getDialogById(id: string): MatDialogRef<any> | undefined;\n    ngOnDestroy(): void;\n    private _closeDialogs;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatDialogBase<any>, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<_MatDialogBase<any>>;\n}\n\n/**\n * Button that will close the current dialog.\n */\nexport declare class MatDialogClose implements OnInit, OnChanges {\n    /**\n     * Reference to the containing dialog.\n     * @deprecated `dialogRef` property to become private.\n     * @breaking-change 13.0.0\n     */\n    dialogRef: MatDialogRef<any>;\n    private _elementRef;\n    private _dialog;\n    /** Screen reader label for the button. */\n    ariaLabel: string;\n    /** Default to \"button\" to prevents accidental form submits. */\n    type: 'submit' | 'button' | 'reset';\n    /** Dialog close input. */\n    dialogResult: any;\n    _matDialogClose: any;\n    constructor(\n    /**\n     * Reference to the containing dialog.\n     * @deprecated `dialogRef` property to become private.\n     * @breaking-change 13.0.0\n     */\n    dialogRef: MatDialogRef<any>, _elementRef: ElementRef<HTMLElement>, _dialog: MatDialog);\n    ngOnInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    _onButtonClick(event: MouseEvent): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDialogClose, [{ optional: true; }, null, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDialogClose, \"[mat-dialog-close], [matDialogClose]\", [\"matDialogClose\"], { \"ariaLabel\": \"aria-label\"; \"type\": \"type\"; \"dialogResult\": \"mat-dialog-close\"; \"_matDialogClose\": \"matDialogClose\"; }, {}, never, never, false>;\n}\n\n/**\n * Configuration for opening a modal dialog with the MatDialog service.\n */\nexport declare class MatDialogConfig<D = any> {\n    /**\n     * Where the attached component should live in Angular's *logical* component tree.\n     * This affects what is available for injection and the change detection order for the\n     * component instantiated inside of the dialog. This does not affect where the dialog\n     * content will be rendered.\n     */\n    viewContainerRef?: ViewContainerRef;\n    /**\n     * Injector used for the instantiation of the component to be attached. If provided,\n     * takes precedence over the injector indirectly provided by `ViewContainerRef`.\n     */\n    injector?: Injector;\n    /** ID for the dialog. If omitted, a unique one will be generated. */\n    id?: string;\n    /** The ARIA role of the dialog element. */\n    role?: DialogRole;\n    /** Custom class for the overlay pane. */\n    panelClass?: string | string[];\n    /** Whether the dialog has a backdrop. */\n    hasBackdrop?: boolean;\n    /** Custom class for the backdrop. */\n    backdropClass?: string | string[];\n    /** Whether the user can use escape or clicking on the backdrop to close the modal. */\n    disableClose?: boolean;\n    /** Width of the dialog. */\n    width?: string;\n    /** Height of the dialog. */\n    height?: string;\n    /** Min-width of the dialog. If a number is provided, assumes pixel units. */\n    minWidth?: number | string;\n    /** Min-height of the dialog. If a number is provided, assumes pixel units. */\n    minHeight?: number | string;\n    /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */\n    maxWidth?: number | string;\n    /** Max-height of the dialog. If a number is provided, assumes pixel units. */\n    maxHeight?: number | string;\n    /** Position overrides. */\n    position?: DialogPosition;\n    /** Data being injected into the child component. */\n    data?: D | null;\n    /** Layout direction for the dialog's content. */\n    direction?: Direction;\n    /** ID of the element that describes the dialog. */\n    ariaDescribedBy?: string | null;\n    /** ID of the element that labels the dialog. */\n    ariaLabelledBy?: string | null;\n    /** Aria label to assign to the dialog element. */\n    ariaLabel?: string | null;\n    /** Whether this is a modal dialog. Used to set the `aria-modal` attribute. */\n    ariaModal?: boolean;\n    /**\n     * Where the dialog should focus on open.\n     * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n     * AutoFocusTarget instead.\n     */\n    autoFocus?: AutoFocusTarget | string | boolean;\n    /**\n     * Whether the dialog should restore focus to the\n     * previously-focused element, after it's closed.\n     */\n    restoreFocus?: boolean;\n    /** Whether to wait for the opening animation to finish before trapping focus. */\n    delayFocusTrap?: boolean;\n    /** Scroll strategy to be used for the dialog. */\n    scrollStrategy?: ScrollStrategy;\n    /**\n     * Whether the dialog should close when the user goes backwards/forwards in history.\n     * Note that this usually doesn't include clicking on links (unless the user is using\n     * the `HashLocationStrategy`).\n     */\n    closeOnNavigation?: boolean;\n    /** Alternate `ComponentFactoryResolver` to use when resolving the associated component. */\n    componentFactoryResolver?: ComponentFactoryResolver;\n    /** Duration of the enter animation. Has to be a valid CSS value (e.g. 100ms). */\n    enterAnimationDuration?: string;\n    /** Duration of the exit animation. Has to be a valid CSS value (e.g. 50ms). */\n    exitAnimationDuration?: string;\n}\n\n/**\n * Internal component that wraps user-provided dialog content.\n * Animation is based on https://material.io/guidelines/motion/choreography.html.\n * @docs-private\n */\nexport declare class MatDialogContainer extends _MatDialogContainerBase {\n    private _changeDetectorRef;\n    /** State of the dialog animation. */\n    _state: 'void' | 'enter' | 'exit';\n    /** Callback, invoked whenever an animation on the host completes. */\n    _onAnimationDone({ toState, totalTime }: AnimationEvent_2): void;\n    /** Callback, invoked when an animation on the host starts. */\n    _onAnimationStart({ toState, totalTime }: AnimationEvent_2): void;\n    /** Starts the dialog exit animation. */\n    _startExitAnimation(): void;\n    constructor(elementRef: ElementRef, focusTrapFactory: FocusTrapFactory, document: any, dialogConfig: MatDialogConfig, checker: InteractivityChecker, ngZone: NgZone, overlayRef: OverlayRef, _changeDetectorRef: ChangeDetectorRef, focusMonitor?: FocusMonitor);\n    _getAnimationState(): {\n        value: \"enter\" | \"void\" | \"exit\";\n        params: {\n            enterAnimationDuration: string;\n            exitAnimationDuration: string;\n        };\n    };\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDialogContainer, [null, null, { optional: true; }, null, null, null, null, null, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDialogContainer, \"mat-dialog-container\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Base class for the `MatDialogContainer`. The base class does not implement\n * animations as these are left to implementers of the dialog container.\n */\nexport declare abstract class _MatDialogContainerBase extends CdkDialogContainer<MatDialogConfig> {\n    /** Emits when an animation state changes. */\n    _animationStateChanged: EventEmitter<DialogAnimationEvent>;\n    constructor(elementRef: ElementRef, focusTrapFactory: FocusTrapFactory, _document: any, dialogConfig: MatDialogConfig, interactivityChecker: InteractivityChecker, ngZone: NgZone, overlayRef: OverlayRef, focusMonitor?: FocusMonitor);\n    /** Starts the dialog exit animation. */\n    abstract _startExitAnimation(): void;\n    protected _captureInitialFocus(): void;\n    /**\n     * Callback for when the open dialog animation has finished. Intended to\n     * be called by sub-classes that use different animation implementations.\n     */\n    protected _openAnimationDone(totalTime: number): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatDialogContainerBase, [null, null, { optional: true; }, null, null, null, null, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<_MatDialogContainerBase, \"ng-component\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Scrollable content container of a dialog.\n */\nexport declare class MatDialogContent {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDialogContent, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDialogContent, \"[mat-dialog-content], mat-dialog-content, [matDialogContent]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatDialogModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDialogModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatDialogModule, [typeof i1.MatDialogContainer, typeof i2.MatDialogClose, typeof i2.MatDialogTitle, typeof i2.MatDialogActions, typeof i2.MatDialogContent], [typeof i3.DialogModule, typeof i4.OverlayModule, typeof i5.PortalModule, typeof i6.MatCommonModule], [typeof i1.MatDialogContainer, typeof i2.MatDialogClose, typeof i2.MatDialogTitle, typeof i2.MatDialogContent, typeof i2.MatDialogActions, typeof i6.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatDialogModule>;\n}\n\n/**\n * Reference to a dialog opened via the MatDialog service.\n */\nexport declare class MatDialogRef<T, R = any> {\n    private _ref;\n    _containerInstance: _MatDialogContainerBase;\n    /** The instance of component opened into the dialog. */\n    componentInstance: T;\n    /** Whether the user is allowed to close the dialog. */\n    disableClose: boolean | undefined;\n    /** Unique ID for the dialog. */\n    id: string;\n    /** Subject for notifying the user that the dialog has finished opening. */\n    private readonly _afterOpened;\n    /** Subject for notifying the user that the dialog has started closing. */\n    private readonly _beforeClosed;\n    /** Result to be passed to afterClosed. */\n    private _result;\n    /** Handle to the timeout that's running as a fallback in case the exit animation doesn't fire. */\n    private _closeFallbackTimeout;\n    /** Current state of the dialog. */\n    private _state;\n    /** Interaction that caused the dialog to close. */\n    private _closeInteractionType;\n    constructor(_ref: DialogRef<R, T>, config: MatDialogConfig, _containerInstance: _MatDialogContainerBase);\n    /**\n     * Close the dialog.\n     * @param dialogResult Optional result to return to the dialog opener.\n     */\n    close(dialogResult?: R): void;\n    /**\n     * Gets an observable that is notified when the dialog is finished opening.\n     */\n    afterOpened(): Observable<void>;\n    /**\n     * Gets an observable that is notified when the dialog is finished closing.\n     */\n    afterClosed(): Observable<R | undefined>;\n    /**\n     * Gets an observable that is notified when the dialog has started closing.\n     */\n    beforeClosed(): Observable<R | undefined>;\n    /**\n     * Gets an observable that emits when the overlay's backdrop has been clicked.\n     */\n    backdropClick(): Observable<MouseEvent>;\n    /**\n     * Gets an observable that emits when keydown events are targeted on the overlay.\n     */\n    keydownEvents(): Observable<KeyboardEvent>;\n    /**\n     * Updates the dialog's position.\n     * @param position New dialog position.\n     */\n    updatePosition(position?: DialogPosition): this;\n    /**\n     * Updates the dialog's width and height.\n     * @param width New width of the dialog.\n     * @param height New height of the dialog.\n     */\n    updateSize(width?: string, height?: string): this;\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes: string | string[]): this;\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes: string | string[]): this;\n    /** Gets the current state of the dialog's lifecycle. */\n    getState(): MatDialogState;\n    /**\n     * Finishes the dialog close by updating the state of the dialog\n     * and disposing the overlay.\n     */\n    private _finishDialogClose;\n}\n\n/** Possible states of the lifecycle of a dialog. */\nexport declare const enum MatDialogState {\n    OPEN = 0,\n    CLOSING = 1,\n    CLOSED = 2\n}\n\n/**\n * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.\n */\nexport declare class MatDialogTitle implements OnInit {\n    private _dialogRef;\n    private _elementRef;\n    private _dialog;\n    /** Unique id for the dialog title. If none is supplied, it will be auto-generated. */\n    id: string;\n    constructor(_dialogRef: MatDialogRef<any>, _elementRef: ElementRef<HTMLElement>, _dialog: MatDialog);\n    ngOnInit(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDialogTitle, [{ optional: true; }, null, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDialogTitle, \"[mat-dialog-title], [matDialogTitle]\", [\"matDialogTitle\"], { \"id\": \"id\"; }, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/dialog/testing/index.d.ts",
      "node_modules/@angular/material/dialog/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentType } from '@angular/cdk/overlay';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { DialogRole } from '@angular/material/dialog';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatDialog } from '@angular/material/dialog';\nimport { _MatDialogBase } from '@angular/material/dialog';\nimport { MatDialogConfig } from '@angular/material/dialog';\nimport { MatDialogContainer } from '@angular/material/dialog';\nimport { _MatDialogContainerBase } from '@angular/material/dialog';\nimport { MatDialogRef } from '@angular/material/dialog';\nimport { OnDestroy } from '@angular/core';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of `MatDialogHarness` instances. */\nexport declare interface DialogHarnessFilters extends BaseHarnessFilters {\n}\n\n/** Harness for interacting with a standard `MatDialog` in tests. */\nexport declare class MatDialogHarness extends _MatDialogHarnessBase {\n    /** The selector for the host element of a `MatDialog` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatDialogHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which dialog instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DialogHarnessFilters): HarnessPredicate<MatDialogHarness>;\n}\n\n/** Base class for the `MatDialogHarness` implementation. */\nexport declare class _MatDialogHarnessBase extends ContentContainerComponentHarness<MatDialogSection | string> {\n    protected _title: AsyncFactoryFn<TestElement | null>;\n    protected _content: AsyncFactoryFn<TestElement | null>;\n    protected _actions: AsyncFactoryFn<TestElement | null>;\n    /** Gets the id of the dialog. */\n    getId(): Promise<string | null>;\n    /** Gets the role of the dialog. */\n    getRole(): Promise<DialogRole | null>;\n    /** Gets the value of the dialog's \"aria-label\" attribute. */\n    getAriaLabel(): Promise<string | null>;\n    /** Gets the value of the dialog's \"aria-labelledby\" attribute. */\n    getAriaLabelledby(): Promise<string | null>;\n    /** Gets the value of the dialog's \"aria-describedby\" attribute. */\n    getAriaDescribedby(): Promise<string | null>;\n    /**\n     * Closes the dialog by pressing escape.\n     *\n     * Note: this method does nothing if `disableClose` has been set to `true` for the dialog.\n     */\n    close(): Promise<void>;\n    /** Gets te dialog's text. */\n    getText(): Promise<string>;\n    /** Gets the dialog's title text. This only works if the dialog is using mat-dialog-title. */\n    getTitleText(): Promise<string>;\n    /** Gets the dialog's content text. This only works if the dialog is using mat-dialog-content. */\n    getContentText(): Promise<string>;\n    /** Gets the dialog's actions text. This only works if the dialog is using mat-dialog-actions. */\n    getActionsText(): Promise<string>;\n}\n\n/** Selectors for different sections of the mat-dialog that can contain user content. */\nexport declare const enum MatDialogSection {\n    TITLE = \".mat-dialog-title\",\n    CONTENT = \".mat-dialog-content\",\n    ACTIONS = \".mat-dialog-actions\"\n}\n\n/** Test component that immediately opens a dialog when created. */\nexport declare class MatTestDialogOpener<T = unknown, R = unknown> extends _MatTestDialogOpenerBase<MatDialogContainer, T, R> {\n    constructor(dialog: MatDialog);\n    /** Static method that prepares this class to open the provided component. */\n    static withComponent<T = unknown, R = unknown>(component: ComponentType<T>, config?: MatDialogConfig): ComponentType<MatTestDialogOpener<T, R>>;\n}\n\n/** Base class for a component that immediately opens a dialog when created. */\nexport declare class _MatTestDialogOpenerBase<C extends _MatDialogContainerBase, T, R> implements OnDestroy {\n    dialog: _MatDialogBase<C>;\n    /** Component that should be opened with the MatDialog `open` method. */\n    protected static component: ComponentType<unknown> | undefined;\n    /** Config that should be provided to the MatDialog `open` method. */\n    protected static config: MatDialogConfig | undefined;\n    /** MatDialogRef returned from the MatDialog `open` method. */\n    dialogRef: MatDialogRef<T, R>;\n    /** Data passed to the `MatDialog` close method. */\n    closedResult: R | undefined;\n    private readonly _afterClosedSubscription;\n    constructor(dialog: _MatDialogBase<C>);\n    ngOnDestroy(): void;\n}\n\nexport declare class MatTestDialogOpenerModule {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/divider/index.d.ts",
      "node_modules/@angular/material/divider/index.d.ts"
    ],
    "content": "import { BooleanInput } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\n\ndeclare namespace i1 {\n    export {\n        MatDivider\n    }\n}\n\nexport declare class MatDivider {\n    /** Whether the divider is vertically aligned. */\n    get vertical(): boolean;\n    set vertical(value: BooleanInput);\n    private _vertical;\n    /** Whether the divider is an inset divider. */\n    get inset(): boolean;\n    set inset(value: BooleanInput);\n    private _inset;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDivider, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDivider, \"mat-divider\", never, { \"vertical\": \"vertical\"; \"inset\": \"inset\"; }, {}, never, never, false>;\n}\n\nexport declare class MatDividerModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDividerModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatDividerModule, [typeof i1.MatDivider], [typeof i2.MatCommonModule], [typeof i1.MatDivider, typeof i2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatDividerModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/divider/testing/index.d.ts",
      "node_modules/@angular/material/divider/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\nexport declare interface DividerHarnessFilters extends BaseHarnessFilters {\n}\n\n/** Harness for interacting with a `mat-divider`. */\nexport declare class MatDividerHarness extends ComponentHarness {\n    static hostSelector: string;\n    static with(options?: DividerHarnessFilters): HarnessPredicate<MatDividerHarness>;\n    getOrientation(): Promise<'horizontal' | 'vertical'>;\n    isInset(): Promise<boolean>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/expansion/index.d.ts",
      "node_modules/@angular/material/expansion/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CdkAccordion } from '@angular/cdk/accordion';\nimport { CdkAccordionItem } from '@angular/cdk/accordion';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i5 from '@angular/common';\nimport * as i6 from '@angular/material/core';\nimport * as i7 from '@angular/cdk/accordion';\nimport * as i8 from '@angular/cdk/portal';\nimport { InjectionToken } from '@angular/core';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { ViewContainerRef } from '@angular/core';\n\n/** Time and timing curve for expansion panel animations. */\nexport declare const EXPANSION_PANEL_ANIMATION_TIMING = \"225ms cubic-bezier(0.4,0.0,0.2,1)\";\n\ndeclare namespace i1 {\n    export {\n        MatAccordion\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatExpansionPanelState,\n        MatExpansionPanelDefaultOptions,\n        MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,\n        MatExpansionPanel,\n        MatExpansionPanelActionRow\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MatExpansionPanelHeader,\n        MatExpansionPanelDescription,\n        MatExpansionPanelTitle\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        MatExpansionPanelContent\n    }\n}\n\n/**\n * Token used to provide a `MatAccordion` to `MatExpansionPanel`.\n * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.\n */\nexport declare const MAT_ACCORDION: InjectionToken<MatAccordionBase>;\n\n/**\n * Token used to provide a `MatExpansionPanel` to `MatExpansionPanelContent`.\n * Used to avoid circular imports between `MatExpansionPanel` and `MatExpansionPanelContent`.\n */\nexport declare const MAT_EXPANSION_PANEL: InjectionToken<MatExpansionPanelBase>;\n\n/**\n * Injection token that can be used to configure the default\n * options for the expansion panel component.\n */\nexport declare const MAT_EXPANSION_PANEL_DEFAULT_OPTIONS: InjectionToken<MatExpansionPanelDefaultOptions>;\n\n/**\n * Directive for a Material Design Accordion.\n */\nexport declare class MatAccordion extends CdkAccordion implements MatAccordionBase, AfterContentInit, OnDestroy {\n    private _keyManager;\n    /** Headers belonging to this accordion. */\n    private _ownHeaders;\n    /** All headers inside the accordion. Includes headers inside nested accordions. */\n    _headers: QueryList<MatExpansionPanelHeader>;\n    /** Whether the expansion indicator should be hidden. */\n    get hideToggle(): boolean;\n    set hideToggle(show: BooleanInput);\n    private _hideToggle;\n    /**\n     * Display mode used for all expansion panels in the accordion. Currently two display\n     * modes exist:\n     *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded\n     *     panel at a different elevation from the rest of the accordion.\n     *  flat - no spacing is placed around expanded panels, showing all panels at the same\n     *     elevation.\n     */\n    displayMode: MatAccordionDisplayMode;\n    /** The position of the expansion indicator. */\n    togglePosition: MatAccordionTogglePosition;\n    ngAfterContentInit(): void;\n    /** Handles keyboard events coming in from the panel headers. */\n    _handleHeaderKeydown(event: KeyboardEvent): void;\n    _handleHeaderFocus(header: MatExpansionPanelHeader): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatAccordion, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatAccordion, \"mat-accordion\", [\"matAccordion\"], { \"multi\": \"multi\"; \"hideToggle\": \"hideToggle\"; \"displayMode\": \"displayMode\"; \"togglePosition\": \"togglePosition\"; }, {}, [\"_headers\"], never, false>;\n}\n\n/**\n * Base interface for a `MatAccordion`.\n * @docs-private\n */\nexport declare interface MatAccordionBase extends CdkAccordion {\n    /** Whether the expansion indicator should be hidden. */\n    hideToggle: boolean;\n    /** Display mode used for all expansion panels in the accordion. */\n    displayMode: MatAccordionDisplayMode;\n    /** The position of the expansion indicator. */\n    togglePosition: MatAccordionTogglePosition;\n    /** Handles keyboard events coming in from the panel headers. */\n    _handleHeaderKeydown: (event: KeyboardEvent) => void;\n    /** Handles focus events on the panel headers. */\n    _handleHeaderFocus: (header: any) => void;\n}\n\n/** MatAccordion's display modes. */\nexport declare type MatAccordionDisplayMode = 'default' | 'flat';\n\n/** MatAccordion's toggle positions. */\nexport declare type MatAccordionTogglePosition = 'before' | 'after';\n\n/**\n * Animations used by the Material expansion panel.\n *\n * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()\n * causes the animation state of moved components to become `void` upon exit, and not update again\n * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state\n * of the panel is `expanded` or `collapsed` but the animation state is `void`.\n *\n * To correctly handle animating to the next state, we animate between `void` and `collapsed` which\n * are defined to have the same styles. Since angular animates from the current styles to the\n * destination state's style definition, in situations where we are moving from `void`'s styles to\n * `collapsed` this acts a noop since no style values change.\n *\n * In the case where angular's animation state is out of sync with the expansion panel's state, the\n * expansion panel being `expanded` and angular animations being `void`, the animation from the\n * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will\n * occur as expected.\n *\n * Angular Bug: https://github.com/angular/angular/issues/18847\n *\n * @docs-private\n */\nexport declare const matExpansionAnimations: {\n    readonly indicatorRotate: AnimationTriggerMetadata;\n    readonly bodyExpansion: AnimationTriggerMetadata;\n};\n\nexport declare class MatExpansionModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatExpansionModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatExpansionModule, [typeof i1.MatAccordion, typeof i2.MatExpansionPanel, typeof i2.MatExpansionPanelActionRow, typeof i3.MatExpansionPanelHeader, typeof i3.MatExpansionPanelTitle, typeof i3.MatExpansionPanelDescription, typeof i4.MatExpansionPanelContent], [typeof i5.CommonModule, typeof i6.MatCommonModule, typeof i7.CdkAccordionModule, typeof i8.PortalModule], [typeof i1.MatAccordion, typeof i2.MatExpansionPanel, typeof i2.MatExpansionPanelActionRow, typeof i3.MatExpansionPanelHeader, typeof i3.MatExpansionPanelTitle, typeof i3.MatExpansionPanelDescription, typeof i4.MatExpansionPanelContent]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatExpansionModule>;\n}\n\n/**\n * This component can be used as a single element to show expandable content, or as one of\n * multiple children of an element with the MatAccordion directive attached.\n */\nexport declare class MatExpansionPanel extends CdkAccordionItem implements AfterContentInit, OnChanges, OnDestroy {\n    private _viewContainerRef;\n    _animationMode: string;\n    private _document;\n    private _hideToggle;\n    private _togglePosition;\n    /** Whether the toggle indicator should be hidden. */\n    get hideToggle(): boolean;\n    set hideToggle(value: BooleanInput);\n    /** The position of the expansion indicator. */\n    get togglePosition(): MatAccordionTogglePosition;\n    set togglePosition(value: MatAccordionTogglePosition);\n    /** An event emitted after the body's expansion animation happens. */\n    readonly afterExpand: EventEmitter<void>;\n    /** An event emitted after the body's collapse animation happens. */\n    readonly afterCollapse: EventEmitter<void>;\n    /** Stream that emits for changes in `@Input` properties. */\n    readonly _inputChanges: Subject<SimpleChanges>;\n    /** Optionally defined accordion the expansion panel belongs to. */\n    accordion: MatAccordionBase;\n    /** Content that will be rendered lazily. */\n    _lazyContent: MatExpansionPanelContent;\n    /** Element containing the panel's user-provided content. */\n    _body: ElementRef<HTMLElement>;\n    /** Portal holding the user's content. */\n    _portal: TemplatePortal;\n    /** ID for the associated header element. Used for a11y labelling. */\n    _headerId: string;\n    /** Stream of body animation done events. */\n    readonly _bodyAnimationDone: Subject<AnimationEvent_2>;\n    constructor(accordion: MatAccordionBase, _changeDetectorRef: ChangeDetectorRef, _uniqueSelectionDispatcher: UniqueSelectionDispatcher, _viewContainerRef: ViewContainerRef, _document: any, _animationMode: string, defaultOptions?: MatExpansionPanelDefaultOptions);\n    /** Determines whether the expansion panel should have spacing between it and its siblings. */\n    _hasSpacing(): boolean;\n    /** Gets the expanded state string. */\n    _getExpandedState(): MatExpansionPanelState;\n    /** Toggles the expanded state of the expansion panel. */\n    toggle(): void;\n    /** Sets the expanded state of the expansion panel to false. */\n    close(): void;\n    /** Sets the expanded state of the expansion panel to true. */\n    open(): void;\n    ngAfterContentInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Checks whether the expansion panel's content contains the currently-focused element. */\n    _containsFocus(): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatExpansionPanel, [{ optional: true; skipSelf: true; }, null, null, null, null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatExpansionPanel, \"mat-expansion-panel\", [\"matExpansionPanel\"], { \"disabled\": \"disabled\"; \"expanded\": \"expanded\"; \"hideToggle\": \"hideToggle\"; \"togglePosition\": \"togglePosition\"; }, { \"opened\": \"opened\"; \"closed\": \"closed\"; \"expandedChange\": \"expandedChange\"; \"afterExpand\": \"afterExpand\"; \"afterCollapse\": \"afterCollapse\"; }, [\"_lazyContent\"], [\"mat-expansion-panel-header\", \"*\", \"mat-action-row\"], false>;\n}\n\n/**\n * Actions of a `<mat-expansion-panel>`.\n */\nexport declare class MatExpansionPanelActionRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatExpansionPanelActionRow, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatExpansionPanelActionRow, \"mat-action-row\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Base interface for a `MatExpansionPanel`.\n * @docs-private\n */\ndeclare interface MatExpansionPanelBase extends CdkAccordionItem {\n    /** Whether the toggle indicator should be hidden. */\n    hideToggle: boolean;\n}\n\n/**\n * Expansion panel content that will be rendered lazily\n * after the panel is opened for the first time.\n */\nexport declare class MatExpansionPanelContent {\n    _template: TemplateRef<any>;\n    _expansionPanel?: MatExpansionPanelBase | undefined;\n    constructor(_template: TemplateRef<any>, _expansionPanel?: MatExpansionPanelBase | undefined);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatExpansionPanelContent, [null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatExpansionPanelContent, \"ng-template[matExpansionPanelContent]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Object that can be used to override the default options\n * for all of the expansion panels in a module.\n */\nexport declare interface MatExpansionPanelDefaultOptions {\n    /** Height of the header while the panel is expanded. */\n    expandedHeight: string;\n    /** Height of the header while the panel is collapsed. */\n    collapsedHeight: string;\n    /** Whether the toggle indicator should be hidden. */\n    hideToggle: boolean;\n}\n\n/**\n * Description element of a `<mat-expansion-panel-header>`.\n */\nexport declare class MatExpansionPanelDescription {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatExpansionPanelDescription, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatExpansionPanelDescription, \"mat-panel-description\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Header element of a `<mat-expansion-panel>`.\n */\nexport declare class MatExpansionPanelHeader extends _MatExpansionPanelHeaderMixinBase implements AfterViewInit, OnDestroy, FocusableOption, HasTabIndex {\n    panel: MatExpansionPanel;\n    private _element;\n    private _focusMonitor;\n    private _changeDetectorRef;\n    _animationMode?: string | undefined;\n    private _parentChangeSubscription;\n    constructor(panel: MatExpansionPanel, _element: ElementRef, _focusMonitor: FocusMonitor, _changeDetectorRef: ChangeDetectorRef, defaultOptions?: MatExpansionPanelDefaultOptions, _animationMode?: string | undefined, tabIndex?: string);\n    /** Height of the header while the panel is expanded. */\n    expandedHeight: string;\n    /** Height of the header while the panel is collapsed. */\n    collapsedHeight: string;\n    /**\n     * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.\n     * @docs-private\n     */\n    get disabled(): boolean;\n    /** Toggles the expanded state of the panel. */\n    _toggle(): void;\n    /** Gets whether the panel is expanded. */\n    _isExpanded(): boolean;\n    /** Gets the expanded state string of the panel. */\n    _getExpandedState(): string;\n    /** Gets the panel id. */\n    _getPanelId(): string;\n    /** Gets the toggle position for the header. */\n    _getTogglePosition(): MatAccordionTogglePosition;\n    /** Gets whether the expand indicator should be shown. */\n    _showToggle(): boolean;\n    /**\n     * Gets the current height of the header. Null if no custom height has been\n     * specified, and if the default height from the stylesheet should be used.\n     */\n    _getHeaderHeight(): string | null;\n    /** Handle keydown event calling to toggle() if appropriate. */\n    _keydown(event: KeyboardEvent): void;\n    /**\n     * Focuses the panel header. Implemented as a part of `FocusableOption`.\n     * @param origin Origin of the action that triggered the focus.\n     * @docs-private\n     */\n    focus(origin?: FocusOrigin, options?: FocusOptions): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatExpansionPanelHeader, [{ host: true; }, null, null, null, { optional: true; }, { optional: true; }, { attribute: \"tabindex\"; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatExpansionPanelHeader, \"mat-expansion-panel-header\", never, { \"tabIndex\": \"tabIndex\"; \"expandedHeight\": \"expandedHeight\"; \"collapsedHeight\": \"collapsedHeight\"; }, {}, never, [\"mat-panel-title\", \"mat-panel-description\", \"*\"], false>;\n}\n\n/** @docs-private */\ndeclare abstract class MatExpansionPanelHeaderBase {\n    abstract readonly disabled: boolean;\n}\n\ndeclare const _MatExpansionPanelHeaderMixinBase: _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & typeof MatExpansionPanelHeaderBase;\n\n/** MatExpansionPanel's states. */\nexport declare type MatExpansionPanelState = 'expanded' | 'collapsed';\n\n/**\n * Title element of a `<mat-expansion-panel-header>`.\n */\nexport declare class MatExpansionPanelTitle {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatExpansionPanelTitle, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatExpansionPanelTitle, \"mat-panel-title\", never, {}, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/expansion/testing/index.d.ts",
      "node_modules/@angular/material/expansion/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessLoader } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\nexport declare interface AccordionHarnessFilters extends BaseHarnessFilters {\n}\n\nexport declare interface ExpansionPanelHarnessFilters extends BaseHarnessFilters {\n    title?: string | RegExp | null;\n    description?: string | RegExp | null;\n    content?: string | RegExp;\n    expanded?: boolean;\n    disabled?: boolean;\n}\n\n/** Harness for interacting with a standard mat-accordion in tests. */\nexport declare class MatAccordionHarness extends ComponentHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for an accordion\n     * with specific attributes.\n     * @param options Options for narrowing the search.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: AccordionHarnessFilters): HarnessPredicate<MatAccordionHarness>;\n    /** Gets all expansion panels which are part of the accordion. */\n    getExpansionPanels(filter?: ExpansionPanelHarnessFilters): Promise<MatExpansionPanelHarness[]>;\n    /** Whether the accordion allows multiple expanded panels simultaneously. */\n    isMulti(): Promise<boolean>;\n}\n\n/** Harness for interacting with a standard mat-expansion-panel in tests. */\nexport declare class MatExpansionPanelHarness extends ContentContainerComponentHarness<MatExpansionPanelSection> {\n    static hostSelector: string;\n    private _header;\n    private _title;\n    private _description;\n    private _expansionIndicator;\n    private _content;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for an expansion-panel\n     * with specific attributes.\n     * @param options Options for narrowing the search:\n     *   - `title` finds an expansion-panel with a specific title text.\n     *   - `description` finds an expansion-panel with a specific description text.\n     *   - `expanded` finds an expansion-panel that is currently expanded.\n     *   - `disabled` finds an expansion-panel that is disabled.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ExpansionPanelHarnessFilters): HarnessPredicate<MatExpansionPanelHarness>;\n    /** Whether the panel is expanded. */\n    isExpanded(): Promise<boolean>;\n    /**\n     * Gets the title text of the panel.\n     * @returns Title text or `null` if no title is set up.\n     */\n    getTitle(): Promise<string | null>;\n    /**\n     * Gets the description text of the panel.\n     * @returns Description text or `null` if no description is set up.\n     */\n    getDescription(): Promise<string | null>;\n    /** Whether the panel is disabled. */\n    isDisabled(): Promise<boolean>;\n    /**\n     * Toggles the expanded state of the panel by clicking on the panel\n     * header. This method will not work if the panel is disabled.\n     */\n    toggle(): Promise<void>;\n    /** Expands the expansion panel if collapsed. */\n    expand(): Promise<void>;\n    /** Collapses the expansion panel if expanded. */\n    collapse(): Promise<void>;\n    /** Gets the text content of the panel. */\n    getTextContent(): Promise<string>;\n    /**\n     * Gets a `HarnessLoader` that can be used to load harnesses for\n     * components within the panel's content area.\n     * @deprecated Use either `getChildLoader(MatExpansionPanelSection.CONTENT)`, `getHarness` or\n     *    `getAllHarnesses` instead.\n     * @breaking-change 12.0.0\n     */\n    getHarnessLoaderForContent(): Promise<HarnessLoader>;\n    /** Focuses the panel. */\n    focus(): Promise<void>;\n    /** Blurs the panel. */\n    blur(): Promise<void>;\n    /** Whether the panel is focused. */\n    isFocused(): Promise<boolean>;\n    /** Whether the panel has a toggle indicator displayed. */\n    hasToggleIndicator(): Promise<boolean>;\n    /** Gets the position of the toggle indicator. */\n    getToggleIndicatorPosition(): Promise<'before' | 'after'>;\n}\n\n/** Selectors for the various `mat-expansion-panel` sections that may contain user content. */\nexport declare const enum MatExpansionPanelSection {\n    HEADER = \".mat-expansion-panel-header\",\n    TITLE = \".mat-expansion-panel-header-title\",\n    DESCRIPTION = \".mat-expansion-panel-header-description\",\n    CONTENT = \".mat-expansion-panel-content\"\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/form-field/index.d.ts",
      "node_modules/@angular/material/form-field/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AbstractControlDirective } from '@angular/forms';\nimport { AfterContentChecked } from '@angular/core';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i10 from '@angular/cdk/observers';\nimport * as i8 from '@angular/common';\nimport * as i9 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { NgControl } from '@angular/forms';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\n\n/** Possible values for the \"floatLabel\" form field input. */\nexport declare type FloatLabelType = 'always' | 'never' | 'auto';\n\n/** @docs-private */\nexport declare function getMatFormFieldDuplicatedHintError(align: string): Error;\n\n/** @docs-private */\nexport declare function getMatFormFieldMissingControlError(): Error;\n\n\n/** @docs-private */\nexport declare function getMatFormFieldPlaceholderConflictError(): Error;\n\ndeclare namespace i1 {\n    export {\n        MAT_ERROR,\n        MatError\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatFormFieldAppearance,\n        FloatLabelType,\n        MatFormFieldDefaultOptions,\n        MAT_FORM_FIELD_DEFAULT_OPTIONS,\n        MAT_FORM_FIELD,\n        MatFormField\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        _MAT_HINT,\n        MatHint\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        MatLabel\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        MatPlaceholder\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        MAT_PREFIX,\n        MatPrefix\n    }\n}\n\ndeclare namespace i7 {\n    export {\n        MAT_SUFFIX,\n        MatSuffix\n    }\n}\n\n/**\n * Injection token that can be used to reference instances of `MatError`. It serves as\n * alternative token to the actual `MatError` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_ERROR: InjectionToken<MatError>;\n\n/**\n * Injection token that can be used to inject an instances of `MatFormField`. It serves\n * as alternative token to the actual `MatFormField` class which would cause unnecessary\n * retention of the `MatFormField` class and its component metadata.\n */\nexport declare const MAT_FORM_FIELD: InjectionToken<MatFormField>;\n\n/**\n * Injection token that can be used to configure the\n * default options for all form field within an app.\n */\nexport declare const MAT_FORM_FIELD_DEFAULT_OPTIONS: InjectionToken<MatFormFieldDefaultOptions>;\n\n/**\n * Injection token that can be used to reference instances of `MatHint`. It serves as\n * alternative token to the actual `MatHint` class which could cause unnecessary\n * retention of the class and its directive metadata.\n *\n * *Note*: This is not part of the public API as the MDC-based form-field will not\n * need a lightweight token for `MatHint` and we want to reduce breaking changes.\n */\nexport declare const _MAT_HINT: InjectionToken<MatHint>;\n\n/**\n * Injection token that can be used to reference instances of `MatPrefix`. It serves as\n * alternative token to the actual `MatPrefix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_PREFIX: InjectionToken<MatPrefix>;\n\n/**\n * Injection token that can be used to reference instances of `MatSuffix`. It serves as\n * alternative token to the actual `MatSuffix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_SUFFIX: InjectionToken<MatSuffix>;\n\n/** Single error message to be shown underneath the form field. */\nexport declare class MatError {\n    id: string;\n    constructor(ariaLive: string, elementRef: ElementRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatError, [{ attribute: \"aria-live\"; }, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatError, \"mat-error\", never, { \"id\": \"id\"; }, {}, never, never, false>;\n}\n\n/** Container for form controls that applies Material Design styling and behavior. */\nexport declare class MatFormField extends _MatFormFieldBase implements AfterContentInit, AfterContentChecked, AfterViewInit, OnDestroy, CanColor {\n    private _changeDetectorRef;\n    private _dir;\n    private _defaults;\n    private _platform;\n    private _ngZone;\n    /**\n     * Whether the outline gap needs to be calculated\n     * immediately on the next change detection run.\n     */\n    private _outlineGapCalculationNeededImmediately;\n    /** Whether the outline gap needs to be calculated next time the zone has stabilized. */\n    private _outlineGapCalculationNeededOnStable;\n    private readonly _destroyed;\n    /** The form field appearance style. */\n    get appearance(): MatFormFieldAppearance;\n    set appearance(value: MatFormFieldAppearance);\n    _appearance: MatFormFieldAppearance;\n    /** Whether the required marker should be hidden. */\n    get hideRequiredMarker(): boolean;\n    set hideRequiredMarker(value: BooleanInput);\n    private _hideRequiredMarker;\n    /** Override for the logic that disables the label animation in certain cases. */\n    private _showAlwaysAnimate;\n    /** Whether the floating label should always float or not. */\n    _shouldAlwaysFloat(): boolean;\n    /** Whether the label can float or not. */\n    _canLabelFloat(): boolean;\n    /** State of the mat-hint and mat-error animations. */\n    _subscriptAnimationState: string;\n    /** Text for the form field hint. */\n    get hintLabel(): string;\n    set hintLabel(value: string);\n    private _hintLabel;\n    readonly _hintLabelId: string;\n    readonly _labelId: string;\n    /**\n     * Whether the label should always float, never float or float as the user types.\n     *\n     * Note: only the legacy appearance supports the `never` option. `never` was originally added as a\n     * way to make the floating label emulate the behavior of a standard input placeholder. However\n     * the form field now supports both floating labels and placeholders. Therefore in the non-legacy\n     * appearances the `never` option has been disabled in favor of just using the placeholder.\n     */\n    get floatLabel(): FloatLabelType;\n    set floatLabel(value: FloatLabelType);\n    private _floatLabel;\n    /** Whether the Angular animations are enabled. */\n    _animationsEnabled: boolean;\n    _connectionContainerRef: ElementRef;\n    _inputContainerRef: ElementRef;\n    private _label;\n    _controlNonStatic: MatFormFieldControl<any>;\n    _controlStatic: MatFormFieldControl<any>;\n    get _control(): MatFormFieldControl<any>;\n    set _control(value: MatFormFieldControl<any>);\n    private _explicitFormFieldControl;\n    _labelChildNonStatic: MatLabel;\n    _labelChildStatic: MatLabel;\n    _placeholderChild: MatPlaceholder;\n    _errorChildren: QueryList<MatError>;\n    _hintChildren: QueryList<MatHint>;\n    _prefixChildren: QueryList<MatPrefix>;\n    _suffixChildren: QueryList<MatSuffix>;\n    constructor(elementRef: ElementRef, _changeDetectorRef: ChangeDetectorRef, _dir: Directionality, _defaults: MatFormFieldDefaultOptions, _platform: Platform, _ngZone: NgZone, _animationMode: string);\n    /**\n     * Gets the id of the label element. If no label is present, returns `null`.\n     */\n    getLabelId(): string | null;\n    /**\n     * Gets an ElementRef for the element that a overlay attached to the form field should be\n     * positioned relative to.\n     */\n    getConnectedOverlayOrigin(): ElementRef;\n    ngAfterContentInit(): void;\n    ngAfterContentChecked(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Determines whether a class from the AbstractControlDirective\n     * should be forwarded to the host element.\n     */\n    _shouldForward(prop: keyof AbstractControlDirective): boolean;\n    _hasPlaceholder(): boolean;\n    _hasLabel(): boolean;\n    _shouldLabelFloat(): boolean;\n    _hideControlPlaceholder(): boolean;\n    _hasFloatingLabel(): boolean;\n    /** Determines whether to display hints or errors. */\n    _getDisplayedMessages(): 'error' | 'hint';\n    /** Animates the placeholder up and locks it in position. */\n    _animateAndLockLabel(): void;\n    /**\n     * Ensure that there is only one placeholder (either `placeholder` attribute on the child control\n     * or child element with the `mat-placeholder` directive).\n     */\n    private _validatePlaceholders;\n    /** Does any extra processing that is required when handling the hints. */\n    private _processHints;\n    /**\n     * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the\n     * attribute being considered as `align=\"start\"`.\n     */\n    private _validateHints;\n    /** Gets the default float label state. */\n    private _getDefaultFloatLabelState;\n    /**\n     * Sets the list of element IDs that describe the child control. This allows the control to update\n     * its `aria-describedby` attribute accordingly.\n     */\n    private _syncDescribedByIds;\n    /** Throws an error if the form field's control is missing. */\n    protected _validateControlChild(): void;\n    /**\n     * Updates the width and position of the gap in the outline. Only relevant for the outline\n     * appearance.\n     */\n    updateOutlineGap(): void;\n    /** Gets the start end of the rect considering the current directionality. */\n    private _getStartEnd;\n    /** Checks whether the form field is attached to the DOM. */\n    private _isAttachedToDOM;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatFormField, [null, null, { optional: true; }, { optional: true; }, null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatFormField, \"mat-form-field\", [\"matFormField\"], { \"color\": \"color\"; \"appearance\": \"appearance\"; \"hideRequiredMarker\": \"hideRequiredMarker\"; \"hintLabel\": \"hintLabel\"; \"floatLabel\": \"floatLabel\"; }, {}, [\"_controlNonStatic\", \"_controlStatic\", \"_labelChildNonStatic\", \"_labelChildStatic\", \"_placeholderChild\", \"_errorChildren\", \"_hintChildren\", \"_prefixChildren\", \"_suffixChildren\"], [\"[matPrefix]\", \"*\", \"mat-placeholder\", \"mat-label\", \"[matSuffix]\", \"mat-error\", \"mat-hint:not([align='end'])\", \"mat-hint[align='end']\"], false>;\n}\n\n/**\n * Animations used by the MatFormField.\n * @docs-private\n */\nexport declare const matFormFieldAnimations: {\n    readonly transitionMessages: AnimationTriggerMetadata;\n};\n\n/** Possible appearance styles for the form field. */\nexport declare type MatFormFieldAppearance = 'legacy' | 'standard' | 'fill' | 'outline';\n\n/**\n * Boilerplate for applying mixins to MatFormField.\n * @docs-private\n */\ndeclare const _MatFormFieldBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\n/** An interface which allows a control to work inside of a `MatFormField`. */\nexport declare abstract class MatFormFieldControl<T> {\n    /** The value of the control. */\n    value: T | null;\n    /**\n     * Stream that emits whenever the state of the control changes such that the parent `MatFormField`\n     * needs to run change detection.\n     */\n    readonly stateChanges: Observable<void>;\n    /** The element ID for this control. */\n    readonly id: string;\n    /** The placeholder for this control. */\n    readonly placeholder: string;\n    /** Gets the AbstractControlDirective for this control. */\n    readonly ngControl: NgControl | AbstractControlDirective | null;\n    /** Whether the control is focused. */\n    readonly focused: boolean;\n    /** Whether the control is empty. */\n    readonly empty: boolean;\n    /** Whether the `MatFormField` label should try to float. */\n    readonly shouldLabelFloat: boolean;\n    /** Whether the control is required. */\n    readonly required: boolean;\n    /** Whether the control is disabled. */\n    readonly disabled: boolean;\n    /** Whether the control is in an error state. */\n    readonly errorState: boolean;\n    /**\n     * An optional name for the control type that can be used to distinguish `mat-form-field` elements\n     * based on their control type. The form field will add a class,\n     * `mat-form-field-type-{{controlType}}` to its root element.\n     */\n    readonly controlType?: string;\n    /**\n     * Whether the input is currently in an autofilled state. If property is not present on the\n     * control it is assumed to be false.\n     */\n    readonly autofilled?: boolean;\n    /**\n     * Value of `aria-describedby` that should be merged with the described-by ids\n     * which are set by the form-field.\n     */\n    readonly userAriaDescribedBy?: string;\n    /** Sets the list of element IDs that currently describe this control. */\n    abstract setDescribedByIds(ids: string[]): void;\n    /** Handles a click on the control's container. */\n    abstract onContainerClick(event: MouseEvent): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatFormFieldControl<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatFormFieldControl<any>, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * Represents the default options for the form field that can be configured\n * using the `MAT_FORM_FIELD_DEFAULT_OPTIONS` injection token.\n */\nexport declare interface MatFormFieldDefaultOptions {\n    /** Default form field appearance style. */\n    appearance?: MatFormFieldAppearance;\n    /** Default color of the form field. */\n    color?: ThemePalette;\n    /** Whether the required marker should be hidden by default. */\n    hideRequiredMarker?: boolean;\n    /**\n     * Whether the label for form fields should by default float `always`,\n     * `never`, or `auto` (only when necessary).\n     */\n    floatLabel?: FloatLabelType;\n}\n\nexport declare class MatFormFieldModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatFormFieldModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatFormFieldModule, [typeof i1.MatError, typeof i2.MatFormField, typeof i3.MatHint, typeof i4.MatLabel, typeof i5.MatPlaceholder, typeof i6.MatPrefix, typeof i7.MatSuffix], [typeof i8.CommonModule, typeof i9.MatCommonModule, typeof i10.ObserversModule], [typeof i9.MatCommonModule, typeof i1.MatError, typeof i2.MatFormField, typeof i3.MatHint, typeof i4.MatLabel, typeof i5.MatPlaceholder, typeof i6.MatPrefix, typeof i7.MatSuffix]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatFormFieldModule>;\n}\n\n/** Hint text to be shown underneath the form field control. */\nexport declare class MatHint {\n    /** Whether to align the hint label at the start or end of the line. */\n    align: 'start' | 'end';\n    /** Unique ID for the hint. Used for the aria-describedby on the form field control. */\n    id: string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatHint, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatHint, \"mat-hint\", never, { \"align\": \"align\"; \"id\": \"id\"; }, {}, never, never, false>;\n}\n\n/** The floating label for a `mat-form-field`. */\nexport declare class MatLabel {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatLabel, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatLabel, \"mat-label\", never, {}, {}, never, never, false>;\n}\n\n/**\n * The placeholder text for an `MatFormField`.\n * @deprecated Use `<mat-label>` to specify the label and the `placeholder` attribute to specify the\n *     placeholder.\n * @breaking-change 8.0.0\n */\nexport declare class MatPlaceholder {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPlaceholder, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatPlaceholder, \"mat-placeholder\", never, {}, {}, never, never, false>;\n}\n\n/** Prefix to be placed in front of the form field. */\nexport declare class MatPrefix {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPrefix, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatPrefix, \"[matPrefix]\", never, {}, {}, never, never, false>;\n}\n\n/** Suffix to be placed at the end of the form field. */\nexport declare class MatSuffix {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSuffix, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatSuffix, \"[matSuffix]\", never, {}, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/form-field/testing/control/index.d.ts",
      "node_modules/@angular/material/form-field/testing/control/index.d.ts"
    ],
    "content": "import { ComponentHarness } from '@angular/cdk/testing';\n\n/**\n * Base class for custom form-field control harnesses. Harnesses for\n * custom controls with form-fields need to implement this interface.\n */\nexport declare abstract class MatFormFieldControlHarness extends ComponentHarness {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/form-field/testing/index.d.ts",
      "node_modules/@angular/material/form-field/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatDatepickerInputHarness } from '@angular/material/datepicker/testing';\nimport { MatDateRangeInputHarness } from '@angular/material/datepicker/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\nimport { MatInputHarness } from '@angular/material/input/testing';\nimport { MatSelectHarness } from '@angular/material/select/testing';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** Possible harnesses of controls which can be bound to a form-field. */\nexport declare type FormFieldControlHarness = MatInputHarness | MatSelectHarness | MatDatepickerInputHarness | MatDateRangeInputHarness;\n\n/** A set of criteria that can be used to filter a list of `MatFormFieldHarness` instances. */\nexport declare interface FormFieldHarnessFilters extends BaseHarnessFilters {\n    /** Filters based on the text of the form field's floating label. */\n    floatingLabelText?: string | RegExp;\n    /** Filters based on whether the form field has error messages. */\n    hasErrors?: boolean;\n}\n\nexport { MatFormFieldControlHarness }\n\n/** Harness for interacting with a standard Material form-field's in tests. */\nexport declare class MatFormFieldHarness extends _MatFormFieldHarnessBase<FormFieldControlHarness> {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatFormFieldHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which form field instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: FormFieldHarnessFilters): HarnessPredicate<MatFormFieldHarness>;\n    protected _prefixContainer: AsyncFactoryFn<TestElement | null>;\n    protected _suffixContainer: AsyncFactoryFn<TestElement | null>;\n    protected _label: AsyncFactoryFn<TestElement | null>;\n    protected _errors: AsyncFactoryFn<TestElement[]>;\n    protected _hints: AsyncFactoryFn<TestElement[]>;\n    protected _inputControl: AsyncFactoryFn<MatInputHarness | null>;\n    protected _selectControl: AsyncFactoryFn<MatSelectHarness | null>;\n    protected _datepickerInputControl: AsyncFactoryFn<MatDatepickerInputHarness | null>;\n    protected _dateRangeInputControl: AsyncFactoryFn<MatDateRangeInputHarness | null>;\n    /** Gets the appearance of the form-field. */\n    getAppearance(): Promise<'legacy' | 'standard' | 'fill' | 'outline'>;\n    /** Whether the form-field has a label. */\n    hasLabel(): Promise<boolean>;\n    /** Whether the label is currently floating. */\n    isLabelFloating(): Promise<boolean>;\n}\n\nexport declare abstract class _MatFormFieldHarnessBase<ControlHarness extends MatFormFieldControlHarness> extends ComponentHarness {\n    protected abstract _prefixContainer: AsyncFactoryFn<TestElement | null>;\n    protected abstract _suffixContainer: AsyncFactoryFn<TestElement | null>;\n    protected abstract _label: AsyncFactoryFn<TestElement | null>;\n    protected abstract _errors: AsyncFactoryFn<TestElement[]>;\n    protected abstract _hints: AsyncFactoryFn<TestElement[]>;\n    protected abstract _inputControl: AsyncFactoryFn<ControlHarness | null>;\n    protected abstract _selectControl: AsyncFactoryFn<ControlHarness | null>;\n    protected abstract _datepickerInputControl: AsyncFactoryFn<ControlHarness | null>;\n    protected abstract _dateRangeInputControl: AsyncFactoryFn<ControlHarness | null>;\n    /** Gets the appearance of the form-field. */\n    abstract getAppearance(): Promise<string>;\n    /** Whether the label is currently floating. */\n    abstract isLabelFloating(): Promise<boolean>;\n    /** Whether the form-field has a label. */\n    abstract hasLabel(): Promise<boolean>;\n    /** Gets the label of the form-field. */\n    getLabel(): Promise<string | null>;\n    /** Whether the form-field has errors. */\n    hasErrors(): Promise<boolean>;\n    /** Whether the form-field is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the form-field is currently autofilled. */\n    isAutofilled(): Promise<boolean>;\n    /**\n     * Gets the harness of the control that is bound to the form-field. Only\n     * default controls such as \"MatInputHarness\" and \"MatSelectHarness\" are\n     * supported.\n     */\n    getControl(): Promise<ControlHarness | null>;\n    /**\n     * Gets the harness of the control that is bound to the form-field. Searches\n     * for a control that matches the specified harness type.\n     */\n    getControl<X extends MatFormFieldControlHarness>(type: ComponentHarnessConstructor<X>): Promise<X | null>;\n    /**\n     * Gets the harness of the control that is bound to the form-field. Searches\n     * for a control that matches the specified harness predicate.\n     */\n    getControl<X extends MatFormFieldControlHarness>(type: HarnessPredicate<X>): Promise<X | null>;\n    /** Gets the theme color of the form-field. */\n    getThemeColor(): Promise<'primary' | 'accent' | 'warn'>;\n    /** Gets error messages which are currently displayed in the form-field. */\n    getTextErrors(): Promise<string[]>;\n    /** Gets hint messages which are currently displayed in the form-field. */\n    getTextHints(): Promise<string[]>;\n    /** Gets the text inside the prefix element. */\n    getPrefixText(): Promise<string>;\n    /** Gets the text inside the suffix element. */\n    getSuffixText(): Promise<string>;\n    /**\n     * Whether the form control has been touched. Returns \"null\"\n     * if no form control is set up.\n     */\n    isControlTouched(): Promise<boolean | null>;\n    /**\n     * Whether the form control is dirty. Returns \"null\"\n     * if no form control is set up.\n     */\n    isControlDirty(): Promise<boolean | null>;\n    /**\n     * Whether the form control is valid. Returns \"null\"\n     * if no form control is set up.\n     */\n    isControlValid(): Promise<boolean | null>;\n    /**\n     * Whether the form control is pending validation. Returns \"null\"\n     * if no form control is set up.\n     */\n    isControlPending(): Promise<boolean | null>;\n    /** Checks whether the form-field control has set up a form control. */\n    private _hasFormControl;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/grid-list/index.d.ts",
      "node_modules/@angular/material/grid-list/index.d.ts"
    ],
    "content": "import { AfterContentChecked } from '@angular/core';\nimport { AfterContentInit } from '@angular/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/material/core';\nimport { MatLine } from '@angular/material/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { OnInit } from '@angular/core';\nimport { QueryList } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        MatGridList\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatGridTile,\n        MatGridTileText,\n        MatGridAvatarCssMatStyler,\n        MatGridTileHeaderCssMatStyler,\n        MatGridTileFooterCssMatStyler\n    }\n}\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * @docs-private\n */\nexport declare class MatGridAvatarCssMatStyler {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatGridAvatarCssMatStyler, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatGridAvatarCssMatStyler, \"[mat-grid-avatar], [matGridAvatar]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatGridList implements MatGridListBase, OnInit, AfterContentChecked, TileStyleTarget {\n    private _element;\n    private _dir;\n    /** Number of columns being rendered. */\n    private _cols;\n    /** Used for determining the position of each tile in the grid. */\n    private _tileCoordinator;\n    /**\n     * Row height value passed in by user. This can be one of three types:\n     * - Number value (ex: \"100px\"):  sets a fixed row height to that value\n     * - Ratio value (ex: \"4:3\"): sets the row height based on width:height ratio\n     * - \"Fit\" mode (ex: \"fit\"): sets the row height to total height divided by number of rows\n     */\n    private _rowHeight;\n    /** The amount of space between tiles. This will be something like '5px' or '2em'. */\n    private _gutter;\n    /** Sets position and size styles for a tile */\n    private _tileStyler;\n    /** Query list of tiles that are being rendered. */\n    _tiles: QueryList<MatGridTile>;\n    constructor(_element: ElementRef<HTMLElement>, _dir: Directionality);\n    /** Amount of columns in the grid list. */\n    get cols(): number;\n    set cols(value: NumberInput);\n    /** Size of the grid list's gutter in pixels. */\n    get gutterSize(): string;\n    set gutterSize(value: string);\n    /** Set internal representation of row height from the user-provided value. */\n    get rowHeight(): string | number;\n    set rowHeight(value: string | number);\n    ngOnInit(): void;\n    /**\n     * The layout calculation is fairly cheap if nothing changes, so there's little cost\n     * to run it frequently.\n     */\n    ngAfterContentChecked(): void;\n    /** Throw a friendly error if cols property is missing */\n    private _checkCols;\n    /** Default to equal width:height if rowHeight property is missing */\n    private _checkRowHeight;\n    /** Creates correct Tile Styler subtype based on rowHeight passed in by user */\n    private _setTileStyler;\n    /** Computes and applies the size and position for all children grid tiles. */\n    private _layoutTiles;\n    /** Sets style on the main grid-list element, given the style name and value. */\n    _setListStyle(style: [string, string | null] | null): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatGridList, [null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatGridList, \"mat-grid-list\", [\"matGridList\"], { \"cols\": \"cols\"; \"gutterSize\": \"gutterSize\"; \"rowHeight\": \"rowHeight\"; }, {}, [\"_tiles\"], [\"*\"], false>;\n}\n\n/**\n * Base interface for a `MatGridList`.\n * @docs-private\n */\ndeclare interface MatGridListBase {\n    cols: number;\n    gutterSize: string;\n    rowHeight: number | string;\n}\n\nexport declare class MatGridListModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatGridListModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatGridListModule, [typeof i1.MatGridList, typeof i2.MatGridTile, typeof i2.MatGridTileText, typeof i2.MatGridTileHeaderCssMatStyler, typeof i2.MatGridTileFooterCssMatStyler, typeof i2.MatGridAvatarCssMatStyler], [typeof i3.MatLineModule, typeof i3.MatCommonModule], [typeof i1.MatGridList, typeof i2.MatGridTile, typeof i2.MatGridTileText, typeof i3.MatLineModule, typeof i3.MatCommonModule, typeof i2.MatGridTileHeaderCssMatStyler, typeof i2.MatGridTileFooterCssMatStyler, typeof i2.MatGridAvatarCssMatStyler]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatGridListModule>;\n}\n\nexport declare class MatGridTile {\n    private _element;\n    _gridList?: MatGridListBase | undefined;\n    _rowspan: number;\n    _colspan: number;\n    constructor(_element: ElementRef<HTMLElement>, _gridList?: MatGridListBase | undefined);\n    /** Amount of rows that the grid tile takes up. */\n    get rowspan(): number;\n    set rowspan(value: NumberInput);\n    /** Amount of columns that the grid tile takes up. */\n    get colspan(): number;\n    set colspan(value: NumberInput);\n    /**\n     * Sets the style of the grid-tile element.  Needs to be set manually to avoid\n     * \"Changed after checked\" errors that would occur with HostBinding.\n     */\n    _setStyle(property: string, value: any): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatGridTile, [null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatGridTile, \"mat-grid-tile\", [\"matGridTile\"], { \"rowspan\": \"rowspan\"; \"colspan\": \"colspan\"; }, {}, never, [\"*\"], false>;\n}\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * @docs-private\n */\nexport declare class MatGridTileFooterCssMatStyler {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatGridTileFooterCssMatStyler, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatGridTileFooterCssMatStyler, \"mat-grid-tile-footer\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * @docs-private\n */\nexport declare class MatGridTileHeaderCssMatStyler {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatGridTileHeaderCssMatStyler, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatGridTileHeaderCssMatStyler, \"mat-grid-tile-header\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatGridTileText implements AfterContentInit {\n    private _element;\n    _lines: QueryList<MatLine>;\n    constructor(_element: ElementRef<HTMLElement>);\n    ngAfterContentInit(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatGridTileText, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatGridTileText, \"mat-grid-tile-header, mat-grid-tile-footer\", never, {}, {}, [\"_lines\"], [\"[mat-grid-avatar], [matGridAvatar]\", \"[mat-line], [matLine]\", \"*\"], false>;\n}\n\n\n/**\n * Interface describing a tile.\n * @docs-private\n */\ndeclare interface Tile {\n    /** Amount of rows that the tile takes up. */\n    rowspan: number;\n    /** Amount of columns that the tile takes up. */\n    colspan: number;\n}\n\n/**\n * Class for determining, from a list of tiles, the (row, col) position of each of those tiles\n * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)\n * because the tiles can have a rowspan.\n *\n * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid\n * large enough to accommodate it so that the tiles still render in the same order in which they\n * are given.\n *\n * The basis of the algorithm is the use of an array to track the already placed tiles. Each\n * element of the array corresponds to a column, and the value indicates how many cells in that\n * column are already occupied; zero indicates an empty cell. Moving \"down\" to the next row\n * decrements each value in the tracking array (indicating that the column is one cell closer to\n * being free).\n *\n * @docs-private\n */\ndeclare class TileCoordinator {\n    /** Tracking array (see class description). */\n    tracker: number[];\n    /** Index at which the search for the next gap will start. */\n    columnIndex: number;\n    /** The current row index. */\n    rowIndex: number;\n    /** Gets the total number of rows occupied by tiles */\n    get rowCount(): number;\n    /**\n     * Gets the total span of rows occupied by tiles.\n     * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.\n     */\n    get rowspan(): number;\n    /** The computed (row, col) position of each tile (the output). */\n    positions: TilePosition[];\n    /**\n     * Updates the tile positions.\n     * @param numColumns Amount of columns in the grid.\n     * @param tiles Tiles to be positioned.\n     */\n    update(numColumns: number, tiles: Tile[]): void;\n    /** Calculates the row and col position of a tile. */\n    private _trackTile;\n    /** Finds the next available space large enough to fit the tile. */\n    private _findMatchingGap;\n    /** Move \"down\" to the next row. */\n    private _nextRow;\n    /**\n     * Finds the end index (exclusive) of a gap given the index from which to start looking.\n     * The gap ends when a non-zero value is found.\n     */\n    private _findGapEndIndex;\n    /** Update the tile tracker to account for the given tile in the given space. */\n    private _markTilePosition;\n}\n\n/**\n * Simple data structure for tile position (row, col).\n * @docs-private\n */\ndeclare class TilePosition {\n    row: number;\n    col: number;\n    constructor(row: number, col: number);\n}\n\n/** Object that can be styled by the `TileStyler`. */\ndeclare interface TileStyleTarget {\n    _setListStyle(style: [string, string | null] | null): void;\n    _tiles: QueryList<MatGridTile>;\n}\n\nexport declare const ɵTileCoordinator: typeof TileCoordinator;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/grid-list/testing/index.d.ts",
      "node_modules/@angular/material/grid-list/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of `MatGridListHarness` instances. */\nexport declare interface GridListHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of `MatTileHarness` instances. */\nexport declare interface GridTileHarnessFilters extends BaseHarnessFilters {\n    /** Text the grid-tile header should match. */\n    headerText?: string | RegExp;\n    /** Text the grid-tile footer should match. */\n    footerText?: string | RegExp;\n}\n\n/** Harness for interacting with a standard `MatGridList` in tests. */\nexport declare class MatGridListHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatGridList` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatGridListHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which dialog instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: GridListHarnessFilters): HarnessPredicate<MatGridListHarness>;\n    /**\n     * Tile coordinator that is used by the \"MatGridList\" for computing\n     * positions of tiles. We leverage the coordinator to provide an API\n     * for retrieving tiles based on visual tile positions.\n     */\n    private _tileCoordinator;\n    /** Gets all tiles of the grid-list. */\n    getTiles(filters?: GridTileHarnessFilters): Promise<MatGridTileHarness[]>;\n    /** Gets the amount of columns of the grid-list. */\n    getColumns(): Promise<number>;\n    /**\n     * Gets a tile of the grid-list that is located at the given location.\n     * @param row Zero-based row index.\n     * @param column Zero-based column index.\n     */\n    getTileAtPosition({ row, column, }: {\n        row: number;\n        column: number;\n    }): Promise<MatGridTileHarness>;\n}\n\n/** Harness for interacting with a standard `MatGridTitle` in tests. */\nexport declare class MatGridTileHarness extends ContentContainerComponentHarness<MatGridTileSection> {\n    /** The selector for the host element of a `MatGridTile` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatGridTileHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which dialog instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: GridTileHarnessFilters): HarnessPredicate<MatGridTileHarness>;\n    private _header;\n    private _footer;\n    private _avatar;\n    /** Gets the amount of rows that the grid-tile takes up. */\n    getRowspan(): Promise<number>;\n    /** Gets the amount of columns that the grid-tile takes up. */\n    getColspan(): Promise<number>;\n    /** Whether the grid-tile has a header. */\n    hasHeader(): Promise<boolean>;\n    /** Whether the grid-tile has a footer. */\n    hasFooter(): Promise<boolean>;\n    /** Whether the grid-tile has an avatar. */\n    hasAvatar(): Promise<boolean>;\n    /** Gets the text of the header if present. */\n    getHeaderText(): Promise<string | null>;\n    /** Gets the text of the footer if present. */\n    getFooterText(): Promise<string | null>;\n}\n\n/** Selectors for the various `mat-grid-tile` sections that may contain user content. */\nexport declare const enum MatGridTileSection {\n    HEADER = \".mat-grid-tile-header\",\n    FOOTER = \".mat-grid-tile-footer\"\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/icon/index.d.ts",
      "node_modules/@angular/material/icon/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewChecked } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { _Constructor } from '@angular/material/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { ElementRef } from '@angular/core';\nimport { ErrorHandler } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Optional } from '@angular/core';\nimport { SafeHtml } from '@angular/platform-browser';\nimport { SafeResourceUrl } from '@angular/platform-browser';\nimport { ThemePalette } from '@angular/material/core';\n\n/**\n * Returns an exception to be thrown when a HTML string couldn't be sanitized.\n * @param literal HTML that was attempted to be sanitized.\n * @docs-private\n */\nexport declare function getMatIconFailedToSanitizeLiteralError(literal: SafeHtml): Error;\n\n/**\n * Returns an exception to be thrown when a URL couldn't be sanitized.\n * @param url URL that was attempted to be sanitized.\n * @docs-private\n */\nexport declare function getMatIconFailedToSanitizeUrlError(url: SafeResourceUrl): Error;\n\n/**\n * Returns an exception to be thrown in the case when attempting to\n * load an icon with a name that cannot be found.\n * @docs-private\n */\nexport declare function getMatIconNameNotFoundError(iconName: string): Error;\n\n/**\n * Returns an exception to be thrown when the consumer attempts to use\n * `<mat-icon>` without including @angular/common/http.\n * @docs-private\n */\nexport declare function getMatIconNoHttpProviderError(): Error;\n\ndeclare namespace i1 {\n    export {\n        MAT_ICON_LOCATION_FACTORY,\n        MatIconDefaultOptions,\n        MAT_ICON_DEFAULT_OPTIONS,\n        MAT_ICON_LOCATION,\n        MatIconLocation,\n        MatIcon\n    }\n}\n\n/** @docs-private */\nexport declare const ICON_REGISTRY_PROVIDER: {\n    provide: typeof MatIconRegistry;\n    deps: (Optional[] | typeof DomSanitizer | typeof ErrorHandler)[];\n    useFactory: typeof ICON_REGISTRY_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\nexport declare function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry: MatIconRegistry, httpClient: HttpClient, sanitizer: DomSanitizer, errorHandler: ErrorHandler, document?: any): MatIconRegistry;\n\n/** Options that can be used to configure how an icon or the icons in an icon set are presented. */\nexport declare interface IconOptions {\n    /** View box to set on the icon. */\n    viewBox?: string;\n    /** Whether or not to fetch the icon or icon set using HTTP credentials. */\n    withCredentials?: boolean;\n}\n\n/**\n * Function that will be invoked by the icon registry when trying to resolve the\n * URL from which to fetch an icon. The returned URL will be used to make a request for the icon.\n */\nexport declare type IconResolver = (name: string, namespace: string) => SafeResourceUrl | SafeResourceUrlWithIconOptions | null;\n\n/** Injection token to be used to override the default options for `mat-icon`. */\nexport declare const MAT_ICON_DEFAULT_OPTIONS: InjectionToken<MatIconDefaultOptions>;\n\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nexport declare const MAT_ICON_LOCATION: InjectionToken<MatIconLocation>;\n\n/** @docs-private */\nexport declare function MAT_ICON_LOCATION_FACTORY(): MatIconLocation;\n\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the `fontIcon` attribute or the\n *   content of the `<mat-icon>` component. If you register a custom font class, don't forget to also\n *   include the special class `mat-ligature-font`. It is recommended to use the attribute alternative\n *   to prevent the ligature text to be selectable and to appear in search engine results.\n *   By default, the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon fontIcon=\"home\"></mat-icon>\n *     <mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\" fontIcon=\"sun\"></mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fortawesome.github.io/Font-Awesome/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\nexport declare class MatIcon extends _MatIconBase implements OnInit, AfterViewChecked, CanColor, OnDestroy {\n    private _iconRegistry;\n    private _location;\n    private readonly _errorHandler;\n    /**\n     * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n     * the element the icon is contained in.\n     */\n    get inline(): boolean;\n    set inline(inline: BooleanInput);\n    private _inline;\n    /** Name of the icon in the SVG icon set. */\n    get svgIcon(): string;\n    set svgIcon(value: string);\n    private _svgIcon;\n    /** Font set that the icon is a part of. */\n    get fontSet(): string;\n    set fontSet(value: string);\n    private _fontSet;\n    /** Name of an icon within a font set. */\n    get fontIcon(): string;\n    set fontIcon(value: string);\n    private _fontIcon;\n    private _previousFontSetClass;\n    private _previousFontIconClass;\n    _svgName: string | null;\n    _svgNamespace: string | null;\n    /** Keeps track of the current page path. */\n    private _previousPath?;\n    /** Keeps track of the elements and attributes that we've prefixed with the current path. */\n    private _elementsWithExternalReferences?;\n    /** Subscription to the current in-progress SVG icon request. */\n    private _currentIconFetch;\n    constructor(elementRef: ElementRef<HTMLElement>, _iconRegistry: MatIconRegistry, ariaHidden: string, _location: MatIconLocation, _errorHandler: ErrorHandler, defaults?: MatIconDefaultOptions);\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws an error if the name contains two or more ':' separators.\n     * Examples:\n     *   `'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws Error)`\n     */\n    private _splitIconName;\n    ngOnInit(): void;\n    ngAfterViewChecked(): void;\n    ngOnDestroy(): void;\n    _usingFontIcon(): boolean;\n    private _setSvgElement;\n    private _clearSvgElement;\n    private _updateFontIconClasses;\n    /**\n     * Cleans up a value to be used as a fontIcon or fontSet.\n     * Since the value ends up being assigned as a CSS class, we\n     * have to trim the value and omit space-separated values.\n     */\n    private _cleanupFontValue;\n    /**\n     * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n     * reference. This is required because WebKit browsers require references to be prefixed with\n     * the current path, if the page has a `base` tag.\n     */\n    private _prependPathToReferences;\n    /**\n     * Caches the children of an SVG element that have `url()`\n     * references that we need to prefix with the current path.\n     */\n    private _cacheChildrenWithExternalReferences;\n    /** Sets a new SVG icon with a particular name. */\n    private _updateSvgIcon;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatIcon, [null, null, { attribute: \"aria-hidden\"; }, null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatIcon, \"mat-icon\", [\"matIcon\"], { \"color\": \"color\"; \"inline\": \"inline\"; \"svgIcon\": \"svgIcon\"; \"fontSet\": \"fontSet\"; \"fontIcon\": \"fontIcon\"; }, {}, never, [\"*\"], false>;\n}\n\n/** @docs-private */\ndeclare const _MatIconBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\n/** Default options for `mat-icon`.  */\nexport declare interface MatIconDefaultOptions {\n    /** Default color of the icon. */\n    color?: ThemePalette;\n    /** Font set that the icon is a part of. */\n    fontSet?: string;\n}\n\n/**\n * Stubbed out location for `MatIcon`.\n * @docs-private\n */\nexport declare interface MatIconLocation {\n    getPathname: () => string;\n}\n\nexport declare class MatIconModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatIconModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatIconModule, [typeof i1.MatIcon], [typeof i2.MatCommonModule], [typeof i1.MatIcon, typeof i2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatIconModule>;\n}\n\n/**\n * Service to register and display icons used by the `<mat-icon>` component.\n * - Registers icon URLs by namespace and name.\n * - Registers icon set URLs by namespace.\n * - Registers aliases for CSS classes, for use with icon fonts.\n * - Loads icons from URLs and extracts individual icons from icon sets.\n */\nexport declare class MatIconRegistry implements OnDestroy {\n    private _httpClient;\n    private _sanitizer;\n    private readonly _errorHandler;\n    private _document;\n    /**\n     * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\n     */\n    private _svgIconConfigs;\n    /**\n     * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\n     * Multiple icon sets can be registered under the same namespace.\n     */\n    private _iconSetConfigs;\n    /** Cache for icons loaded by direct URLs. */\n    private _cachedIconsByUrl;\n    /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */\n    private _inProgressUrlFetches;\n    /** Map from font identifiers to their CSS class names. Used for icon fonts. */\n    private _fontCssClassesByAlias;\n    /** Registered icon resolver functions. */\n    private _resolvers;\n    /**\n     * The CSS classes to apply when an `<mat-icon>` component has no icon name, url, or font\n     * specified. The default 'material-icons' value assumes that the material icon font has been\n     * loaded as described at http://google.github.io/material-design-icons/#icon-font-for-the-web\n     */\n    private _defaultFontSetClass;\n    constructor(_httpClient: HttpClient, _sanitizer: DomSanitizer, document: any, _errorHandler: ErrorHandler);\n    /**\n     * Registers an icon by URL in the default namespace.\n     * @param iconName Name under which the icon should be registered.\n     * @param url\n     */\n    addSvgIcon(iconName: string, url: SafeResourceUrl, options?: IconOptions): this;\n    /**\n     * Registers an icon using an HTML string in the default namespace.\n     * @param iconName Name under which the icon should be registered.\n     * @param literal SVG source of the icon.\n     */\n    addSvgIconLiteral(iconName: string, literal: SafeHtml, options?: IconOptions): this;\n    /**\n     * Registers an icon by URL in the specified namespace.\n     * @param namespace Namespace in which the icon should be registered.\n     * @param iconName Name under which the icon should be registered.\n     * @param url\n     */\n    addSvgIconInNamespace(namespace: string, iconName: string, url: SafeResourceUrl, options?: IconOptions): this;\n    /**\n     * Registers an icon resolver function with the registry. The function will be invoked with the\n     * name and namespace of an icon when the registry tries to resolve the URL from which to fetch\n     * the icon. The resolver is expected to return a `SafeResourceUrl` that points to the icon,\n     * an object with the icon URL and icon options, or `null` if the icon is not supported. Resolvers\n     * will be invoked in the order in which they have been registered.\n     * @param resolver Resolver function to be registered.\n     */\n    addSvgIconResolver(resolver: IconResolver): this;\n    /**\n     * Registers an icon using an HTML string in the specified namespace.\n     * @param namespace Namespace in which the icon should be registered.\n     * @param iconName Name under which the icon should be registered.\n     * @param literal SVG source of the icon.\n     */\n    addSvgIconLiteralInNamespace(namespace: string, iconName: string, literal: SafeHtml, options?: IconOptions): this;\n    /**\n     * Registers an icon set by URL in the default namespace.\n     * @param url\n     */\n    addSvgIconSet(url: SafeResourceUrl, options?: IconOptions): this;\n    /**\n     * Registers an icon set using an HTML string in the default namespace.\n     * @param literal SVG source of the icon set.\n     */\n    addSvgIconSetLiteral(literal: SafeHtml, options?: IconOptions): this;\n    /**\n     * Registers an icon set by URL in the specified namespace.\n     * @param namespace Namespace in which to register the icon set.\n     * @param url\n     */\n    addSvgIconSetInNamespace(namespace: string, url: SafeResourceUrl, options?: IconOptions): this;\n    /**\n     * Registers an icon set using an HTML string in the specified namespace.\n     * @param namespace Namespace in which to register the icon set.\n     * @param literal SVG source of the icon set.\n     */\n    addSvgIconSetLiteralInNamespace(namespace: string, literal: SafeHtml, options?: IconOptions): this;\n    /**\n     * Defines an alias for CSS class names to be used for icon fonts. Creating an matIcon\n     * component with the alias as the fontSet input will cause the class name to be applied\n     * to the `<mat-icon>` element.\n     *\n     * If the registered font is a ligature font, then don't forget to also include the special\n     * class `mat-ligature-font` to allow the usage via attribute. So register like this:\n     *\n     * ```ts\n     * iconRegistry.registerFontClassAlias('f1', 'font1 mat-ligature-font');\n     * ```\n     *\n     * And use like this:\n     *\n     * ```html\n     * <mat-icon fontSet=\"f1\" fontIcon=\"home\"></mat-icon>\n     * ```\n     *\n     * @param alias Alias for the font.\n     * @param classNames Class names override to be used instead of the alias.\n     */\n    registerFontClassAlias(alias: string, classNames?: string): this;\n    /**\n     * Returns the CSS class name associated with the alias by a previous call to\n     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\n     */\n    classNameForFontAlias(alias: string): string;\n    /**\n     * Sets the CSS classes to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     */\n    setDefaultFontSetClass(...classNames: string[]): this;\n    /**\n     * Returns the CSS classes to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     */\n    getDefaultFontSetClass(): string[];\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\n     * it will not contain any modifications made to elements previously returned).\n     *\n     * @param safeUrl URL from which to fetch the SVG icon.\n     */\n    getSvgIconFromUrl(safeUrl: SafeResourceUrl): Observable<SVGElement>;\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name\n     * and namespace. The icon must have been previously registered with addIcon or addIconSet;\n     * if not, the Observable will throw an error.\n     *\n     * @param name Name of the icon to be retrieved.\n     * @param namespace Namespace in which to look for the icon.\n     */\n    getNamedSvgIcon(name: string, namespace?: string): Observable<SVGElement>;\n    ngOnDestroy(): void;\n    /**\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\n     */\n    private _getSvgFromConfig;\n    /**\n     * Attempts to find an icon with the specified name in any of the SVG icon sets.\n     * First searches the available cached icons for a nested element with a matching name, and\n     * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets\n     * that have not been cached, and searches again after all fetches are completed.\n     * The returned Observable produces the SVG element if possible, and throws\n     * an error if no icon with the specified name can be found.\n     */\n    private _getSvgFromIconSetConfigs;\n    /**\n     * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     */\n    private _extractIconWithNameFromAnySet;\n    /**\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     */\n    private _loadSvgIconFromConfig;\n    /**\n     * Loads the content of the icon set URL specified in the\n     * SvgIconConfig and attaches it to the config.\n     */\n    private _loadSvgIconSetFromConfig;\n    /**\n     * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     */\n    private _extractSvgIconFromSet;\n    /**\n     * Creates a DOM element from the given SVG string.\n     */\n    private _svgElementFromString;\n    /**\n     * Converts an element into an SVG node by cloning all of its children.\n     */\n    private _toSvgElement;\n    /**\n     * Sets the default attributes for an SVG element to be used as an icon.\n     */\n    private _setSvgAttributes;\n    /**\n     * Returns an Observable which produces the string contents of the given icon. Results may be\n     * cached, so future calls with the same URL may not cause another HTTP request.\n     */\n    private _fetchIcon;\n    /**\n     * Registers an icon config by name in the specified namespace.\n     * @param namespace Namespace in which to register the icon config.\n     * @param iconName Name under which to register the config.\n     * @param config Config to be registered.\n     */\n    private _addSvgIconConfig;\n    /**\n     * Registers an icon set config in the specified namespace.\n     * @param namespace Namespace in which to register the icon config.\n     * @param config Config to be registered.\n     */\n    private _addSvgIconSetConfig;\n    /** Parses a config's text into an SVG element. */\n    private _svgElementFromConfig;\n    /** Tries to create an icon config through the registered resolver functions. */\n    private _getIconConfigFromResolvers;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatIconRegistry, [{ optional: true; }, null, { optional: true; }, null]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatIconRegistry>;\n}\n\n/** Object that specifies a URL from which to fetch an icon and the options to use for it. */\nexport declare interface SafeResourceUrlWithIconOptions {\n    url: SafeResourceUrl;\n    options: IconOptions;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/icon/testing/index.d.ts",
      "node_modules/@angular/material/icon/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport * as i0 from '@angular/core';\nimport { MatIconRegistry } from '@angular/material/icon';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\n\n/**\n * A null icon registry that must be imported to allow disabling of custom\n * icons.\n */\nexport declare class FakeMatIconRegistry implements PublicApi<MatIconRegistry>, OnDestroy {\n    addSvgIcon(): this;\n    addSvgIconLiteral(): this;\n    addSvgIconInNamespace(): this;\n    addSvgIconLiteralInNamespace(): this;\n    addSvgIconSet(): this;\n    addSvgIconSetLiteral(): this;\n    addSvgIconSetInNamespace(): this;\n    addSvgIconSetLiteralInNamespace(): this;\n    registerFontClassAlias(): this;\n    classNameForFontAlias(alias: string): string;\n    getDefaultFontSetClass(): string[];\n    getSvgIconFromUrl(): Observable<SVGElement>;\n    getNamedSvgIcon(): Observable<SVGElement>;\n    setDefaultFontSetClass(): this;\n    addSvgIconResolver(): this;\n    ngOnDestroy(): void;\n    private _generateEmptySvg;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FakeMatIconRegistry, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<FakeMatIconRegistry>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatIconHarness` instances. */\nexport declare interface IconHarnessFilters extends BaseHarnessFilters {\n    /** Filters based on the typef of the icon. */\n    type?: IconType;\n    /** Filters based on the name of the icon. */\n    name?: string | RegExp;\n    /** Filters based on the namespace of the icon. */\n    namespace?: string | null | RegExp;\n}\n\n/** Possible types of icons. */\nexport declare const enum IconType {\n    SVG = 0,\n    FONT = 1\n}\n\n/** Harness for interacting with a standard mat-icon in tests. */\nexport declare class MatIconHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatIcon` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatIconHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which icon instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: IconHarnessFilters): HarnessPredicate<MatIconHarness>;\n    /** Gets the type of the icon. */\n    getType(): Promise<IconType>;\n    /** Gets the name of the icon. */\n    getName(): Promise<string | null>;\n    /** Gets the namespace of the icon. */\n    getNamespace(): Promise<string | null>;\n    /** Gets whether the icon is inline. */\n    isInline(): Promise<boolean>;\n}\n\n/** Import this module in tests to install the null icon registry. */\nexport declare class MatIconTestingModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatIconTestingModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatIconTestingModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatIconTestingModule>;\n}\n\ndeclare type PublicApi<T> = {\n    [K in keyof T]: T[K] extends (...x: any[]) => T ? (...x: any[]) => PublicApi<T> : T[K];\n};\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/index.d.ts",
      "node_modules/@angular/material/index.d.ts"
    ],
    "content": "\nexport declare const ɵɵtsModuleIndicatorApiExtractorWorkaround = true;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/input/index.d.ts",
      "node_modules/@angular/material/input/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AutofillMonitor } from '@angular/cdk/text-field';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanUpdateErrorState } from '@angular/material/core';\nimport { _Constructor } from '@angular/material/core';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { ErrorStateMatcher } from '@angular/material/core';\nimport { FormGroupDirective } from '@angular/forms';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/cdk/text-field';\nimport * as i3 from '@angular/material/form-field';\nimport * as i4 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { MatFormField } from '@angular/material/form-field';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { NgControl } from '@angular/forms';\nimport { NgForm } from '@angular/forms';\nimport { NgZone } from '@angular/core';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs';\n\n\n/** @docs-private */\nexport declare function getMatInputUnsupportedTypeError(type: string): Error;\n\ndeclare namespace i1 {\n    export {\n        MatInput\n    }\n}\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport declare const MAT_INPUT_VALUE_ACCESSOR: InjectionToken<{\n    value: any;\n}>;\n\n/** Directive that allows a native input to work inside a `MatFormField`. */\nexport declare class MatInput extends _MatInputBase implements MatFormFieldControl<any>, OnChanges, OnDestroy, AfterViewInit, DoCheck, CanUpdateErrorState {\n    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>;\n    protected _platform: Platform;\n    private _autofillMonitor;\n    private _formField?;\n    protected _uid: string;\n    protected _previousNativeValue: any;\n    private _inputValueAccessor;\n    private _previousPlaceholder;\n    /** Whether the component is being rendered on the server. */\n    readonly _isServer: boolean;\n    /** Whether the component is a native html select. */\n    readonly _isNativeSelect: boolean;\n    /** Whether the component is a textarea. */\n    readonly _isTextarea: boolean;\n    /** Whether the input is inside of a form field. */\n    readonly _isInFormField: boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    focused: boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    readonly stateChanges: Subject<void>;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    controlType: string;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    autofilled: boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    protected _disabled: boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id(): string;\n    set id(value: string);\n    protected _id: string;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    placeholder: string;\n    /**\n     * Name of the input.\n     * @docs-private\n     */\n    name: string;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    protected _required: boolean | undefined;\n    /** Input type of the element. */\n    get type(): string;\n    set type(value: string);\n    protected _type: string;\n    /** An object used to control when error messages are shown. */\n    errorStateMatcher: ErrorStateMatcher;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    userAriaDescribedBy: string;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value(): string;\n    set value(value: any);\n    /** Whether the element is readonly. */\n    get readonly(): boolean;\n    set readonly(value: BooleanInput);\n    private _readonly;\n    protected _neverEmptyInputTypes: string[];\n    constructor(_elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>, _platform: Platform, ngControl: NgControl, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, _defaultErrorStateMatcher: ErrorStateMatcher, inputValueAccessor: any, _autofillMonitor: AutofillMonitor, ngZone: NgZone, _formField?: MatFormField | undefined);\n    ngAfterViewInit(): void;\n    ngOnChanges(): void;\n    ngOnDestroy(): void;\n    ngDoCheck(): void;\n    /** Focuses the input. */\n    focus(options?: FocusOptions): void;\n    /** Callback for the cases where the focused state of the input changes. */\n    _focusChanged(isFocused: boolean): void;\n    _onInput(): void;\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\n    private _dirtyCheckPlaceholder;\n    /** Does some manual dirty checking on the native input `value` property. */\n    protected _dirtyCheckNativeValue(): void;\n    /** Make sure the input is a supported type. */\n    protected _validateType(): void;\n    /** Checks whether the input type is one of the types that are never empty. */\n    protected _isNeverEmpty(): boolean;\n    /** Checks whether the input is invalid based on the native validation. */\n    protected _isBadInput(): boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty(): boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat(): boolean;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids: string[]): void;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick(): void;\n    /** Whether the form control is a native select that is displayed inline. */\n    _isInlineSelect(): boolean;\n    private _iOSKeyupListener;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatInput, [null, null, { optional: true; self: true; }, { optional: true; }, { optional: true; }, null, { optional: true; self: true; }, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatInput, \"input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]\", [\"matInput\"], { \"disabled\": \"disabled\"; \"id\": \"id\"; \"placeholder\": \"placeholder\"; \"name\": \"name\"; \"required\": \"required\"; \"type\": \"type\"; \"errorStateMatcher\": \"errorStateMatcher\"; \"userAriaDescribedBy\": \"aria-describedby\"; \"value\": \"value\"; \"readonly\": \"readonly\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatInputBase: _Constructor<CanUpdateErrorState> & _AbstractConstructor<CanUpdateErrorState> & {\n    new (_defaultErrorStateMatcher: ErrorStateMatcher, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, ngControl: NgControl): {\n        /**\n         * Emits whenever the component state changes and should cause the parent\n         * form field to update. Implemented as part of `MatFormFieldControl`.\n         * @docs-private\n         */\n        readonly stateChanges: Subject<void>;\n        _defaultErrorStateMatcher: ErrorStateMatcher;\n        _parentForm: NgForm;\n        _parentFormGroup: FormGroupDirective;\n        /**\n         * Form control bound to the component.\n         * Implemented as part of `MatFormFieldControl`.\n         * @docs-private\n         */\n        ngControl: NgControl;\n    };\n};\n\nexport declare class MatInputModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatInputModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatInputModule, [typeof i1.MatInput], [typeof i2.TextFieldModule, typeof i3.MatFormFieldModule, typeof i4.MatCommonModule], [typeof i2.TextFieldModule, typeof i3.MatFormFieldModule, typeof i1.MatInput]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatInputModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/input/testing/index.d.ts",
      "node_modules/@angular/material/input/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\n\n/** A set of criteria that can be used to filter a list of `MatInputHarness` instances. */\nexport declare interface InputHarnessFilters extends BaseHarnessFilters {\n    /** Filters based on the value of the input. */\n    value?: string | RegExp;\n    /** Filters based on the placeholder text of the input. */\n    placeholder?: string | RegExp;\n}\n\n/** Harness for interacting with a standard Material inputs in tests. */\nexport declare class MatInputHarness extends MatFormFieldControlHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatInputHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: InputHarnessFilters): HarnessPredicate<MatInputHarness>;\n    /** Whether the input is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the input is required. */\n    isRequired(): Promise<boolean>;\n    /** Whether the input is readonly. */\n    isReadonly(): Promise<boolean>;\n    /** Gets the value of the input. */\n    getValue(): Promise<string>;\n    /** Gets the name of the input. */\n    getName(): Promise<string>;\n    /**\n     * Gets the type of the input. Returns \"textarea\" if the input is\n     * a textarea.\n     */\n    getType(): Promise<string>;\n    /** Gets the placeholder of the input. */\n    getPlaceholder(): Promise<string>;\n    /** Gets the id of the input. */\n    getId(): Promise<string>;\n    /**\n     * Focuses the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    focus(): Promise<void>;\n    /**\n     * Blurs the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    blur(): Promise<void>;\n    /** Whether the input is focused. */\n    isFocused(): Promise<boolean>;\n    /**\n     * Sets the value of the input. The value will be set by simulating\n     * keypresses that correspond to the given value.\n     */\n    setValue(newValue: string): Promise<void>;\n}\n\n/** Harness for interacting with a native `option` in tests. */\nexport declare class MatNativeOptionHarness extends ComponentHarness {\n    /** Selector used to locate option instances. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNativeOptionHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which option instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: NativeOptionHarnessFilters): HarnessPredicate<MatNativeOptionHarness>;\n    /** Gets the option's label text. */\n    getText(): Promise<string>;\n    /** Index of the option within the native `select` element. */\n    getIndex(): Promise<number>;\n    /** Gets whether the option is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets whether the option is selected. */\n    isSelected(): Promise<boolean>;\n}\n\n/** Harness for interacting with a native `select` in tests. */\nexport declare class MatNativeSelectHarness extends MatFormFieldControlHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNativeSelectHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which select instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: NativeSelectHarnessFilters): HarnessPredicate<MatNativeSelectHarness>;\n    /** Gets a boolean promise indicating if the select is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets a boolean promise indicating if the select is required. */\n    isRequired(): Promise<boolean>;\n    /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n    isMultiple(): Promise<boolean>;\n    /** Gets the name of the select. */\n    getName(): Promise<string>;\n    /** Gets the id of the select. */\n    getId(): Promise<string>;\n    /** Focuses the select and returns a void promise that indicates when the action is complete. */\n    focus(): Promise<void>;\n    /** Blurs the select and returns a void promise that indicates when the action is complete. */\n    blur(): Promise<void>;\n    /** Whether the select is focused. */\n    isFocused(): Promise<boolean>;\n    /** Gets the options inside the select panel. */\n    getOptions(filter?: NativeOptionHarnessFilters): Promise<MatNativeOptionHarness[]>;\n    /**\n     * Selects the options that match the passed-in filter. If the select is in multi-selection\n     * mode all options will be clicked, otherwise the harness will pick the first matching option.\n     */\n    selectOptions(filter?: NativeOptionHarnessFilters): Promise<void>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatNativeOptionHarness` instances. */\nexport declare interface NativeOptionHarnessFilters extends BaseHarnessFilters {\n    text?: string | RegExp;\n    index?: number;\n    isSelected?: boolean;\n}\n\n/** A set of criteria that can be used to filter a list of `MatNativeSelectHarness` instances. */\nexport declare interface NativeSelectHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/list/index.d.ts",
      "node_modules/@angular/material/list/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/material/core';\nimport * as i4 from '@angular/common';\nimport * as i5 from '@angular/material/divider';\nimport { InjectionToken } from '@angular/core';\nimport { MatLine } from '@angular/material/core';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { ThemePalette } from '@angular/material/core';\n\ndeclare namespace i1 {\n    export {\n        MAT_LIST,\n        MAT_NAV_LIST,\n        MatNavList,\n        MatList,\n        MatListAvatarCssMatStyler,\n        MatListIconCssMatStyler,\n        MatListSubheaderCssMatStyler,\n        MatListItem\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MAT_SELECTION_LIST_VALUE_ACCESSOR,\n        MatSelectionListChange,\n        MatListOptionCheckboxPosition,\n        MatListOption,\n        MatSelectionList\n    }\n}\n\n/**\n * Injection token that can be used to inject instances of `MatList`. It serves as\n * alternative token to the actual `MatList` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport declare const MAT_LIST: InjectionToken<MatList>;\n\n/**\n * Injection token that can be used to inject instances of `MatNavList`. It serves as\n * alternative token to the actual `MatNavList` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport declare const MAT_NAV_LIST: InjectionToken<MatNavList>;\n\n/** @docs-private */\nexport declare const MAT_SELECTION_LIST_VALUE_ACCESSOR: any;\n\nexport declare class MatList extends _MatListBase implements CanDisable, CanDisableRipple, OnChanges, OnDestroy {\n    private _elementRef;\n    /** Emits when the state of the list changes. */\n    readonly _stateChanges: Subject<void>;\n    constructor(_elementRef: ElementRef<HTMLElement>);\n    _getListType(): 'list' | 'action-list' | null;\n    ngOnChanges(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatList, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatList, \"mat-list, mat-action-list\", [\"matList\"], { \"disableRipple\": \"disableRipple\"; \"disabled\": \"disabled\"; }, {}, never, [\"*\"], false>;\n}\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * @docs-private\n */\nexport declare class MatListAvatarCssMatStyler {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatListAvatarCssMatStyler, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatListAvatarCssMatStyler, \"[mat-list-avatar], [matListAvatar]\", never, {}, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatListBase: _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (): {};\n};\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * @docs-private\n */\nexport declare class MatListIconCssMatStyler {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatListIconCssMatStyler, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatListIconCssMatStyler, \"[mat-list-icon], [matListIcon]\", never, {}, {}, never, never, false>;\n}\n\n/** An item within a Material Design list. */\nexport declare class MatListItem extends _MatListItemMixinBase implements AfterContentInit, CanDisableRipple, OnDestroy {\n    private _element;\n    private _isInteractiveList;\n    private _list?;\n    private readonly _destroyed;\n    _lines: QueryList<MatLine>;\n    _avatar: MatListAvatarCssMatStyler;\n    _icon: MatListIconCssMatStyler;\n    constructor(_element: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, navList?: MatNavList, list?: MatList);\n    /** Whether the option is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Whether this list item should show a ripple effect when clicked. */\n    _isRippleDisabled(): boolean;\n    /** Retrieves the DOM element of the component host. */\n    _getHostElement(): HTMLElement;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatListItem, [null, null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatListItem, \"mat-list-item, a[mat-list-item], button[mat-list-item]\", [\"matListItem\"], { \"disableRipple\": \"disableRipple\"; \"disabled\": \"disabled\"; }, {}, [\"_avatar\", \"_icon\", \"_lines\"], [\"[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]\", \"[mat-line], [matLine]\", \"*\"], false>;\n}\n\n/** @docs-private */\ndeclare const _MatListItemMixinBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (): {};\n};\n\nexport declare class MatListModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatListModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatListModule, [typeof i1.MatList, typeof i1.MatNavList, typeof i1.MatListItem, typeof i1.MatListAvatarCssMatStyler, typeof i1.MatListIconCssMatStyler, typeof i1.MatListSubheaderCssMatStyler, typeof i2.MatSelectionList, typeof i2.MatListOption], [typeof i3.MatLineModule, typeof i3.MatRippleModule, typeof i3.MatCommonModule, typeof i3.MatPseudoCheckboxModule, typeof i4.CommonModule], [typeof i1.MatList, typeof i1.MatNavList, typeof i1.MatListItem, typeof i1.MatListAvatarCssMatStyler, typeof i3.MatLineModule, typeof i3.MatCommonModule, typeof i1.MatListIconCssMatStyler, typeof i1.MatListSubheaderCssMatStyler, typeof i3.MatPseudoCheckboxModule, typeof i2.MatSelectionList, typeof i2.MatListOption, typeof i5.MatDividerModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatListModule>;\n}\n\n/**\n * Component for list-options of selection-list. Each list-option can automatically\n * generate a checkbox and can put current item into the selectionModel of selection-list\n * if the current item is selected.\n */\nexport declare class MatListOption extends _MatListOptionBase implements AfterContentInit, OnDestroy, OnInit, FocusableOption, CanDisableRipple {\n    private _element;\n    private _changeDetector;\n    /** @docs-private */\n    selectionList: MatSelectionList;\n    private _selected;\n    private _disabled;\n    private _hasFocus;\n    _avatar: MatListAvatarCssMatStyler;\n    _icon: MatListIconCssMatStyler;\n    _lines: QueryList<MatLine>;\n    /**\n     * Emits when the selected state of the option has changed.\n     * Use to facilitate two-data binding to the `selected` property.\n     * @docs-private\n     */\n    readonly selectedChange: EventEmitter<boolean>;\n    /** DOM element containing the item's text. */\n    _text: ElementRef;\n    /** Whether the label should appear before or after the checkbox. Defaults to 'after' */\n    checkboxPosition: MatListOptionCheckboxPosition;\n    /** Theme color of the list option. This sets the color of the checkbox. */\n    get color(): ThemePalette;\n    set color(newValue: ThemePalette);\n    private _color;\n    /**\n     * This is set to true after the first OnChanges cycle so we don't clear the value of `selected`\n     * in the first cycle.\n     */\n    private _inputsInitialized;\n    /** Value of the option */\n    get value(): any;\n    set value(newValue: any);\n    private _value;\n    /** Whether the option is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    /** Whether the option is selected. */\n    get selected(): boolean;\n    set selected(value: BooleanInput);\n    constructor(_element: ElementRef<HTMLElement>, _changeDetector: ChangeDetectorRef, \n    /** @docs-private */\n    selectionList: MatSelectionList);\n    ngOnInit(): void;\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Toggles the selection state of the option. */\n    toggle(): void;\n    /** Allows for programmatic focusing of the option. */\n    focus(): void;\n    /**\n     * Returns the list item's text label. Implemented as a part of the FocusKeyManager.\n     * @docs-private\n     */\n    getLabel(): any;\n    /** Whether this list item should show a ripple effect when clicked. */\n    _isRippleDisabled(): boolean;\n    _handleClick(): void;\n    _handleFocus(): void;\n    _handleBlur(): void;\n    /** Retrieves the DOM element of the component host. */\n    _getHostElement(): HTMLElement;\n    /** Sets the selected state of the option. Returns whether the value has changed. */\n    _setSelected(selected: boolean): boolean;\n    /**\n     * Notifies Angular that the option needs to be checked in the next change detection run. Mainly\n     * used to trigger an update of the list option if the disabled state of the selection list\n     * changed.\n     */\n    _markForCheck(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatListOption, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatListOption, \"mat-list-option\", [\"matListOption\"], { \"disableRipple\": \"disableRipple\"; \"checkboxPosition\": \"checkboxPosition\"; \"color\": \"color\"; \"value\": \"value\"; \"disabled\": \"disabled\"; \"selected\": \"selected\"; }, { \"selectedChange\": \"selectedChange\"; }, [\"_avatar\", \"_icon\", \"_lines\"], [\"*\", \"[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]\"], false>;\n}\n\ndeclare const _MatListOptionBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (): {};\n};\n\n/**\n * Type describing possible positions of a checkbox in a list option\n * with respect to the list item's text.\n */\nexport declare type MatListOptionCheckboxPosition = 'before' | 'after';\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * @docs-private\n */\nexport declare class MatListSubheaderCssMatStyler {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatListSubheaderCssMatStyler, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatListSubheaderCssMatStyler, \"[mat-subheader], [matSubheader]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatNavList extends _MatListBase implements CanDisable, CanDisableRipple, OnChanges, OnDestroy {\n    /** Emits when the state of the list changes. */\n    readonly _stateChanges: Subject<void>;\n    ngOnChanges(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatNavList, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatNavList, \"mat-nav-list\", [\"matNavList\"], { \"disableRipple\": \"disableRipple\"; \"disabled\": \"disabled\"; }, {}, never, [\"*\"], false>;\n}\n\n/**\n * Material Design list component where each item is a selectable option. Behaves as a listbox.\n */\nexport declare class MatSelectionList extends _MatSelectionListBase implements CanDisableRipple, AfterContentInit, ControlValueAccessor, OnDestroy, OnChanges {\n    private _element;\n    private _changeDetector;\n    private _focusMonitor;\n    private _multiple;\n    private _contentInitialized;\n    /** The FocusKeyManager which handles focus. */\n    _keyManager: FocusKeyManager<MatListOption>;\n    /** The option components contained within this selection-list. */\n    options: QueryList<MatListOption>;\n    /** Emits a change event whenever the selected state of an option changes. */\n    readonly selectionChange: EventEmitter<MatSelectionListChange>;\n    /** Theme color of the selection list. This sets the checkbox color for all list options. */\n    color: ThemePalette;\n    /**\n     * Function used for comparing an option against the selected value when determining which\n     * options should appear as selected. The first argument is the value of an options. The second\n     * one is a value from the selected value. A boolean must be returned.\n     */\n    compareWith: (o1: any, o2: any) => boolean;\n    /** Whether the selection list is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Whether selection is limited to one or multiple items (default multiple). */\n    get multiple(): boolean;\n    set multiple(value: BooleanInput);\n    /** The currently selected options. */\n    selectedOptions: SelectionModel<MatListOption>;\n    /** The tabindex of the selection list. */\n    _tabIndex: number;\n    /** View to model callback that should be called whenever the selected options change. */\n    private _onChange;\n    /** Keeps track of the currently-selected value. */\n    _value: string[] | null;\n    /** Emits when the list has been destroyed. */\n    private readonly _destroyed;\n    /** View to model callback that should be called if the list or its options lost focus. */\n    _onTouched: () => void;\n    /** Whether the list has been destroyed. */\n    private _isDestroyed;\n    constructor(_element: ElementRef<HTMLElement>, _changeDetector: ChangeDetectorRef, _focusMonitor: FocusMonitor);\n    ngAfterContentInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Focuses the selection list. */\n    focus(options?: FocusOptions): void;\n    /** Selects all of the options. Returns the options that changed as a result. */\n    selectAll(): MatListOption[];\n    /** Deselects all of the options. Returns the options that changed as a result. */\n    deselectAll(): MatListOption[];\n    /** Sets the focused option of the selection-list. */\n    _setFocusedOption(option: MatListOption): void;\n    /**\n     * Removes an option from the selection list and updates the active item.\n     * @returns Currently-active item.\n     */\n    _removeOptionFromList(option: MatListOption): MatListOption | null;\n    /** Passes relevant key presses to our key manager. */\n    _keydown(event: KeyboardEvent): void;\n    /** Reports a value change to the ControlValueAccessor */\n    _reportValueChange(): void;\n    /** Emits a change event if the selected state of an option changed. */\n    _emitChangeEvent(options: MatListOption[]): void;\n    /** Implemented as part of ControlValueAccessor. */\n    writeValue(values: string[]): void;\n    /** Implemented as a part of ControlValueAccessor. */\n    setDisabledState(isDisabled: boolean): void;\n    /** Implemented as part of ControlValueAccessor. */\n    registerOnChange(fn: (value: any) => void): void;\n    /** Implemented as part of ControlValueAccessor. */\n    registerOnTouched(fn: () => void): void;\n    /** Sets the selected options based on the specified values. */\n    private _setOptionsFromValues;\n    /** Returns the values of the selected options. */\n    private _getSelectedOptionValues;\n    /** Toggles the state of the currently focused option if enabled. */\n    private _toggleFocusedOption;\n    /**\n     * Sets the selected state on all of the options\n     * and emits an event if anything changed.\n     */\n    private _setAllOptionsSelected;\n    /**\n     * Utility to ensure all indexes are valid.\n     * @param index The index to be checked.\n     * @returns True if the index is valid for our list of options.\n     */\n    private _isValidIndex;\n    /** Returns the index of the specified list option. */\n    private _getOptionIndex;\n    /** Marks all the options to be checked in the next change detection run. */\n    private _markOptionsForCheck;\n    /**\n     * Removes the tabindex from the selection list and resets it back afterwards, allowing the user\n     * to tab out of it. This prevents the list from capturing focus and redirecting it back within\n     * the list, creating a focus trap if it user tries to tab away.\n     */\n    private _allowFocusEscape;\n    /** Updates the tabindex based upon if the selection list is empty. */\n    private _updateTabIndex;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSelectionList, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSelectionList, \"mat-selection-list\", [\"matSelectionList\"], { \"disableRipple\": \"disableRipple\"; \"color\": \"color\"; \"compareWith\": \"compareWith\"; \"disabled\": \"disabled\"; \"multiple\": \"multiple\"; }, { \"selectionChange\": \"selectionChange\"; }, [\"options\"], [\"*\"], false>;\n}\n\ndeclare const _MatSelectionListBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (): {};\n};\n\n/** Change event that is being fired whenever the selected state of an option changes. */\nexport declare class MatSelectionListChange {\n    /** Reference to the selection list that emitted the event. */\n    source: MatSelectionList;\n    /** Reference to the options that have been changed. */\n    options: MatListOption[];\n    constructor(\n    /** Reference to the selection list that emitted the event. */\n    source: MatSelectionList, \n    /** Reference to the options that have been changed. */\n    options: MatListOption[]);\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/list/testing/index.d.ts",
      "node_modules/@angular/material/list/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { DividerHarnessFilters } from '@angular/material/divider/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatDividerHarness } from '@angular/material/divider/testing';\nimport { MatListOptionCheckboxPosition } from '@angular/material/list';\n\nexport declare interface ActionListHarnessFilters extends BaseHarnessFilters {\n}\n\nexport declare interface ActionListItemHarnessFilters extends BaseListItemHarnessFilters {\n}\n\nexport declare interface BaseListItemHarnessFilters extends BaseHarnessFilters {\n    text?: string | RegExp;\n}\n\nexport declare interface ListHarnessFilters extends BaseHarnessFilters {\n}\n\nexport declare interface ListItemHarnessFilters extends BaseListItemHarnessFilters {\n}\n\nexport declare interface ListOptionHarnessFilters extends BaseListItemHarnessFilters {\n    selected?: boolean;\n}\n\n/** Represents a section of a list falling under a specific header. */\ndeclare interface ListSection<I> {\n    /** The heading for this list section. `undefined` if there is no heading. */\n    heading?: string;\n    /** The items in this list section. */\n    items: I[];\n}\n\n/** Harness for interacting with a standard mat-action-list in tests. */\nexport declare class MatActionListHarness extends MatListHarnessBase<typeof MatActionListItemHarness, MatActionListItemHarness, ActionListItemHarnessFilters> {\n    /** The selector for the host element of a `MatActionList` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatActionListHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which action list instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ActionListHarnessFilters): HarnessPredicate<MatActionListHarness>;\n    _itemHarness: typeof MatActionListItemHarness;\n}\n\n/** Harness for interacting with an action list item. */\nexport declare class MatActionListItemHarness extends MatListItemHarnessBase {\n    /** The selector for the host element of a `MatListItem` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatActionListItemHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which action list item instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ActionListItemHarnessFilters): HarnessPredicate<MatActionListItemHarness>;\n    /** Clicks on the action list item. */\n    click(): Promise<void>;\n    /** Focuses the action list item. */\n    focus(): Promise<void>;\n    /** Blurs the action list item. */\n    blur(): Promise<void>;\n    /** Whether the action list item is focused. */\n    isFocused(): Promise<boolean>;\n}\n\n/** Harness for interacting with a standard mat-list in tests. */\nexport declare class MatListHarness extends MatListHarnessBase<typeof MatListItemHarness, MatListItemHarness, ListItemHarnessFilters> {\n    /** The selector for the host element of a `MatList` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatListHarness` that meets certain\n     * criteria.\n     * @param options Options for filtering which list instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ListHarnessFilters): HarnessPredicate<MatListHarness>;\n    _itemHarness: typeof MatListItemHarness;\n}\n\n/**\n * Shared behavior among the harnesses for the various `MatList` flavors.\n * @template T A constructor type for a list item harness type used by this list harness.\n * @template C The list item harness type that `T` constructs.\n * @template F The filter type used filter list item harness of type `C`.\n * @docs-private\n */\ndeclare abstract class MatListHarnessBase<T extends ComponentHarnessConstructor<C> & {\n    with: (options?: F) => HarnessPredicate<C>;\n}, C extends ComponentHarness, F extends BaseListItemHarnessFilters> extends ComponentHarness {\n    protected _itemHarness: T;\n    /**\n     * Gets a list of harnesses representing the items in this list.\n     * @param filters Optional filters used to narrow which harnesses are included\n     * @return The list of items matching the given filters.\n     */\n    getItems(filters?: F): Promise<C[]>;\n    /**\n     * Gets a list of `ListSection` representing the list items grouped by subheaders. If the list has\n     * no subheaders it is represented as a single `ListSection` with an undefined `heading` property.\n     * @param filters Optional filters used to narrow which list item harnesses are included\n     * @return The list of items matching the given filters, grouped into sections by subheader.\n     */\n    getItemsGroupedBySubheader(filters?: F): Promise<ListSection<C>[]>;\n    /**\n     * Gets a list of sub-lists representing the list items grouped by dividers. If the list has no\n     * dividers it is represented as a list with a single sub-list.\n     * @param filters Optional filters used to narrow which list item harnesses are included\n     * @return The list of items matching the given filters, grouped into sub-lists by divider.\n     */\n    getItemsGroupedByDividers(filters?: F): Promise<C[][]>;\n    /**\n     * Gets a list of harnesses representing all of the items, subheaders, and dividers\n     * (in the order they appear in the list). Use `instanceof` to check which type of harness a given\n     * item is.\n     * @param filters Optional filters used to narrow which list items, subheaders, and dividers are\n     *     included. A value of `false` for the `item`, `subheader`, or `divider` properties indicates\n     *     that the respective harness type should be omitted completely.\n     * @return The list of harnesses representing the items, subheaders, and dividers matching the\n     *     given filters.\n     */\n    getItemsWithSubheadersAndDividers(filters: {\n        item: false;\n        subheader: false;\n        divider: false;\n    }): Promise<[]>;\n    getItemsWithSubheadersAndDividers(filters: {\n        item?: F | false;\n        subheader: false;\n        divider: false;\n    }): Promise<C[]>;\n    getItemsWithSubheadersAndDividers(filters: {\n        item: false;\n        subheader?: SubheaderHarnessFilters | false;\n        divider: false;\n    }): Promise<MatSubheaderHarness[]>;\n    getItemsWithSubheadersAndDividers(filters: {\n        item: false;\n        subheader: false;\n        divider?: DividerHarnessFilters | false;\n    }): Promise<MatDividerHarness[]>;\n    getItemsWithSubheadersAndDividers(filters: {\n        item?: F | false;\n        subheader?: SubheaderHarnessFilters | false;\n        divider: false;\n    }): Promise<(C | MatSubheaderHarness)[]>;\n    getItemsWithSubheadersAndDividers(filters: {\n        item?: F | false;\n        subheader: false;\n        divider?: false | DividerHarnessFilters;\n    }): Promise<(C | MatDividerHarness)[]>;\n    getItemsWithSubheadersAndDividers(filters: {\n        item: false;\n        subheader?: false | SubheaderHarnessFilters;\n        divider?: false | DividerHarnessFilters;\n    }): Promise<(MatSubheaderHarness | MatDividerHarness)[]>;\n    getItemsWithSubheadersAndDividers(filters?: {\n        item?: F | false;\n        subheader?: SubheaderHarnessFilters | false;\n        divider?: DividerHarnessFilters | false;\n    }): Promise<(C | MatSubheaderHarness | MatDividerHarness)[]>;\n}\n\n/** Harness for interacting with a list item. */\nexport declare class MatListItemHarness extends MatListItemHarnessBase {\n    /** The selector for the host element of a `MatListItem` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatListItemHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which list item instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ListItemHarnessFilters): HarnessPredicate<MatListItemHarness>;\n}\n\n/**\n * Shared behavior among the harnesses for the various `MatListItem` flavors.\n * @docs-private\n */\ndeclare abstract class MatListItemHarnessBase extends ContentContainerComponentHarness<MatListItemSection> {\n    private _lines;\n    private _avatar;\n    private _icon;\n    /** Gets the full text content of the list item. */\n    getText(): Promise<string>;\n    /** Gets the lines of text (`mat-line` elements) in this nav list item. */\n    getLinesText(): Promise<string[]>;\n    /** Whether this list item has an avatar. */\n    hasAvatar(): Promise<boolean>;\n    /** Whether this list item has an icon. */\n    hasIcon(): Promise<boolean>;\n    /** Whether this list option is disabled. */\n    isDisabled(): Promise<boolean>;\n}\n\n/** Selectors for the various list item sections that may contain user content. */\nexport declare const enum MatListItemSection {\n    CONTENT = \".mat-list-item-content\"\n}\n\n/** Harness for interacting with a list option. */\nexport declare class MatListOptionHarness extends MatListItemHarnessBase {\n    /** The selector for the host element of a `MatListOption` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatListOptionHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which list option instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ListOptionHarnessFilters): HarnessPredicate<MatListOptionHarness>;\n    private _itemContent;\n    /** Gets the position of the checkbox relative to the list option content. */\n    getCheckboxPosition(): Promise<MatListOptionCheckboxPosition>;\n    /** Whether the list option is selected. */\n    isSelected(): Promise<boolean>;\n    /** Focuses the list option. */\n    focus(): Promise<void>;\n    /** Blurs the list option. */\n    blur(): Promise<void>;\n    /** Whether the list option is focused. */\n    isFocused(): Promise<boolean>;\n    /** Toggles the checked state of the checkbox. */\n    toggle(): Promise<void>;\n    /**\n     * Puts the list option in a checked state by toggling it if it is currently unchecked, or doing\n     * nothing if it is already checked.\n     */\n    select(): Promise<void>;\n    /**\n     * Puts the list option in an unchecked state by toggling it if it is currently checked, or doing\n     * nothing if it is already unchecked.\n     */\n    deselect(): Promise<void>;\n}\n\n/** Harness for interacting with a standard mat-nav-list in tests. */\nexport declare class MatNavListHarness extends MatListHarnessBase<typeof MatNavListItemHarness, MatNavListItemHarness, NavListItemHarnessFilters> {\n    /** The selector for the host element of a `MatNavList` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNavListHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which nav list instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: NavListHarnessFilters): HarnessPredicate<MatNavListHarness>;\n    _itemHarness: typeof MatNavListItemHarness;\n}\n\n/** Harness for interacting with a nav list item. */\nexport declare class MatNavListItemHarness extends MatListItemHarnessBase {\n    /** The selector for the host element of a `MatListItem` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNavListItemHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which nav list item instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: NavListItemHarnessFilters): HarnessPredicate<MatNavListItemHarness>;\n    /** Gets the href for this nav list item. */\n    getHref(): Promise<string | null>;\n    /** Clicks on the nav list item. */\n    click(): Promise<void>;\n    /** Focuses the nav list item. */\n    focus(): Promise<void>;\n    /** Blurs the nav list item. */\n    blur(): Promise<void>;\n    /** Whether the nav list item is focused. */\n    isFocused(): Promise<boolean>;\n}\n\n/** Harness for interacting with a standard mat-selection-list in tests. */\nexport declare class MatSelectionListHarness extends MatListHarnessBase<typeof MatListOptionHarness, MatListOptionHarness, ListOptionHarnessFilters> {\n    /** The selector for the host element of a `MatSelectionList` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSelectionListHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which selection list instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: SelectionListHarnessFilters): HarnessPredicate<MatSelectionListHarness>;\n    _itemHarness: typeof MatListOptionHarness;\n    /** Whether the selection list is disabled. */\n    isDisabled(): Promise<boolean>;\n    /**\n     * Selects all items matching any of the given filters.\n     * @param filters Filters that specify which items should be selected.\n     */\n    selectItems(...filters: ListOptionHarnessFilters[]): Promise<void>;\n    /**\n     * Deselects all items matching any of the given filters.\n     * @param filters Filters that specify which items should be deselected.\n     */\n    deselectItems(...filters: ListItemHarnessFilters[]): Promise<void>;\n    /** Gets all items matching the given list of filters. */\n    private _getItems;\n}\n\n/** Harness for interacting with a list subheader. */\ndeclare class MatSubheaderHarness extends ComponentHarness {\n    static hostSelector: string;\n    static with(options?: SubheaderHarnessFilters): HarnessPredicate<MatSubheaderHarness>;\n    /** Gets the full text content of the list item (including text from any font icons). */\n    getText(): Promise<string>;\n}\n\nexport declare interface NavListHarnessFilters extends BaseHarnessFilters {\n}\n\nexport declare interface NavListItemHarnessFilters extends BaseListItemHarnessFilters {\n    href?: string | RegExp | null;\n}\n\nexport declare interface SelectionListHarnessFilters extends BaseHarnessFilters {\n}\n\nexport declare interface SubheaderHarnessFilters extends BaseHarnessFilters {\n    text?: string | RegExp;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/menu/index.d.ts",
      "node_modules/@angular/material/menu/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { ApplicationRef } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { Direction } from '@angular/cdk/bidi';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i5 from '@angular/common';\nimport * as i6 from '@angular/material/core';\nimport * as i7 from '@angular/cdk/overlay';\nimport * as i8 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { QueryList } from '@angular/core';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { Subject } from 'rxjs';\nimport { TemplateRef } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nexport declare const fadeInItems: AnimationTriggerMetadata;\n\ndeclare namespace i1 {\n    export {\n        MAT_MENU_DEFAULT_OPTIONS_FACTORY,\n        MatMenuDefaultOptions,\n        MAT_MENU_DEFAULT_OPTIONS,\n        MenuCloseReason,\n        _MatMenuBase,\n        MatMenu\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatMenuItem\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MAT_MENU_SCROLL_STRATEGY_FACTORY,\n        MAT_MENU_SCROLL_STRATEGY,\n        MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER,\n        MENU_PANEL_TOP_PADDING,\n        _MatMenuTriggerBase,\n        MatMenuTrigger\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        MAT_MENU_CONTENT,\n        _MatMenuContentBase,\n        MatMenuContent\n    }\n}\n\n/**\n * Injection token that can be used to reference instances of `MatMenuContent`. It serves\n * as alternative token to the actual `MatMenuContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_MENU_CONTENT: InjectionToken<MatMenuContent>;\n\n/** Injection token to be used to override the default options for `mat-menu`. */\nexport declare const MAT_MENU_DEFAULT_OPTIONS: InjectionToken<MatMenuDefaultOptions>;\n\n/** @docs-private */\ndeclare function MAT_MENU_DEFAULT_OPTIONS_FACTORY(): MatMenuDefaultOptions;\n\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * @docs-private\n */\nexport declare const MAT_MENU_PANEL: InjectionToken<MatMenuPanel<any>>;\n\n/** Injection token that determines the scroll handling while the menu is open. */\nexport declare const MAT_MENU_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\ndeclare function MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/** @docs-private */\ndeclare const MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_MENU_SCROLL_STRATEGY_FACTORY;\n};\n\n/** @docs-public MatMenu */\nexport declare class MatMenu extends _MatMenuBase {\n    protected _elevationPrefix: string;\n    protected _baseElevation: number;\n    /**\n     * @deprecated `changeDetectorRef` parameter will become a required parameter.\n     * @breaking-change 15.0.0\n     */\n    constructor(elementRef: ElementRef<HTMLElement>, ngZone: NgZone, defaultOptions: MatMenuDefaultOptions);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenu, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatMenu, \"mat-menu\", [\"matMenu\"], {}, {}, never, [\"*\"], false>;\n}\n\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * @docs-private\n */\nexport declare const matMenuAnimations: {\n    readonly transformMenu: AnimationTriggerMetadata;\n    readonly fadeInItems: AnimationTriggerMetadata;\n};\n\n/** Base class with all of the `MatMenu` functionality. */\nexport declare class _MatMenuBase implements AfterContentInit, MatMenuPanel<MatMenuItem>, OnInit, OnDestroy {\n    private _elementRef;\n    private _ngZone;\n    private _defaultOptions;\n    private _changeDetectorRef?;\n    private _keyManager;\n    private _xPosition;\n    private _yPosition;\n    private _previousElevation;\n    protected _elevationPrefix: string;\n    protected _baseElevation: number;\n    /** All items inside the menu. Includes items nested inside another menu. */\n    _allItems: QueryList<MatMenuItem>;\n    /** Only the direct descendant menu items. */\n    _directDescendantItems: QueryList<MatMenuItem>;\n    /** Subscription to tab events on the menu panel */\n    private _tabSubscription;\n    /** Config object to be passed into the menu's ngClass */\n    _classList: {\n        [key: string]: boolean;\n    };\n    /** Current state of the panel animation. */\n    _panelAnimationState: 'void' | 'enter';\n    /** Emits whenever an animation on the menu completes. */\n    readonly _animationDone: Subject<AnimationEvent_2>;\n    /** Whether the menu is animating. */\n    _isAnimating: boolean;\n    /** Parent menu of the current menu panel. */\n    parentMenu: MatMenuPanel | undefined;\n    /** Layout direction of the menu. */\n    direction: Direction;\n    /** Class or list of classes to be added to the overlay panel. */\n    overlayPanelClass: string | string[];\n    /** Class to be added to the backdrop element. */\n    backdropClass: string;\n    /** aria-label for the menu panel. */\n    ariaLabel: string;\n    /** aria-labelledby for the menu panel. */\n    ariaLabelledby: string;\n    /** aria-describedby for the menu panel. */\n    ariaDescribedby: string;\n    /** Position of the menu in the X axis. */\n    get xPosition(): MenuPositionX;\n    set xPosition(value: MenuPositionX);\n    /** Position of the menu in the Y axis. */\n    get yPosition(): MenuPositionY;\n    set yPosition(value: MenuPositionY);\n    /** @docs-private */\n    templateRef: TemplateRef<any>;\n    /**\n     * List of the items inside of a menu.\n     * @deprecated\n     * @breaking-change 8.0.0\n     */\n    items: QueryList<MatMenuItem>;\n    /**\n     * Menu content that will be rendered lazily.\n     * @docs-private\n     */\n    lazyContent: MatMenuContent;\n    /** Whether the menu should overlap its trigger. */\n    get overlapTrigger(): boolean;\n    set overlapTrigger(value: BooleanInput);\n    private _overlapTrigger;\n    /** Whether the menu has a backdrop. */\n    get hasBackdrop(): boolean | undefined;\n    set hasBackdrop(value: BooleanInput);\n    private _hasBackdrop;\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param classes list of class names\n     */\n    set panelClass(classes: string);\n    private _previousPanelClass;\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * @breaking-change 8.0.0\n     */\n    get classList(): string;\n    set classList(classes: string);\n    /** Event emitted when the menu is closed. */\n    readonly closed: EventEmitter<MenuCloseReason>;\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * @breaking-change 8.0.0\n     */\n    readonly close: EventEmitter<MenuCloseReason>;\n    readonly panelId: string;\n    constructor(elementRef: ElementRef<HTMLElement>, ngZone: NgZone, defaultOptions: MatMenuDefaultOptions, changeDetectorRef: ChangeDetectorRef);\n    /**\n     * @deprecated `_changeDetectorRef` to become a required parameter.\n     * @breaking-change 15.0.0\n     */\n    constructor(elementRef: ElementRef<HTMLElement>, ngZone: NgZone, defaultOptions: MatMenuDefaultOptions, changeDetectorRef?: ChangeDetectorRef);\n    ngOnInit(): void;\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Stream that emits whenever the hovered menu item changes. */\n    _hovered(): Observable<MatMenuItem>;\n    addItem(_item: MatMenuItem): void;\n    /**\n     * Removes an item from the menu.\n     * @docs-private\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 9.0.0\n     */\n    removeItem(_item: MatMenuItem): void;\n    /** Handle a keyboard event from the menu, delegating to the appropriate action. */\n    _handleKeydown(event: KeyboardEvent): void;\n    /**\n     * Focus the first item in the menu.\n     * @param origin Action from which the focus originated. Used to set the correct styling.\n     */\n    focusFirstItem(origin?: FocusOrigin): void;\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     */\n    resetActiveItem(): void;\n    /**\n     * Sets the menu panel elevation.\n     * @param depth Number of parent menus that come before the menu.\n     */\n    setElevation(depth: number): void;\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * @param posX Position of the menu along the x axis.\n     * @param posY Position of the menu along the y axis.\n     * @docs-private\n     */\n    setPositionClasses(posX?: MenuPositionX, posY?: MenuPositionY): void;\n    /** Starts the enter animation. */\n    _startAnimation(): void;\n    /** Resets the panel animation to its initial state. */\n    _resetAnimation(): void;\n    /** Callback that is invoked when the panel animation completes. */\n    _onAnimationDone(event: AnimationEvent_2): void;\n    _onAnimationStart(event: AnimationEvent_2): void;\n    /**\n     * Sets up a stream that will keep track of any newly-added menu items and will update the list\n     * of direct descendants. We collect the descendants this way, because `_allItems` can include\n     * items that are part of child menus, and using a custom way of registering items is unreliable\n     * when it comes to maintaining the item order.\n     */\n    private _updateDirectDescendants;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatMenuBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatMenuBase, never, never, { \"backdropClass\": \"backdropClass\"; \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"ariaDescribedby\": \"aria-describedby\"; \"xPosition\": \"xPosition\"; \"yPosition\": \"yPosition\"; \"overlapTrigger\": \"overlapTrigger\"; \"hasBackdrop\": \"hasBackdrop\"; \"panelClass\": \"class\"; \"classList\": \"classList\"; }, { \"closed\": \"closed\"; \"close\": \"close\"; }, [\"lazyContent\", \"_allItems\", \"items\"], never, false>;\n}\n\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nexport declare class MatMenuContent extends _MatMenuContentBase {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuContent, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatMenuContent, \"ng-template[matMenuContent]\", never, {}, {}, never, never, false>;\n}\n\nexport declare abstract class _MatMenuContentBase implements OnDestroy {\n    private _template;\n    private _componentFactoryResolver;\n    private _appRef;\n    private _injector;\n    private _viewContainerRef;\n    private _document;\n    private _changeDetectorRef?;\n    private _portal;\n    private _outlet;\n    /** Emits when the menu content has been attached. */\n    readonly _attached: Subject<void>;\n    constructor(template: TemplateRef<any>, componentFactoryResolver: ComponentFactoryResolver, appRef: ApplicationRef, injector: Injector, viewContainerRef: ViewContainerRef, document: any, changeDetectorRef: ChangeDetectorRef);\n    /**\n     * @deprecated `changeDetectorRef` is now a required parameter.\n     * @breaking-change 9.0.0\n     */\n    constructor(template: TemplateRef<any>, componentFactoryResolver: ComponentFactoryResolver, appRef: ApplicationRef, injector: Injector, viewContainerRef: ViewContainerRef, document: any, changeDetectorRef?: ChangeDetectorRef);\n    /**\n     * Attaches the content with a particular context.\n     * @docs-private\n     */\n    attach(context?: any): void;\n    /**\n     * Detaches the content.\n     * @docs-private\n     */\n    detach(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatMenuContentBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatMenuContentBase, never, never, {}, {}, never, never, false>;\n}\n\n/** Default `mat-menu` options that can be overridden. */\nexport declare interface MatMenuDefaultOptions {\n    /** The x-axis position of the menu. */\n    xPosition: MenuPositionX;\n    /** The y-axis position of the menu. */\n    yPosition: MenuPositionY;\n    /** Whether the menu should overlap the menu trigger. */\n    overlapTrigger: boolean;\n    /** Class to be applied to the menu's backdrop. */\n    backdropClass: string;\n    /** Class or list of classes to be applied to the menu's overlay panel. */\n    overlayPanelClass?: string | string[];\n    /** Whether the menu has a backdrop. */\n    hasBackdrop?: boolean;\n}\n\n/**\n * Single item inside of a `mat-menu`. Provides the menu item styling and accessibility treatment.\n */\nexport declare class MatMenuItem extends _MatMenuItemBase implements FocusableOption, CanDisable, CanDisableRipple, AfterViewInit, OnDestroy {\n    private _elementRef;\n    private _document?;\n    private _focusMonitor?;\n    _parentMenu?: MatMenuPanel<MatMenuItem> | undefined;\n    private _changeDetectorRef?;\n    /** ARIA role for the menu item. */\n    role: 'menuitem' | 'menuitemradio' | 'menuitemcheckbox';\n    /** Stream that emits when the menu item is hovered. */\n    readonly _hovered: Subject<MatMenuItem>;\n    /** Stream that emits when the menu item is focused. */\n    readonly _focused: Subject<MatMenuItem>;\n    /** Whether the menu item is highlighted. */\n    _highlighted: boolean;\n    /** Whether the menu item acts as a trigger for a sub-menu. */\n    _triggersSubmenu: boolean;\n    constructor(elementRef: ElementRef<HTMLElement>, document: any, focusMonitor: FocusMonitor, parentMenu: MatMenuPanel<MatMenuItem> | undefined, changeDetectorRef: ChangeDetectorRef);\n    /**\n     * @deprecated `document`, `changeDetectorRef` and `focusMonitor` to become required.\n     * @breaking-change 12.0.0\n     */\n    constructor(elementRef: ElementRef<HTMLElement>, document?: any, focusMonitor?: FocusMonitor, parentMenu?: MatMenuPanel<MatMenuItem>, changeDetectorRef?: ChangeDetectorRef);\n    /** Focuses the menu item. */\n    focus(origin?: FocusOrigin, options?: FocusOptions): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /** Used to set the `tabindex`. */\n    _getTabIndex(): string;\n    /** Returns the host DOM element. */\n    _getHostElement(): HTMLElement;\n    /** Prevents the default element actions if it is disabled. */\n    _checkDisabled(event: Event): void;\n    /** Emits to the hover stream. */\n    _handleMouseEnter(): void;\n    /** Gets the label to be used when determining whether the option should be focused. */\n    getLabel(): string;\n    _setHighlighted(isHighlighted: boolean): void;\n    _hasFocus(): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuItem, [null, null, null, { optional: true; }, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatMenuItem, \"[mat-menu-item]\", [\"matMenuItem\"], { \"disabled\": \"disabled\"; \"disableRipple\": \"disableRipple\"; \"role\": \"role\"; }, {}, never, [\"*\"], false>;\n}\n\n/** @docs-private */\ndeclare const _MatMenuItemBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (): {};\n};\n\nexport declare class MatMenuModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatMenuModule, [typeof i1.MatMenu, typeof i2.MatMenuItem, typeof i3.MatMenuTrigger, typeof i4.MatMenuContent], [typeof i5.CommonModule, typeof i6.MatCommonModule, typeof i6.MatRippleModule, typeof i7.OverlayModule], [typeof i8.CdkScrollableModule, typeof i6.MatCommonModule, typeof i1.MatMenu, typeof i2.MatMenuItem, typeof i3.MatMenuTrigger, typeof i4.MatMenuContent]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatMenuModule>;\n}\n\n/**\n * Interface for a custom menu panel that can be used with `matMenuTriggerFor`.\n * @docs-private\n */\nexport declare interface MatMenuPanel<T = any> {\n    xPosition: MenuPositionX;\n    yPosition: MenuPositionY;\n    overlapTrigger: boolean;\n    templateRef: TemplateRef<any>;\n    readonly close: EventEmitter<void | 'click' | 'keydown' | 'tab'>;\n    parentMenu?: MatMenuPanel | undefined;\n    direction?: Direction;\n    focusFirstItem: (origin?: FocusOrigin) => void;\n    resetActiveItem: () => void;\n    setPositionClasses?: (x: MenuPositionX, y: MenuPositionY) => void;\n    setElevation?(depth: number): void;\n    lazyContent?: MatMenuContent;\n    backdropClass?: string;\n    overlayPanelClass?: string | string[];\n    hasBackdrop?: boolean;\n    readonly panelId?: string;\n    /**\n     * @deprecated To be removed.\n     * @breaking-change 8.0.0\n     */\n    addItem?: (item: T) => void;\n    /**\n     * @deprecated To be removed.\n     * @breaking-change 8.0.0\n     */\n    removeItem?: (item: T) => void;\n}\n\n/** Directive applied to an element that should trigger a `mat-menu`. */\nexport declare class MatMenuTrigger extends _MatMenuTriggerBase {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuTrigger, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatMenuTrigger, \"[mat-menu-trigger-for], [matMenuTriggerFor]\", [\"matMenuTrigger\"], {}, {}, never, never, false>;\n}\n\nexport declare abstract class _MatMenuTriggerBase implements AfterContentInit, OnDestroy {\n    private _overlay;\n    private _element;\n    private _viewContainerRef;\n    private _menuItemInstance;\n    private _dir;\n    private _focusMonitor;\n    private _ngZone?;\n    private _portal;\n    private _overlayRef;\n    private _menuOpen;\n    private _closingActionsSubscription;\n    private _hoverSubscription;\n    private _menuCloseSubscription;\n    private _scrollStrategy;\n    /**\n     * We're specifically looking for a `MatMenu` here since the generic `MatMenuPanel`\n     * interface lacks some functionality around nested menus and animations.\n     */\n    private _parentMaterialMenu;\n    /**\n     * Cached value of the padding of the parent menu panel.\n     * Used to offset sub-menus to compensate for the padding.\n     */\n    private _parentInnerPadding;\n    /**\n     * Handles touch start events on the trigger.\n     * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n     */\n    private _handleTouchStart;\n    _openedBy: Exclude<FocusOrigin, 'program' | null> | undefined;\n    /**\n     * @deprecated\n     * @breaking-change 8.0.0\n     */\n    get _deprecatedMatMenuTriggerFor(): MatMenuPanel | null;\n    set _deprecatedMatMenuTriggerFor(v: MatMenuPanel | null);\n    /** References the menu instance that the trigger is associated with. */\n    get menu(): MatMenuPanel | null;\n    set menu(menu: MatMenuPanel | null);\n    private _menu;\n    /** Data to be passed along to any lazily-rendered content. */\n    menuData: any;\n    /**\n     * Whether focus should be restored when the menu is closed.\n     * Note that disabling this option can have accessibility implications\n     * and it's up to you to manage focus, if you decide to turn it off.\n     */\n    restoreFocus: boolean;\n    /** Event emitted when the associated menu is opened. */\n    readonly menuOpened: EventEmitter<void>;\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * @breaking-change 8.0.0\n     */\n    readonly onMenuOpen: EventEmitter<void>;\n    /** Event emitted when the associated menu is closed. */\n    readonly menuClosed: EventEmitter<void>;\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * @breaking-change 8.0.0\n     */\n    readonly onMenuClose: EventEmitter<void>;\n    constructor(overlay: Overlay, element: ElementRef<HTMLElement>, viewContainerRef: ViewContainerRef, scrollStrategy: any, parentMenu: MatMenuPanel, menuItemInstance: MatMenuItem, dir: Directionality, focusMonitor: FocusMonitor, ngZone: NgZone);\n    /**\n     * @deprecated `focusMonitor` will become a required parameter.\n     * @breaking-change 8.0.0\n     */\n    constructor(overlay: Overlay, element: ElementRef<HTMLElement>, viewContainerRef: ViewContainerRef, scrollStrategy: any, parentMenu: MatMenuPanel, menuItemInstance: MatMenuItem, dir: Directionality, focusMonitor?: FocusMonitor | null);\n    /**\n     * @deprecated `ngZone` will become a required parameter.\n     * @breaking-change 15.0.0\n     */\n    constructor(overlay: Overlay, element: ElementRef<HTMLElement>, viewContainerRef: ViewContainerRef, scrollStrategy: any, parentMenu: MatMenuPanel, menuItemInstance: MatMenuItem, dir: Directionality, focusMonitor: FocusMonitor);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Whether the menu is open. */\n    get menuOpen(): boolean;\n    /** The text direction of the containing app. */\n    get dir(): Direction;\n    /** Whether the menu triggers a sub-menu or a top-level one. */\n    triggersSubmenu(): boolean;\n    /** Toggles the menu between the open and closed states. */\n    toggleMenu(): void;\n    /** Opens the menu. */\n    openMenu(): void;\n    /** Closes the menu. */\n    closeMenu(): void;\n    /**\n     * Focuses the menu trigger.\n     * @param origin Source of the menu trigger's focus.\n     */\n    focus(origin?: FocusOrigin, options?: FocusOptions): void;\n    /**\n     * Updates the position of the menu to ensure that it fits all options within the viewport.\n     */\n    updatePosition(): void;\n    /** Closes the menu and does the necessary cleanup. */\n    private _destroyMenu;\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     */\n    private _initMenu;\n    /** Updates the menu elevation based on the amount of parent menus that it has. */\n    private _setMenuElevation;\n    private _setIsMenuOpen;\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     */\n    private _createOverlay;\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @returns OverlayConfig\n     */\n    private _getOverlayConfig;\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     */\n    private _subscribeToPositions;\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param positionStrategy Strategy whose position to update.\n     */\n    private _setPosition;\n    /** Returns a stream that emits whenever an action that should close the menu occurs. */\n    private _menuClosingActions;\n    /** Handles mouse presses on the trigger. */\n    _handleMousedown(event: MouseEvent): void;\n    /** Handles key presses on the trigger. */\n    _handleKeydown(event: KeyboardEvent): void;\n    /** Handles click events on the trigger. */\n    _handleClick(event: MouseEvent): void;\n    /** Handles the cases where the user hovers over the trigger. */\n    private _handleHover;\n    /** Gets the portal that should be attached to the overlay. */\n    private _getPortal;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatMenuTriggerBase, [null, null, null, null, { optional: true; }, { optional: true; self: true; }, { optional: true; }, null, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatMenuTriggerBase, never, never, { \"_deprecatedMatMenuTriggerFor\": \"mat-menu-trigger-for\"; \"menu\": \"matMenuTriggerFor\"; \"menuData\": \"matMenuTriggerData\"; \"restoreFocus\": \"matMenuTriggerRestoreFocus\"; }, { \"menuOpened\": \"menuOpened\"; \"onMenuOpen\": \"onMenuOpen\"; \"menuClosed\": \"menuClosed\"; \"onMenuClose\": \"onMenuClose\"; }, never, never, false>;\n}\n\n/**\n * Default top padding of the menu panel.\n * @deprecated No longer being used. Will be removed.\n * @breaking-change 15.0.0\n */\ndeclare const MENU_PANEL_TOP_PADDING = 8;\n\n/** Reason why the menu was closed. */\ndeclare type MenuCloseReason = void | 'click' | 'keydown' | 'tab';\n\n\nexport declare type MenuPositionX = 'before' | 'after';\n\nexport declare type MenuPositionY = 'above' | 'below';\n\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nexport declare const transformMenu: AnimationTriggerMetadata;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/menu/testing/index.d.ts",
      "node_modules/@angular/material/menu/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessLoader } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-menu in tests. */\nexport declare class MatMenuHarness extends _MatMenuHarnessBase<typeof MatMenuItemHarness, MatMenuItemHarness, MenuItemHarnessFilters> {\n    /** The selector for the host element of a `MatMenu` instance. */\n    static hostSelector: string;\n    protected _itemClass: typeof MatMenuItemHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatMenuHarness` that meets certain\n     * criteria.\n     * @param options Options for filtering which menu instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: MenuHarnessFilters): HarnessPredicate<MatMenuHarness>;\n}\n\nexport declare abstract class _MatMenuHarnessBase<ItemType extends ComponentHarnessConstructor<Item> & {\n    with: (options?: ItemFilters) => HarnessPredicate<Item>;\n}, Item extends ComponentHarness & {\n    click(): Promise<void>;\n    getSubmenu(): Promise<_MatMenuHarnessBase<ItemType, Item, ItemFilters> | null>;\n}, ItemFilters extends BaseHarnessFilters> extends ContentContainerComponentHarness<string> {\n    private _documentRootLocator;\n    protected abstract _itemClass: ItemType;\n    /** Whether the menu is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the menu is open. */\n    isOpen(): Promise<boolean>;\n    /** Gets the text of the menu's trigger element. */\n    getTriggerText(): Promise<string>;\n    /** Focuses the menu. */\n    focus(): Promise<void>;\n    /** Blurs the menu. */\n    blur(): Promise<void>;\n    /** Whether the menu is focused. */\n    isFocused(): Promise<boolean>;\n    /** Opens the menu. */\n    open(): Promise<void>;\n    /** Closes the menu. */\n    close(): Promise<void>;\n    /**\n     * Gets a list of `MatMenuItemHarness` representing the items in the menu.\n     * @param filters Optionally filters which menu items are included.\n     */\n    getItems(filters?: Omit<ItemFilters, 'ancestor'>): Promise<Item[]>;\n    /**\n     * Clicks an item in the menu, and optionally continues clicking items in subsequent sub-menus.\n     * @param itemFilter A filter used to represent which item in the menu should be clicked. The\n     *     first matching menu item will be clicked.\n     * @param subItemFilters A list of filters representing the items to click in any subsequent\n     *     sub-menus. The first item in the sub-menu matching the corresponding filter in\n     *     `subItemFilters` will be clicked.\n     */\n    clickItem(itemFilter: Omit<ItemFilters, 'ancestor'>, ...subItemFilters: Omit<ItemFilters, 'ancestor'>[]): Promise<void>;\n    protected getRootHarnessLoader(): Promise<HarnessLoader>;\n    /** Gets the menu panel associated with this menu. */\n    private _getMenuPanel;\n    /** Gets the id of the menu panel associated with this menu. */\n    private _getPanelId;\n}\n\n/** Harness for interacting with a standard mat-menu-item in tests. */\nexport declare class MatMenuItemHarness extends _MatMenuItemHarnessBase<typeof MatMenuHarness, MatMenuHarness> {\n    /** The selector for the host element of a `MatMenuItem` instance. */\n    static hostSelector: string;\n    protected _menuClass: typeof MatMenuHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatMenuItemHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which menu item instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: MenuItemHarnessFilters): HarnessPredicate<MatMenuItemHarness>;\n}\n\nexport declare abstract class _MatMenuItemHarnessBase<MenuType extends ComponentHarnessConstructor<Menu>, Menu extends ComponentHarness> extends ContentContainerComponentHarness<string> {\n    protected abstract _menuClass: MenuType;\n    /** Whether the menu is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets the text of the menu item. */\n    getText(): Promise<string>;\n    /** Focuses the menu item. */\n    focus(): Promise<void>;\n    /** Blurs the menu item. */\n    blur(): Promise<void>;\n    /** Whether the menu item is focused. */\n    isFocused(): Promise<boolean>;\n    /** Clicks the menu item. */\n    click(): Promise<void>;\n    /** Whether this item has a submenu. */\n    hasSubmenu(): Promise<boolean>;\n    /** Gets the submenu associated with this menu item, or null if none. */\n    getSubmenu(): Promise<Menu | null>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatMenuHarness` instances. */\nexport declare interface MenuHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose trigger text matches the given value. */\n    triggerText?: string | RegExp;\n}\n\n/** A set of criteria that can be used to filter a list of `MatMenuItemHarness` instances. */\nexport declare interface MenuItemHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n    /** Only find instances that have a sub-menu. */\n    hasSubmenu?: boolean;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/paginator/index.d.ts",
      "node_modules/@angular/material/paginator/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisable } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { EventEmitter } from '@angular/core';\nimport { HasInitialized } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/common';\nimport * as i3 from '@angular/material/button';\nimport * as i4 from '@angular/material/select';\nimport * as i5 from '@angular/material/tooltip';\nimport * as i6 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { MatFormFieldAppearance } from '@angular/material/form-field';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Optional } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { ThemePalette } from '@angular/material/core';\n\ndeclare namespace i1 {\n    export {\n        PageEvent,\n        MatPaginatorDefaultOptions,\n        MAT_PAGINATOR_DEFAULT_OPTIONS,\n        MatPaginatorSelectConfig,\n        _MatPaginatorBase,\n        MatPaginator\n    }\n}\n\n/** Injection token that can be used to provide the default options for the paginator module. */\nexport declare const MAT_PAGINATOR_DEFAULT_OPTIONS: InjectionToken<MatPaginatorDefaultOptions>;\n\n/** @docs-private */\nexport declare const MAT_PAGINATOR_INTL_PROVIDER: {\n    provide: typeof MatPaginatorIntl;\n    deps: Optional[][];\n    useFactory: typeof MAT_PAGINATOR_INTL_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\nexport declare function MAT_PAGINATOR_INTL_PROVIDER_FACTORY(parentIntl: MatPaginatorIntl): MatPaginatorIntl;\n\n/**\n * Component to provide navigation between paged information. Displays the size of the current\n * page, user-selectable options to change that size, what items are being shown, and\n * navigational button to go to the previous or next page.\n */\nexport declare class MatPaginator extends _MatPaginatorBase<MatPaginatorDefaultOptions> {\n    /** If set, styles the \"page size\" form field with the designated style. */\n    _formFieldAppearance?: MatFormFieldAppearance;\n    constructor(intl: MatPaginatorIntl, changeDetectorRef: ChangeDetectorRef, defaults?: MatPaginatorDefaultOptions);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPaginator, [null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatPaginator, \"mat-paginator\", [\"matPaginator\"], { \"disabled\": \"disabled\"; }, {}, never, never, false>;\n}\n\n/**\n * Base class with all of the `MatPaginator` functionality.\n * @docs-private\n */\nexport declare abstract class _MatPaginatorBase<O extends {\n    pageSize?: number;\n    pageSizeOptions?: number[];\n    hidePageSize?: boolean;\n    showFirstLastButtons?: boolean;\n}> extends _MatPaginatorMixinBase implements OnInit, OnDestroy, CanDisable, HasInitialized {\n    _intl: MatPaginatorIntl;\n    private _changeDetectorRef;\n    private _initialized;\n    private _intlChanges;\n    /** Theme color to be used for the underlying form controls. */\n    color: ThemePalette;\n    /** The zero-based page index of the displayed list of items. Defaulted to 0. */\n    get pageIndex(): number;\n    set pageIndex(value: NumberInput);\n    private _pageIndex;\n    /** The length of the total number of items that are being paginated. Defaulted to 0. */\n    get length(): number;\n    set length(value: NumberInput);\n    private _length;\n    /** Number of items to display on a page. By default set to 50. */\n    get pageSize(): number;\n    set pageSize(value: NumberInput);\n    private _pageSize;\n    /** The set of provided page size options to display to the user. */\n    get pageSizeOptions(): number[];\n    set pageSizeOptions(value: number[] | readonly number[]);\n    private _pageSizeOptions;\n    /** Whether to hide the page size selection UI from the user. */\n    get hidePageSize(): boolean;\n    set hidePageSize(value: BooleanInput);\n    private _hidePageSize;\n    /** Whether to show the first/last buttons UI to the user. */\n    get showFirstLastButtons(): boolean;\n    set showFirstLastButtons(value: BooleanInput);\n    private _showFirstLastButtons;\n    /** Used to configure the underlying `MatSelect` inside the paginator. */\n    selectConfig: MatPaginatorSelectConfig;\n    /** Event emitted when the paginator changes the page size or page index. */\n    readonly page: EventEmitter<PageEvent>;\n    /** Displayed set of page size options. Will be sorted and include current page size. */\n    _displayedPageSizeOptions: number[];\n    constructor(_intl: MatPaginatorIntl, _changeDetectorRef: ChangeDetectorRef, defaults?: O);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Advances to the next page if it exists. */\n    nextPage(): void;\n    /** Move back to the previous page if it exists. */\n    previousPage(): void;\n    /** Move to the first page if not already there. */\n    firstPage(): void;\n    /** Move to the last page if not already there. */\n    lastPage(): void;\n    /** Whether there is a previous page. */\n    hasPreviousPage(): boolean;\n    /** Whether there is a next page. */\n    hasNextPage(): boolean;\n    /** Calculate the number of pages */\n    getNumberOfPages(): number;\n    /**\n     * Changes the page size so that the first item displayed on the page will still be\n     * displayed using the new page size.\n     *\n     * For example, if the page size is 10 and on the second page (items indexed 10-19) then\n     * switching so that the page size is 5 will set the third page as the current page so\n     * that the 10th item will still be displayed.\n     */\n    _changePageSize(pageSize: number): void;\n    /** Checks whether the buttons for going forwards should be disabled. */\n    _nextButtonsDisabled(): boolean;\n    /** Checks whether the buttons for going backwards should be disabled. */\n    _previousButtonsDisabled(): boolean;\n    /**\n     * Updates the list of page size options to display to the user. Includes making sure that\n     * the page size is an option and that the list is sorted.\n     */\n    private _updateDisplayedPageSizeOptions;\n    /** Emits an event notifying that a change of the paginator's properties has been triggered. */\n    private _emitPageEvent;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatPaginatorBase<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatPaginatorBase<any>, never, never, { \"color\": \"color\"; \"pageIndex\": \"pageIndex\"; \"length\": \"length\"; \"pageSize\": \"pageSize\"; \"pageSizeOptions\": \"pageSizeOptions\"; \"hidePageSize\": \"hidePageSize\"; \"showFirstLastButtons\": \"showFirstLastButtons\"; \"selectConfig\": \"selectConfig\"; }, { \"page\": \"page\"; }, never, never, false>;\n}\n\n/** Object that can be used to configure the default options for the paginator module. */\nexport declare interface MatPaginatorDefaultOptions {\n    /** Number of items to display on a page. By default set to 50. */\n    pageSize?: number;\n    /** The set of provided page size options to display to the user. */\n    pageSizeOptions?: number[];\n    /** Whether to hide the page size selection UI from the user. */\n    hidePageSize?: boolean;\n    /** Whether to show the first/last buttons UI to the user. */\n    showFirstLastButtons?: boolean;\n    /** The default form-field appearance to apply to the page size options selector. */\n    formFieldAppearance?: MatFormFieldAppearance;\n}\n\n/**\n * To modify the labels and text displayed, create a new instance of MatPaginatorIntl and\n * include it in a custom provider\n */\nexport declare class MatPaginatorIntl {\n    /**\n     * Stream to emit from when labels are changed. Use this to notify components when the labels have\n     * changed after initialization.\n     */\n    readonly changes: Subject<void>;\n    /** A label for the page size selector. */\n    itemsPerPageLabel: string;\n    /** A label for the button that increments the current page. */\n    nextPageLabel: string;\n    /** A label for the button that decrements the current page. */\n    previousPageLabel: string;\n    /** A label for the button that moves to the first page. */\n    firstPageLabel: string;\n    /** A label for the button that moves to the last page. */\n    lastPageLabel: string;\n    /** A label for the range of items within the current page and the length of the whole list. */\n    getRangeLabel: (page: number, pageSize: number, length: number) => string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPaginatorIntl, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatPaginatorIntl>;\n}\n\n/** @docs-private */\ndeclare const _MatPaginatorMixinBase: _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & (new (...args: any[]) => HasInitialized) & {\n    new (): {};\n};\n\nexport declare class MatPaginatorModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPaginatorModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatPaginatorModule, [typeof i1.MatPaginator], [typeof i2.CommonModule, typeof i3.MatButtonModule, typeof i4.MatSelectModule, typeof i5.MatTooltipModule, typeof i6.MatCommonModule], [typeof i1.MatPaginator]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatPaginatorModule>;\n}\n\n/** Object that can used to configure the underlying `MatSelect` inside a `MatPaginator`. */\nexport declare interface MatPaginatorSelectConfig {\n    /** Whether to center the active option over the trigger. */\n    disableOptionCentering?: boolean;\n    /** Classes to be passed to the select panel. */\n    panelClass?: string | string[] | Set<string> | {\n        [key: string]: any;\n    };\n}\n\n/**\n * Change event object that is emitted when the user selects a\n * different page size or navigates to another page.\n */\nexport declare class PageEvent {\n    /** The current page index. */\n    pageIndex: number;\n    /**\n     * Index of the page that was selected previously.\n     * @breaking-change 8.0.0 To be made into a required property.\n     */\n    previousPageIndex?: number;\n    /** The current page size */\n    pageSize: number;\n    /** The current total number of items being paged */\n    length: number;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/paginator/testing/index.d.ts",
      "node_modules/@angular/material/paginator/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatSelectHarness } from '@angular/material/select/testing';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-paginator in tests. */\nexport declare class MatPaginatorHarness extends _MatPaginatorHarnessBase {\n    /** Selector used to find paginator instances. */\n    static hostSelector: string;\n    protected _nextButton: AsyncFactoryFn<TestElement>;\n    protected _previousButton: AsyncFactoryFn<TestElement>;\n    protected _firstPageButton: AsyncFactoryFn<TestElement | null>;\n    protected _lastPageButton: AsyncFactoryFn<TestElement | null>;\n    protected _select: AsyncFactoryFn<MatSelectHarness | null>;\n    protected _pageSizeFallback: AsyncFactoryFn<TestElement>;\n    protected _rangeLabel: AsyncFactoryFn<TestElement>;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatPaginatorHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which paginator instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: PaginatorHarnessFilters): HarnessPredicate<MatPaginatorHarness>;\n}\n\nexport declare abstract class _MatPaginatorHarnessBase extends ComponentHarness {\n    protected abstract _nextButton: AsyncFactoryFn<TestElement>;\n    protected abstract _previousButton: AsyncFactoryFn<TestElement>;\n    protected abstract _firstPageButton: AsyncFactoryFn<TestElement | null>;\n    protected abstract _lastPageButton: AsyncFactoryFn<TestElement | null>;\n    protected abstract _select: AsyncFactoryFn<(ComponentHarness & {\n        getValueText(): Promise<string>;\n        clickOptions(...filters: unknown[]): Promise<void>;\n    }) | null>;\n    protected abstract _pageSizeFallback: AsyncFactoryFn<TestElement>;\n    protected abstract _rangeLabel: AsyncFactoryFn<TestElement>;\n    /** Goes to the next page in the paginator. */\n    goToNextPage(): Promise<void>;\n    /** Returns whether or not the next page button is disabled. */\n    isNextPageDisabled(): Promise<boolean>;\n    isPreviousPageDisabled(): Promise<boolean>;\n    /** Goes to the previous page in the paginator. */\n    goToPreviousPage(): Promise<void>;\n    /** Goes to the first page in the paginator. */\n    goToFirstPage(): Promise<void>;\n    /** Goes to the last page in the paginator. */\n    goToLastPage(): Promise<void>;\n    /**\n     * Sets the page size of the paginator.\n     * @param size Page size that should be select.\n     */\n    setPageSize(size: number): Promise<void>;\n    /** Gets the page size of the paginator. */\n    getPageSize(): Promise<number>;\n    /** Gets the text of the range labe of the paginator. */\n    getRangeLabel(): Promise<string>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatPaginatorHarness` instances. */\nexport declare interface PaginatorHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/progress-bar/index.d.ts",
      "node_modules/@angular/material/progress-bar/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewInit } from '@angular/core';\nimport { CanColor } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/common';\nimport * as i3 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { OnDestroy } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\n\ndeclare namespace i1 {\n    export {\n        MAT_PROGRESS_BAR_LOCATION_FACTORY,\n        ProgressAnimationEnd,\n        MAT_PROGRESS_BAR_LOCATION,\n        MatProgressBarLocation,\n        ProgressBarMode,\n        MatProgressBarDefaultOptions,\n        MAT_PROGRESS_BAR_DEFAULT_OPTIONS,\n        MatProgressBar\n    }\n}\n\n/** Injection token to be used to override the default options for `mat-progress-bar`. */\nexport declare const MAT_PROGRESS_BAR_DEFAULT_OPTIONS: InjectionToken<MatProgressBarDefaultOptions>;\n\n/**\n * Injection token used to provide the current location to `MatProgressBar`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nexport declare const MAT_PROGRESS_BAR_LOCATION: InjectionToken<MatProgressBarLocation>;\n\n/** @docs-private */\nexport declare function MAT_PROGRESS_BAR_LOCATION_FACTORY(): MatProgressBarLocation;\n\n/**\n * `<mat-progress-bar>` component.\n */\nexport declare class MatProgressBar extends _MatProgressBarBase implements CanColor, AfterViewInit, OnDestroy {\n    private _ngZone;\n    _animationMode?: string | undefined;\n    /**\n     * @deprecated `_changeDetectorRef` parameter to be made required.\n     * @breaking-change 11.0.0\n     */\n    private _changeDetectorRef?;\n    constructor(elementRef: ElementRef, _ngZone: NgZone, _animationMode?: string | undefined, \n    /**\n     * @deprecated `location` parameter to be made required.\n     * @breaking-change 8.0.0\n     */\n    location?: MatProgressBarLocation, defaults?: MatProgressBarDefaultOptions, \n    /**\n     * @deprecated `_changeDetectorRef` parameter to be made required.\n     * @breaking-change 11.0.0\n     */\n    _changeDetectorRef?: ChangeDetectorRef | undefined);\n    /** Flag that indicates whether NoopAnimations mode is set to true. */\n    _isNoopAnimation: boolean;\n    /** Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow. */\n    get value(): number;\n    set value(v: NumberInput);\n    private _value;\n    /** Buffer value of the progress bar. Defaults to zero. */\n    get bufferValue(): number;\n    set bufferValue(v: number);\n    private _bufferValue;\n    _primaryValueBar: ElementRef;\n    /**\n     * Event emitted when animation of the primary progress bar completes. This event will not\n     * be emitted when animations are disabled, nor will it be emitted for modes with continuous\n     * animations (indeterminate and query).\n     */\n    readonly animationEnd: EventEmitter<ProgressAnimationEnd>;\n    /** Reference to animation end subscription to be unsubscribed on destroy. */\n    private _animationEndSubscription;\n    /**\n     * Mode of the progress bar.\n     *\n     * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to\n     * 'determinate'.\n     * Mirrored to mode attribute.\n     */\n    mode: ProgressBarMode;\n    /** ID of the progress bar. */\n    progressbarId: string;\n    /** Attribute to be used for the `fill` attribute on the internal `rect` element. */\n    _rectangleFillValue: string;\n    /** Gets the current transform value for the progress bar's primary indicator. */\n    _primaryTransform(): {\n        transform: string;\n    };\n    /**\n     * Gets the current transform value for the progress bar's buffer indicator. Only used if the\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\n     */\n    _bufferTransform(): {\n        transform: string;\n    } | null;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatProgressBar, [null, null, { optional: true; }, { optional: true; }, { optional: true; }, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatProgressBar, \"mat-progress-bar\", [\"matProgressBar\"], { \"color\": \"color\"; \"value\": \"value\"; \"bufferValue\": \"bufferValue\"; \"mode\": \"mode\"; }, { \"animationEnd\": \"animationEnd\"; }, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatProgressBarBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\n/** Default `mat-progress-bar` options that can be overridden. */\nexport declare interface MatProgressBarDefaultOptions {\n    /** Default color of the progress bar. */\n    color?: ThemePalette;\n    /** Default mode of the progress bar. */\n    mode?: ProgressBarMode;\n}\n\n/**\n * Stubbed out location for `MatProgressBar`.\n * @docs-private\n */\nexport declare interface MatProgressBarLocation {\n    getPathname: () => string;\n}\n\nexport declare class MatProgressBarModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatProgressBarModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatProgressBarModule, [typeof i1.MatProgressBar], [typeof i2.CommonModule, typeof i3.MatCommonModule], [typeof i1.MatProgressBar, typeof i3.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatProgressBarModule>;\n}\n\n/** Last animation end data. */\nexport declare interface ProgressAnimationEnd {\n    value: number;\n}\n\nexport declare type ProgressBarMode = 'determinate' | 'indeterminate' | 'buffer' | 'query';\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/progress-bar/testing/index.d.ts",
      "node_modules/@angular/material/progress-bar/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-progress-bar in tests. */\nexport declare class MatProgressBarHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatProgressBar` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatProgressBarHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which progress bar instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ProgressBarHarnessFilters): HarnessPredicate<MatProgressBarHarness>;\n    /** Gets the progress bar's value. */\n    getValue(): Promise<number | null>;\n    /** Gets the progress bar's mode. */\n    getMode(): Promise<string | null>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatProgressBarHarness` instances. */\nexport declare interface ProgressBarHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/progress-spinner/index.d.ts",
      "node_modules/@angular/material/progress-spinner/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { CanColor } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport * as i3 from '@angular/common';\nimport { InjectionToken } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { ThemePalette } from '@angular/material/core';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\ndeclare namespace i1 {\n    export {\n        MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY,\n        ProgressSpinnerMode,\n        MatProgressSpinnerDefaultOptions,\n        MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,\n        MatProgressSpinner\n    }\n}\n\n/** Injection token to be used to override the default options for `mat-progress-spinner`. */\nexport declare const MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS: InjectionToken<MatProgressSpinnerDefaultOptions>;\n\n/** @docs-private */\nexport declare function MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY(): MatProgressSpinnerDefaultOptions;\n\n/**\n * `<mat-progress-spinner>` component.\n */\nexport declare class MatProgressSpinner extends _MatProgressSpinnerBase implements OnInit, OnDestroy, CanColor {\n    private _document;\n    private _diameter;\n    private _value;\n    private _strokeWidth;\n    private _resizeSubscription;\n    /**\n     * Element to which we should add the generated style tags for the indeterminate animation.\n     * For most elements this is the document, but for the ones in the Shadow DOM we need to\n     * use the shadow root.\n     */\n    private _styleRoot;\n    /**\n     * Tracks diameters of existing instances to de-dupe generated styles (default d = 100).\n     * We need to keep track of which elements the diameters were attached to, because for\n     * elements in the Shadow DOM the style tags are attached to the shadow root, rather\n     * than the document head.\n     */\n    private static _diameters;\n    /** Whether the _mat-animation-noopable class should be applied, disabling animations.  */\n    _noopAnimations: boolean;\n    /** A string that is used for setting the spinner animation-name CSS property */\n    _spinnerAnimationLabel: string;\n    /** The diameter of the progress spinner (will set width and height of svg). */\n    get diameter(): number;\n    set diameter(size: NumberInput);\n    /** Stroke width of the progress spinner. */\n    get strokeWidth(): number;\n    set strokeWidth(value: NumberInput);\n    /** Mode of the progress circle */\n    mode: ProgressSpinnerMode;\n    /** Value of the progress circle. */\n    get value(): number;\n    set value(newValue: NumberInput);\n    constructor(elementRef: ElementRef<HTMLElement>, _platform: Platform, _document: any, animationMode: string, defaults?: MatProgressSpinnerDefaultOptions, \n    /**\n     * @deprecated `changeDetectorRef`, `viewportRuler` and `ngZone`\n     * parameters to become required.\n     * @breaking-change 14.0.0\n     */\n    changeDetectorRef?: ChangeDetectorRef, viewportRuler?: ViewportRuler, ngZone?: NgZone);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** The radius of the spinner, adjusted for stroke width. */\n    _getCircleRadius(): number;\n    /** The view box of the spinner's svg element. */\n    _getViewBox(): string;\n    /** The stroke circumference of the svg circle. */\n    _getStrokeCircumference(): number;\n    /** The dash offset of the svg circle. */\n    _getStrokeDashOffset(): number | null;\n    /** Stroke width of the circle in percent. */\n    _getCircleStrokeWidth(): number;\n    /** Gets the `transform-origin` for the inner circle element. */\n    _getCircleTransformOrigin(svg: HTMLElement): string;\n    /** Dynamically generates a style tag containing the correct animation for this diameter. */\n    private _attachStyleNode;\n    /** Generates animation styles adjusted for the spinner's diameter. */\n    private _getAnimationText;\n    /** Returns the circle diameter formatted for use with the animation-name CSS property. */\n    private _getSpinnerAnimationLabel;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatProgressSpinner, [null, null, { optional: true; }, { optional: true; }, null, null, null, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatProgressSpinner, \"mat-progress-spinner, mat-spinner\", [\"matProgressSpinner\"], { \"color\": \"color\"; \"diameter\": \"diameter\"; \"strokeWidth\": \"strokeWidth\"; \"mode\": \"mode\"; \"value\": \"value\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatProgressSpinnerBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\n/** Default `mat-progress-spinner` options that can be overridden. */\nexport declare interface MatProgressSpinnerDefaultOptions {\n    /** Default color of the spinner. */\n    color?: ThemePalette;\n    /** Diameter of the spinner. */\n    diameter?: number;\n    /** Width of the spinner's stroke. */\n    strokeWidth?: number;\n    /**\n     * Whether the animations should be force to be enabled, ignoring if the current environment is\n     * using NoopAnimationsModule.\n     */\n    _forceAnimations?: boolean;\n}\n\nexport declare class MatProgressSpinnerModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatProgressSpinnerModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatProgressSpinnerModule, [typeof i1.MatProgressSpinner], [typeof i2.MatCommonModule, typeof i3.CommonModule], [typeof i1.MatProgressSpinner, typeof i2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatProgressSpinnerModule>;\n}\n\n/**\n * @deprecated Import `MatProgressSpinner` instead. Note that the\n *    `mat-spinner` selector isn't deprecated.\n * @breaking-change 8.0.0\n */\nexport declare const MatSpinner: typeof MatProgressSpinner;\n\n/** Possible mode for a progress spinner. */\nexport declare type ProgressSpinnerMode = 'determinate' | 'indeterminate';\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/progress-spinner/testing/index.d.ts",
      "node_modules/@angular/material/progress-spinner/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { ProgressSpinnerMode } from '@angular/material/progress-spinner';\n\n/** Harness for interacting with a standard mat-progress-spinner in tests. */\nexport declare class MatProgressSpinnerHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatProgressSpinner` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatProgressSpinnerHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which progress spinner instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ProgressSpinnerHarnessFilters): HarnessPredicate<MatProgressSpinnerHarness>;\n    /** Gets the progress spinner's value. */\n    getValue(): Promise<number | null>;\n    /** Gets the progress spinner's mode. */\n    getMode(): Promise<ProgressSpinnerMode>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatProgressSpinnerHarness` instances. */\nexport declare interface ProgressSpinnerHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/radio/index.d.ts",
      "node_modules/@angular/material/radio/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\n\ndeclare namespace i1 {\n    export {\n        MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n        MatRadioDefaultOptions,\n        MAT_RADIO_DEFAULT_OPTIONS,\n        MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n        MatRadioChange,\n        MAT_RADIO_GROUP,\n        _MatRadioGroupBase,\n        MatRadioGroup,\n        _MatRadioButtonBase,\n        MatRadioButton\n    }\n}\n\nexport declare const MAT_RADIO_DEFAULT_OPTIONS: InjectionToken<MatRadioDefaultOptions>;\n\nexport declare function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions;\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport declare const MAT_RADIO_GROUP: InjectionToken<_MatRadioGroupBase<_MatRadioButtonBase>>;\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport declare const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any;\n\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\nexport declare class MatRadioButton extends _MatRadioButtonBase {\n    constructor(radioGroup: MatRadioGroup, elementRef: ElementRef, changeDetector: ChangeDetectorRef, focusMonitor: FocusMonitor, radioDispatcher: UniqueSelectionDispatcher, animationMode?: string, providerOverride?: MatRadioDefaultOptions, tabIndex?: string);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRadioButton, [{ optional: true; }, null, null, null, null, { optional: true; }, { optional: true; }, { attribute: \"tabindex\"; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatRadioButton, \"mat-radio-button\", [\"matRadioButton\"], { \"disableRipple\": \"disableRipple\"; \"tabIndex\": \"tabIndex\"; }, {}, never, [\"*\"], false>;\n}\n\n/** @docs-private */\ndeclare abstract class MatRadioButtonBase {\n    _elementRef: ElementRef;\n    abstract disabled: boolean;\n    constructor(_elementRef: ElementRef);\n}\n\n/**\n * Base class with all of the `MatRadioButton` functionality.\n * @docs-private\n */\nexport declare abstract class _MatRadioButtonBase extends _MatRadioButtonMixinBase implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex {\n    protected _changeDetector: ChangeDetectorRef;\n    private _focusMonitor;\n    private _radioDispatcher;\n    private _providerOverride?;\n    private _uniqueId;\n    /** The unique ID for the radio button. */\n    id: string;\n    /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n    name: string;\n    /** Used to set the 'aria-label' attribute on the underlying input element. */\n    ariaLabel: string;\n    /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n    ariaLabelledby: string;\n    /** The 'aria-describedby' attribute is read after the element's label and field type. */\n    ariaDescribedby: string;\n    /** Whether this radio button is checked. */\n    get checked(): boolean;\n    set checked(value: BooleanInput);\n    /** The value of this radio button. */\n    get value(): any;\n    set value(value: any);\n    /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n    get labelPosition(): 'before' | 'after';\n    set labelPosition(value: 'before' | 'after');\n    private _labelPosition;\n    /** Whether the radio button is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    /** Whether the radio button is required. */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    /** Theme color of the radio button. */\n    get color(): ThemePalette;\n    set color(newValue: ThemePalette);\n    private _color;\n    /**\n     * Event emitted when the checked state of this radio button changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * the radio button (the same behavior as `<input type-\"radio\">`).\n     */\n    readonly change: EventEmitter<MatRadioChange>;\n    /** The parent radio group. May or may not be present. */\n    radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>;\n    /** ID of the native input element inside `<mat-radio-button>` */\n    get inputId(): string;\n    /** Whether this radio is checked. */\n    private _checked;\n    /** Whether this radio is disabled. */\n    private _disabled;\n    /** Whether this radio is required. */\n    private _required;\n    /** Value assigned to this radio. */\n    private _value;\n    /** Unregister function for _radioDispatcher */\n    private _removeUniqueSelectionListener;\n    /** Previous value of the input's tabindex. */\n    private _previousTabIndex;\n    /** The native `<input type=radio>` element */\n    _inputElement: ElementRef<HTMLInputElement>;\n    /** Whether animations are disabled. */\n    _noopAnimations: boolean;\n    constructor(radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>, elementRef: ElementRef, _changeDetector: ChangeDetectorRef, _focusMonitor: FocusMonitor, _radioDispatcher: UniqueSelectionDispatcher, animationMode?: string, _providerOverride?: MatRadioDefaultOptions | undefined, tabIndex?: string);\n    /** Focuses the radio button. */\n    focus(options?: FocusOptions, origin?: FocusOrigin): void;\n    /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     */\n    _markForCheck(): void;\n    ngOnInit(): void;\n    ngDoCheck(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /** Dispatch change event with current value. */\n    private _emitChangeEvent;\n    _isRippleDisabled(): boolean;\n    _onInputClick(event: Event): void;\n    /** Triggered when the radio button receives an interaction from the user. */\n    _onInputInteraction(event: Event): void;\n    /** Sets the disabled state and marks for check if a change occurred. */\n    protected _setDisabled(value: boolean): void;\n    /** Gets the tabindex for the underlying input element. */\n    private _updateTabIndex;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatRadioButtonBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatRadioButtonBase, never, never, { \"id\": \"id\"; \"name\": \"name\"; \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"ariaDescribedby\": \"aria-describedby\"; \"checked\": \"checked\"; \"value\": \"value\"; \"labelPosition\": \"labelPosition\"; \"disabled\": \"disabled\"; \"required\": \"required\"; \"color\": \"color\"; }, { \"change\": \"change\"; }, never, never, false>;\n}\n\ndeclare const _MatRadioButtonMixinBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & typeof MatRadioButtonBase;\n\n/** Change event object emitted by MatRadio and MatRadioGroup. */\nexport declare class MatRadioChange {\n    /** The MatRadioButton that emits the change event. */\n    source: _MatRadioButtonBase;\n    /** The value of the MatRadioButton. */\n    value: any;\n    constructor(\n    /** The MatRadioButton that emits the change event. */\n    source: _MatRadioButtonBase, \n    /** The value of the MatRadioButton. */\n    value: any);\n}\n\nexport declare interface MatRadioDefaultOptions {\n    color: ThemePalette;\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\nexport declare class MatRadioGroup extends _MatRadioGroupBase<MatRadioButton> {\n    _radios: QueryList<MatRadioButton>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRadioGroup, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatRadioGroup, \"mat-radio-group\", [\"matRadioGroup\"], {}, {}, [\"_radios\"], never, false>;\n}\n\n/**\n * Base class with all of the `MatRadioGroup` functionality.\n * @docs-private\n */\nexport declare abstract class _MatRadioGroupBase<T extends _MatRadioButtonBase> implements AfterContentInit, ControlValueAccessor {\n    private _changeDetector;\n    /** Selected value for the radio group. */\n    private _value;\n    /** The HTML name attribute applied to radio buttons in this group. */\n    private _name;\n    /** The currently selected radio button. Should match value. */\n    private _selected;\n    /** Whether the `value` has been set to its initial value. */\n    private _isInitialized;\n    /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n    private _labelPosition;\n    /** Whether the radio group is disabled. */\n    private _disabled;\n    /** Whether the radio group is required. */\n    private _required;\n    /** The method to be called in order to update ngModel */\n    _controlValueAccessorChangeFn: (value: any) => void;\n    /**\n     * onTouch function registered via registerOnTouch (ControlValueAccessor).\n     * @docs-private\n     */\n    onTouched: () => any;\n    /**\n     * Event emitted when the group value changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * a radio button (the same behavior as `<input type-\"radio\">`).\n     */\n    readonly change: EventEmitter<MatRadioChange>;\n    /** Child radio buttons. */\n    abstract _radios: QueryList<T>;\n    /** Theme color for all of the radio buttons in the group. */\n    color: ThemePalette;\n    /** Name of the radio button group. All radio buttons inside this group will use this name. */\n    get name(): string;\n    set name(value: string);\n    /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n    get labelPosition(): 'before' | 'after';\n    set labelPosition(v: 'before' | 'after');\n    /**\n     * Value for the radio-group. Should equal the value of the selected radio button if there is\n     * a corresponding radio button with a matching value. If there is not such a corresponding\n     * radio button, this value persists to be applied in case a new radio button is added with a\n     * matching value.\n     */\n    get value(): any;\n    set value(newValue: any);\n    _checkSelectedRadioButton(): void;\n    /**\n     * The currently selected radio button. If set to a new radio button, the radio group value\n     * will be updated to match the new selected button.\n     */\n    get selected(): T | null;\n    set selected(selected: T | null);\n    /** Whether the radio group is disabled */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    /** Whether the radio group is required */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    constructor(_changeDetector: ChangeDetectorRef);\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     */\n    ngAfterContentInit(): void;\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     */\n    _touch(): void;\n    private _updateRadioButtonNames;\n    /** Updates the `selected` radio button from the internal _value state. */\n    private _updateSelectedRadioFromValue;\n    /** Dispatch change event with current selection and group value. */\n    _emitChangeEvent(): void;\n    _markRadiosForCheck(): void;\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param value\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    registerOnChange(fn: (value: any) => void): void;\n    /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    registerOnTouched(fn: any): void;\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param isDisabled Whether the control should be disabled.\n     */\n    setDisabledState(isDisabled: boolean): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatRadioGroupBase<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatRadioGroupBase<any>, never, never, { \"color\": \"color\"; \"name\": \"name\"; \"labelPosition\": \"labelPosition\"; \"value\": \"value\"; \"selected\": \"selected\"; \"disabled\": \"disabled\"; \"required\": \"required\"; }, { \"change\": \"change\"; }, never, never, false>;\n}\n\nexport declare class MatRadioModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRadioModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatRadioModule, [typeof i1.MatRadioGroup, typeof i1.MatRadioButton], [typeof i2.MatRippleModule, typeof i2.MatCommonModule], [typeof i1.MatRadioGroup, typeof i1.MatRadioButton, typeof i2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatRadioModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/radio/testing/index.d.ts",
      "node_modules/@angular/material/radio/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-radio-button in tests. */\nexport declare class MatRadioButtonHarness extends _MatRadioButtonHarnessBase {\n    /** The selector for the host element of a `MatRadioButton` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatRadioButtonHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which radio button instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: RadioButtonHarnessFilters): HarnessPredicate<MatRadioButtonHarness>;\n    protected _textLabel: AsyncFactoryFn<TestElement>;\n    protected _clickLabel: AsyncFactoryFn<TestElement>;\n}\n\nexport declare abstract class _MatRadioButtonHarnessBase extends ComponentHarness {\n    protected abstract _textLabel: AsyncFactoryFn<TestElement>;\n    protected abstract _clickLabel: AsyncFactoryFn<TestElement>;\n    private _input;\n    /** Whether the radio-button is checked. */\n    isChecked(): Promise<boolean>;\n    /** Whether the radio-button is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the radio-button is required. */\n    isRequired(): Promise<boolean>;\n    /** Gets the radio-button's name. */\n    getName(): Promise<string | null>;\n    /** Gets the radio-button's id. */\n    getId(): Promise<string | null>;\n    /**\n     * Gets the value of the radio-button. The radio-button value will be converted to a string.\n     *\n     * Note: This means that for radio-button's with an object as a value `[object Object]` is\n     * intentionally returned.\n     */\n    getValue(): Promise<string | null>;\n    /** Gets the radio-button's label text. */\n    getLabelText(): Promise<string>;\n    /** Focuses the radio-button. */\n    focus(): Promise<void>;\n    /** Blurs the radio-button. */\n    blur(): Promise<void>;\n    /** Whether the radio-button is focused. */\n    isFocused(): Promise<boolean>;\n    /**\n     * Puts the radio-button in a checked state by clicking it if it is currently unchecked,\n     * or doing nothing if it is already checked.\n     */\n    check(): Promise<void>;\n}\n\n/** Harness for interacting with a standard mat-radio-group in tests. */\nexport declare class MatRadioGroupHarness extends _MatRadioGroupHarnessBase<typeof MatRadioButtonHarness, MatRadioButtonHarness, RadioButtonHarnessFilters> {\n    /** The selector for the host element of a `MatRadioGroup` instance. */\n    static hostSelector: string;\n    protected _buttonClass: typeof MatRadioButtonHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatRadioGroupHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which radio group instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: RadioGroupHarnessFilters): HarnessPredicate<MatRadioGroupHarness>;\n}\n\nexport declare abstract class _MatRadioGroupHarnessBase<ButtonType extends ComponentHarnessConstructor<Button> & {\n    with: (options?: ButtonFilters) => HarnessPredicate<Button>;\n}, Button extends ComponentHarness & {\n    isChecked(): Promise<boolean>;\n    getValue(): Promise<string | null>;\n    getName(): Promise<string | null>;\n    check(): Promise<void>;\n}, ButtonFilters extends BaseHarnessFilters> extends ComponentHarness {\n    protected abstract _buttonClass: ButtonType;\n    /** Gets the name of the radio-group. */\n    getName(): Promise<string | null>;\n    /** Gets the id of the radio-group. */\n    getId(): Promise<string | null>;\n    /** Gets the checked radio-button in a radio-group. */\n    getCheckedRadioButton(): Promise<Button | null>;\n    /** Gets the checked value of the radio-group. */\n    getCheckedValue(): Promise<string | null>;\n    /**\n     * Gets a list of radio buttons which are part of the radio-group.\n     * @param filter Optionally filters which radio buttons are included.\n     */\n    getRadioButtons(filter?: ButtonFilters): Promise<Button[]>;\n    /**\n     * Checks a radio button in this group.\n     * @param filter An optional filter to apply to the child radio buttons. The first tab matching\n     *     the filter will be selected.\n     */\n    checkRadioButton(filter?: ButtonFilters): Promise<void>;\n    /** Gets the name attribute of the host element. */\n    private _getGroupNameFromHost;\n    /** Gets a list of the name attributes of all child radio buttons. */\n    private _getNamesFromRadioButtons;\n    /** Checks if the specified radio names are all equal. */\n    private _checkRadioNamesInGroupEqual;\n    /**\n     * Checks if a radio-group harness has the given name. Throws if a radio-group with\n     * matching name could be found but has mismatching radio-button names.\n     */\n    protected static _checkRadioGroupName(harness: _MatRadioGroupHarnessBase<any, any, any>, name: string): Promise<boolean>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatRadioButtonHarness` instances. */\nexport declare interface RadioButtonHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose label matches the given value. */\n    label?: string | RegExp;\n    /** Only find instances whose name attribute is the given value. */\n    name?: string;\n    /** Only find instances with the given checked value. */\n    checked?: boolean;\n}\n\n/** A set of criteria that can be used to filter a list of `MatRadioGroupHarness` instances. */\nexport declare interface RadioGroupHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose name attribute is the given value. */\n    name?: string;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-add/fonts/material-fonts.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from '../schema';\n/** Adds the Material Design fonts to the index HTML file. */\nexport declare function addFontsToIndex(options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-add/index.d.ts",
      "node_modules/@angular/material/schematics/ng-add/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/**\n * Schematic factory entry-point for the `ng-add` schematic. The ng-add schematic will be\n * automatically executed if developers run `ng add @angular/material`.\n *\n * Since the Angular Material schematics depend on the schematic utility functions from the CDK,\n * we need to install the CDK before loading the schematic files that import from the CDK.\n */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-add/package-config.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Tree } from '@angular-devkit/schematics';\n/** Adds a package to the package.json in the given host tree. */\nexport declare function addPackageToPackageJson(host: Tree, pkg: string, version: string): Tree;\n/** Gets the version of the specified package by looking at the package.json in the given tree. */\nexport declare function getPackageVersionFromPackageJson(tree: Tree, name: string): string | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-add/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport interface Schema {\n    /** Name of the project. */\n    project: string;\n    /** Whether the Angular browser animations module should be included and enabled. */\n    animations: 'enabled' | 'disabled' | 'excluded';\n    /** Name of pre-built theme to install. */\n    theme: 'indigo-pink' | 'deeppurple-amber' | 'pink-bluegrey' | 'purple-green' | 'custom';\n    /** Whether to set up global typography styles. */\n    typography: boolean;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-add/setup-project.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/**\n * Scaffolds the basics of a Angular Material application, this includes:\n *  - Add Packages to package.json\n *  - Adds pre-built themes to styles.ext\n *  - Adds Browser Animation to app.module\n */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-add/theming/create-custom-theme.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Create custom theme for the given application configuration. */\nexport declare function createCustomTheme(name?: string): string;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-add/theming/theming.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from '../schema';\n/** Add pre-built styles to the main project style file. */\nexport declare function addThemeToAppStyles(options: Schema): Rule;\n/** Adds the global typography class to the body element. */\nexport declare function addTypographyClass(options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/address-form/index.d.ts",
      "node_modules/@angular/material/schematics/ng-generate/address-form/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/**\n * Scaffolds a new table component.\n * Internally it bootstraps the base component schematic\n */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/address-form/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Schema as ComponentSchema } from '@schematics/angular/component/schema';\nexport interface Schema extends ComponentSchema {\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/dashboard/index.d.ts",
      "node_modules/@angular/material/schematics/ng-generate/dashboard/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/**\n * Scaffolds a new dashboard component.\n * Internally it bootstraps the base component schematic\n */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/dashboard/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Schema as ComponentSchema } from '@schematics/angular/component/schema';\nexport interface Schema extends ComponentSchema {\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/navigation/index.d.ts",
      "node_modules/@angular/material/schematics/ng-generate/navigation/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/**\n * Scaffolds a new navigation component.\n * Internally it bootstraps the base component schematic\n */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/navigation/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Schema as ComponentSchema } from '@schematics/angular/component/schema';\nexport interface Schema extends ComponentSchema {\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/table/index.d.ts",
      "node_modules/@angular/material/schematics/ng-generate/table/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/**\n * Scaffolds a new table component.\n * Internally it bootstraps the base component schematic\n */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/table/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Schema as ComponentSchema } from '@schematics/angular/component/schema';\nexport interface Schema extends ComponentSchema {\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/tree/index.d.ts",
      "node_modules/@angular/material/schematics/ng-generate/tree/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\nimport { Schema } from './schema';\n/**\n * Scaffolds a new tree component.\n * Internally it bootstraps the base component schematic\n */\nexport default function (options: Schema): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-generate/tree/schema.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Schema as ComponentSchema } from '@schematics/angular/component/schema';\nexport interface Schema extends ComponentSchema {\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/attribute-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { AttributeSelectorUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const attributeSelectors: VersionChanges<AttributeSelectorUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/class-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ClassNameUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const classNames: VersionChanges<ClassNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/constructor-checks.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ConstructorChecksUpgradeData, VersionChanges } from '@angular/cdk/schematics';\n/**\n * List of class names for which the constructor signature has been changed. The new constructor\n * signature types don't need to be stored here because the signature will be determined\n * automatically through type checking.\n */\nexport declare const constructorChecks: VersionChanges<ConstructorChecksUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/css-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { VersionChanges } from '@angular/cdk/schematics';\nexport interface MaterialCssSelectorData {\n    /** The CSS selector to replace. */\n    replace: string;\n    /** The new CSS selector. */\n    replaceWith: string;\n    /**\n     * Controls which file types in which this replacement is made. If omitted, it is made in all\n     * files.\n     */\n    replaceIn?: {\n        /** Replace this name in stylesheet files. */\n        stylesheet?: boolean;\n        /** Replace this name in HTML files. */\n        html?: boolean;\n        /** Replace this name in TypeScript strings. */\n        tsStringLiterals?: boolean;\n    };\n}\nexport declare const cssSelectors: VersionChanges<MaterialCssSelectorData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/element-selectors.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ElementSelectorUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const elementSelectors: VersionChanges<ElementSelectorUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/index.d.ts",
      "node_modules/@angular/material/schematics/ng-update/data/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './attribute-selectors';\nexport * from './class-names';\nexport * from './constructor-checks';\nexport * from './css-selectors';\nexport * from './element-selectors';\nexport * from './input-names';\nexport * from './method-call-checks';\nexport * from './output-names';\nexport * from './property-names';\nexport * from './symbol-removal';\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/input-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InputNameUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const inputNames: VersionChanges<InputNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/method-call-checks.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { MethodCallUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const methodCallChecks: VersionChanges<MethodCallUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/output-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { OutputNameUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const outputNames: VersionChanges<OutputNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/property-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { PropertyNameUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const propertyNames: VersionChanges<PropertyNameUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/data/symbol-removal.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { SymbolRemovalUpgradeData, VersionChanges } from '@angular/cdk/schematics';\nexport declare const symbolRemoval: VersionChanges<SymbolRemovalUpgradeData>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/index.d.ts",
      "node_modules/@angular/material/schematics/ng-update/index.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Rule } from '@angular-devkit/schematics';\n/** Entry point for the migration schematics with target of Angular Material v6 */\nexport declare function updateToV6(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v7 */\nexport declare function updateToV7(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v8 */\nexport declare function updateToV8(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v9 */\nexport declare function updateToV9(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v10 */\nexport declare function updateToV10(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v11 */\nexport declare function updateToV11(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v12 */\nexport declare function updateToV12(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v13 */\nexport declare function updateToV13(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v14 */\nexport declare function updateToV14(): Rule;\n/** Entry point for the migration schematics with target of Angular Material v15 */\nexport declare function updateToV15(): Rule;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/hammer-gestures-v9/find-hammer-script-tags.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { parse5 } from '@angular/cdk/schematics';\n/**\n * Parses the specified HTML content and looks for \"script\" elements which\n * potentially import HammerJS. These elements will be returned.\n */\nexport declare function findHammerScriptImportElements(htmlContent: string): parse5.Element[];\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/hammer-gestures-v9/find-main-module.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/**\n * Finds the main Angular module within the specified source file. The first module\n * that is part of the \"bootstrapModule\" expression is returned.\n */\nexport declare function findMainModuleExpression(mainSourceFile: ts.SourceFile): ts.Expression | null;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/hammer-gestures-v9/hammer-gestures-migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { SchematicContext, Tree } from '@angular-devkit/schematics';\nimport { DevkitMigration, PostMigrationAction, ResolvedResource, TargetVersion } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\nexport declare class HammerGesturesMigration extends DevkitMigration<null> {\n    enabled: boolean;\n    private _printer;\n    private _importManager;\n    private _nodeFailures;\n    /**\n     * Whether custom HammerJS events provided by the Material gesture\n     * config are used in a template.\n     */\n    private _customEventsUsedInTemplate;\n    /** Whether standard HammerJS events are used in a template. */\n    private _standardEventsUsedInTemplate;\n    /** Whether HammerJS is accessed at runtime. */\n    private _usedInRuntime;\n    /**\n     * List of imports that make \"hammerjs\" available globally. We keep track of these\n     * since we might need to remove them if Hammer is not used.\n     */\n    private _installImports;\n    /**\n     * List of identifiers which resolve to the gesture config from Angular Material.\n     */\n    private _gestureConfigReferences;\n    /**\n     * List of identifiers which resolve to the \"HAMMER_GESTURE_CONFIG\" token from\n     * \"@angular/platform-browser\".\n     */\n    private _hammerConfigTokenReferences;\n    /**\n     * List of identifiers which resolve to the \"HammerModule\" from\n     * \"@angular/platform-browser\".\n     */\n    private _hammerModuleReferences;\n    /**\n     * List of identifiers that have been deleted from source files. This can be\n     * used to determine if certain imports are still used or not.\n     */\n    private _deletedIdentifiers;\n    visitTemplate(template: ResolvedResource): void;\n    visitNode(node: ts.Node): void;\n    postAnalysis(): void;\n    /**\n     * Sets up the hammer gesture config in the current project. To achieve this, the\n     * following steps are performed:\n     *   1) Create copy of Angular Material gesture config.\n     *   2) Rewrite all references to the Angular Material gesture config to the\n     *      new gesture config.\n     *   3) Setup the HAMMER_GESTURE_CONFIG in the root app module (if not done already).\n     *   4) Setup the \"HammerModule\" in the root app module (if not done already).\n     */\n    private _setupHammerWithCustomEvents;\n    /**\n     * Sets up the standard hammer module in the project and removes all\n     * references to the deprecated Angular Material gesture config.\n     */\n    private _setupHammerWithStandardEvents;\n    /**\n     * Removes Hammer from the current project. The following steps are performed:\n     *   1) Delete all TypeScript imports to \"hammerjs\".\n     *   2) Remove references to the Angular Material gesture config.\n     *   3) Remove \"hammerjs\" from all index HTML files of the current project.\n     */\n    private _removeHammerSetup;\n    /**\n     * Removes the gesture config setup by deleting all found references to the Angular\n     * Material gesture config. Additionally, unused imports to the hammer gesture config\n     * token from \"@angular/platform-browser\" will be removed as well.\n     */\n    private _removeMaterialGestureConfigSetup;\n    /** Removes all references to the \"HammerModule\" from \"@angular/platform-browser\". */\n    private _removeHammerModuleReferences;\n    /**\n     * Checks if the given node is a reference to the hammer gesture config\n     * token from platform-browser. If so, keeps track of the reference.\n     */\n    private _checkForHammerGestureConfigToken;\n    /**\n     * Checks if the given node is a reference to the HammerModule from\n     * \"@angular/platform-browser\". If so, keeps track of the reference.\n     */\n    private _checkForHammerModuleReference;\n    /**\n     * Checks if the given node is an import to the HammerJS package. Imports to\n     * HammerJS which load specific symbols from the package are considered as\n     * runtime usage of Hammer. e.g. `import {Symbol} from \"hammerjs\";`.\n     */\n    private _checkHammerImports;\n    /**\n     * Checks if the given node accesses the global \"Hammer\" symbol at runtime. If so,\n     * the migration rule state will be updated to reflect that Hammer is used at runtime.\n     */\n    private _checkForRuntimeHammerUsage;\n    /**\n     * Checks if the given node references the gesture config from Angular Material.\n     * If so, we keep track of the found symbol reference.\n     */\n    private _checkForMaterialGestureConfig;\n    /**\n     * Checks if the given Hammer gesture config token reference is part of an\n     * Angular provider definition that sets up a custom gesture config.\n     */\n    private _checkForCustomGestureConfigSetup;\n    /**\n     * Determines an available file name for the gesture config which should\n     * be stored in the specified file path.\n     */\n    private _getAvailableGestureConfigFileName;\n    /** Replaces a given gesture config reference with a new import. */\n    private _replaceGestureConfigReference;\n    /**\n     * Removes a given gesture config reference and its corresponding import from\n     * its containing source file. Imports will be always removed, but in some cases,\n     * where it's not guaranteed that a removal can be performed safely, we just\n     * create a migration failure (and add a TODO if possible).\n     */\n    private _removeGestureConfigReference;\n    /** Removes the given hammer config token import if it is not used. */\n    private _removeHammerConfigTokenImportIfUnused;\n    /** Removes Hammer from all index HTML files of the current project. */\n    private _removeHammerFromIndexFile;\n    /** Sets up the Hammer gesture config in the root module if needed. */\n    private _setupNewGestureConfigInRootModule;\n    /**\n     * Gets the TypeScript symbol of the root module by looking for the module\n     * bootstrap expression in the specified source file.\n     */\n    private _getRootModuleSymbol;\n    /** Sets up the \"HammerModule\" in the root module of the current project. */\n    private _setupHammerModuleInRootModule;\n    /** Prints a given node within the specified source file. */\n    private _printNode;\n    /** Gets all referenced gesture config identifiers of a given source file */\n    private _getGestureConfigIdentifiersOfFile;\n    /** Gets the symbol that contains the value declaration of the specified node. */\n    private _getDeclarationSymbolOfNode;\n    /**\n     * Checks whether the given expression resolves to a hammer gesture config\n     * token reference from \"@angular/platform-browser\".\n     */\n    private _isReferenceToHammerConfigToken;\n    /**\n     * Creates migration failures of the collected node failures. The returned migration\n     * failures are updated to reflect the post-migration state of source files. Meaning\n     * that failure positions are corrected if source file modifications shifted lines.\n     */\n    private _createMigrationFailures;\n    /** Global state of whether Hammer is used in any analyzed project target. */\n    static globalUsesHammer: boolean;\n    /**\n     * Static migration rule method that will be called once all project targets\n     * have been migrated individually. This method can be used to make changes based\n     * on the analysis of the individual targets. For example: we only remove Hammer\n     * from the \"package.json\" if it is not used in *any* project target.\n     */\n    static globalPostMigration(tree: Tree, target: TargetVersion, context: SchematicContext): PostMigrationAction;\n    /**\n     * Removes the hammer package from the workspace \"package.json\".\n     * @returns Whether Hammer was set up and has been removed from the \"package.json\"\n     */\n    private static _removeHammerFromPackageJson;\n    /** Gets whether the migration is allowed to run for specified target version. */\n    private static _isAllowedVersion;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/hammer-gestures-v9/hammer-template-check.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parses the specified HTML and searches for elements with Angular outputs listening to\n * one of the known HammerJS events. This check naively assumes that the bindings never\n * match on a component output, but only on the Hammer plugin.\n */\nexport declare function isHammerJsUsedInTemplate(html: string): {\n    standardEvents: boolean;\n    customEvents: boolean;\n};\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/hammer-gestures-v9/import-manager.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { FileSystem } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n/**\n * Import manager that can be used to add or remove TypeScript imports within source\n * files. The manager ensures that multiple transformations are applied properly\n * without shifted offsets and that existing imports are re-used.\n */\nexport declare class ImportManager {\n    private _fileSystem;\n    private _printer;\n    /** Map of source-files and their previously used identifier names. */\n    private _usedIdentifierNames;\n    /** Map of source files and their analyzed imports. */\n    private _importCache;\n    constructor(_fileSystem: FileSystem, _printer: ts.Printer);\n    /**\n     * Analyzes the import of the specified source file if needed. In order to perform\n     * modifications to imports of a source file, we store all imports in memory and\n     * update the source file once all changes have been made. This is essential to\n     * ensure that we can re-use newly added imports and not break file offsets.\n     */\n    private _analyzeImportsIfNeeded;\n    /**\n     * Checks whether the given specifier, which can be relative to the base path,\n     * matches the passed module name.\n     */\n    private _isModuleSpecifierMatching;\n    /** Deletes a given named binding import from the specified source file. */\n    deleteNamedBindingImport(sourceFile: ts.SourceFile, symbolName: string, moduleName: string): void;\n    /** Deletes the import that matches the given import declaration if found. */\n    deleteImportByDeclaration(declaration: ts.ImportDeclaration): void;\n    /**\n     * Adds an import to the given source file and returns the TypeScript expression that\n     * can be used to access the newly imported symbol.\n     *\n     * Whenever an import is added to a source file, it's recommended that the returned\n     * expression is used to reference th symbol. This is necessary because the symbol\n     * could be aliased if it would collide with existing imports in source file.\n     *\n     * @param sourceFile Source file to which the import should be added.\n     * @param symbolName Name of the symbol that should be imported. Can be null if\n     *    the default export is requested.\n     * @param moduleName Name of the module of which the symbol should be imported.\n     * @param typeImport Whether the symbol is a type.\n     * @param ignoreIdentifierCollisions List of identifiers which can be ignored when\n     *    the import manager checks for import collisions.\n     */\n    addImportToSourceFile(sourceFile: ts.SourceFile, symbolName: string | null, moduleName: string, typeImport?: boolean, ignoreIdentifierCollisions?: ts.Identifier[]): ts.Expression;\n    /**\n     * Applies the recorded changes in the update recorders of the corresponding source files.\n     * The changes are applied separately after all changes have been recorded because otherwise\n     * file offsets will change and the source files would need to be re-parsed after each change.\n     */\n    recordChanges(): void;\n    /**\n     * Corrects the line and character position of a given node. Since nodes of\n     * source files are immutable and we sometimes make changes to the containing\n     * source file, the node position might shift (e.g. if we add a new import before).\n     *\n     * This method can be used to retrieve a corrected position of the given node. This\n     * is helpful when printing out error messages which should reflect the new state of\n     * source files.\n     */\n    correctNodePosition(node: ts.Node, offset: number, position: ts.LineAndCharacter): ts.LineAndCharacter;\n    /**\n     * Returns an unique identifier name for the specified symbol name.\n     * @param sourceFile Source file to check for identifier collisions.\n     * @param symbolName Name of the symbol for which we want to generate an unique name.\n     * @param ignoreIdentifierCollisions List of identifiers which should be ignored when\n     *    checking for identifier collisions in the given source file.\n     */\n    private _getUniqueIdentifier;\n    /**\n     * Checks whether the specified identifier name is used within the given source file.\n     * @param sourceFile Source file to check for identifier collisions.\n     * @param name Name of the identifier which is checked for its uniqueness.\n     * @param ignoreIdentifierCollisions List of identifiers which should be ignored when\n     *    checking for identifier collisions in the given source file.\n     */\n    private _isUniqueIdentifierName;\n    /**\n     * Records that the given identifier is used within the specified source file. This\n     * is necessary since we do not apply changes to source files per change, but still\n     * want to avoid conflicts with newly imported symbols.\n     */\n    private _recordUsedIdentifier;\n    /**\n     * Determines the full end of a given node. By default the end position of a node is\n     * before all trailing comments. This could mean that generated imports shift comments.\n     */\n    private _getEndPositionOfNode;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/hammer-gestures-v9/remove-array-element.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { UpdateRecorder } from '@angular-devkit/schematics';\nimport * as ts from 'typescript';\n/**\n * Retrieves the parent syntax list of the given node. A syntax list node is usually\n * hidden from the default AST node hierarchy because it only contains information that\n * is need when printing a node. e.g. it contains information about comma positions in\n * an array literal expression.\n */\nexport declare function getParentSyntaxList(node: ts.Node): ts.SyntaxList | null;\n/** Removes a given element from its parent array literal expression. */\nexport declare function removeElementFromArrayExpression(element: ts.Node, recorder: UpdateRecorder): void;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/hammer-gestures-v9/remove-element-from-html.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { UpdateRecorder } from '@angular-devkit/schematics';\nimport { parse5 } from '@angular/cdk/schematics';\n/**\n * Removes the specified element. Additionally, preceding whitespace will be removed\n * to not leave empty lines in the resulting HTML.\n */\nexport declare function removeElementFromHtml(element: parse5.Element, recorder: UpdateRecorder): void;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/misc-checks/misc-class-inheritance.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n/**\n * Migration that checks for classes that extend Angular Material classes which\n * have changed their API.\n */\nexport declare class MiscClassInheritanceMigration extends Migration<null> {\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    private _visitClassDeclaration;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/misc-checks/misc-class-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n/**\n * Migration that looks for class name identifiers that have been removed but\n * cannot be automatically migrated.\n */\nexport declare class MiscClassNamesMigration extends Migration<null> {\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    private _visitIdentifier;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/misc-checks/misc-imports.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n/**\n * Migration that detects import declarations that refer to outdated identifiers from\n * Angular Material which cannot be updated automatically.\n */\nexport declare class MiscImportsMigration extends Migration<null> {\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    private _visitImportDeclaration;\n    /**\n     * Checks for named imports that refer to the deleted animation constants.\n     * https://github.com/angular/components/commit/9f3bf274c4f15f0b0fbd8ab7dbf1a453076e66d9\n     */\n    private _checkAnimationConstants;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/misc-checks/misc-property-names.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n/**\n * Migration that walks through every property access expression and and reports a failure if\n * a given property name no longer exists but cannot be automatically migrated.\n */\nexport declare class MiscPropertyNamesMigration extends Migration<null> {\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    private _visitPropertyAccessExpression;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/misc-checks/misc-template.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration, ResolvedResource } from '@angular/cdk/schematics';\n/**\n * Migration that walks through every inline or external template and reports if there\n * are outdated usages of the Angular Material API that needs to be updated manually.\n */\nexport declare class MiscTemplateMigration extends Migration<null> {\n    enabled: boolean;\n    visitTemplate(template: ResolvedResource): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/misc-ripples-v7/ripple-speed-factor-migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration, ResolvedResource } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n/**\n * Migration that walks through every property assignment and switches the global `baseSpeedFactor`\n * ripple option to the new global animation config. Also updates every class member assignment\n * that refers to MatRipple#speedFactor.\n */\nexport declare class RippleSpeedFactorMigration extends Migration<null> {\n    enabled: boolean;\n    visitNode(node: ts.Node): void;\n    visitTemplate(template: ResolvedResource): void;\n    /** Switches binary expressions (e.g. myRipple.speedFactor = 0.5) to the new animation config. */\n    private _visitBinaryExpression;\n    /**\n     * Switches the global option `baseSpeedFactor` to the new animation config. For this\n     * we assume that the `baseSpeedFactor` is not used in combination with individual\n     * speed factors.\n     */\n    private _visitPropertyAssignment;\n    private _replaceText;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/misc-ripples-v7/ripple-speed-factor.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Converts the specified speed factor into the exact static enter duration. */\nexport declare function convertSpeedFactorToDuration(factor: number): number;\n/**\n * Creates a runtime TypeScript expression that can be used in order to calculate the duration\n * from the speed factor expression that couldn't be statically analyzed.\n *\n * @param speedFactorValue Speed factor expression that couldn't be statically analyzed.\n */\nexport declare function createSpeedFactorConvertExpression(speedFactorValue: string): string;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/package-imports-v8/secondary-entry-points-migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Migration } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n/**\n * Migration that updates imports which refer to the primary Angular Material\n * entry-point to use the appropriate secondary entry points (e.g. @angular/material/button).\n */\nexport declare class SecondaryEntryPointsMigration extends Migration<null> {\n    printer: ts.Printer;\n    enabled: boolean;\n    visitNode(declaration: ts.Node): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/theming-api-v12/config.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mapping of Material mixins that should be renamed. */\nexport declare const materialMixins: Record<string, string>;\n/** Mapping of Material functions that should be renamed. */\nexport declare const materialFunctions: Record<string, string>;\n/** Mapping of Material variables that should be renamed. */\nexport declare const materialVariables: Record<string, string>;\n/** Mapping of CDK variables that should be renamed. */\nexport declare const cdkVariables: Record<string, string>;\n/** Mapping of CDK mixins that should be renamed. */\nexport declare const cdkMixins: Record<string, string>;\n/**\n * Material variables that have been removed from the public API\n * and which should be replaced with their values.\n */\nexport declare const removedMaterialVariables: Record<string, string>;\n/**\n * Material variables **without a `mat-` prefix** that have been removed from the public API\n * and which should be replaced with their values. These should be migrated only when there's a\n * Material import, because their names could conflict with other variables in the user's app.\n */\nexport declare const unprefixedRemovedVariables: Record<string, string>;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/theming-api-v12/migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Addition mixin and function names that can be updated when invoking migration directly. */\ninterface ExtraSymbols {\n    mixins?: Record<string, string>;\n    functions?: Record<string, string>;\n    variables?: Record<string, string>;\n}\n/**\n * Migrates the content of a file to the new theming API. Note that this migration is using plain\n * string manipulation, rather than the AST from PostCSS and the schematics string manipulation\n * APIs, because it allows us to run it inside g3 and to avoid introducing new dependencies.\n * @param fileContent Content of the file.\n * @param oldMaterialPrefix Prefix with which the old Material imports should start.\n *   Has to end with a slash. E.g. if `@import '@angular/material/theming'` should be\n *   matched, the prefix would be `@angular/material/`.\n * @param oldCdkPrefix Prefix with which the old CDK imports should start.\n *   Has to end with a slash. E.g. if `@import '@angular/cdk/overlay'` should be\n *   matched, the prefix would be `@angular/cdk/`.\n * @param newMaterialImportPath New import to the Material theming API (e.g. `@angular/material`).\n * @param newCdkImportPath New import to the CDK Sass APIs (e.g. `@angular/cdk`).\n * @param excludedImports Pattern that can be used to exclude imports from being processed.\n */\nexport declare function migrateFileContent(fileContent: string, oldMaterialPrefix: string, oldCdkPrefix: string, newMaterialImportPath: string, newCdkImportPath: string, extraMaterialSymbols?: ExtraSymbols, excludedImports?: RegExp): string;\nexport {};\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/migrations/theming-api-v12/theming-api-migration.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { SchematicContext } from '@angular-devkit/schematics';\nimport { DevkitMigration, ResolvedResource, TargetVersion } from '@angular/cdk/schematics';\n/** Migration that switches all Sass files using Material theming APIs to `@use`. */\nexport declare class ThemingApiMigration extends DevkitMigration<null> {\n    /** Number of files that have been migrated. */\n    static migratedFileCount: number;\n    enabled: boolean;\n    visitStylesheet(stylesheet: ResolvedResource): void;\n    /** Logs out the number of migrated files at the end of the migration. */\n    static globalPostMigration(_tree: unknown, _targetVersion: TargetVersion, context: SchematicContext): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/typescript/module-specifiers.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n/** Name of the Angular Material module specifier. */\nexport declare const materialModuleSpecifier = \"@angular/material\";\n/** Name of the Angular CDK module specifier. */\nexport declare const cdkModuleSpecifier = \"@angular/cdk\";\n/** Whether the specified node is part of an Angular Material or CDK import declaration. */\nexport declare function isMaterialImportDeclaration(node: ts.Node): boolean;\n/** Whether the specified node is part of an Angular Material or CDK import declaration. */\nexport declare function isMaterialExportDeclaration(node: ts.Node): boolean;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/ng-update/upgrade-data.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { UpgradeData } from '@angular/cdk/schematics';\n/** Upgrade data that will be used for the Angular Material ng-update schematic. */\nexport declare const materialUpgradeData: UpgradeData;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/schematics/paths.d.ts"
    ],
    "content": "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Path to the schematic collection for non-migration schematics. */\nexport declare const COLLECTION_PATH: string;\n/** Path to the schematic collection that includes the migrations. */\nexport declare const MIGRATION_PATH: string;\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/select/index.d.ts",
      "node_modules/@angular/material/select/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { AfterContentInit } from '@angular/core';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { CanUpdateErrorState } from '@angular/material/core';\nimport { CdkConnectedOverlay } from '@angular/cdk/overlay';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ConnectedPosition } from '@angular/cdk/overlay';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { ErrorStateMatcher } from '@angular/material/core';\nimport { EventEmitter } from '@angular/core';\nimport { FormGroupDirective } from '@angular/forms';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/common';\nimport * as i3 from '@angular/cdk/overlay';\nimport * as i4 from '@angular/material/core';\nimport * as i5 from '@angular/cdk/scrolling';\nimport * as i6 from '@angular/material/form-field';\nimport { InjectionToken } from '@angular/core';\nimport { LiveAnnouncer } from '@angular/cdk/a11y';\nimport { MatFormField } from '@angular/material/form-field';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { MatOptgroup } from '@angular/material/core';\nimport { MatOption } from '@angular/material/core';\nimport { _MatOptionBase } from '@angular/material/core';\nimport { MatOptionSelectionChange } from '@angular/material/core';\nimport { NgControl } from '@angular/forms';\nimport { NgForm } from '@angular/forms';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { QueryList } from '@angular/core';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\ndeclare namespace i1 {\n    export {\n        MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,\n        SELECT_PANEL_MAX_HEIGHT,\n        SELECT_PANEL_PADDING_X,\n        SELECT_PANEL_INDENT_PADDING_X,\n        SELECT_ITEM_HEIGHT_EM,\n        SELECT_MULTIPLE_PANEL_PADDING_X,\n        SELECT_PANEL_VIEWPORT_PADDING,\n        MAT_SELECT_SCROLL_STRATEGY,\n        MatSelectConfig,\n        MAT_SELECT_CONFIG,\n        MAT_SELECT_SCROLL_STRATEGY_PROVIDER,\n        MatSelectChange,\n        MAT_SELECT_TRIGGER,\n        MatSelectTrigger,\n        _MatSelectBase,\n        MatSelect\n    }\n}\n\n/** Injection token that can be used to provide the default options the select module. */\nexport declare const MAT_SELECT_CONFIG: InjectionToken<MatSelectConfig>;\n\n/** Injection token that determines the scroll handling while a select is open. */\nexport declare const MAT_SELECT_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\nexport declare const MAT_SELECT_SCROLL_STRATEGY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\nexport declare function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport declare const MAT_SELECT_TRIGGER: InjectionToken<MatSelectTrigger>;\n\nexport declare class MatSelect extends _MatSelectBase<MatSelectChange> implements OnInit {\n    /** The scroll position of the overlay panel, calculated to center the selected option. */\n    private _scrollTop;\n    /** The last measured value for the trigger's client bounding rect. */\n    _triggerRect: ClientRect;\n    /** The cached font-size of the trigger element. */\n    _triggerFontSize: number;\n    /** The value of the select panel's transform-origin property. */\n    _transformOrigin: string;\n    /**\n     * The y-offset of the overlay panel in relation to the trigger's top start corner.\n     * This must be adjusted to align the selected option text over the trigger text.\n     * when the panel opens. Will change based on the y-position of the selected option.\n     */\n    _offsetY: number;\n    options: QueryList<MatOption>;\n    optionGroups: QueryList<MatOptgroup>;\n    customTrigger: MatSelectTrigger;\n    _positions: ConnectedPosition[];\n    /**\n     * Calculates the scroll position of the select's overlay panel.\n     *\n     * Attempts to center the selected option in the panel. If the option is\n     * too high or too low in the panel to be scrolled to the center, it clamps the\n     * scroll position to the min or max scroll positions respectively.\n     */\n    _calculateOverlayScroll(selectedIndex: number, scrollBuffer: number, maxScroll: number): number;\n    ngOnInit(): void;\n    open(): void;\n    /** Scrolls the active option into view. */\n    protected _scrollOptionIntoView(index: number): void;\n    protected _positioningSettled(): void;\n    protected _panelDoneAnimating(isOpen: boolean): void;\n    protected _getChangeEvent(value: any): MatSelectChange;\n    /**\n     * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.\n     * This must be adjusted to align the selected option text over the trigger text when\n     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\n     * can't be calculated until the panel has been attached, because we need to know the\n     * content width in order to constrain the panel within the viewport.\n     */\n    private _calculateOverlayOffsetX;\n    /**\n     * Calculates the y-offset of the select's overlay panel in relation to the\n     * top start corner of the trigger. It has to be adjusted in order for the\n     * selected option to be aligned over the trigger when the panel opens.\n     */\n    private _calculateOverlayOffsetY;\n    /**\n     * Checks that the attempted overlay position will fit within the viewport.\n     * If it will not fit, tries to adjust the scroll position and the associated\n     * y-offset so the panel can open fully on-screen. If it still won't fit,\n     * sets the offset back to 0 to allow the fallback position to take over.\n     */\n    private _checkOverlayWithinViewport;\n    /** Adjusts the overlay panel up to fit in the viewport. */\n    private _adjustPanelUp;\n    /** Adjusts the overlay panel down to fit in the viewport. */\n    private _adjustPanelDown;\n    /** Calculates the scroll position and x- and y-offsets of the overlay panel. */\n    private _calculateOverlayPosition;\n    /** Sets the transform origin point based on the selected option. */\n    private _getOriginBasedOnOption;\n    /** Calculates the height of the select's options. */\n    private _getItemHeight;\n    /** Calculates the amount of items in the select. This includes options and group labels. */\n    private _getItemCount;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSelect, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSelect, \"mat-select\", [\"matSelect\"], { \"disabled\": \"disabled\"; \"disableRipple\": \"disableRipple\"; \"tabIndex\": \"tabIndex\"; }, {}, [\"customTrigger\", \"options\", \"optionGroups\"], [\"mat-select-trigger\", \"*\"], false>;\n}\n\n/**\n * The following are all the animations for the mat-select component, with each\n * const containing the metadata for one animation.\n *\n * The values below match the implementation of the AngularJS Material mat-select animation.\n * @docs-private\n */\nexport declare const matSelectAnimations: {\n    readonly transformPanelWrap: AnimationTriggerMetadata;\n    readonly transformPanel: AnimationTriggerMetadata;\n};\n\n/** Base class with all of the `MatSelect` functionality. */\nexport declare abstract class _MatSelectBase<C> extends _MatSelectMixinBase implements AfterContentInit, OnChanges, OnDestroy, OnInit, DoCheck, ControlValueAccessor, CanDisable, HasTabIndex, MatFormFieldControl<any>, CanUpdateErrorState, CanDisableRipple {\n    protected _viewportRuler: ViewportRuler;\n    protected _changeDetectorRef: ChangeDetectorRef;\n    protected _ngZone: NgZone;\n    private _dir;\n    protected _parentFormField: MatFormField;\n    private _liveAnnouncer;\n    private _defaultOptions?;\n    /** All of the defined select options. */\n    abstract options: QueryList<_MatOptionBase>;\n    /** All of the defined groups of options. */\n    abstract optionGroups: QueryList<MatOptgroup>;\n    /** User-supplied override of the trigger element. */\n    abstract customTrigger: {};\n    /**\n     * This position config ensures that the top \"start\" corner of the overlay\n     * is aligned with with the top \"start\" of the origin by default (overlapping\n     * the trigger completely). If the panel cannot fit below the trigger, it\n     * will fall back to a position above the trigger.\n     */\n    abstract _positions: ConnectedPosition[];\n    /** Scrolls a particular option into the view. */\n    protected abstract _scrollOptionIntoView(index: number): void;\n    /** Called when the panel has been opened and the overlay has settled on its final position. */\n    protected abstract _positioningSettled(): void;\n    /** Creates a change event object that should be emitted by the select. */\n    protected abstract _getChangeEvent(value: any): C;\n    /** Factory function used to create a scroll strategy for this select. */\n    private _scrollStrategyFactory;\n    /** Whether or not the overlay panel is open. */\n    private _panelOpen;\n    /** Comparison function to specify which option is displayed. Defaults to object equality. */\n    private _compareWith;\n    /** Unique id for this input. */\n    private _uid;\n    /** Current `aria-labelledby` value for the select trigger. */\n    private _triggerAriaLabelledBy;\n    /**\n     * Keeps track of the previous form control assigned to the select.\n     * Used to detect if it has changed.\n     */\n    private _previousControl;\n    /** Emits whenever the component is destroyed. */\n    protected readonly _destroy: Subject<void>;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    userAriaDescribedBy: string;\n    /** Deals with the selection logic. */\n    _selectionModel: SelectionModel<MatOption>;\n    /** Manages keyboard events for options in the panel. */\n    _keyManager: ActiveDescendantKeyManager<MatOption>;\n    /** `View -> model callback called when value changes` */\n    _onChange: (value: any) => void;\n    /** `View -> model callback called when select has been touched` */\n    _onTouched: () => void;\n    /** ID for the DOM node containing the select's value. */\n    _valueId: string;\n    /** Emits when the panel element is finished transforming in. */\n    readonly _panelDoneAnimatingStream: Subject<string>;\n    /** Strategy that will be used to handle scrolling while the select panel is open. */\n    _scrollStrategy: ScrollStrategy;\n    _overlayPanelClass: string | string[];\n    /** Whether the select is focused. */\n    get focused(): boolean;\n    private _focused;\n    /** A name for this control that can be used by `mat-form-field`. */\n    controlType: string;\n    /** Trigger that opens the select. */\n    trigger: ElementRef;\n    /** Panel containing the select options. */\n    panel: ElementRef;\n    /** Overlay pane containing the options. */\n    protected _overlayDir: CdkConnectedOverlay;\n    /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */\n    panelClass: string | string[] | Set<string> | {\n        [key: string]: any;\n    };\n    /** Placeholder to be shown if no value has been selected. */\n    get placeholder(): string;\n    set placeholder(value: string);\n    private _placeholder;\n    /** Whether the component is required. */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    private _required;\n    /** Whether the user should be allowed to select multiple options. */\n    get multiple(): boolean;\n    set multiple(value: BooleanInput);\n    private _multiple;\n    /** Whether to center the active option over the trigger. */\n    get disableOptionCentering(): boolean;\n    set disableOptionCentering(value: BooleanInput);\n    private _disableOptionCentering;\n    /**\n     * Function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     */\n    get compareWith(): (o1: any, o2: any) => boolean;\n    set compareWith(fn: (o1: any, o2: any) => boolean);\n    /** Value of the select control. */\n    get value(): any;\n    set value(newValue: any);\n    private _value;\n    /** Aria label of the select. */\n    ariaLabel: string;\n    /** Input that can be used to specify the `aria-labelledby` attribute. */\n    ariaLabelledby: string;\n    /** Object used to control when error messages are shown. */\n    errorStateMatcher: ErrorStateMatcher;\n    /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n    get typeaheadDebounceInterval(): number;\n    set typeaheadDebounceInterval(value: NumberInput);\n    private _typeaheadDebounceInterval;\n    /**\n     * Function used to sort the values in a select in multiple mode.\n     * Follows the same logic as `Array.prototype.sort`.\n     */\n    sortComparator: (a: MatOption, b: MatOption, options: MatOption[]) => number;\n    /** Unique id of the element. */\n    get id(): string;\n    set id(value: string);\n    private _id;\n    /** Combined stream of all of the child options' change events. */\n    readonly optionSelectionChanges: Observable<MatOptionSelectionChange>;\n    /** Event emitted when the select panel has been toggled. */\n    readonly openedChange: EventEmitter<boolean>;\n    /** Event emitted when the select has been opened. */\n    readonly _openedStream: Observable<void>;\n    /** Event emitted when the select has been closed. */\n    readonly _closedStream: Observable<void>;\n    /** Event emitted when the selected value has been changed by the user. */\n    readonly selectionChange: EventEmitter<C>;\n    /**\n     * Event that emits whenever the raw value of the select changes. This is here primarily\n     * to facilitate the two-way binding for the `value` input.\n     * @docs-private\n     */\n    readonly valueChange: EventEmitter<any>;\n    constructor(_viewportRuler: ViewportRuler, _changeDetectorRef: ChangeDetectorRef, _ngZone: NgZone, _defaultErrorStateMatcher: ErrorStateMatcher, elementRef: ElementRef, _dir: Directionality, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, _parentFormField: MatFormField, ngControl: NgControl, tabIndex: string, scrollStrategyFactory: any, _liveAnnouncer: LiveAnnouncer, _defaultOptions?: MatSelectConfig | undefined);\n    ngOnInit(): void;\n    ngAfterContentInit(): void;\n    ngDoCheck(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Toggles the overlay panel open or closed. */\n    toggle(): void;\n    /** Opens the overlay panel. */\n    open(): void;\n    /** Closes the overlay panel and focuses the host element. */\n    close(): void;\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param value New value to be written to the model.\n     */\n    writeValue(value: any): void;\n    /**\n     * Saves a callback function to be invoked when the select's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the value changes.\n     */\n    registerOnChange(fn: (value: any) => void): void;\n    /**\n     * Saves a callback function to be invoked when the select is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the component has been touched.\n     */\n    registerOnTouched(fn: () => {}): void;\n    /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param isDisabled Sets whether the component is disabled.\n     */\n    setDisabledState(isDisabled: boolean): void;\n    /** Whether or not the overlay panel is open. */\n    get panelOpen(): boolean;\n    /** The currently selected option. */\n    get selected(): MatOption | MatOption[];\n    /** The value displayed in the trigger. */\n    get triggerValue(): string;\n    /** Whether the element is in RTL mode. */\n    _isRtl(): boolean;\n    /** Handles all keydown events on the select. */\n    _handleKeydown(event: KeyboardEvent): void;\n    /** Handles keyboard events while the select is closed. */\n    private _handleClosedKeydown;\n    /** Handles keyboard events when the selected is open. */\n    private _handleOpenKeydown;\n    _onFocus(): void;\n    /**\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n     * \"blur\" to the panel when it opens, causing a false positive.\n     */\n    _onBlur(): void;\n    /**\n     * Callback that is invoked when the overlay panel has been attached.\n     */\n    _onAttached(): void;\n    /** Returns the theme to be used on the panel. */\n    _getPanelTheme(): string;\n    /** Whether the select has a value. */\n    get empty(): boolean;\n    private _initializeSelection;\n    /**\n     * Sets the selected option based on a value. If no option can be\n     * found with the designated value, the select trigger is cleared.\n     */\n    private _setSelectionByValue;\n    /**\n     * Finds and selects and option based on its value.\n     * @returns Option that has the corresponding value.\n     */\n    private _selectOptionByValue;\n    /** Assigns a specific value to the select. Returns whether the value has changed. */\n    private _assignValue;\n    /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n    private _initKeyManager;\n    /** Drops current option subscriptions and IDs and resets from scratch. */\n    private _resetOptions;\n    /** Invoked when an option is clicked. */\n    private _onSelect;\n    /** Sorts the selected values in the selected based on their order in the panel. */\n    private _sortValues;\n    /** Emits change event to set the model value. */\n    private _propagateChanges;\n    /**\n     * Highlights the selected item. If no option is selected, it will highlight\n     * the first item instead.\n     */\n    private _highlightCorrectOption;\n    /** Whether the panel is allowed to open. */\n    protected _canOpen(): boolean;\n    /** Focuses the select element. */\n    focus(options?: FocusOptions): void;\n    /** Gets the aria-labelledby for the select panel. */\n    _getPanelAriaLabelledby(): string | null;\n    /** Determines the `aria-activedescendant` to be set on the host. */\n    _getAriaActiveDescendant(): string | null;\n    /** Gets the aria-labelledby of the select component trigger. */\n    private _getTriggerAriaLabelledby;\n    /** Called when the overlay panel is done animating. */\n    protected _panelDoneAnimating(isOpen: boolean): void;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids: string[]): void;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick(): void;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat(): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatSelectBase<any>, [null, null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; self: true; }, { attribute: \"tabindex\"; }, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatSelectBase<any>, never, never, { \"userAriaDescribedBy\": \"aria-describedby\"; \"panelClass\": \"panelClass\"; \"placeholder\": \"placeholder\"; \"required\": \"required\"; \"multiple\": \"multiple\"; \"disableOptionCentering\": \"disableOptionCentering\"; \"compareWith\": \"compareWith\"; \"value\": \"value\"; \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"errorStateMatcher\": \"errorStateMatcher\"; \"typeaheadDebounceInterval\": \"typeaheadDebounceInterval\"; \"sortComparator\": \"sortComparator\"; \"id\": \"id\"; }, { \"openedChange\": \"openedChange\"; \"_openedStream\": \"opened\"; \"_closedStream\": \"closed\"; \"selectionChange\": \"selectionChange\"; \"valueChange\": \"valueChange\"; }, never, never, false>;\n}\n\n/** Change event object that is emitted when the select value has changed. */\nexport declare class MatSelectChange {\n    /** Reference to the select that emitted the change event. */\n    source: MatSelect;\n    /** Current value of the select that emitted the event. */\n    value: any;\n    constructor(\n    /** Reference to the select that emitted the change event. */\n    source: MatSelect, \n    /** Current value of the select that emitted the event. */\n    value: any);\n}\n\n/** Object that can be used to configure the default options for the select module. */\nexport declare interface MatSelectConfig {\n    /** Whether option centering should be disabled. */\n    disableOptionCentering?: boolean;\n    /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n    typeaheadDebounceInterval?: number;\n    /** Class or list of classes to be applied to the menu's overlay panel. */\n    overlayPanelClass?: string | string[];\n}\n\n/** @docs-private */\ndeclare const _MatSelectMixinBase: _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & _Constructor<CanUpdateErrorState> & _AbstractConstructor<CanUpdateErrorState> & {\n    new (_elementRef: ElementRef, _defaultErrorStateMatcher: ErrorStateMatcher, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, ngControl: NgControl): {\n        /**\n         * Emits whenever the component state changes and should cause the parent\n         * form-field to update. Implemented as part of `MatFormFieldControl`.\n         * @docs-private\n         */\n        readonly stateChanges: Subject<void>;\n        _elementRef: ElementRef;\n        _defaultErrorStateMatcher: ErrorStateMatcher;\n        _parentForm: NgForm;\n        _parentFormGroup: FormGroupDirective;\n        /**\n         * Form control bound to the component.\n         * Implemented as part of `MatFormFieldControl`.\n         * @docs-private\n         */\n        ngControl: NgControl;\n    };\n};\n\nexport declare class MatSelectModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSelectModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatSelectModule, [typeof i1.MatSelect, typeof i1.MatSelectTrigger], [typeof i2.CommonModule, typeof i3.OverlayModule, typeof i4.MatOptionModule, typeof i4.MatCommonModule], [typeof i5.CdkScrollableModule, typeof i6.MatFormFieldModule, typeof i1.MatSelect, typeof i1.MatSelectTrigger, typeof i4.MatOptionModule, typeof i4.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatSelectModule>;\n}\n\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\nexport declare class MatSelectTrigger {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSelectTrigger, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatSelectTrigger, \"mat-select-trigger\", never, {}, {}, never, never, false>;\n}\n\n/** The height of the select items in `em` units. */\ndeclare const SELECT_ITEM_HEIGHT_EM = 3;\n\n/**\n * Distance between the panel edge and the option text in\n * multi-selection mode.\n *\n * Calculated as:\n * (SELECT_PANEL_PADDING_X * 1.5) + 16 = 40\n * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.\n * The checkbox width is 16px.\n */\ndeclare const SELECT_MULTIPLE_PANEL_PADDING_X: number;\n\n/** The panel's x axis padding if it is indented (e.g. there is an option group). */\ndeclare const SELECT_PANEL_INDENT_PADDING_X: number;\n\n/** The max height of the select's overlay panel. */\ndeclare const SELECT_PANEL_MAX_HEIGHT = 256;\n\n/** The panel's padding on the x-axis. */\ndeclare const SELECT_PANEL_PADDING_X = 16;\n\n/**\n * The select panel will only \"fit\" inside the viewport if it is positioned at\n * this value or more away from the viewport boundary.\n */\ndeclare const SELECT_PANEL_VIEWPORT_PADDING = 8;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/select/testing/index.d.ts",
      "node_modules/@angular/material/select/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\nimport { MatOptgroupHarness } from '@angular/material/core/testing';\nimport { MatOptionHarness } from '@angular/material/core/testing';\nimport { OptgroupHarnessFilters } from '@angular/material/core/testing';\nimport { OptionHarnessFilters } from '@angular/material/core/testing';\n\n/** Harness for interacting with a standard mat-select in tests. */\nexport declare class MatSelectHarness extends _MatSelectHarnessBase<typeof MatOptionHarness, MatOptionHarness, OptionHarnessFilters, typeof MatOptgroupHarness, MatOptgroupHarness, OptgroupHarnessFilters> {\n    static hostSelector: string;\n    protected _prefix: string;\n    protected _optionClass: typeof MatOptionHarness;\n    protected _optionGroupClass: typeof MatOptgroupHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSelectHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which select instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: SelectHarnessFilters): HarnessPredicate<MatSelectHarness>;\n}\n\nexport declare abstract class _MatSelectHarnessBase<OptionType extends ComponentHarnessConstructor<Option> & {\n    with: (options?: OptionFilters) => HarnessPredicate<Option>;\n}, Option extends ComponentHarness & {\n    click(): Promise<void>;\n}, OptionFilters extends BaseHarnessFilters, OptionGroupType extends ComponentHarnessConstructor<OptionGroup> & {\n    with: (options?: OptionGroupFilters) => HarnessPredicate<OptionGroup>;\n}, OptionGroup extends ComponentHarness, OptionGroupFilters extends BaseHarnessFilters> extends MatFormFieldControlHarness {\n    protected abstract _prefix: string;\n    protected abstract _optionClass: OptionType;\n    protected abstract _optionGroupClass: OptionGroupType;\n    private _documentRootLocator;\n    private _backdrop;\n    /** Gets a boolean promise indicating if the select is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets a boolean promise indicating if the select is valid. */\n    isValid(): Promise<boolean>;\n    /** Gets a boolean promise indicating if the select is required. */\n    isRequired(): Promise<boolean>;\n    /** Gets a boolean promise indicating if the select is empty (no value is selected). */\n    isEmpty(): Promise<boolean>;\n    /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n    isMultiple(): Promise<boolean>;\n    /** Gets a promise for the select's value text. */\n    getValueText(): Promise<string>;\n    /** Focuses the select and returns a void promise that indicates when the action is complete. */\n    focus(): Promise<void>;\n    /** Blurs the select and returns a void promise that indicates when the action is complete. */\n    blur(): Promise<void>;\n    /** Whether the select is focused. */\n    isFocused(): Promise<boolean>;\n    /** Gets the options inside the select panel. */\n    getOptions(filter?: Omit<OptionFilters, 'ancestor'>): Promise<Option[]>;\n    /** Gets the groups of options inside the panel. */\n    getOptionGroups(filter?: Omit<OptionGroupFilters, 'ancestor'>): Promise<OptionGroup[]>;\n    /** Gets whether the select is open. */\n    isOpen(): Promise<boolean>;\n    /** Opens the select's panel. */\n    open(): Promise<void>;\n    /**\n     * Clicks the options that match the passed-in filter. If the select is in multi-selection\n     * mode all options will be clicked, otherwise the harness will pick the first matching option.\n     */\n    clickOptions(filter?: OptionFilters): Promise<void>;\n    /** Closes the select's panel. */\n    close(): Promise<void>;\n    /** Gets the selector that should be used to find this select's panel. */\n    private _getPanelSelector;\n}\n\n/** A set of criteria that can be used to filter a list of `MatSelectHarness` instances. */\nexport declare interface SelectHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/sidenav/index.d.ts",
      "node_modules/@angular/material/sidenav/index.d.ts"
    ],
    "content": "import { AfterContentChecked } from '@angular/core';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { DoCheck } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/common';\nimport * as i4 from '@angular/material/core';\nimport * as i5 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { InteractivityChecker } from '@angular/cdk/a11y';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { Subject } from 'rxjs';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\n/** Options for where to set focus to automatically on dialog open */\ndeclare type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\ndeclare namespace i1 {\n    export {\n        throwMatDuplicatedDrawerError,\n        MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\n        AutoFocusTarget,\n        MatDrawerToggleResult,\n        MatDrawerMode,\n        MAT_DRAWER_DEFAULT_AUTOSIZE,\n        MAT_DRAWER_CONTAINER,\n        MatDrawerContent,\n        MatDrawer,\n        MatDrawerContainer\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatSidenavContent,\n        MatSidenav,\n        MatSidenavContainer\n    }\n}\n\n/**\n * Used to provide a drawer container to a drawer while avoiding circular references.\n * @docs-private\n */\ndeclare const MAT_DRAWER_CONTAINER: InjectionToken<unknown>;\n\n/** Configures whether drawers should use auto sizing by default. */\nexport declare const MAT_DRAWER_DEFAULT_AUTOSIZE: InjectionToken<boolean>;\n\n/** @docs-private */\nexport declare function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY(): boolean;\n\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\nexport declare class MatDrawer implements AfterViewInit, AfterContentChecked, OnDestroy {\n    private _elementRef;\n    private _focusTrapFactory;\n    private _focusMonitor;\n    private _platform;\n    private _ngZone;\n    private readonly _interactivityChecker;\n    private _doc;\n    _container?: MatDrawerContainer | undefined;\n    private _focusTrap;\n    private _elementFocusedBeforeDrawerWasOpened;\n    /** Whether the drawer is initialized. Used for disabling the initial animation. */\n    private _enableAnimations;\n    /** Whether the view of the component has been attached. */\n    private _isAttached;\n    /** Anchor node used to restore the drawer to its initial position. */\n    private _anchor;\n    /** The side that the drawer is attached to. */\n    get position(): 'start' | 'end';\n    set position(value: 'start' | 'end');\n    private _position;\n    /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n    get mode(): MatDrawerMode;\n    set mode(value: MatDrawerMode);\n    private _mode;\n    /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n    get disableClose(): boolean;\n    set disableClose(value: BooleanInput);\n    private _disableClose;\n    /**\n     * Whether the drawer should focus the first focusable element automatically when opened.\n     * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\n     * enabled, focus will be moved into the sidenav in `side` mode as well.\n     * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or AutoFocusTarget\n     * instead.\n     */\n    get autoFocus(): AutoFocusTarget | string | boolean;\n    set autoFocus(value: AutoFocusTarget | string | BooleanInput);\n    private _autoFocus;\n    /**\n     * Whether the drawer is opened. We overload this because we trigger an event when it\n     * starts or end.\n     */\n    get opened(): boolean;\n    set opened(value: BooleanInput);\n    private _opened;\n    /** How the sidenav was opened (keypress, mouse click etc.) */\n    private _openedVia;\n    /** Emits whenever the drawer has started animating. */\n    readonly _animationStarted: Subject<AnimationEvent_2>;\n    /** Emits whenever the drawer is done animating. */\n    readonly _animationEnd: Subject<AnimationEvent_2>;\n    /** Current state of the sidenav animation. */\n    _animationState: 'open-instant' | 'open' | 'void';\n    /** Event emitted when the drawer open state is changed. */\n    readonly openedChange: EventEmitter<boolean>;\n    /** Event emitted when the drawer has been opened. */\n    readonly _openedStream: Observable<void>;\n    /** Event emitted when the drawer has started opening. */\n    readonly openedStart: Observable<void>;\n    /** Event emitted when the drawer has been closed. */\n    readonly _closedStream: Observable<void>;\n    /** Event emitted when the drawer has started closing. */\n    readonly closedStart: Observable<void>;\n    /** Emits when the component is destroyed. */\n    private readonly _destroyed;\n    /** Event emitted when the drawer's position changes. */\n    readonly onPositionChanged: EventEmitter<void>;\n    /** Reference to the inner element that contains all the content. */\n    _content: ElementRef<HTMLElement>;\n    /**\n     * An observable that emits when the drawer mode changes. This is used by the drawer container to\n     * to know when to when the mode changes so it can adapt the margins on the content.\n     */\n    readonly _modeChanged: Subject<void>;\n    constructor(_elementRef: ElementRef<HTMLElement>, _focusTrapFactory: FocusTrapFactory, _focusMonitor: FocusMonitor, _platform: Platform, _ngZone: NgZone, _interactivityChecker: InteractivityChecker, _doc: any, _container?: MatDrawerContainer | undefined);\n    /**\n     * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n     * attribute to forcefully focus it. The attribute is removed after focus is moved.\n     * @param element The element to focus.\n     */\n    private _forceFocus;\n    /**\n     * Focuses the first element that matches the given selector within the focus trap.\n     * @param selector The CSS selector for the element to set focus to.\n     */\n    private _focusByCssSelector;\n    /**\n     * Moves focus into the drawer. Note that this works even if\n     * the focus trap is disabled in `side` mode.\n     */\n    private _takeFocus;\n    /**\n     * Restores focus to the element that was originally focused when the drawer opened.\n     * If no element was focused at that time, the focus will be restored to the drawer.\n     */\n    private _restoreFocus;\n    /** Whether focus is currently within the drawer. */\n    private _isFocusWithinDrawer;\n    ngAfterViewInit(): void;\n    ngAfterContentChecked(): void;\n    ngOnDestroy(): void;\n    /**\n     * Open the drawer.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    open(openedVia?: FocusOrigin): Promise<MatDrawerToggleResult>;\n    /** Close the drawer. */\n    close(): Promise<MatDrawerToggleResult>;\n    /** Closes the drawer with context that the backdrop was clicked. */\n    _closeViaBackdropClick(): Promise<MatDrawerToggleResult>;\n    /**\n     * Toggle this drawer.\n     * @param isOpen Whether the drawer should be open.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    toggle(isOpen?: boolean, openedVia?: FocusOrigin): Promise<MatDrawerToggleResult>;\n    /**\n     * Toggles the opened state of the drawer.\n     * @param isOpen Whether the drawer should open or close.\n     * @param restoreFocus Whether focus should be restored on close.\n     * @param focusOrigin Origin to use when restoring focus.\n     */\n    private _setOpen;\n    _getWidth(): number;\n    /** Updates the enabled state of the focus trap. */\n    private _updateFocusTrapState;\n    /**\n     * Updates the position of the drawer in the DOM. We need to move the element around ourselves\n     * when it's in the `end` position so that it comes after the content and the visual order\n     * matches the tab order. We also need to be able to move it back to `start` if the sidenav\n     * started off as `end` and was changed to `start`.\n     */\n    private _updatePositionInParent;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDrawer, [null, null, null, null, null, null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDrawer, \"mat-drawer\", [\"matDrawer\"], { \"position\": \"position\"; \"mode\": \"mode\"; \"disableClose\": \"disableClose\"; \"autoFocus\": \"autoFocus\"; \"opened\": \"opened\"; }, { \"openedChange\": \"openedChange\"; \"_openedStream\": \"opened\"; \"openedStart\": \"openedStart\"; \"_closedStream\": \"closed\"; \"closedStart\": \"closedStart\"; \"onPositionChanged\": \"positionChanged\"; }, never, [\"*\"], false>;\n}\n\n/**\n * Animations used by the Material drawers.\n * @docs-private\n */\nexport declare const matDrawerAnimations: {\n    readonly transformDrawer: AnimationTriggerMetadata;\n};\n\n/**\n * `<mat-drawer-container>` component.\n *\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nexport declare class MatDrawerContainer implements AfterContentInit, DoCheck, OnDestroy {\n    private _dir;\n    private _element;\n    private _ngZone;\n    private _changeDetectorRef;\n    private _animationMode?;\n    /** All drawers in the container. Includes drawers from inside nested containers. */\n    _allDrawers: QueryList<MatDrawer>;\n    /** Drawers that belong to this container. */\n    _drawers: QueryList<MatDrawer>;\n    _content: MatDrawerContent;\n    _userContent: MatDrawerContent;\n    /** The drawer child with the `start` position. */\n    get start(): MatDrawer | null;\n    /** The drawer child with the `end` position. */\n    get end(): MatDrawer | null;\n    /**\n     * Whether to automatically resize the container whenever\n     * the size of any of its drawers changes.\n     *\n     * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n     * the drawers on every change detection cycle. Can be configured globally via the\n     * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n     */\n    get autosize(): boolean;\n    set autosize(value: BooleanInput);\n    private _autosize;\n    /**\n     * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n     * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n     * mode as well.\n     */\n    get hasBackdrop(): boolean;\n    set hasBackdrop(value: BooleanInput);\n    _backdropOverride: boolean | null;\n    /** Event emitted when the drawer backdrop is clicked. */\n    readonly backdropClick: EventEmitter<void>;\n    /** The drawer at the start/end position, independent of direction. */\n    private _start;\n    private _end;\n    /**\n     * The drawer at the left/right. When direction changes, these will change as well.\n     * They're used as aliases for the above to set the left/right style properly.\n     * In LTR, _left == _start and _right == _end.\n     * In RTL, _left == _end and _right == _start.\n     */\n    private _left;\n    private _right;\n    /** Emits when the component is destroyed. */\n    private readonly _destroyed;\n    /** Emits on every ngDoCheck. Used for debouncing reflows. */\n    private readonly _doCheckSubject;\n    /**\n     * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n     * drawer is open. We use margin rather than transform even for push mode because transform breaks\n     * fixed position elements inside of the transformed element.\n     */\n    _contentMargins: {\n        left: number | null;\n        right: number | null;\n    };\n    readonly _contentMarginChanges: Subject<{\n        left: number | null;\n        right: number | null;\n    }>;\n    /** Reference to the CdkScrollable instance that wraps the scrollable content. */\n    get scrollable(): CdkScrollable;\n    constructor(_dir: Directionality, _element: ElementRef<HTMLElement>, _ngZone: NgZone, _changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, defaultAutosize?: boolean, _animationMode?: string | undefined);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Calls `open` of both start and end drawers */\n    open(): void;\n    /** Calls `close` of both start and end drawers */\n    close(): void;\n    /**\n     * Recalculates and updates the inline styles for the content. Note that this should be used\n     * sparingly, because it causes a reflow.\n     */\n    updateContentMargins(): void;\n    ngDoCheck(): void;\n    /**\n     * Subscribes to drawer events in order to set a class on the main container element when the\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n     * is properly hidden.\n     */\n    private _watchDrawerToggle;\n    /**\n     * Subscribes to drawer onPositionChanged event in order to\n     * re-validate drawers when the position changes.\n     */\n    private _watchDrawerPosition;\n    /** Subscribes to changes in drawer mode so we can run change detection. */\n    private _watchDrawerMode;\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n    private _setContainerClass;\n    /** Validate the state of the drawer children components. */\n    private _validateDrawers;\n    /** Whether the container is being pushed to the side by one of the drawers. */\n    private _isPushed;\n    _onBackdropClicked(): void;\n    _closeModalDrawersViaBackdrop(): void;\n    _isShowingBackdrop(): boolean;\n    private _canHaveBackdrop;\n    private _isDrawerOpen;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDrawerContainer, [{ optional: true; }, null, null, null, null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDrawerContainer, \"mat-drawer-container\", [\"matDrawerContainer\"], { \"autosize\": \"autosize\"; \"hasBackdrop\": \"hasBackdrop\"; }, { \"backdropClick\": \"backdropClick\"; }, [\"_content\", \"_allDrawers\"], [\"mat-drawer\", \"mat-drawer-content\", \"*\"], false>;\n}\n\nexport declare class MatDrawerContent extends CdkScrollable implements AfterContentInit {\n    private _changeDetectorRef;\n    _container: MatDrawerContainer;\n    constructor(_changeDetectorRef: ChangeDetectorRef, _container: MatDrawerContainer, elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone);\n    ngAfterContentInit(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatDrawerContent, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatDrawerContent, \"mat-drawer-content\", never, {}, {}, never, [\"*\"], false>;\n}\n\n/** Drawer and SideNav display modes. */\nexport declare type MatDrawerMode = 'over' | 'push' | 'side';\n\n/** Result of the toggle promise that indicates the state of the drawer. */\nexport declare type MatDrawerToggleResult = 'open' | 'close';\n\nexport declare class MatSidenav extends MatDrawer {\n    /** Whether the sidenav is fixed in the viewport. */\n    get fixedInViewport(): boolean;\n    set fixedInViewport(value: BooleanInput);\n    private _fixedInViewport;\n    /**\n     * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n     * mode.\n     */\n    get fixedTopGap(): number;\n    set fixedTopGap(value: NumberInput);\n    private _fixedTopGap;\n    /**\n     * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n     * fixed mode.\n     */\n    get fixedBottomGap(): number;\n    set fixedBottomGap(value: NumberInput);\n    private _fixedBottomGap;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSidenav, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSidenav, \"mat-sidenav\", [\"matSidenav\"], { \"fixedInViewport\": \"fixedInViewport\"; \"fixedTopGap\": \"fixedTopGap\"; \"fixedBottomGap\": \"fixedBottomGap\"; }, {}, never, [\"*\"], false>;\n}\n\nexport declare class MatSidenavContainer extends MatDrawerContainer {\n    _allDrawers: QueryList<MatSidenav>;\n    _content: MatSidenavContent;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSidenavContainer, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSidenavContainer, \"mat-sidenav-container\", [\"matSidenavContainer\"], {}, {}, [\"_content\", \"_allDrawers\"], [\"mat-sidenav\", \"mat-sidenav-content\", \"*\"], false>;\n}\n\nexport declare class MatSidenavContent extends MatDrawerContent {\n    constructor(changeDetectorRef: ChangeDetectorRef, container: MatSidenavContainer, elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSidenavContent, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSidenavContent, \"mat-sidenav-content\", never, {}, {}, never, [\"*\"], false>;\n}\n\nexport declare class MatSidenavModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSidenavModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatSidenavModule, [typeof i1.MatDrawer, typeof i1.MatDrawerContainer, typeof i1.MatDrawerContent, typeof i2.MatSidenav, typeof i2.MatSidenavContainer, typeof i2.MatSidenavContent], [typeof i3.CommonModule, typeof i4.MatCommonModule, typeof i5.CdkScrollableModule], [typeof i5.CdkScrollableModule, typeof i4.MatCommonModule, typeof i1.MatDrawer, typeof i1.MatDrawerContainer, typeof i1.MatDrawerContent, typeof i2.MatSidenav, typeof i2.MatSidenavContainer, typeof i2.MatSidenavContent]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatSidenavModule>;\n}\n\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @docs-private\n */\nexport declare function throwMatDuplicatedDrawerError(position: string): void;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/sidenav/testing/index.d.ts",
      "node_modules/@angular/material/sidenav/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of `MatDrawerContainerHarness` instances. */\nexport declare interface DrawerContainerHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of `MatDrawerContentHarness` instances. */\nexport declare interface DrawerContentHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of `MatDrawerHarness` instances. */\nexport declare interface DrawerHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose side is the given value. */\n    position?: 'start' | 'end';\n}\n\n/** Harness for interacting with a standard mat-drawer-container in tests. */\nexport declare class MatDrawerContainerHarness extends ContentContainerComponentHarness<string> {\n    /** The selector for the host element of a `MatDrawerContainer` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatDrawerContainerHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which container instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DrawerContainerHarnessFilters): HarnessPredicate<MatDrawerContainerHarness>;\n    /**\n     * Gets drawers that match particular criteria within the container.\n     * @param filter Optionally filters which chips are included.\n     */\n    getDrawers(filter?: DrawerHarnessFilters): Promise<MatDrawerHarness[]>;\n    /** Gets the element that has the container's content. */\n    getContent(): Promise<MatDrawerContentHarness>;\n}\n\n/** Harness for interacting with a standard mat-drawer-content in tests. */\nexport declare class MatDrawerContentHarness extends ContentContainerComponentHarness<string> {\n    /** The selector for the host element of a `MatDrawerContent` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatDrawerContentHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which drawer content instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DrawerContentHarnessFilters): HarnessPredicate<MatDrawerContentHarness>;\n}\n\n/** Harness for interacting with a standard mat-drawer in tests. */\nexport declare class MatDrawerHarness extends MatDrawerHarnessBase {\n    /** The selector for the host element of a `MatDrawer` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatDrawerHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which drawer instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DrawerHarnessFilters): HarnessPredicate<MatDrawerHarness>;\n}\n\n/**\n * Base class for the drawer harness functionality.\n * @docs-private\n */\ndeclare class MatDrawerHarnessBase extends ContentContainerComponentHarness<string> {\n    /** Whether the drawer is open. */\n    isOpen(): Promise<boolean>;\n    /** Gets the position of the drawer inside its container. */\n    getPosition(): Promise<'start' | 'end'>;\n    /** Gets the mode that the drawer is in. */\n    getMode(): Promise<'over' | 'push' | 'side'>;\n}\n\n/** Harness for interacting with a standard mat-sidenav-container in tests. */\nexport declare class MatSidenavContainerHarness extends ContentContainerComponentHarness<string> {\n    /** The selector for the host element of a `MatSidenavContainer` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSidenavContainerHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which container instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DrawerContainerHarnessFilters): HarnessPredicate<MatSidenavContainerHarness>;\n    /**\n     * Gets sidenavs that match particular criteria within the container.\n     * @param filter Optionally filters which chips are included.\n     */\n    getSidenavs(filter?: DrawerHarnessFilters): Promise<MatSidenavHarness[]>;\n    /** Gets the element that has the container's content. */\n    getContent(): Promise<MatSidenavContentHarness>;\n}\n\n/** Harness for interacting with a standard mat-sidenav-content in tests. */\nexport declare class MatSidenavContentHarness extends ContentContainerComponentHarness<string> {\n    /** The selector for the host element of a `MatSidenavContent` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSidenavContentHarness` that\n     * meets certain criteria.\n     * @param options Options for filtering which sidenav content instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DrawerContentHarnessFilters): HarnessPredicate<MatSidenavContentHarness>;\n}\n\n/** Harness for interacting with a standard mat-sidenav in tests. */\nexport declare class MatSidenavHarness extends MatDrawerHarnessBase {\n    /** The selector for the host element of a `MatSidenav` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSidenavHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which sidenav instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: DrawerHarnessFilters): HarnessPredicate<MatSidenavHarness>;\n    /** Whether the sidenav is fixed in the viewport. */\n    isFixedInViewport(): Promise<boolean>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/slide-toggle/index.d.ts",
      "node_modules/@angular/material/slide-toggle/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { CheckboxRequiredValidator } from '@angular/forms';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/material/core';\nimport * as i4 from '@angular/cdk/observers';\nimport { InjectionToken } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { Provider } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\nimport { Type } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR,\n        MatSlideToggleRequiredValidator\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MAT_SLIDE_TOGGLE_VALUE_ACCESSOR,\n        MatSlideToggleChange,\n        _MatSlideToggleBase,\n        MatSlideToggle\n    }\n}\n\n/** Injection token to be used to override the default options for `mat-slide-toggle`. */\nexport declare const MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS: InjectionToken<MatSlideToggleDefaultOptions>;\n\nexport declare const MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR: Provider;\n\n/** @docs-private */\nexport declare const MAT_SLIDE_TOGGLE_VALUE_ACCESSOR: {\n    provide: InjectionToken<readonly ControlValueAccessor[]>;\n    useExisting: Type<any>;\n    multi: boolean;\n};\n\n/** Represents a slidable \"switch\" toggle that can be moved between on and off. */\nexport declare class MatSlideToggle extends _MatSlideToggleBase<MatSlideToggleChange> {\n    /** Reference to the underlying input element. */\n    _inputElement: ElementRef<HTMLInputElement>;\n    constructor(elementRef: ElementRef, focusMonitor: FocusMonitor, changeDetectorRef: ChangeDetectorRef, tabIndex: string, defaults: MatSlideToggleDefaultOptions, animationMode?: string);\n    protected _createChangeEvent(isChecked: boolean): MatSlideToggleChange;\n    /** Method being called whenever the underlying input emits a change event. */\n    _onChangeEvent(event: Event): void;\n    /** Method being called whenever the slide-toggle has been clicked. */\n    _onInputClick(event: Event): void;\n    /** Focuses the slide-toggle. */\n    focus(options?: FocusOptions, origin?: FocusOrigin): void;\n    /** Method being called whenever the label text changes. */\n    _onLabelTextChange(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSlideToggle, [null, null, null, { attribute: \"tabindex\"; }, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSlideToggle, \"mat-slide-toggle\", [\"matSlideToggle\"], { \"disabled\": \"disabled\"; \"disableRipple\": \"disableRipple\"; \"color\": \"color\"; \"tabIndex\": \"tabIndex\"; }, {}, never, [\"*\"], false>;\n}\n\nexport declare abstract class _MatSlideToggleBase<T> extends _MatSlideToggleMixinBase implements OnDestroy, AfterContentInit, ControlValueAccessor, CanDisable, CanColor, HasTabIndex, CanDisableRipple {\n    protected _focusMonitor: FocusMonitor;\n    protected _changeDetectorRef: ChangeDetectorRef;\n    defaults: MatSlideToggleDefaultOptions;\n    protected _onChange: (_: any) => void;\n    private _onTouched;\n    protected _uniqueId: string;\n    private _required;\n    private _checked;\n    protected abstract _createChangeEvent(isChecked: boolean): T;\n    abstract focus(options?: FocusOptions, origin?: FocusOrigin): void;\n    /** Whether noop animations are enabled. */\n    _noopAnimations: boolean;\n    /** Whether the slide toggle is currently focused. */\n    _focused: boolean;\n    /** Name value will be applied to the input element if present. */\n    name: string | null;\n    /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */\n    id: string;\n    /** Whether the label should appear after or before the slide-toggle. Defaults to 'after'. */\n    labelPosition: 'before' | 'after';\n    /** Used to set the aria-label attribute on the underlying input element. */\n    ariaLabel: string | null;\n    /** Used to set the aria-labelledby attribute on the underlying input element. */\n    ariaLabelledby: string | null;\n    /** Used to set the aria-describedby attribute on the underlying input element. */\n    ariaDescribedby: string;\n    /** Whether the slide-toggle is required. */\n    get required(): boolean;\n    set required(value: BooleanInput);\n    /** Whether the slide-toggle element is checked or not. */\n    get checked(): boolean;\n    set checked(value: BooleanInput);\n    /** An event will be dispatched each time the slide-toggle changes its value. */\n    readonly change: EventEmitter<T>;\n    /**\n     * An event will be dispatched each time the slide-toggle input is toggled.\n     * This event is always emitted when the user toggles the slide toggle, but this does not mean\n     * the slide toggle's value has changed.\n     */\n    readonly toggleChange: EventEmitter<void>;\n    /** Returns the unique id for the visual hidden input. */\n    get inputId(): string;\n    constructor(elementRef: ElementRef, _focusMonitor: FocusMonitor, _changeDetectorRef: ChangeDetectorRef, tabIndex: string, defaults: MatSlideToggleDefaultOptions, animationMode: string | undefined, idPrefix: string);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Implemented as part of ControlValueAccessor. */\n    writeValue(value: any): void;\n    /** Implemented as part of ControlValueAccessor. */\n    registerOnChange(fn: any): void;\n    /** Implemented as part of ControlValueAccessor. */\n    registerOnTouched(fn: any): void;\n    /** Implemented as a part of ControlValueAccessor. */\n    setDisabledState(isDisabled: boolean): void;\n    /** Toggles the checked state of the slide-toggle. */\n    toggle(): void;\n    /**\n     * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n     */\n    protected _emitChangeEvent(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatSlideToggleBase<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatSlideToggleBase<any>, never, never, { \"name\": \"name\"; \"id\": \"id\"; \"labelPosition\": \"labelPosition\"; \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"ariaDescribedby\": \"aria-describedby\"; \"required\": \"required\"; \"checked\": \"checked\"; }, { \"change\": \"change\"; \"toggleChange\": \"toggleChange\"; }, never, never, false>;\n}\n\n/** Change event object emitted by a MatSlideToggle. */\nexport declare class MatSlideToggleChange {\n    /** The source MatSlideToggle of the event. */\n    source: MatSlideToggle;\n    /** The new `checked` value of the MatSlideToggle. */\n    checked: boolean;\n    constructor(\n    /** The source MatSlideToggle of the event. */\n    source: MatSlideToggle, \n    /** The new `checked` value of the MatSlideToggle. */\n    checked: boolean);\n}\n\n/** Default `mat-slide-toggle` options that can be overridden. */\nexport declare interface MatSlideToggleDefaultOptions {\n    /** Whether toggle action triggers value changes in slide toggle. */\n    disableToggleValue?: boolean;\n    /** Default color for slide toggles. */\n    color?: ThemePalette;\n}\n\n/** @docs-private */\ndeclare const _MatSlideToggleMixinBase: _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & _Constructor<CanColor> & _AbstractConstructor<CanColor> & _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\nexport declare class MatSlideToggleModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSlideToggleModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatSlideToggleModule, [typeof i2.MatSlideToggle], [typeof _MatSlideToggleRequiredValidatorModule, typeof i3.MatRippleModule, typeof i3.MatCommonModule, typeof i4.ObserversModule], [typeof _MatSlideToggleRequiredValidatorModule, typeof i2.MatSlideToggle, typeof i3.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatSlideToggleModule>;\n}\n\n/**\n * Validator for Material slide-toggle components with the required attribute in a\n * template-driven form. The default validator for required form controls asserts\n * that the control value is not undefined but that is not appropriate for a slide-toggle\n * where the value is always defined.\n *\n * Required slide-toggle form controls are valid when checked.\n */\nexport declare class MatSlideToggleRequiredValidator extends CheckboxRequiredValidator {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSlideToggleRequiredValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatSlideToggleRequiredValidator, \"mat-slide-toggle[required][formControlName],             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]\", never, {}, {}, never, never, false>;\n}\n\n/** This module is used by both original and MDC-based slide-toggle implementations. */\nexport declare class _MatSlideToggleRequiredValidatorModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatSlideToggleRequiredValidatorModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<_MatSlideToggleRequiredValidatorModule, [typeof i1.MatSlideToggleRequiredValidator], never, [typeof i1.MatSlideToggleRequiredValidator]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<_MatSlideToggleRequiredValidatorModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/slide-toggle/testing/index.d.ts",
      "node_modules/@angular/material/slide-toggle/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-slide-toggle in tests. */\nexport declare class MatSlideToggleHarness extends _MatSlideToggleHarnessBase {\n    private _inputContainer;\n    protected _nativeElement: AsyncFactoryFn<TestElement>;\n    /** The selector for the host element of a `MatSlideToggle` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSlideToggleHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which slide toggle instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: SlideToggleHarnessFilters): HarnessPredicate<MatSlideToggleHarness>;\n    /** Toggle the checked state of the slide-toggle. */\n    toggle(): Promise<void>;\n    /** Whether the slide-toggle is checked. */\n    isChecked(): Promise<boolean>;\n}\n\nexport declare abstract class _MatSlideToggleHarnessBase extends ComponentHarness {\n    private _label;\n    protected abstract _nativeElement: AsyncFactoryFn<TestElement>;\n    /** Toggle the checked state of the slide-toggle. */\n    abstract toggle(): Promise<void>;\n    /** Whether the slide-toggle is checked. */\n    abstract isChecked(): Promise<boolean>;\n    /** Whether the slide-toggle is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Whether the slide-toggle is required. */\n    isRequired(): Promise<boolean>;\n    /** Whether the slide-toggle is valid. */\n    isValid(): Promise<boolean>;\n    /** Gets the slide-toggle's name. */\n    getName(): Promise<string | null>;\n    /** Gets the slide-toggle's aria-label. */\n    getAriaLabel(): Promise<string | null>;\n    /** Gets the slide-toggle's aria-labelledby. */\n    getAriaLabelledby(): Promise<string | null>;\n    /** Gets the slide-toggle's label text. */\n    getLabelText(): Promise<string>;\n    /** Focuses the slide-toggle. */\n    focus(): Promise<void>;\n    /** Blurs the slide-toggle. */\n    blur(): Promise<void>;\n    /** Whether the slide-toggle is focused. */\n    isFocused(): Promise<boolean>;\n    /**\n     * Puts the slide-toggle in a checked state by toggling it if it is currently unchecked, or doing\n     * nothing if it is already checked.\n     */\n    check(): Promise<void>;\n    /**\n     * Puts the slide-toggle in an unchecked state by toggling it if it is currently checked, or doing\n     * nothing if it is already unchecked.\n     */\n    uncheck(): Promise<void>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatSlideToggleHarness` instances. */\nexport declare interface SlideToggleHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose label matches the given value. */\n    label?: string | RegExp;\n    /** Only find instances whose name is the given value. */\n    name?: string;\n    /** Only find instances with the given checked value. */\n    checked?: boolean;\n    /** Only find instances where the disabled state matches the given value. */\n    disabled?: boolean;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/slider/index.d.ts",
      "node_modules/@angular/material/slider/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { CanDisable } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/common';\nimport * as i3 from '@angular/material/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { OnDestroy } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        MAT_SLIDER_VALUE_ACCESSOR,\n        MatSliderChange,\n        MatSlider\n    }\n}\n\n/**\n * Provider Expression that allows mat-slider to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)] and [formControl].\n * @docs-private\n */\nexport declare const MAT_SLIDER_VALUE_ACCESSOR: any;\n\n/**\n * Allows users to select from a range of values by moving the slider thumb. It is similar in\n * behavior to the native `<input type=\"range\">` element.\n */\nexport declare class MatSlider extends _MatSliderBase implements ControlValueAccessor, OnDestroy, CanDisable, CanColor, AfterViewInit, HasTabIndex {\n    private _focusMonitor;\n    private _changeDetectorRef;\n    private _dir;\n    private _ngZone;\n    _animationMode?: string | undefined;\n    /** Whether the slider is inverted. */\n    get invert(): boolean;\n    set invert(value: BooleanInput);\n    private _invert;\n    /** The maximum value that the slider can have. */\n    get max(): number;\n    set max(v: NumberInput);\n    private _max;\n    /** The minimum value that the slider can have. */\n    get min(): number;\n    set min(v: NumberInput);\n    private _min;\n    /** The values at which the thumb will snap. */\n    get step(): number;\n    set step(v: NumberInput);\n    private _step;\n    /** Whether or not to show the thumb label. */\n    get thumbLabel(): boolean;\n    set thumbLabel(value: BooleanInput);\n    private _thumbLabel;\n    /**\n     * How often to show ticks. Relative to the step so that a tick always appears on a step.\n     * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).\n     */\n    get tickInterval(): 'auto' | number;\n    set tickInterval(value: 'auto' | NumberInput);\n    private _tickInterval;\n    /** Value of the slider. */\n    get value(): number;\n    set value(v: NumberInput);\n    private _value;\n    /**\n     * Function that will be used to format the value before it is displayed\n     * in the thumb label. Can be used to format very large number in order\n     * for them to fit into the slider thumb.\n     */\n    displayWith: (value: number) => string | number;\n    /** Text corresponding to the slider's value. Used primarily for improved accessibility. */\n    valueText: string;\n    /** Whether the slider is vertical. */\n    get vertical(): boolean;\n    set vertical(value: BooleanInput);\n    private _vertical;\n    /** Event emitted when the slider value has changed. */\n    readonly change: EventEmitter<MatSliderChange>;\n    /** Event emitted when the slider thumb moves. */\n    readonly input: EventEmitter<MatSliderChange>;\n    /**\n     * Emits when the raw value of the slider changes. This is here primarily\n     * to facilitate the two-way binding for the `value` input.\n     * @docs-private\n     */\n    readonly valueChange: EventEmitter<number | null>;\n    /** The value to be used for display purposes. */\n    get displayValue(): string | number;\n    /** set focus to the host element */\n    focus(options?: FocusOptions): void;\n    /** blur the host element */\n    blur(): void;\n    /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\n    onTouched: () => any;\n    /** The percentage of the slider that coincides with the value. */\n    get percent(): number;\n    private _percent;\n    /**\n     * Whether or not the thumb is sliding and what the user is using to slide it with.\n     * Used to determine if there should be a transition for the thumb and fill track.\n     */\n    _isSliding: 'keyboard' | 'pointer' | null;\n    /**\n     * Whether or not the slider is active (clicked or sliding).\n     * Used to shrink and grow the thumb as according to the Material Design spec.\n     */\n    _isActive: boolean;\n    /**\n     * Whether the axis of the slider is inverted.\n     * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).\n     */\n    _shouldInvertAxis(): boolean;\n    /** Whether the slider is at its minimum value. */\n    _isMinValue(): boolean;\n    /**\n     * The amount of space to leave between the slider thumb and the track fill & track background\n     * elements.\n     */\n    _getThumbGap(): 7 | 10 | 0;\n    /** CSS styles for the track background element. */\n    _getTrackBackgroundStyles(): {\n        [key: string]: string;\n    };\n    /** CSS styles for the track fill element. */\n    _getTrackFillStyles(): {\n        [key: string]: string;\n    };\n    /** CSS styles for the ticks container element. */\n    _getTicksContainerStyles(): {\n        [key: string]: string;\n    };\n    /** CSS styles for the ticks element. */\n    _getTicksStyles(): {\n        [key: string]: string;\n    };\n    _getThumbContainerStyles(): {\n        [key: string]: string;\n    };\n    /** The size of a tick interval as a percentage of the size of the track. */\n    private _tickIntervalPercent;\n    /** The dimensions of the slider. */\n    private _sliderDimensions;\n    private _controlValueAccessorChangeFn;\n    /** Decimal places to round to, based on the step amount. */\n    private _roundToDecimal;\n    /** Subscription to the Directionality change EventEmitter. */\n    private _dirChangeSubscription;\n    /** The value of the slider when the slide start event fires. */\n    private _valueOnSlideStart;\n    /** Reference to the inner slider wrapper element. */\n    private _sliderWrapper;\n    /**\n     * Whether mouse events should be converted to a slider position by calculating their distance\n     * from the right or bottom edge of the slider as opposed to the top or left.\n     */\n    _shouldInvertMouseCoords(): boolean;\n    /** The language direction for this slider element. */\n    private _getDirection;\n    /** Keeps track of the last pointer event that was captured by the slider. */\n    private _lastPointerEvent;\n    /** Used to subscribe to global move and end events */\n    protected _document: Document;\n    /**\n     * Identifier used to attribute a touch event to a particular slider.\n     * Will be undefined if one of the following conditions is true:\n     * - The user isn't dragging using a touch device.\n     * - The browser doesn't support `Touch.identifier`.\n     * - Dragging hasn't started yet.\n     */\n    private _touchId;\n    constructor(elementRef: ElementRef, _focusMonitor: FocusMonitor, _changeDetectorRef: ChangeDetectorRef, _dir: Directionality, tabIndex: string, _ngZone: NgZone, _document: any, _animationMode?: string | undefined);\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    _onMouseenter(): void;\n    _onFocus(): void;\n    _onBlur(): void;\n    _onKeydown(event: KeyboardEvent): void;\n    _onKeyup(): void;\n    /** Called when the user has put their pointer down on the slider. */\n    private _pointerDown;\n    /**\n     * Called when the user has moved their pointer after\n     * starting to drag. Bound on the document level.\n     */\n    private _pointerMove;\n    /** Called when the user has lifted their pointer. Bound on the document level. */\n    private _pointerUp;\n    /** Called when the window has lost focus. */\n    private _windowBlur;\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    private _getWindow;\n    /**\n     * Binds our global move and end events. They're bound at the document level and only while\n     * dragging so that the user doesn't have to keep their pointer exactly over the slider\n     * as they're swiping across the screen.\n     */\n    private _bindGlobalEvents;\n    /** Removes any global event listeners that we may have added. */\n    private _removeGlobalEvents;\n    /** Increments the slider by the given number of steps (negative number decrements). */\n    private _increment;\n    /** Calculate the new value from the new physical location. The value will always be snapped. */\n    private _updateValueFromPosition;\n    /** Emits a change event if the current value is different from the last emitted value. */\n    private _emitChangeEvent;\n    /** Emits an input event when the current value is different from the last emitted value. */\n    private _emitInputEvent;\n    /** Updates the amount of space between ticks as a percentage of the width of the slider. */\n    private _updateTickIntervalPercent;\n    /** Creates a slider change object from the specified value. */\n    private _createChangeEvent;\n    /** Calculates the percentage of the slider that a value is. */\n    private _calculatePercentage;\n    /** Calculates the value a percentage of the slider corresponds to. */\n    private _calculateValue;\n    /** Return a number between two numbers. */\n    private _clamp;\n    /**\n     * Get the bounding client rect of the slider track element.\n     * The track is used rather than the native element to ignore the extra space that the thumb can\n     * take up.\n     */\n    private _getSliderDimensions;\n    /**\n     * Focuses the native element.\n     * Currently only used to allow a blur event to fire but will be used with keyboard input later.\n     */\n    private _focusHostElement;\n    /** Blurs the native element. */\n    private _blurHostElement;\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param value\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a callback to be triggered when the value has changed.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    registerOnChange(fn: (value: any) => void): void;\n    /**\n     * Registers a callback to be triggered when the component is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    registerOnTouched(fn: any): void;\n    /**\n     * Sets whether the component should be disabled.\n     * Implemented as part of ControlValueAccessor.\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled: boolean): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSlider, [null, null, null, { optional: true; }, { attribute: \"tabindex\"; }, null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSlider, \"mat-slider\", [\"matSlider\"], { \"disabled\": \"disabled\"; \"color\": \"color\"; \"tabIndex\": \"tabIndex\"; \"invert\": \"invert\"; \"max\": \"max\"; \"min\": \"min\"; \"step\": \"step\"; \"thumbLabel\": \"thumbLabel\"; \"tickInterval\": \"tickInterval\"; \"value\": \"value\"; \"displayWith\": \"displayWith\"; \"valueText\": \"valueText\"; \"vertical\": \"vertical\"; }, { \"change\": \"change\"; \"input\": \"input\"; \"valueChange\": \"valueChange\"; }, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatSliderBase: _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & _Constructor<CanColor> & _AbstractConstructor<CanColor> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\n/** A simple change event emitted by the MatSlider component. */\nexport declare class MatSliderChange {\n    /** The MatSlider that changed. */\n    source: MatSlider;\n    /** The new value of the source slider. */\n    value: number | null;\n}\n\nexport declare class MatSliderModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSliderModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatSliderModule, [typeof i1.MatSlider], [typeof i2.CommonModule, typeof i3.MatCommonModule], [typeof i1.MatSlider, typeof i3.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatSliderModule>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/slider/testing/index.d.ts",
      "node_modules/@angular/material/slider/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-slider in tests. */\nexport declare class MatSliderHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatSlider` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSliderHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which slider instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: SliderHarnessFilters): HarnessPredicate<MatSliderHarness>;\n    private _textLabel;\n    private _wrapper;\n    /** Gets the slider's id. */\n    getId(): Promise<string | null>;\n    /**\n     * Gets the current display value of the slider. Returns a null promise if the thumb label is\n     * disabled.\n     */\n    getDisplayValue(): Promise<string | null>;\n    /** Gets the current percentage value of the slider. */\n    getPercentage(): Promise<number>;\n    /** Gets the current value of the slider. */\n    getValue(): Promise<number>;\n    /** Gets the maximum value of the slider. */\n    getMaxValue(): Promise<number>;\n    /** Gets the minimum value of the slider. */\n    getMinValue(): Promise<number>;\n    /** Whether the slider is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets the orientation of the slider. */\n    getOrientation(): Promise<'horizontal' | 'vertical'>;\n    /**\n     * Sets the value of the slider by clicking on the slider track.\n     *\n     * Note that in rare cases the value cannot be set to the exact specified value. This\n     * can happen if not every value of the slider maps to a single pixel that could be\n     * clicked using mouse interaction. In such cases consider using the keyboard to\n     * select the given value or expand the slider's size for a better user experience.\n     */\n    setValue(value: number): Promise<void>;\n    /** Focuses the slider. */\n    focus(): Promise<void>;\n    /** Blurs the slider. */\n    blur(): Promise<void>;\n    /** Whether the slider is focused. */\n    isFocused(): Promise<boolean>;\n    /** Calculates the percentage of the given value. */\n    private _calculatePercentage;\n}\n\n/** A set of criteria that can be used to filter a list of `MatSliderHarness` instances. */\nexport declare interface SliderHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/snack-bar/index.d.ts",
      "node_modules/@angular/material/snack-bar/index.d.ts"
    ],
    "content": "import { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { AriaLivePoliteness } from '@angular/cdk/a11y';\nimport { BasePortalOutlet } from '@angular/cdk/portal';\nimport { BreakpointObserver } from '@angular/cdk/layout';\nimport { CdkPortalOutlet } from '@angular/cdk/portal';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ComponentRef } from '@angular/core';\nimport { ComponentType } from '@angular/cdk/portal';\nimport { Direction } from '@angular/cdk/bidi';\nimport { DomPortal } from '@angular/cdk/portal';\nimport { ElementRef } from '@angular/core';\nimport { EmbeddedViewRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/cdk/overlay';\nimport * as i4 from '@angular/cdk/portal';\nimport * as i5 from '@angular/common';\nimport * as i6 from '@angular/material/button';\nimport * as i7 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { LiveAnnouncer } from '@angular/cdk/a11y';\nimport { NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        _MatSnackBarContainerBase,\n        MatSnackBarContainer\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        TextOnlySnackBar,\n        SimpleSnackBar\n    }\n}\n\n/** Injection token that can be used to access the data that was passed in to a snack bar. */\nexport declare const MAT_SNACK_BAR_DATA: InjectionToken<any>;\n\n/** Injection token that can be used to specify default snack bar. */\nexport declare const MAT_SNACK_BAR_DEFAULT_OPTIONS: InjectionToken<MatSnackBarConfig<any>>;\n\n/** @docs-private */\nexport declare function MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY(): MatSnackBarConfig;\n\n/**\n * Service to dispatch Material Design snack bar messages.\n */\nexport declare class MatSnackBar extends _MatSnackBarBase {\n    protected simpleSnackBarComponent: typeof SimpleSnackBar;\n    protected snackBarContainerComponent: typeof MatSnackBarContainer;\n    protected handsetCssClass: string;\n    constructor(overlay: Overlay, live: LiveAnnouncer, injector: Injector, breakpointObserver: BreakpointObserver, parentSnackBar: MatSnackBar, defaultConfig: MatSnackBarConfig);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSnackBar, [null, null, null, null, { optional: true; skipSelf: true; }, null]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatSnackBar>;\n}\n\n/**\n * Animations used by the Material snack bar.\n * @docs-private\n */\nexport declare const matSnackBarAnimations: {\n    readonly snackBarState: AnimationTriggerMetadata;\n};\n\nexport declare abstract class _MatSnackBarBase implements OnDestroy {\n    private _overlay;\n    private _live;\n    private _injector;\n    private _breakpointObserver;\n    private _parentSnackBar;\n    private _defaultConfig;\n    /**\n     * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).\n     * If there is a parent snack-bar service, all operations should delegate to that parent\n     * via `_openedSnackBarRef`.\n     */\n    private _snackBarRefAtThisLevel;\n    /** The component that should be rendered as the snack bar's simple component. */\n    protected abstract simpleSnackBarComponent: Type<TextOnlySnackBar>;\n    /** The container component that attaches the provided template or component. */\n    protected abstract snackBarContainerComponent: Type<_MatSnackBarContainerBase>;\n    /** The CSS class to apply for handset mode. */\n    protected abstract handsetCssClass: string;\n    /** Reference to the currently opened snackbar at *any* level. */\n    get _openedSnackBarRef(): MatSnackBarRef<any> | null;\n    set _openedSnackBarRef(value: MatSnackBarRef<any> | null);\n    constructor(_overlay: Overlay, _live: LiveAnnouncer, _injector: Injector, _breakpointObserver: BreakpointObserver, _parentSnackBar: _MatSnackBarBase, _defaultConfig: MatSnackBarConfig);\n    /**\n     * Creates and dispatches a snack bar with a custom component for the content, removing any\n     * currently opened snack bars.\n     *\n     * @param component Component to be instantiated.\n     * @param config Extra configuration for the snack bar.\n     */\n    openFromComponent<T, D = any>(component: ComponentType<T>, config?: MatSnackBarConfig<D>): MatSnackBarRef<T>;\n    /**\n     * Creates and dispatches a snack bar with a custom template for the content, removing any\n     * currently opened snack bars.\n     *\n     * @param template Template to be instantiated.\n     * @param config Extra configuration for the snack bar.\n     */\n    openFromTemplate(template: TemplateRef<any>, config?: MatSnackBarConfig): MatSnackBarRef<EmbeddedViewRef<any>>;\n    /**\n     * Opens a snackbar with a message and an optional action.\n     * @param message The message to show in the snackbar.\n     * @param action The label for the snackbar action.\n     * @param config Additional configuration options for the snackbar.\n     */\n    open(message: string, action?: string, config?: MatSnackBarConfig): MatSnackBarRef<TextOnlySnackBar>;\n    /**\n     * Dismisses the currently-visible snack bar.\n     */\n    dismiss(): void;\n    ngOnDestroy(): void;\n    /**\n     * Attaches the snack bar container component to the overlay.\n     */\n    private _attachSnackBarContainer;\n    /**\n     * Places a new component or a template as the content of the snack bar container.\n     */\n    private _attach;\n    /** Animates the old snack bar out and the new one in. */\n    private _animateSnackBar;\n    /**\n     * Creates a new overlay and places it in the correct location.\n     * @param config The user-specified snack bar config.\n     */\n    private _createOverlay;\n    /**\n     * Creates an injector to be used inside of a snack bar component.\n     * @param config Config that was used to create the snack bar.\n     * @param snackBarRef Reference to the snack bar.\n     */\n    private _createInjector;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatSnackBarBase, [null, null, null, null, { optional: true; skipSelf: true; }, null]>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<_MatSnackBarBase>;\n}\n\n/**\n * Configuration used when opening a snack-bar.\n */\nexport declare class MatSnackBarConfig<D = any> {\n    /** The politeness level for the MatAriaLiveAnnouncer announcement. */\n    politeness?: AriaLivePoliteness;\n    /**\n     * Message to be announced by the LiveAnnouncer. When opening a snackbar without a custom\n     * component or template, the announcement message will default to the specified message.\n     */\n    announcementMessage?: string;\n    /**\n     * The view container that serves as the parent for the snackbar for the purposes of dependency\n     * injection. Note: this does not affect where the snackbar is inserted in the DOM.\n     */\n    viewContainerRef?: ViewContainerRef;\n    /** The length of time in milliseconds to wait before automatically dismissing the snack bar. */\n    duration?: number;\n    /** Extra CSS classes to be added to the snack bar container. */\n    panelClass?: string | string[];\n    /** Text layout direction for the snack bar. */\n    direction?: Direction;\n    /** Data being injected into the child component. */\n    data?: D | null;\n    /** The horizontal position to place the snack bar. */\n    horizontalPosition?: MatSnackBarHorizontalPosition;\n    /** The vertical position to place the snack bar. */\n    verticalPosition?: MatSnackBarVerticalPosition;\n}\n\n/**\n * Internal component that wraps user-provided snack bar content.\n * @docs-private\n */\nexport declare class MatSnackBarContainer extends _MatSnackBarContainerBase {\n    protected _afterPortalAttached(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSnackBarContainer, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSnackBarContainer, \"snack-bar-container\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Base class for snack bar containers.\n * @docs-private\n */\nexport declare abstract class _MatSnackBarContainerBase extends BasePortalOutlet implements OnDestroy {\n    private _ngZone;\n    protected _elementRef: ElementRef<HTMLElement>;\n    private _changeDetectorRef;\n    private _platform;\n    /** The snack bar configuration. */\n    snackBarConfig: MatSnackBarConfig;\n    /** The number of milliseconds to wait before announcing the snack bar's content. */\n    private readonly _announceDelay;\n    /** The timeout for announcing the snack bar's content. */\n    private _announceTimeoutId;\n    /** Whether the component has been destroyed. */\n    private _destroyed;\n    /** The portal outlet inside of this container into which the snack bar content will be loaded. */\n    _portalOutlet: CdkPortalOutlet;\n    /** Subject for notifying that the snack bar has announced to screen readers. */\n    readonly _onAnnounce: Subject<void>;\n    /** Subject for notifying that the snack bar has exited from view. */\n    readonly _onExit: Subject<void>;\n    /** Subject for notifying that the snack bar has finished entering the view. */\n    readonly _onEnter: Subject<void>;\n    /** The state of the snack bar animations. */\n    _animationState: string;\n    /** aria-live value for the live region. */\n    _live: AriaLivePoliteness;\n    /**\n     * Role of the live region. This is only for Firefox as there is a known issue where Firefox +\n     * JAWS does not read out aria-live message.\n     */\n    _role?: 'status' | 'alert';\n    constructor(_ngZone: NgZone, _elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, _platform: Platform, \n    /** The snack bar configuration. */\n    snackBarConfig: MatSnackBarConfig);\n    /** Attach a component portal as content to this snack bar container. */\n    attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n    /** Attach a template portal as content to this snack bar container. */\n    attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n    /**\n     * Attaches a DOM portal to the snack bar container.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    attachDomPortal: (portal: DomPortal) => void;\n    /** Handle end of animations, updating the state of the snackbar. */\n    onAnimationEnd(event: AnimationEvent_2): void;\n    /** Begin animation of snack bar entrance into view. */\n    enter(): void;\n    /** Begin animation of the snack bar exiting from view. */\n    exit(): Observable<void>;\n    /** Makes sure the exit callbacks have been invoked when the element is destroyed. */\n    ngOnDestroy(): void;\n    /**\n     * Waits for the zone to settle before removing the element. Helps prevent\n     * errors where we end up removing an element which is in the middle of an animation.\n     */\n    private _completeExit;\n    /**\n     * Called after the portal contents have been attached. Can be\n     * used to modify the DOM once it's guaranteed to be in place.\n     */\n    protected _afterPortalAttached(): void;\n    /** Asserts that no content is already attached to the container. */\n    private _assertNotAttached;\n    /**\n     * Starts a timeout to move the snack bar content to the live region so screen readers will\n     * announce it.\n     */\n    private _screenReaderAnnounce;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatSnackBarContainerBase, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatSnackBarContainerBase, never, never, {}, {}, never, never, false>;\n}\n\n/** Event that is emitted when a snack bar is dismissed. */\nexport declare interface MatSnackBarDismiss {\n    /** Whether the snack bar was dismissed using the action button. */\n    dismissedByAction: boolean;\n}\n\n/** Possible values for horizontalPosition on MatSnackBarConfig. */\nexport declare type MatSnackBarHorizontalPosition = 'start' | 'center' | 'end' | 'left' | 'right';\n\nexport declare class MatSnackBarModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSnackBarModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatSnackBarModule, [typeof i1.MatSnackBarContainer, typeof i2.SimpleSnackBar], [typeof i3.OverlayModule, typeof i4.PortalModule, typeof i5.CommonModule, typeof i6.MatButtonModule, typeof i7.MatCommonModule], [typeof i1.MatSnackBarContainer, typeof i7.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatSnackBarModule>;\n}\n\n/**\n * Reference to a snack bar dispatched from the snack bar service.\n */\nexport declare class MatSnackBarRef<T> {\n    private _overlayRef;\n    /** The instance of the component making up the content of the snack bar. */\n    instance: T;\n    /**\n     * The instance of the component making up the content of the snack bar.\n     * @docs-private\n     */\n    containerInstance: _MatSnackBarContainerBase;\n    /** Subject for notifying the user that the snack bar has been dismissed. */\n    private readonly _afterDismissed;\n    /** Subject for notifying the user that the snack bar has opened and appeared. */\n    private readonly _afterOpened;\n    /** Subject for notifying the user that the snack bar action was called. */\n    private readonly _onAction;\n    /**\n     * Timeout ID for the duration setTimeout call. Used to clear the timeout if the snackbar is\n     * dismissed before the duration passes.\n     */\n    private _durationTimeoutId;\n    /** Whether the snack bar was dismissed using the action button. */\n    private _dismissedByAction;\n    constructor(containerInstance: _MatSnackBarContainerBase, _overlayRef: OverlayRef);\n    /** Dismisses the snack bar. */\n    dismiss(): void;\n    /** Marks the snackbar action clicked. */\n    dismissWithAction(): void;\n    /**\n     * Marks the snackbar action clicked.\n     * @deprecated Use `dismissWithAction` instead.\n     * @breaking-change 8.0.0\n     */\n    closeWithAction(): void;\n    /** Dismisses the snack bar after some duration */\n    _dismissAfter(duration: number): void;\n    /** Marks the snackbar as opened */\n    _open(): void;\n    /** Cleans up the DOM after closing. */\n    private _finishDismiss;\n    /** Gets an observable that is notified when the snack bar is finished closing. */\n    afterDismissed(): Observable<MatSnackBarDismiss>;\n    /** Gets an observable that is notified when the snack bar has opened and appeared. */\n    afterOpened(): Observable<void>;\n    /** Gets an observable that is notified when the snack bar action is called. */\n    onAction(): Observable<void>;\n}\n\n/** Possible values for verticalPosition on MatSnackBarConfig. */\nexport declare type MatSnackBarVerticalPosition = 'top' | 'bottom';\n\n/**\n * A component used to open as the default snack bar, matching material spec.\n * This should only be used internally by the snack bar service.\n */\nexport declare class SimpleSnackBar implements TextOnlySnackBar {\n    snackBarRef: MatSnackBarRef<SimpleSnackBar>;\n    /** Data that was injected into the snack bar. */\n    data: {\n        message: string;\n        action: string;\n    };\n    constructor(snackBarRef: MatSnackBarRef<SimpleSnackBar>, data: any);\n    /** Performs the action on the snack bar. */\n    action(): void;\n    /** If the action button should be shown. */\n    get hasAction(): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<SimpleSnackBar, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<SimpleSnackBar, \"simple-snack-bar\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Interface for a simple snack bar component that has a message and a single action.\n */\nexport declare interface TextOnlySnackBar {\n    data: {\n        message: string;\n        action: string;\n    };\n    snackBarRef: MatSnackBarRef<TextOnlySnackBar>;\n    action: () => void;\n    hasAction: boolean;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/snack-bar/testing/index.d.ts",
      "node_modules/@angular/material/snack-bar/testing/index.d.ts"
    ],
    "content": "import { AriaLivePoliteness } from '@angular/cdk/a11y';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-snack-bar in tests. */\nexport declare class MatSnackBarHarness extends ContentContainerComponentHarness<string> {\n    /** The selector for the host element of a `MatSnackBar` instance. */\n    static hostSelector: string;\n    protected _messageSelector: string;\n    protected _actionButtonSelector: string;\n    private _snackBarLiveRegion;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSnackBarHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which snack bar instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: SnackBarHarnessFilters): HarnessPredicate<MatSnackBarHarness>;\n    /**\n     * Gets the role of the snack-bar. The role of a snack-bar is determined based\n     * on the ARIA politeness specified in the snack-bar config.\n     * @deprecated Use `getAriaLive` instead.\n     * @breaking-change 13.0.0\n     */\n    getRole(): Promise<'alert' | 'status' | null>;\n    /**\n     * Gets the aria-live of the snack-bar's live region. The aria-live of a snack-bar is\n     * determined based on the ARIA politeness specified in the snack-bar config.\n     */\n    getAriaLive(): Promise<AriaLivePoliteness>;\n    /**\n     * Whether the snack-bar has an action. Method cannot be used for snack-bar's with custom content.\n     */\n    hasAction(): Promise<boolean>;\n    /**\n     * Gets the description of the snack-bar. Method cannot be used for snack-bar's without action or\n     * with custom content.\n     */\n    getActionDescription(): Promise<string>;\n    /**\n     * Dismisses the snack-bar by clicking the action button. Method cannot be used for snack-bar's\n     * without action or with custom content.\n     */\n    dismissWithAction(): Promise<void>;\n    /**\n     * Gets the message of the snack-bar. Method cannot be used for snack-bar's with custom content.\n     */\n    getMessage(): Promise<string>;\n    /** Gets whether the snack-bar has been dismissed. */\n    isDismissed(): Promise<boolean>;\n    /**\n     * Asserts that the current snack-bar has annotated content. Promise reject\n     * if content is not annotated.\n     */\n    protected _assertContentAnnotated(): Promise<void>;\n    /**\n     * Asserts that the current snack-bar has an action defined. Otherwise the\n     * promise will reject.\n     */\n    protected _assertHasAction(): Promise<void>;\n    /** Whether the snack-bar is using the default content template. */\n    private _isSimpleSnackBar;\n    /** Gets the simple snack bar action button. */\n    private _getActionButton;\n}\n\n/** A set of criteria that can be used to filter a list of `MatSnackBarHarness` instances. */\nexport declare interface SnackBarHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/sort/index.d.ts",
      "node_modules/@angular/material/sort/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { AriaDescriber } from '@angular/cdk/a11y';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisable } from '@angular/material/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { HasInitialized } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i3 from '@angular/common';\nimport * as i4 from '@angular/material/core';\nimport { InjectionToken } from '@angular/core';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Optional } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n/**\n * Valid positions for the arrow to be in for its opacity and translation. If the state is a\n * sort direction, the position of the arrow will be above/below and opacity 0. If the state is\n * hint, the arrow will be in the center with a slight opacity. Active state means the arrow will\n * be fully opaque in the center.\n *\n * @docs-private\n */\nexport declare type ArrowViewState = SortDirection | 'hint' | 'active';\n\n/**\n * States describing the arrow's animated position (animating fromState to toState).\n * If the fromState is not defined, there will be no animated transition to the toState.\n * @docs-private\n */\nexport declare interface ArrowViewStateTransition {\n    fromState?: ArrowViewState;\n    toState?: ArrowViewState;\n}\n\ndeclare namespace i1 {\n    export {\n        SortHeaderArrowPosition,\n        MatSortable,\n        Sort,\n        MatSortDefaultOptions,\n        MAT_SORT_DEFAULT_OPTIONS,\n        MatSort\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        ArrowViewState,\n        ArrowViewStateTransition,\n        MatSortHeader\n    }\n}\n\n/** Injection token to be used to override the default options for `mat-sort`. */\nexport declare const MAT_SORT_DEFAULT_OPTIONS: InjectionToken<MatSortDefaultOptions>;\n\n/** @docs-private */\nexport declare const MAT_SORT_HEADER_INTL_PROVIDER: {\n    provide: typeof MatSortHeaderIntl;\n    deps: Optional[][];\n    useFactory: typeof MAT_SORT_HEADER_INTL_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\nexport declare function MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl: MatSortHeaderIntl): MatSortHeaderIntl;\n\n/** Container for MatSortables to manage the sort state and provide default sort parameters. */\nexport declare class MatSort extends _MatSortBase implements CanDisable, HasInitialized, OnChanges, OnDestroy, OnInit {\n    private _defaultOptions?;\n    /** Collection of all registered sortables that this directive manages. */\n    sortables: Map<string, MatSortable>;\n    /** Used to notify any child components listening to state changes. */\n    readonly _stateChanges: Subject<void>;\n    /** The id of the most recently sorted MatSortable. */\n    active: string;\n    /**\n     * The direction to set when an MatSortable is initially sorted.\n     * May be overridden by the MatSortable's sort start.\n     */\n    start: SortDirection;\n    /** The sort direction of the currently active MatSortable. */\n    get direction(): SortDirection;\n    set direction(direction: SortDirection);\n    private _direction;\n    /**\n     * Whether to disable the user from clearing the sort by finishing the sort direction cycle.\n     * May be overridden by the MatSortable's disable clear input.\n     */\n    get disableClear(): boolean;\n    set disableClear(v: BooleanInput);\n    private _disableClear;\n    /** Event emitted when the user changes either the active sort or sort direction. */\n    readonly sortChange: EventEmitter<Sort>;\n    constructor(_defaultOptions?: MatSortDefaultOptions | undefined);\n    /**\n     * Register function to be used by the contained MatSortables. Adds the MatSortable to the\n     * collection of MatSortables.\n     */\n    register(sortable: MatSortable): void;\n    /**\n     * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the\n     * collection of contained MatSortables.\n     */\n    deregister(sortable: MatSortable): void;\n    /** Sets the active sort id and determines the new sort direction. */\n    sort(sortable: MatSortable): void;\n    /** Returns the next sort direction of the active sortable, checking for potential overrides. */\n    getNextSortDirection(sortable: MatSortable): SortDirection;\n    ngOnInit(): void;\n    ngOnChanges(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSort, [{ optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatSort, \"[matSort]\", [\"matSort\"], { \"disabled\": \"matSortDisabled\"; \"active\": \"matSortActive\"; \"start\": \"matSortStart\"; \"direction\": \"matSortDirection\"; \"disableClear\": \"matSortDisableClear\"; }, { \"sortChange\": \"matSortChange\"; }, never, never, false>;\n}\n\n/** Interface for a directive that holds sorting state consumed by `MatSortHeader`. */\nexport declare interface MatSortable {\n    /** The id of the column being sorted. */\n    id: string;\n    /** Starting sort direction. */\n    start: SortDirection;\n    /** Whether to disable clearing the sorting state. */\n    disableClear: boolean;\n}\n\n/**\n * Animations used by MatSort.\n * @docs-private\n */\nexport declare const matSortAnimations: {\n    readonly indicator: AnimationTriggerMetadata;\n    readonly leftPointer: AnimationTriggerMetadata;\n    readonly rightPointer: AnimationTriggerMetadata;\n    readonly arrowOpacity: AnimationTriggerMetadata;\n    readonly arrowPosition: AnimationTriggerMetadata;\n    readonly allowChildren: AnimationTriggerMetadata;\n};\n\n/** @docs-private */\ndeclare const _MatSortBase: (new (...args: any[]) => HasInitialized) & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (): {};\n};\n\n/** Default options for `mat-sort`.  */\nexport declare interface MatSortDefaultOptions {\n    /** Whether to disable clearing the sorting state. */\n    disableClear?: boolean;\n    /** Position of the arrow that displays when sorted. */\n    arrowPosition?: SortHeaderArrowPosition;\n}\n\n/**\n * Applies sorting behavior (click to change sort) and styles to an element, including an\n * arrow to display the current sort direction.\n *\n * Must be provided with an id and contained within a parent MatSort directive.\n *\n * If used on header cells in a CdkTable, it will automatically default its id from its containing\n * column definition.\n */\nexport declare class MatSortHeader extends _MatSortHeaderBase implements CanDisable, MatSortable, OnDestroy, OnInit, AfterViewInit {\n    /**\n     * @deprecated `_intl` parameter isn't being used anymore and it'll be removed.\n     * @breaking-change 13.0.0\n     */\n    _intl: MatSortHeaderIntl;\n    private _changeDetectorRef;\n    _sort: MatSort;\n    _columnDef: MatSortHeaderColumnDef;\n    private _focusMonitor;\n    private _elementRef;\n    /** @breaking-change 14.0.0 _ariaDescriber will be required. */\n    private _ariaDescriber?;\n    private _rerenderSubscription;\n    /**\n     * The element with role=\"button\" inside this component's view. We need this\n     * in order to apply a description with AriaDescriber.\n     */\n    private _sortButton;\n    /**\n     * Flag set to true when the indicator should be displayed while the sort is not active. Used to\n     * provide an affordance that the header is sortable by showing on focus and hover.\n     */\n    _showIndicatorHint: boolean;\n    /**\n     * The view transition state of the arrow (translation/ opacity) - indicates its `from` and `to`\n     * position through the animation. If animations are currently disabled, the fromState is removed\n     * so that there is no animation displayed.\n     */\n    _viewState: ArrowViewStateTransition;\n    /** The direction the arrow should be facing according to the current state. */\n    _arrowDirection: SortDirection;\n    /**\n     * Whether the view state animation should show the transition between the `from` and `to` states.\n     */\n    _disableViewStateAnimation: boolean;\n    /**\n     * ID of this sort header. If used within the context of a CdkColumnDef, this will default to\n     * the column's name.\n     */\n    id: string;\n    /** Sets the position of the arrow that displays when sorted. */\n    arrowPosition: SortHeaderArrowPosition;\n    /** Overrides the sort start value of the containing MatSort for this MatSortable. */\n    start: SortDirection;\n    /**\n     * Description applied to MatSortHeader's button element with aria-describedby. This text should\n     * describe the action that will occur when the user clicks the sort header.\n     */\n    get sortActionDescription(): string;\n    set sortActionDescription(value: string);\n    private _sortActionDescription;\n    /** Overrides the disable clear value of the containing MatSort for this MatSortable. */\n    get disableClear(): boolean;\n    set disableClear(v: BooleanInput);\n    private _disableClear;\n    constructor(\n    /**\n     * @deprecated `_intl` parameter isn't being used anymore and it'll be removed.\n     * @breaking-change 13.0.0\n     */\n    _intl: MatSortHeaderIntl, _changeDetectorRef: ChangeDetectorRef, _sort: MatSort, _columnDef: MatSortHeaderColumnDef, _focusMonitor: FocusMonitor, _elementRef: ElementRef<HTMLElement>, \n    /** @breaking-change 14.0.0 _ariaDescriber will be required. */\n    _ariaDescriber?: AriaDescriber | null | undefined, defaultOptions?: MatSortDefaultOptions);\n    ngOnInit(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Sets the \"hint\" state such that the arrow will be semi-transparently displayed as a hint to the\n     * user showing what the active sort will become. If set to false, the arrow will fade away.\n     */\n    _setIndicatorHintVisible(visible: boolean): void;\n    /**\n     * Sets the animation transition view state for the arrow's position and opacity. If the\n     * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that\n     * no animation appears.\n     */\n    _setAnimationTransitionState(viewState: ArrowViewStateTransition): void;\n    /** Triggers the sort on this sort header and removes the indicator hint. */\n    _toggleOnInteraction(): void;\n    _handleClick(): void;\n    _handleKeydown(event: KeyboardEvent): void;\n    /** Whether this MatSortHeader is currently sorted in either ascending or descending order. */\n    _isSorted(): boolean;\n    /** Returns the animation state for the arrow direction (indicator and pointers). */\n    _getArrowDirectionState(): string;\n    /** Returns the arrow position state (opacity, translation). */\n    _getArrowViewState(): string;\n    /**\n     * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be\n     * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently\n     * active sorted direction. The reason this is updated through a function is because the direction\n     * should only be changed at specific times - when deactivated but the hint is displayed and when\n     * the sort is active and the direction changes. Otherwise the arrow's direction should linger\n     * in cases such as the sort becoming deactivated but we want to animate the arrow away while\n     * preserving its direction, even though the next sort direction is actually different and should\n     * only be changed once the arrow displays again (hint or activation).\n     */\n    _updateArrowDirection(): void;\n    _isDisabled(): boolean;\n    /**\n     * Gets the aria-sort attribute that should be applied to this sort header. If this header\n     * is not sorted, returns null so that the attribute is removed from the host element. Aria spec\n     * says that the aria-sort property should only be present on one header at a time, so removing\n     * ensures this is true.\n     */\n    _getAriaSortAttribute(): \"none\" | \"ascending\" | \"descending\";\n    /** Whether the arrow inside the sort header should be rendered. */\n    _renderArrow(): boolean;\n    private _updateSortActionDescription;\n    /** Handles changes in the sorting state. */\n    private _handleStateChanges;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSortHeader, [null, null, { optional: true; }, { optional: true; }, null, null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatSortHeader, \"[mat-sort-header]\", [\"matSortHeader\"], { \"disabled\": \"disabled\"; \"id\": \"mat-sort-header\"; \"arrowPosition\": \"arrowPosition\"; \"start\": \"start\"; \"sortActionDescription\": \"sortActionDescription\"; \"disableClear\": \"disableClear\"; }, {}, never, [\"*\"], false>;\n}\n\n/** @docs-private */\ndeclare const _MatSortHeaderBase: _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (): {};\n};\n\n/** Column definition associated with a `MatSortHeader`. */\ndeclare interface MatSortHeaderColumnDef {\n    name: string;\n}\n\n/**\n * To modify the labels and text displayed, create a new instance of MatSortHeaderIntl and\n * include it in a custom provider.\n */\nexport declare class MatSortHeaderIntl {\n    /**\n     * Stream that emits whenever the labels here are changed. Use this to notify\n     * components if the labels have changed after initialization.\n     */\n    readonly changes: Subject<void>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSortHeaderIntl, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatSortHeaderIntl>;\n}\n\nexport declare class MatSortModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatSortModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatSortModule, [typeof i1.MatSort, typeof i2.MatSortHeader], [typeof i3.CommonModule, typeof i4.MatCommonModule], [typeof i1.MatSort, typeof i2.MatSortHeader]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatSortModule>;\n}\n\n/** The current sort state. */\nexport declare interface Sort {\n    /** The id of the column being sorted. */\n    active: string;\n    /** The sort direction. */\n    direction: SortDirection;\n}\n\n\nexport declare type SortDirection = 'asc' | 'desc' | '';\n\n/** Position of the arrow that displays when sorted. */\nexport declare type SortHeaderArrowPosition = 'before' | 'after';\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/sort/testing/index.d.ts",
      "node_modules/@angular/material/sort/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { SortDirection } from '@angular/material/sort';\n\n/** Harness for interacting with a standard `mat-sort` in tests. */\nexport declare class MatSortHarness extends ComponentHarness {\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `mat-sort` with specific attributes.\n     * @param options Options for narrowing the search.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: SortHarnessFilters): HarnessPredicate<MatSortHarness>;\n    /** Gets all of the sort headers in the `mat-sort`. */\n    getSortHeaders(filter?: SortHeaderHarnessFilters): Promise<MatSortHeaderHarness[]>;\n    /** Gets the selected header in the `mat-sort`. */\n    getActiveHeader(): Promise<MatSortHeaderHarness | null>;\n}\n\n/** Harness for interacting with a standard Angular Material sort header in tests. */\nexport declare class MatSortHeaderHarness extends ComponentHarness {\n    static hostSelector: string;\n    private _container;\n    /**\n     * Gets a `HarnessPredicate` that can be used to\n     * search for a sort header with specific attributes.\n     */\n    static with(options?: SortHeaderHarnessFilters): HarnessPredicate<MatSortHeaderHarness>;\n    /** Gets the label of the sort header. */\n    getLabel(): Promise<string>;\n    /** Gets the sorting direction of the header. */\n    getSortDirection(): Promise<SortDirection>;\n    /** Gets whether the sort header is currently being sorted by. */\n    isActive(): Promise<boolean>;\n    /** Whether the sort header is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Clicks the header to change its sorting direction. Only works if the header is enabled. */\n    click(): Promise<void>;\n}\n\nexport declare interface SortHarnessFilters extends BaseHarnessFilters {\n}\n\nexport declare interface SortHeaderHarnessFilters extends BaseHarnessFilters {\n    label?: string | RegExp;\n    sortDirection?: SortDirection;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/stepper/index.d.ts",
      "node_modules/@angular/material/stepper/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AbstractControl } from '@angular/forms';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { CanColor } from '@angular/material/core';\nimport { CdkStep } from '@angular/cdk/stepper';\nimport { CdkStepLabel } from '@angular/cdk/stepper';\nimport { CdkStepper } from '@angular/cdk/stepper';\nimport { CdkStepperNext } from '@angular/cdk/stepper';\nimport { CdkStepperPrevious } from '@angular/cdk/stepper';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { ErrorStateMatcher } from '@angular/material/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { FormGroupDirective } from '@angular/forms';\nimport * as i0 from '@angular/core';\nimport * as i10 from '@angular/material/button';\nimport * as i11 from '@angular/cdk/stepper';\nimport * as i12 from '@angular/material/icon';\nimport * as i7 from '@angular/material/core';\nimport * as i8 from '@angular/common';\nimport * as i9 from '@angular/cdk/portal';\nimport { NgForm } from '@angular/forms';\nimport { OnDestroy } from '@angular/core';\nimport { Optional } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { StepperOptions } from '@angular/cdk/stepper';\nimport { StepperOrientation } from '@angular/cdk/stepper';\nimport { StepState } from '@angular/cdk/stepper';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\nimport { ViewContainerRef } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        MatStep,\n        MatStepper\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatStepLabel\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MatStepperNext,\n        MatStepperPrevious\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        MatStepHeader\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        MatStepperIconContext,\n        MatStepperIcon\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        MatStepContent\n    }\n}\n\n/** @docs-private */\nexport declare const MAT_STEPPER_INTL_PROVIDER: {\n    provide: typeof MatStepperIntl;\n    deps: Optional[][];\n    useFactory: typeof MAT_STEPPER_INTL_PROVIDER_FACTORY;\n};\n\n/** @docs-private */\nexport declare function MAT_STEPPER_INTL_PROVIDER_FACTORY(parentIntl: MatStepperIntl): MatStepperIntl;\n\nexport declare class MatStep extends CdkStep implements ErrorStateMatcher, AfterContentInit, OnDestroy {\n    private _errorStateMatcher;\n    private _viewContainerRef;\n    private _isSelected;\n    /** Content for step label given by `<ng-template matStepLabel>`. */\n    stepLabel: MatStepLabel;\n    /** Theme color for the particular step. */\n    color: ThemePalette;\n    /** Content that will be rendered lazily. */\n    _lazyContent: MatStepContent;\n    /** Currently-attached portal containing the lazy content. */\n    _portal: TemplatePortal;\n    constructor(stepper: MatStepper, _errorStateMatcher: ErrorStateMatcher, _viewContainerRef: ViewContainerRef, stepperOptions?: StepperOptions);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Custom error state matcher that additionally checks for validity of interacted form. */\n    isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStep, [null, { skipSelf: true; }, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatStep, \"mat-step\", [\"matStep\"], { \"color\": \"color\"; }, {}, [\"stepLabel\", \"_lazyContent\"], [\"*\"], false>;\n}\n\n/**\n * Content for a `mat-step` that will be rendered lazily.\n */\nexport declare class MatStepContent {\n    _template: TemplateRef<any>;\n    constructor(_template: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepContent, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStepContent, \"ng-template[matStepContent]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatStepHeader extends _MatStepHeaderBase implements AfterViewInit, OnDestroy, CanColor {\n    _intl: MatStepperIntl;\n    private _focusMonitor;\n    private _intlSubscription;\n    /** State of the given step. */\n    state: StepState;\n    /** Label of the given step. */\n    label: MatStepLabel | string;\n    /** Error message to display when there's an error. */\n    errorMessage: string;\n    /** Overrides for the header icons, passed in via the stepper. */\n    iconOverrides: {\n        [key: string]: TemplateRef<MatStepperIconContext>;\n    };\n    /** Index of the given step. */\n    index: number;\n    /** Whether the given step is selected. */\n    selected: boolean;\n    /** Whether the given step label is active. */\n    active: boolean;\n    /** Whether the given step is optional. */\n    optional: boolean;\n    /** Whether the ripple should be disabled. */\n    disableRipple: boolean;\n    constructor(_intl: MatStepperIntl, _focusMonitor: FocusMonitor, _elementRef: ElementRef<HTMLElement>, changeDetectorRef: ChangeDetectorRef);\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /** Focuses the step header. */\n    focus(origin?: FocusOrigin, options?: FocusOptions): void;\n    /** Returns string label of given step if it is a text label. */\n    _stringLabel(): string | null;\n    /** Returns MatStepLabel if the label of given step is a template label. */\n    _templateLabel(): MatStepLabel | null;\n    /** Returns the host HTML element. */\n    _getHostElement(): HTMLElement;\n    /** Template context variables that are exposed to the `matStepperIcon` instances. */\n    _getIconContext(): MatStepperIconContext;\n    _getDefaultTextForState(state: StepState): string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepHeader, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatStepHeader, \"mat-step-header\", never, { \"color\": \"color\"; \"state\": \"state\"; \"label\": \"label\"; \"errorMessage\": \"errorMessage\"; \"iconOverrides\": \"iconOverrides\"; \"index\": \"index\"; \"selected\": \"selected\"; \"active\": \"active\"; \"optional\": \"optional\"; \"disableRipple\": \"disableRipple\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatStepHeaderBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & {\n    new (elementRef: ElementRef): {\n        _elementRef: ElementRef<HTMLElement>;\n        focus(): void;\n    };\n    ɵfac: unknown;\n    ɵdir: unknown;\n};\n\nexport declare class MatStepLabel extends CdkStepLabel {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepLabel, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStepLabel, \"[matStepLabel]\", never, {}, {}, never, never, false>;\n}\n\nexport declare class MatStepper extends CdkStepper implements AfterContentInit {\n    /** The list of step headers of the steps in the stepper. */\n    _stepHeader: QueryList<MatStepHeader>;\n    /** Full list of steps inside the stepper, including inside nested steppers. */\n    _steps: QueryList<MatStep>;\n    /** Steps that belong to the current stepper, excluding ones from nested steppers. */\n    readonly steps: QueryList<MatStep>;\n    /** Custom icon overrides passed in by the consumer. */\n    _icons: QueryList<MatStepperIcon>;\n    /** Event emitted when the current step is done transitioning in. */\n    readonly animationDone: EventEmitter<void>;\n    /** Whether ripples should be disabled for the step headers. */\n    disableRipple: boolean;\n    /** Theme color for all of the steps in stepper. */\n    color: ThemePalette;\n    /**\n     * Whether the label should display in bottom or end position.\n     * Only applies in the `horizontal` orientation.\n     */\n    labelPosition: 'bottom' | 'end';\n    /**\n     * Position of the stepper's header.\n     * Only applies in the `horizontal` orientation.\n     */\n    headerPosition: 'top' | 'bottom';\n    /** Consumer-specified template-refs to be used to override the header icons. */\n    _iconOverrides: Record<string, TemplateRef<MatStepperIconContext>>;\n    /** Stream of animation `done` events when the body expands/collapses. */\n    readonly _animationDone: Subject<AnimationEvent_2>;\n    /** Duration for the animation. Will be normalized to milliseconds if no units are set. */\n    get animationDuration(): string;\n    set animationDuration(value: string);\n    private _animationDuration;\n    constructor(dir: Directionality, changeDetectorRef: ChangeDetectorRef, elementRef: ElementRef<HTMLElement>);\n    ngAfterContentInit(): void;\n    _stepIsNavigable(index: number, step: MatStep): boolean;\n    _getAnimationDuration(): string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepper, [{ optional: true; }, null, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatStepper, \"mat-stepper, mat-vertical-stepper, mat-horizontal-stepper, [matStepper]\", [\"matStepper\", \"matVerticalStepper\", \"matHorizontalStepper\"], { \"selectedIndex\": \"selectedIndex\"; \"disableRipple\": \"disableRipple\"; \"color\": \"color\"; \"labelPosition\": \"labelPosition\"; \"headerPosition\": \"headerPosition\"; \"animationDuration\": \"animationDuration\"; }, { \"animationDone\": \"animationDone\"; }, [\"_steps\", \"_icons\"], never, false>;\n}\n\n/**\n * Animations used by the Material steppers.\n * @docs-private\n */\nexport declare const matStepperAnimations: {\n    readonly horizontalStepTransition: AnimationTriggerMetadata;\n    readonly verticalStepTransition: AnimationTriggerMetadata;\n};\n\n/**\n * Template to be used to override the icons inside the step header.\n */\nexport declare class MatStepperIcon {\n    templateRef: TemplateRef<MatStepperIconContext>;\n    /** Name of the icon to be overridden. */\n    name: StepState;\n    constructor(templateRef: TemplateRef<MatStepperIconContext>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepperIcon, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStepperIcon, \"ng-template[matStepperIcon]\", never, { \"name\": \"matStepperIcon\"; }, {}, never, never, false>;\n}\n\n/** Template context available to an attached `matStepperIcon`. */\nexport declare interface MatStepperIconContext {\n    /** Index of the step. */\n    index: number;\n    /** Whether the step is currently active. */\n    active: boolean;\n    /** Whether the step is optional. */\n    optional: boolean;\n}\n\n/** Stepper data that is required for internationalization. */\nexport declare class MatStepperIntl {\n    /**\n     * Stream that emits whenever the labels here are changed. Use this to notify\n     * components if the labels have changed after initialization.\n     */\n    readonly changes: Subject<void>;\n    /** Label that is rendered below optional steps. */\n    optionalLabel: string;\n    /** Label that is used to indicate step as completed to screen readers. */\n    completedLabel: string;\n    /** Label that is used to indicate step as editable to screen readers. */\n    editableLabel: string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepperIntl, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<MatStepperIntl>;\n}\n\nexport declare class MatStepperModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepperModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatStepperModule, [typeof i1.MatStep, typeof i2.MatStepLabel, typeof i1.MatStepper, typeof i3.MatStepperNext, typeof i3.MatStepperPrevious, typeof i4.MatStepHeader, typeof i5.MatStepperIcon, typeof i6.MatStepContent], [typeof i7.MatCommonModule, typeof i8.CommonModule, typeof i9.PortalModule, typeof i10.MatButtonModule, typeof i11.CdkStepperModule, typeof i12.MatIconModule, typeof i7.MatRippleModule], [typeof i7.MatCommonModule, typeof i1.MatStep, typeof i2.MatStepLabel, typeof i1.MatStepper, typeof i3.MatStepperNext, typeof i3.MatStepperPrevious, typeof i4.MatStepHeader, typeof i5.MatStepperIcon, typeof i6.MatStepContent]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatStepperModule>;\n}\n\n/** Button that moves to the next step in a stepper workflow. */\nexport declare class MatStepperNext extends CdkStepperNext {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepperNext, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStepperNext, \"button[matStepperNext]\", never, { \"type\": \"type\"; }, {}, never, never, false>;\n}\n\n/** Button that moves to the previous step in a stepper workflow. */\nexport declare class MatStepperPrevious extends CdkStepperPrevious {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatStepperPrevious, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStepperPrevious, \"button[matStepperPrevious]\", never, { \"type\": \"type\"; }, {}, never, never, false>;\n}\n\nexport { StepperOrientation }\n\nexport { StepState }\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/stepper/testing/index.d.ts",
      "node_modules/@angular/material/stepper/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessLoader } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard Angular Material step in tests. */\nexport declare class MatStepHarness extends ContentContainerComponentHarness<string> {\n    /** The selector for the host element of a `MatStep` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatStepHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which steps are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: StepHarnessFilters): HarnessPredicate<MatStepHarness>;\n    /** Gets the label of the step. */\n    getLabel(): Promise<string>;\n    /** Gets the `aria-label` of the step. */\n    getAriaLabel(): Promise<string | null>;\n    /** Gets the value of the `aria-labelledby` attribute. */\n    getAriaLabelledby(): Promise<string | null>;\n    /** Whether the step is selected. */\n    isSelected(): Promise<boolean>;\n    /** Whether the step has been filled out. */\n    isCompleted(): Promise<boolean>;\n    /**\n     * Whether the step is currently showing its error state. Note that this doesn't mean that there\n     * are or aren't any invalid form controls inside the step, but that the step is showing its\n     * error-specific styling which depends on there being invalid controls, as well as the\n     * `ErrorStateMatcher` determining that an error should be shown and that the `showErrors`\n     * option was enabled through the `STEPPER_GLOBAL_OPTIONS` injection token.\n     */\n    hasErrors(): Promise<boolean>;\n    /** Whether the step is optional. */\n    isOptional(): Promise<boolean>;\n    /**\n     * Selects the given step by clicking on the label. The step may not be selected\n     * if the stepper doesn't allow it (e.g. if there are validation errors).\n     */\n    select(): Promise<void>;\n    protected getRootHarnessLoader(): Promise<HarnessLoader>;\n    /**\n     * Gets the state of the step. Note that we have a `StepState` which we could use to type the\n     * return value, but it's basically the same as `string`, because the type has `| string`.\n     */\n    private _getIconState;\n}\n\n/** Harness for interacting with a standard Material stepper in tests. */\nexport declare class MatStepperHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatStepper` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatStepperHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which stepper instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: StepperHarnessFilters): HarnessPredicate<MatStepperHarness>;\n    /**\n     * Gets the list of steps in the stepper.\n     * @param filter Optionally filters which steps are included.\n     */\n    getSteps(filter?: StepHarnessFilters): Promise<MatStepHarness[]>;\n    /** Gets the orientation of the stepper. */\n    getOrientation(): Promise<StepperOrientation>;\n    /**\n     * Selects a step in this stepper.\n     * @param filter An optional filter to apply to the child steps. The first step matching the\n     *    filter will be selected.\n     */\n    selectStep(filter?: StepHarnessFilters): Promise<void>;\n}\n\n/** Harness for interacting with a standard Angular Material stepper next button in tests. */\nexport declare class MatStepperNextHarness extends StepperButtonHarness {\n    /** The selector for the host element of a `MatStep` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatStepperNextHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which steps are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: StepperButtonHarnessFilters): HarnessPredicate<MatStepperNextHarness>;\n}\n\n/** Harness for interacting with a standard Angular Material stepper previous button in tests. */\nexport declare class MatStepperPreviousHarness extends StepperButtonHarness {\n    /** The selector for the host element of a `MatStep` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatStepperPreviousHarness`\n     * that meets certain criteria.\n     * @param options Options for filtering which steps are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: StepperButtonHarnessFilters): HarnessPredicate<MatStepperPreviousHarness>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatStepHarness` instances. */\nexport declare interface StepHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose label matches the given value. */\n    label?: string | RegExp;\n    /** Only find steps with the given selected state. */\n    selected?: boolean;\n    /** Only find completed steps. */\n    completed?: boolean;\n    /** Only find steps that have errors. */\n    invalid?: boolean;\n}\n\n/** Base class for stepper button harnesses. */\ndeclare abstract class StepperButtonHarness extends ComponentHarness {\n    /** Gets the text of the button. */\n    getText(): Promise<string>;\n    /** Clicks the button. */\n    click(): Promise<void>;\n}\n\n/**\n * A set of criteria that can be used to filter a list of\n * `MatStepperNextHarness` and `MatStepperPreviousHarness` instances.\n */\nexport declare interface StepperButtonHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n}\n\n/** A set of criteria that can be used to filter a list of `MatStepperHarness` instances. */\nexport declare interface StepperHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose orientation matches the given value. */\n    orientation?: StepperOrientation;\n}\n\n/** Possible orientations for a stepper. */\nexport declare const enum StepperOrientation {\n    HORIZONTAL = 0,\n    VERTICAL = 1\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/table/index.d.ts",
      "node_modules/@angular/material/table/index.d.ts"
    ],
    "content": "import { BehaviorSubject } from 'rxjs';\nimport { CdkCell } from '@angular/cdk/table';\nimport { CdkCellDef } from '@angular/cdk/table';\nimport { CdkColumnDef } from '@angular/cdk/table';\nimport { CdkFooterCell } from '@angular/cdk/table';\nimport { CdkFooterCellDef } from '@angular/cdk/table';\nimport { CdkFooterRow } from '@angular/cdk/table';\nimport { CdkFooterRowDef } from '@angular/cdk/table';\nimport { CdkHeaderCell } from '@angular/cdk/table';\nimport { CdkHeaderCellDef } from '@angular/cdk/table';\nimport { CdkHeaderRow } from '@angular/cdk/table';\nimport { CdkHeaderRowDef } from '@angular/cdk/table';\nimport { CdkNoDataRow } from '@angular/cdk/table';\nimport { CdkRow } from '@angular/cdk/table';\nimport { CdkRowDef } from '@angular/cdk/table';\nimport { CdkTable } from '@angular/cdk/table';\nimport { CdkTextColumn } from '@angular/cdk/table';\nimport { DataSource } from '@angular/cdk/table';\nimport * as i0 from '@angular/core';\nimport * as i5 from '@angular/cdk/table';\nimport * as i6 from '@angular/material/core';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { MatSort } from '@angular/material/sort';\nimport { Observable } from 'rxjs';\nimport { Subject } from 'rxjs';\nimport { Subscription } from 'rxjs';\n\ndeclare namespace i1 {\n    export {\n        MatRecycleRows,\n        MatTable\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatCellDef,\n        MatHeaderCellDef,\n        MatFooterCellDef,\n        MatColumnDef,\n        MatHeaderCell,\n        MatFooterCell,\n        MatCell\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MatHeaderRowDef,\n        MatFooterRowDef,\n        MatRowDef,\n        MatHeaderRow,\n        MatFooterRow,\n        MatRow,\n        MatNoDataRow\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        MatTextColumn\n    }\n}\n\n/** Cell template container that adds the right classes and role. */\nexport declare class MatCell extends CdkCell {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCell, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCell, \"mat-cell, td[mat-cell]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Cell definition for the mat-table.\n * Captures the template of a column's data row cell as well as cell-specific properties.\n */\nexport declare class MatCellDef extends CdkCellDef {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatCellDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatCellDef, \"[matCellDef]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Column definition for the mat-table.\n * Defines a set of cells available for a table column.\n */\nexport declare class MatColumnDef extends CdkColumnDef {\n    /** Unique name for this column. */\n    get name(): string;\n    set name(name: string);\n    /**\n     * Add \"mat-column-\" prefix in addition to \"cdk-column-\" prefix.\n     * In the future, this will only add \"mat-column-\" and columnCssClassName\n     * will change from type string[] to string.\n     * @docs-private\n     */\n    protected _updateColumnCssClassName(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatColumnDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatColumnDef, \"[matColumnDef]\", never, { \"sticky\": \"sticky\"; \"name\": \"matColumnDef\"; }, {}, never, never, false>;\n}\n\n/** Footer cell template container that adds the right classes and role. */\nexport declare class MatFooterCell extends CdkFooterCell {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatFooterCell, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatFooterCell, \"mat-footer-cell, td[mat-footer-cell]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Footer cell definition for the mat-table.\n * Captures the template of a column's footer cell and as well as cell-specific properties.\n */\nexport declare class MatFooterCellDef extends CdkFooterCellDef {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatFooterCellDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatFooterCellDef, \"[matFooterCellDef]\", never, {}, {}, never, never, false>;\n}\n\n/** Footer template container that contains the cell outlet. Adds the right class and role. */\nexport declare class MatFooterRow extends CdkFooterRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatFooterRow, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatFooterRow, \"mat-footer-row, tr[mat-footer-row]\", [\"matFooterRow\"], {}, {}, never, never, false>;\n}\n\n/**\n * Footer row definition for the mat-table.\n * Captures the footer row's template and other footer properties such as the columns to display.\n */\nexport declare class MatFooterRowDef extends CdkFooterRowDef {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatFooterRowDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatFooterRowDef, \"[matFooterRowDef]\", never, { \"columns\": \"matFooterRowDef\"; \"sticky\": \"matFooterRowDefSticky\"; }, {}, never, never, false>;\n}\n\n/** Header cell template container that adds the right classes and role. */\nexport declare class MatHeaderCell extends CdkHeaderCell {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatHeaderCell, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatHeaderCell, \"mat-header-cell, th[mat-header-cell]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Header cell definition for the mat-table.\n * Captures the template of a column's header cell and as well as cell-specific properties.\n */\nexport declare class MatHeaderCellDef extends CdkHeaderCellDef {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatHeaderCellDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatHeaderCellDef, \"[matHeaderCellDef]\", never, {}, {}, never, never, false>;\n}\n\n/** Header template container that contains the cell outlet. Adds the right class and role. */\nexport declare class MatHeaderRow extends CdkHeaderRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatHeaderRow, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatHeaderRow, \"mat-header-row, tr[mat-header-row]\", [\"matHeaderRow\"], {}, {}, never, never, false>;\n}\n\n/**\n * Header row definition for the mat-table.\n * Captures the header row's template and other header properties such as the columns to display.\n */\nexport declare class MatHeaderRowDef extends CdkHeaderRowDef {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatHeaderRowDef, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatHeaderRowDef, \"[matHeaderRowDef]\", never, { \"columns\": \"matHeaderRowDef\"; \"sticky\": \"matHeaderRowDefSticky\"; }, {}, never, never, false>;\n}\n\n/** Row that can be used to display a message when no data is shown in the table. */\nexport declare class MatNoDataRow extends CdkNoDataRow {\n    _contentClassName: string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatNoDataRow, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatNoDataRow, \"ng-template[matNoDataRow]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Enables the recycle view repeater strategy, which reduces rendering latency. Not compatible with\n * tables that animate rows.\n */\nexport declare class MatRecycleRows {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRecycleRows, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatRecycleRows, \"mat-table[recycleRows], table[mat-table][recycleRows]\", never, {}, {}, never, never, false>;\n}\n\n/** Data row template container that contains the cell outlet. Adds the right class and role. */\nexport declare class MatRow extends CdkRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRow, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatRow, \"mat-row, tr[mat-row]\", [\"matRow\"], {}, {}, never, never, false>;\n}\n\n/**\n * Data row definition for the mat-table.\n * Captures the data row's template and other properties such as the columns to display and\n * a when predicate that describes when this row should be used.\n */\nexport declare class MatRowDef<T> extends CdkRowDef<T> {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatRowDef<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatRowDef<any>, \"[matRowDef]\", never, { \"columns\": \"matRowDefColumns\"; \"when\": \"matRowDefWhen\"; }, {}, never, never, false>;\n}\n\n/**\n * Wrapper for the CdkTable with Material design styles.\n */\nexport declare class MatTable<T> extends CdkTable<T> {\n    /** Overrides the sticky CSS class set by the `CdkTable`. */\n    protected stickyCssClass: string;\n    /** Overrides the need to add position: sticky on every sticky cell element in `CdkTable`. */\n    protected needsPositionStickyOnElement: boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTable<any>, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTable<any>, \"mat-table, table[mat-table]\", [\"matTable\"], {}, {}, never, [\"caption\", \"colgroup, col\"], false>;\n}\n\n/**\n * Data source that accepts a client-side data array and includes native support of filtering,\n * sorting (using MatSort), and pagination (using MatPaginator).\n *\n * Allows for sort customization by overriding sortingDataAccessor, which defines how data\n * properties are accessed. Also allows for filter customization by overriding filterTermAccessor,\n * which defines how row data is converted to a string for filter matching.\n *\n * **Note:** This class is meant to be a simple data source to help you get started. As such\n * it isn't equipped to handle some more advanced cases like robust i18n support or server-side\n * interactions. If your app needs to support more advanced use cases, consider implementing your\n * own `DataSource`.\n */\nexport declare class MatTableDataSource<T> extends _MatTableDataSource<T, MatPaginator> {\n}\n\n/** Shared base class with MDC-based implementation. */\nexport declare class _MatTableDataSource<T, P extends MatTableDataSourcePaginator = MatTableDataSourcePaginator> extends DataSource<T> {\n    /** Stream that emits when a new data array is set on the data source. */\n    private readonly _data;\n    /** Stream emitting render data to the table (depends on ordered data changes). */\n    private readonly _renderData;\n    /** Stream that emits when a new filter string is set on the data source. */\n    private readonly _filter;\n    /** Used to react to internal changes of the paginator that are made by the data source itself. */\n    private readonly _internalPageChanges;\n    /**\n     * Subscription to the changes that should trigger an update to the table's rendered rows, such\n     * as filtering, sorting, pagination, or base data changes.\n     */\n    _renderChangesSubscription: Subscription | null;\n    /**\n     * The filtered set of data that has been matched by the filter string, or all the data if there\n     * is no filter. Useful for knowing the set of data the table represents.\n     * For example, a 'selectAll()' function would likely want to select the set of filtered data\n     * shown to the user rather than all the data.\n     */\n    filteredData: T[];\n    /** Array of data that should be rendered by the table, where each object represents one row. */\n    get data(): T[];\n    set data(data: T[]);\n    /**\n     * Filter term that should be used to filter out objects from the data array. To override how\n     * data objects match to this filter string, provide a custom function for filterPredicate.\n     */\n    get filter(): string;\n    set filter(filter: string);\n    /**\n     * Instance of the MatSort directive used by the table to control its sorting. Sort changes\n     * emitted by the MatSort will trigger an update to the table's rendered data.\n     */\n    get sort(): MatSort | null;\n    set sort(sort: MatSort | null);\n    private _sort;\n    /**\n     * Instance of the MatPaginator component used by the table to control what page of the data is\n     * displayed. Page changes emitted by the MatPaginator will trigger an update to the\n     * table's rendered data.\n     *\n     * Note that the data source uses the paginator's properties to calculate which page of data\n     * should be displayed. If the paginator receives its properties as template inputs,\n     * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been\n     * initialized before assigning it to this data source.\n     */\n    get paginator(): P | null;\n    set paginator(paginator: P | null);\n    private _paginator;\n    /**\n     * Data accessor function that is used for accessing data properties for sorting through\n     * the default sortData function.\n     * This default function assumes that the sort header IDs (which defaults to the column name)\n     * matches the data's properties (e.g. column Xyz represents data['Xyz']).\n     * May be set to a custom function for different behavior.\n     * @param data Data object that is being accessed.\n     * @param sortHeaderId The name of the column that represents the data.\n     */\n    sortingDataAccessor: (data: T, sortHeaderId: string) => string | number;\n    /**\n     * Gets a sorted copy of the data array based on the state of the MatSort. Called\n     * after changes are made to the filtered data or when sort changes are emitted from MatSort.\n     * By default, the function retrieves the active sort and its direction and compares data\n     * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation\n     * of data ordering.\n     * @param data The array of data that should be sorted.\n     * @param sort The connected MatSort that holds the current sort state.\n     */\n    sortData: (data: T[], sort: MatSort) => T[];\n    /**\n     * Checks if a data object matches the data source's filter string. By default, each data object\n     * is converted to a string of its properties and returns true if the filter has\n     * at least one occurrence in that string. By default, the filter string has its whitespace\n     * trimmed and the match is case-insensitive. May be overridden for a custom implementation of\n     * filter matching.\n     * @param data Data object used to check against the filter.\n     * @param filter Filter string that has been set on the data source.\n     * @returns Whether the filter matches against the data\n     */\n    filterPredicate: (data: T, filter: string) => boolean;\n    constructor(initialData?: T[]);\n    /**\n     * Subscribe to changes that should trigger an update to the table's rendered rows. When the\n     * changes occur, process the current state of the filter, sort, and pagination along with\n     * the provided base data and send it to the table for rendering.\n     */\n    _updateChangeSubscription(): void;\n    /**\n     * Returns a filtered data array where each filter object contains the filter string within\n     * the result of the filterTermAccessor function. If no filter is set, returns the data array\n     * as provided.\n     */\n    _filterData(data: T[]): T[];\n    /**\n     * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the\n     * data array as provided. Uses the default data accessor for data lookup, unless a\n     * sortDataAccessor function is defined.\n     */\n    _orderData(data: T[]): T[];\n    /**\n     * Returns a paged slice of the provided data array according to the provided MatPaginator's page\n     * index and length. If there is no paginator provided, returns the data array as provided.\n     */\n    _pageData(data: T[]): T[];\n    /**\n     * Updates the paginator to reflect the length of the filtered data, and makes sure that the page\n     * index does not exceed the paginator's last page. Values are changed in a resolved promise to\n     * guard against making property changes within a round of change detection.\n     */\n    _updatePaginator(filteredDataLength: number): void;\n    /**\n     * Used by the MatTable. Called when it connects to the data source.\n     * @docs-private\n     */\n    connect(): BehaviorSubject<T[]>;\n    /**\n     * Used by the MatTable. Called when it disconnects from the data source.\n     * @docs-private\n     */\n    disconnect(): void;\n}\n\n/**\n * Interface that matches the required API parts for the MatPaginator's PageEvent.\n * Decoupled so that users can depend on either the legacy or MDC-based paginator.\n */\nexport declare interface MatTableDataSourcePageEvent {\n    pageIndex: number;\n    pageSize: number;\n    length: number;\n}\n\n/**\n * Interface that matches the required API parts of the MatPaginator.\n * Decoupled so that users can depend on either the legacy or MDC-based paginator.\n */\nexport declare interface MatTableDataSourcePaginator {\n    page: Subject<MatTableDataSourcePageEvent>;\n    pageIndex: number;\n    initialized: Observable<void>;\n    pageSize: number;\n    length: number;\n}\n\nexport declare class MatTableModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTableModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatTableModule, [typeof i1.MatTable, typeof i1.MatRecycleRows, typeof i2.MatHeaderCellDef, typeof i3.MatHeaderRowDef, typeof i2.MatColumnDef, typeof i2.MatCellDef, typeof i3.MatRowDef, typeof i2.MatFooterCellDef, typeof i3.MatFooterRowDef, typeof i2.MatHeaderCell, typeof i2.MatCell, typeof i2.MatFooterCell, typeof i3.MatHeaderRow, typeof i3.MatRow, typeof i3.MatFooterRow, typeof i3.MatNoDataRow, typeof i4.MatTextColumn], [typeof i5.CdkTableModule, typeof i6.MatCommonModule], [typeof i6.MatCommonModule, typeof i1.MatTable, typeof i1.MatRecycleRows, typeof i2.MatHeaderCellDef, typeof i3.MatHeaderRowDef, typeof i2.MatColumnDef, typeof i2.MatCellDef, typeof i3.MatRowDef, typeof i2.MatFooterCellDef, typeof i3.MatFooterRowDef, typeof i2.MatHeaderCell, typeof i2.MatCell, typeof i2.MatFooterCell, typeof i3.MatHeaderRow, typeof i3.MatRow, typeof i3.MatFooterRow, typeof i3.MatNoDataRow, typeof i4.MatTextColumn]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatTableModule>;\n}\n\n/**\n * Column that simply shows text content for the header and row cells. Assumes that the table\n * is using the native table implementation (`<table>`).\n *\n * By default, the name of this column will be the header text and data property accessor.\n * The header text can be overridden with the `headerText` input. Cell values can be overridden with\n * the `dataAccessor` input. Change the text justification to the start or end using the `justify`\n * input.\n */\nexport declare class MatTextColumn<T> extends CdkTextColumn<T> {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTextColumn<any>, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTextColumn<any>, \"mat-text-column\", never, {}, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/table/testing/index.d.ts",
      "node_modules/@angular/material/table/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ComponentHarnessConstructor } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** A set of criteria that can be used to filter a list of cell harness instances. */\nexport declare interface CellHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n    /** Only find instances whose column name matches the given value. */\n    columnName?: string | RegExp;\n}\n\n/** Harness for interacting with a standard Angular Material table cell. */\nexport declare class MatCellHarness extends ContentContainerComponentHarness {\n    /** The selector for the host element of a `MatCellHarness` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a table cell with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: CellHarnessFilters): HarnessPredicate<MatCellHarness>;\n    /** Gets the cell's text. */\n    getText(): Promise<string>;\n    /** Gets the name of the column that the cell belongs to. */\n    getColumnName(): Promise<string>;\n    protected static _getCellPredicate<T extends MatCellHarness>(type: ComponentHarnessConstructor<T>, options: CellHarnessFilters): HarnessPredicate<T>;\n}\n\n/** Harness for interacting with a standard Angular Material table footer cell. */\nexport declare class MatFooterCellHarness extends MatCellHarness {\n    /** The selector for the host element of a `MatFooterCellHarness` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for\n     * a table footer cell with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: CellHarnessFilters): HarnessPredicate<MatFooterCellHarness>;\n}\n\n/** Harness for interacting with a standard Angular Material table footer row. */\nexport declare class MatFooterRowHarness extends _MatRowHarnessBase<typeof MatFooterCellHarness, MatFooterCellHarness> {\n    /** The selector for the host element of a `MatFooterRowHarness` instance. */\n    static hostSelector: string;\n    protected _cellHarness: typeof MatFooterCellHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for\n     * a table footer row cell with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: RowHarnessFilters): HarnessPredicate<MatFooterRowHarness>;\n}\n\n/** Harness for interacting with a standard Angular Material table header cell. */\nexport declare class MatHeaderCellHarness extends MatCellHarness {\n    /** The selector for the host element of a `MatHeaderCellHarness` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for\n     * a table header cell with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: CellHarnessFilters): HarnessPredicate<MatHeaderCellHarness>;\n}\n\n/** Harness for interacting with a standard Angular Material table header row. */\nexport declare class MatHeaderRowHarness extends _MatRowHarnessBase<typeof MatHeaderCellHarness, MatHeaderCellHarness> {\n    /** The selector for the host element of a `MatHeaderRowHarness` instance. */\n    static hostSelector: string;\n    protected _cellHarness: typeof MatHeaderCellHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for\n     * a table header row with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: RowHarnessFilters): HarnessPredicate<MatHeaderRowHarness>;\n}\n\n/** Harness for interacting with a standard Angular Material table row. */\nexport declare class MatRowHarness extends _MatRowHarnessBase<typeof MatCellHarness, MatCellHarness> {\n    /** The selector for the host element of a `MatRowHarness` instance. */\n    static hostSelector: string;\n    protected _cellHarness: typeof MatCellHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a table row with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: RowHarnessFilters): HarnessPredicate<MatRowHarness>;\n}\n\nexport declare abstract class _MatRowHarnessBase<CellType extends ComponentHarnessConstructor<Cell> & {\n    with: (options?: CellHarnessFilters) => HarnessPredicate<Cell>;\n}, Cell extends ComponentHarness & {\n    getText(): Promise<string>;\n    getColumnName(): Promise<string>;\n}> extends ComponentHarness {\n    protected abstract _cellHarness: CellType;\n    /** Gets a list of `MatCellHarness` for all cells in the row. */\n    getCells(filter?: CellHarnessFilters): Promise<Cell[]>;\n    /** Gets the text of the cells in the row. */\n    getCellTextByIndex(filter?: CellHarnessFilters): Promise<string[]>;\n    /** Gets the text inside the row organized by columns. */\n    getCellTextByColumnName(): Promise<MatRowHarnessColumnsText>;\n}\n\n/** Text extracted from a table row organized by columns. */\nexport declare interface MatRowHarnessColumnsText {\n    [columnName: string]: string;\n}\n\n/** Harness for interacting with a standard mat-table in tests. */\nexport declare class MatTableHarness extends _MatTableHarnessBase<typeof MatHeaderRowHarness, MatHeaderRowHarness, typeof MatRowHarness, MatRowHarness, typeof MatFooterRowHarness, MatFooterRowHarness> {\n    /** The selector for the host element of a `MatTableHarness` instance. */\n    static hostSelector: string;\n    protected _headerRowHarness: typeof MatHeaderRowHarness;\n    protected _rowHarness: typeof MatRowHarness;\n    protected _footerRowHarness: typeof MatFooterRowHarness;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a table with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TableHarnessFilters): HarnessPredicate<MatTableHarness>;\n}\n\nexport declare abstract class _MatTableHarnessBase<HeaderRowType extends ComponentHarnessConstructor<HeaderRow> & {\n    with: (options?: RowHarnessFilters) => HarnessPredicate<HeaderRow>;\n}, HeaderRow extends RowBase, RowType extends ComponentHarnessConstructor<Row> & {\n    with: (options?: RowHarnessFilters) => HarnessPredicate<Row>;\n}, Row extends RowBase, FooterRowType extends ComponentHarnessConstructor<FooterRow> & {\n    with: (options?: RowHarnessFilters) => HarnessPredicate<FooterRow>;\n}, FooterRow extends RowBase> extends ContentContainerComponentHarness<string> {\n    protected abstract _headerRowHarness: HeaderRowType;\n    protected abstract _rowHarness: RowType;\n    protected abstract _footerRowHarness: FooterRowType;\n    /** Gets all of the header rows in a table. */\n    getHeaderRows(filter?: RowHarnessFilters): Promise<HeaderRow[]>;\n    /** Gets all of the regular data rows in a table. */\n    getRows(filter?: RowHarnessFilters): Promise<Row[]>;\n    /** Gets all of the footer rows in a table. */\n    getFooterRows(filter?: RowHarnessFilters): Promise<FooterRow[]>;\n    /** Gets the text inside the entire table organized by rows. */\n    getCellTextByIndex(): Promise<string[][]>;\n    /** Gets the text inside the entire table organized by columns. */\n    getCellTextByColumnName(): Promise<MatTableHarnessColumnsText>;\n}\n\n/** Text extracted from a table organized by columns. */\nexport declare interface MatTableHarnessColumnsText {\n    [columnName: string]: {\n        text: string[];\n        headerText: string[];\n        footerText: string[];\n    };\n}\n\ndeclare interface RowBase extends ComponentHarness {\n    getCellTextByColumnName(): Promise<MatRowHarnessColumnsText>;\n    getCellTextByIndex(): Promise<string[]>;\n}\n\n/** A set of criteria that can be used to filter a list of row harness instances. */\nexport declare interface RowHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of table harness instances. */\nexport declare interface TableHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/tabs/index.d.ts",
      "node_modules/@angular/material/tabs/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentChecked } from '@angular/core';\nimport { AfterContentInit } from '@angular/core';\nimport { AfterViewInit } from '@angular/core';\nimport { AnimationEvent as AnimationEvent_2 } from '@angular/animations';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanColor } from '@angular/material/core';\nimport { CanDisable } from '@angular/material/core';\nimport { CanDisableRipple } from '@angular/material/core';\nimport { CdkPortal } from '@angular/cdk/portal';\nimport { CdkPortalOutlet } from '@angular/cdk/portal';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { _Constructor } from '@angular/material/core';\nimport { Direction } from '@angular/cdk/bidi';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { FocusableOption } from '@angular/cdk/a11y';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { FocusOrigin } from '@angular/cdk/a11y';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i10 from '@angular/common';\nimport * as i11 from '@angular/material/core';\nimport * as i12 from '@angular/cdk/portal';\nimport * as i13 from '@angular/cdk/observers';\nimport * as i14 from '@angular/cdk/a11y';\nimport { InjectionToken } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\nimport { RippleConfig } from '@angular/material/core';\nimport { RippleGlobalOptions } from '@angular/material/core';\nimport { RippleTarget } from '@angular/material/core';\nimport { SimpleChanges } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { TemplateRef } from '@angular/core';\nimport { ThemePalette } from '@angular/material/core';\nimport { ViewContainerRef } from '@angular/core';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\ndeclare namespace i1 {\n    export {\n        MatTabChangeEvent,\n        MatTabHeaderPosition,\n        _MatTabGroupBase,\n        MatTabGroup\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MAT_TAB_LABEL,\n        MAT_TAB,\n        MatTabLabel\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MAT_TAB_GROUP,\n        MatTab\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        _MAT_INK_BAR_POSITIONER_FACTORY,\n        _MatInkBarPositioner,\n        _MAT_INK_BAR_POSITIONER,\n        MatInkBar\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        MatTabLabelWrapper\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        _MatTabNavBase,\n        MatTabNav,\n        _MatTabLinkBase,\n        MatTabLink,\n        MatTabNavPanel\n    }\n}\n\ndeclare namespace i7 {\n    export {\n        MatTabBodyPositionState,\n        MatTabBodyOriginState,\n        MatTabBodyPortal,\n        _MatTabBodyBase,\n        MatTabBody\n    }\n}\n\ndeclare namespace i8 {\n    export {\n        _MatTabHeaderBase,\n        MatTabHeader\n    }\n}\n\ndeclare namespace i9 {\n    export {\n        MAT_TAB_CONTENT,\n        MatTabContent\n    }\n}\n\n/** Injection token for the MatInkBar's Positioner. */\nexport declare const _MAT_INK_BAR_POSITIONER: InjectionToken<_MatInkBarPositioner>;\n\n/**\n * The default positioner function for the MatInkBar.\n * @docs-private\n */\ndeclare function _MAT_INK_BAR_POSITIONER_FACTORY(): _MatInkBarPositioner;\n\n/**\n * Used to provide a tab label to a tab without causing a circular dependency.\n * @docs-private\n */\nexport declare const MAT_TAB: InjectionToken<any>;\n\n/**\n * Injection token that can be used to reference instances of `MatTabContent`. It serves as\n * alternative token to the actual `MatTabContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\ndeclare const MAT_TAB_CONTENT: InjectionToken<MatTabContent>;\n\n/**\n * Used to provide a tab group to a tab without causing a circular dependency.\n * @docs-private\n */\nexport declare const MAT_TAB_GROUP: InjectionToken<any>;\n\n/**\n * Injection token that can be used to reference instances of `MatTabLabel`. It serves as\n * alternative token to the actual `MatTabLabel` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\ndeclare const MAT_TAB_LABEL: InjectionToken<MatTabLabel>;\n\n/** Injection token that can be used to provide the default options the tabs module. */\nexport declare const MAT_TABS_CONFIG: InjectionToken<MatTabsConfig>;\n\n/**\n * The ink-bar is used to display and animate the line underneath the current active tab label.\n * @docs-private\n */\nexport declare class MatInkBar {\n    private _elementRef;\n    private _ngZone;\n    private _inkBarPositioner;\n    _animationMode?: string | undefined;\n    constructor(_elementRef: ElementRef<HTMLElement>, _ngZone: NgZone, _inkBarPositioner: _MatInkBarPositioner, _animationMode?: string | undefined);\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param element\n     */\n    alignToElement(element: HTMLElement): void;\n    /** Shows the ink bar. */\n    show(): void;\n    /** Hides the ink bar. */\n    hide(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatInkBar, [null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatInkBar, \"mat-ink-bar\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Interface for a a MatInkBar positioner method, defining the positioning and width of the ink\n * bar in a set of tabs.\n */\nexport declare interface _MatInkBarPositioner {\n    (element: HTMLElement): {\n        left: string;\n        width: string;\n    };\n}\n\n/**\n * Base class for a tab header that supported pagination.\n * @docs-private\n */\ndeclare abstract class MatPaginatedTabHeader implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy {\n    protected _elementRef: ElementRef<HTMLElement>;\n    protected _changeDetectorRef: ChangeDetectorRef;\n    private _viewportRuler;\n    private _dir;\n    private _ngZone;\n    private _platform;\n    _animationMode?: string | undefined;\n    abstract _items: QueryList<MatPaginatedTabHeaderItem>;\n    abstract _inkBar: {\n        hide: () => void;\n        alignToElement: (element: HTMLElement) => void;\n    };\n    abstract _tabListContainer: ElementRef<HTMLElement>;\n    abstract _tabList: ElementRef<HTMLElement>;\n    abstract _tabListInner: ElementRef<HTMLElement>;\n    abstract _nextPaginator: ElementRef<HTMLElement>;\n    abstract _previousPaginator: ElementRef<HTMLElement>;\n    /** The distance in pixels that the tab labels should be translated to the left. */\n    private _scrollDistance;\n    /** Whether the header should scroll to the selected index after the view has been checked. */\n    private _selectedIndexChanged;\n    /** Emits when the component is destroyed. */\n    protected readonly _destroyed: Subject<void>;\n    /** Whether the controls for pagination should be displayed */\n    _showPaginationControls: boolean;\n    /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n    _disableScrollAfter: boolean;\n    /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n    _disableScrollBefore: boolean;\n    /**\n     * The number of tab labels that are displayed on the header. When this changes, the header\n     * should re-evaluate the scroll position.\n     */\n    private _tabLabelCount;\n    /** Whether the scroll distance has changed and should be applied after the view is checked. */\n    private _scrollDistanceChanged;\n    /** Used to manage focus between the tabs. */\n    private _keyManager;\n    /** Cached text content of the header. */\n    private _currentTextContent;\n    /** Stream that will stop the automated scrolling. */\n    private _stopScrolling;\n    /**\n     * Whether pagination should be disabled. This can be used to avoid unnecessary\n     * layout recalculations if it's known that pagination won't be required.\n     */\n    get disablePagination(): boolean;\n    set disablePagination(value: BooleanInput);\n    private _disablePagination;\n    /** The index of the active tab. */\n    get selectedIndex(): number;\n    set selectedIndex(value: NumberInput);\n    private _selectedIndex;\n    /** Event emitted when the option is selected. */\n    readonly selectFocusedIndex: EventEmitter<number>;\n    /** Event emitted when a label is focused. */\n    readonly indexFocused: EventEmitter<number>;\n    constructor(_elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, _viewportRuler: ViewportRuler, _dir: Directionality, _ngZone: NgZone, _platform: Platform, _animationMode?: string | undefined);\n    /** Called when the user has selected an item via the keyboard. */\n    protected abstract _itemSelected(event: KeyboardEvent): void;\n    ngAfterViewInit(): void;\n    ngAfterContentInit(): void;\n    /** Sends any changes that could affect the layout of the items. */\n    private _itemsResized;\n    ngAfterContentChecked(): void;\n    ngOnDestroy(): void;\n    /** Handles keyboard events on the header. */\n    _handleKeydown(event: KeyboardEvent): void;\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     */\n    _onContentChanges(): void;\n    /**\n     * Updates the view whether pagination should be enabled or not.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance. It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     */\n    updatePagination(): void;\n    /** Tracks which element has focus; used for keyboard navigation */\n    get focusIndex(): number;\n    /** When the focus index is set, we must manually send focus to the correct label */\n    set focusIndex(value: number);\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     */\n    _isValidIndex(index: number): boolean;\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     */\n    _setTabFocus(tabIndex: number): void;\n    /** The layout direction of the containing app. */\n    _getLayoutDirection(): Direction;\n    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n    _updateTabScrollPosition(): void;\n    /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n    get scrollDistance(): number;\n    set scrollDistance(value: number);\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _scrollHeader(direction: ScrollDirection): {\n        maxScrollDistance: number;\n        distance: number;\n    };\n    /** Handles click events on the pagination arrows. */\n    _handlePaginatorClick(direction: ScrollDirection): void;\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _scrollToLabel(labelIndex: number): void;\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _checkPaginationEnabled(): void;\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _checkScrollingControls(): void;\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    _getMaxScrollDistance(): number;\n    /** Tells the ink-bar to align itself to the current label wrapper */\n    _alignInkBarToSelectedTab(): void;\n    /** Stops the currently-running paginator interval.  */\n    _stopInterval(): void;\n    /**\n     * Handles the user pressing down on one of the paginators.\n     * Starts scrolling the header after a certain amount of time.\n     * @param direction In which direction the paginator should be scrolled.\n     */\n    _handlePaginatorPress(direction: ScrollDirection, mouseEvent?: MouseEvent): void;\n    /**\n     * Scrolls the header to a given position.\n     * @param position Position to which to scroll.\n     * @returns Information on the current scroll distance and the maximum.\n     */\n    private _scrollTo;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatPaginatedTabHeader, [null, null, null, { optional: true; }, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatPaginatedTabHeader, never, never, { \"disablePagination\": \"disablePagination\"; }, {}, never, never, false>;\n}\n\n/** Item inside a paginated tab header. */\ndeclare type MatPaginatedTabHeaderItem = FocusableOption & {\n    elementRef: ElementRef;\n};\n\nexport declare class MatTab extends _MatTabBase implements OnInit, CanDisable, OnChanges, OnDestroy {\n    private _viewContainerRef;\n    _closestTabGroup: any;\n    /** Content for the tab label given by `<ng-template mat-tab-label>`. */\n    get templateLabel(): MatTabLabel;\n    set templateLabel(value: MatTabLabel);\n    protected _templateLabel: MatTabLabel;\n    /**\n     * Template provided in the tab content that will be used if present, used to enable lazy-loading\n     */\n    _explicitContent: TemplateRef<any>;\n    /** Template inside the MatTab view that contains an `<ng-content>`. */\n    _implicitContent: TemplateRef<any>;\n    /** Plain text label for the tab, used when there is no template label. */\n    textLabel: string;\n    /** Aria label for the tab. */\n    ariaLabel: string;\n    /**\n     * Reference to the element that the tab is labelled by.\n     * Will be cleared if `aria-label` is set at the same time.\n     */\n    ariaLabelledby: string;\n    /**\n     * Classes to be passed to the tab label inside the mat-tab-header container.\n     * Supports string and string array values, same as `ngClass`.\n     */\n    labelClass: string | string[];\n    /**\n     * Classes to be passed to the tab mat-tab-body container.\n     * Supports string and string array values, same as `ngClass`.\n     */\n    bodyClass: string | string[];\n    /** Portal that will be the hosted content of the tab */\n    private _contentPortal;\n    /** @docs-private */\n    get content(): TemplatePortal | null;\n    /** Emits whenever the internal state of the tab changes. */\n    readonly _stateChanges: Subject<void>;\n    /**\n     * The relatively indexed position where 0 represents the center, negative is left, and positive\n     * represents the right.\n     */\n    position: number | null;\n    /**\n     * The initial relatively index origin of the tab if it was created and selected after there\n     * was already a selected tab. Provides context of what position the tab should originate from.\n     */\n    origin: number | null;\n    /**\n     * Whether the tab is currently active.\n     */\n    isActive: boolean;\n    constructor(_viewContainerRef: ViewContainerRef, _closestTabGroup: any);\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    ngOnInit(): void;\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    protected _setTemplateLabelInput(value: MatTabLabel | undefined): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTab, [null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTab, \"mat-tab\", [\"matTab\"], { \"disabled\": \"disabled\"; \"textLabel\": \"label\"; \"ariaLabel\": \"aria-label\"; \"ariaLabelledby\": \"aria-labelledby\"; \"labelClass\": \"labelClass\"; \"bodyClass\": \"bodyClass\"; }, {}, [\"templateLabel\", \"_explicitContent\"], [\"*\"], false>;\n}\n\n/** @docs-private */\ndeclare const _MatTabBase: _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (): {};\n};\n\n/**\n * Wrapper for the contents of a tab.\n * @docs-private\n */\nexport declare class MatTabBody extends _MatTabBodyBase {\n    _portalHost: CdkPortalOutlet;\n    constructor(elementRef: ElementRef<HTMLElement>, dir: Directionality, changeDetectorRef: ChangeDetectorRef);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabBody, [null, { optional: true; }, null]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTabBody, \"mat-tab-body\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Base class with all of the `MatTabBody` functionality.\n * @docs-private\n */\nexport declare abstract class _MatTabBodyBase implements OnInit, OnDestroy {\n    private _elementRef;\n    private _dir;\n    /** Current position of the tab-body in the tab-group. Zero means that the tab is visible. */\n    private _positionIndex;\n    /** Subscription to the directionality change observable. */\n    private _dirChangeSubscription;\n    /** Tab body position state. Used by the animation trigger for the current state. */\n    _position: MatTabBodyPositionState;\n    /** Emits when an animation on the tab is complete. */\n    readonly _translateTabComplete: Subject<AnimationEvent_2>;\n    /** Event emitted when the tab begins to animate towards the center as the active tab. */\n    readonly _onCentering: EventEmitter<number>;\n    /** Event emitted before the centering of the tab begins. */\n    readonly _beforeCentering: EventEmitter<boolean>;\n    /** Event emitted before the centering of the tab begins. */\n    readonly _afterLeavingCenter: EventEmitter<void>;\n    /** Event emitted when the tab completes its animation towards the center. */\n    readonly _onCentered: EventEmitter<void>;\n    /** The portal host inside of this container into which the tab body content will be loaded. */\n    abstract _portalHost: CdkPortalOutlet;\n    /** The tab body content to display. */\n    _content: TemplatePortal;\n    /** Position that will be used when the tab is immediately becoming visible after creation. */\n    origin: number | null;\n    /** Duration for the tab's animation. */\n    animationDuration: string;\n    /** Whether the tab's content should be kept in the DOM while it's off-screen. */\n    preserveContent: boolean;\n    /** The shifted index position of the tab body, where zero represents the active center tab. */\n    set position(position: number);\n    constructor(_elementRef: ElementRef<HTMLElement>, _dir: Directionality, changeDetectorRef: ChangeDetectorRef);\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     */\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    _onTranslateTabStarted(event: AnimationEvent_2): void;\n    /** The text direction of the containing app. */\n    _getLayoutDirection(): Direction;\n    /** Whether the provided position state is considered center, regardless of origin. */\n    _isCenterPosition(position: MatTabBodyPositionState | string): boolean;\n    /** Computes the position state that will be used for the tab-body animation trigger. */\n    private _computePositionAnimationState;\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     */\n    private _computePositionFromOrigin;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatTabBodyBase, [null, { optional: true; }, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatTabBodyBase, never, never, { \"_content\": \"content\"; \"origin\": \"origin\"; \"animationDuration\": \"animationDuration\"; \"preserveContent\": \"preserveContent\"; \"position\": \"position\"; }, { \"_onCentering\": \"_onCentering\"; \"_beforeCentering\": \"_beforeCentering\"; \"_afterLeavingCenter\": \"_afterLeavingCenter\"; \"_onCentered\": \"_onCentered\"; }, never, never, false>;\n}\n\n/**\n * The origin state is an internally used state that is set on a new tab body indicating if it\n * began to the left or right of the prior selected index. For example, if the selected index was\n * set to 1, and a new tab is created and selected at index 2, then the tab body would have an\n * origin of right because its index was greater than the prior selected index.\n */\nexport declare type MatTabBodyOriginState = 'left' | 'right';\n\n/**\n * The portal host directive for the contents of the tab.\n * @docs-private\n */\nexport declare class MatTabBodyPortal extends CdkPortalOutlet implements OnInit, OnDestroy {\n    private _host;\n    /** Subscription to events for when the tab body begins centering. */\n    private _centeringSub;\n    /** Subscription to events for when the tab body finishes leaving from center position. */\n    private _leavingSub;\n    constructor(componentFactoryResolver: ComponentFactoryResolver, viewContainerRef: ViewContainerRef, _host: MatTabBody, _document: any);\n    /** Set initial visibility or set up subscription for changing visibility. */\n    ngOnInit(): void;\n    /** Clean up centering subscription. */\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabBodyPortal, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTabBodyPortal, \"[matTabBodyHost]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * These position states are used internally as animation states for the tab body. Setting the\n * position state to left, right, or center will transition the tab body from its current\n * position to its respective state. If there is not current position (void, in the case of a new\n * tab body), then there will be no transition animation to its state.\n *\n * In the case of a new tab body that should immediately be centered with an animating transition,\n * then left-origin-center or right-origin-center can be used, which will use left or right as its\n * pseudo-prior state.\n */\nexport declare type MatTabBodyPositionState = 'left' | 'center' | 'right' | 'left-origin-center' | 'right-origin-center';\n\n/** A simple change event emitted on focus or selection changes. */\nexport declare class MatTabChangeEvent {\n    /** Index of the currently-selected tab. */\n    index: number;\n    /** Reference to the currently-selected tab. */\n    tab: MatTab;\n}\n\n/** Decorates the `ng-template` tags and reads out the template from it. */\nexport declare class MatTabContent {\n    template: TemplateRef<any>;\n    constructor(/** Content for the tab. */ template: TemplateRef<any>);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabContent, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTabContent, \"[matTabContent]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Material design tab-group component. Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\nexport declare class MatTabGroup extends _MatTabGroupBase {\n    _allTabs: QueryList<MatTab>;\n    _tabBodyWrapper: ElementRef;\n    _tabHeader: MatTabGroupBaseHeader;\n    constructor(elementRef: ElementRef, changeDetectorRef: ChangeDetectorRef, defaultConfig?: MatTabsConfig, animationMode?: string);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabGroup, [null, null, { optional: true; }, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTabGroup, \"mat-tab-group\", [\"matTabGroup\"], { \"color\": \"color\"; \"disableRipple\": \"disableRipple\"; }, {}, [\"_allTabs\"], never, false>;\n}\n\n/**\n * Base class with all of the `MatTabGroupBase` functionality.\n * @docs-private\n */\nexport declare abstract class _MatTabGroupBase extends _MatTabGroupMixinBase implements AfterContentInit, AfterContentChecked, OnDestroy, CanColor, CanDisableRipple {\n    protected _changeDetectorRef: ChangeDetectorRef;\n    _animationMode?: string | undefined;\n    /**\n     * All tabs inside the tab group. This includes tabs that belong to groups that are nested\n     * inside the current one. We filter out only the tabs that belong to this group in `_tabs`.\n     */\n    abstract _allTabs: QueryList<MatTab>;\n    abstract _tabBodyWrapper: ElementRef;\n    abstract _tabHeader: MatTabGroupBaseHeader;\n    /** All of the tabs that belong to the group. */\n    _tabs: QueryList<MatTab>;\n    /** The tab index that should be selected after the content has been checked. */\n    private _indexToSelect;\n    /** Index of the tab that was focused last. */\n    private _lastFocusedTabIndex;\n    /** Snapshot of the height of the tab body wrapper before another tab is activated. */\n    private _tabBodyWrapperHeight;\n    /** Subscription to tabs being added/removed. */\n    private _tabsSubscription;\n    /** Subscription to changes in the tab labels. */\n    private _tabLabelSubscription;\n    /** Whether the tab group should grow to the size of the active tab. */\n    get dynamicHeight(): boolean;\n    set dynamicHeight(value: BooleanInput);\n    private _dynamicHeight;\n    /** The index of the active tab. */\n    get selectedIndex(): number | null;\n    set selectedIndex(value: NumberInput);\n    private _selectedIndex;\n    /** Position of the tab header. */\n    headerPosition: MatTabHeaderPosition;\n    /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n    get animationDuration(): string;\n    set animationDuration(value: NumberInput);\n    private _animationDuration;\n    /**\n     * `tabindex` to be set on the inner element that wraps the tab content. Can be used for improved\n     * accessibility when the tab does not have focusable elements or if it has scrollable content.\n     * The `tabindex` will be removed automatically for inactive tabs.\n     * Read more at https://www.w3.org/TR/wai-aria-practices/examples/tabs/tabs-2/tabs.html\n     */\n    get contentTabIndex(): number | null;\n    set contentTabIndex(value: NumberInput);\n    private _contentTabIndex;\n    /**\n     * Whether pagination should be disabled. This can be used to avoid unnecessary\n     * layout recalculations if it's known that pagination won't be required.\n     */\n    get disablePagination(): boolean;\n    set disablePagination(value: BooleanInput);\n    private _disablePagination;\n    /**\n     * By default tabs remove their content from the DOM while it's off-screen.\n     * Setting this to `true` will keep it in the DOM which will prevent elements\n     * like iframes and videos from reloading next time it comes back into the view.\n     */\n    get preserveContent(): boolean;\n    set preserveContent(value: BooleanInput);\n    private _preserveContent;\n    /** Background color of the tab group. */\n    get backgroundColor(): ThemePalette;\n    set backgroundColor(value: ThemePalette);\n    private _backgroundColor;\n    /** Output to enable support for two-way binding on `[(selectedIndex)]` */\n    readonly selectedIndexChange: EventEmitter<number>;\n    /** Event emitted when focus has changed within a tab group. */\n    readonly focusChange: EventEmitter<MatTabChangeEvent>;\n    /** Event emitted when the body animation has completed */\n    readonly animationDone: EventEmitter<void>;\n    /** Event emitted when the tab selection has changed. */\n    readonly selectedTabChange: EventEmitter<MatTabChangeEvent>;\n    private _groupId;\n    constructor(elementRef: ElementRef, _changeDetectorRef: ChangeDetectorRef, defaultConfig?: MatTabsConfig, _animationMode?: string | undefined);\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     */\n    ngAfterContentChecked(): void;\n    ngAfterContentInit(): void;\n    /** Listens to changes in all of the tabs. */\n    private _subscribeToAllTabChanges;\n    ngOnDestroy(): void;\n    /** Re-aligns the ink bar to the selected tab element. */\n    realignInkBar(): void;\n    /**\n     * Recalculates the tab group's pagination dimensions.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance. It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     */\n    updatePagination(): void;\n    /**\n     * Sets focus to a particular tab.\n     * @param index Index of the tab to be focused.\n     */\n    focusTab(index: number): void;\n    _focusChanged(index: number): void;\n    private _createChangeEvent;\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     */\n    private _subscribeToTabLabels;\n    /** Clamps the given index to the bounds of 0 and the tabs length. */\n    private _clampTabIndex;\n    /** Returns a unique id for each tab label element */\n    _getTabLabelId(i: number): string;\n    /** Returns a unique id for each tab content element */\n    _getTabContentId(i: number): string;\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     */\n    _setTabBodyWrapperHeight(tabHeight: number): void;\n    /** Removes the height of the tab body wrapper. */\n    _removeTabBodyWrapperHeight(): void;\n    /** Handle click events, setting new selected index if appropriate. */\n    _handleClick(tab: MatTab, tabHeader: MatTabGroupBaseHeader, index: number): void;\n    /** Retrieves the tabindex for the tab. */\n    _getTabIndex(tab: MatTab, index: number): number | null;\n    /** Callback for when the focused state of a tab has changed. */\n    _tabFocusChanged(focusOrigin: FocusOrigin, index: number): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatTabGroupBase, [null, null, { optional: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatTabGroupBase, never, never, { \"dynamicHeight\": \"dynamicHeight\"; \"selectedIndex\": \"selectedIndex\"; \"headerPosition\": \"headerPosition\"; \"animationDuration\": \"animationDuration\"; \"contentTabIndex\": \"contentTabIndex\"; \"disablePagination\": \"disablePagination\"; \"preserveContent\": \"preserveContent\"; \"backgroundColor\": \"backgroundColor\"; }, { \"selectedIndexChange\": \"selectedIndexChange\"; \"focusChange\": \"focusChange\"; \"animationDone\": \"animationDone\"; \"selectedTabChange\": \"selectedTabChange\"; }, never, never, false>;\n}\n\ndeclare interface MatTabGroupBaseHeader {\n    _alignInkBarToSelectedTab(): void;\n    updatePagination(): void;\n    focusIndex: number;\n}\n\n/** @docs-private */\ndeclare const _MatTabGroupMixinBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * @docs-private\n */\nexport declare class MatTabHeader extends _MatTabHeaderBase {\n    _items: QueryList<MatTabLabelWrapper>;\n    _inkBar: MatInkBar;\n    _tabListContainer: ElementRef;\n    _tabList: ElementRef;\n    _tabListInner: ElementRef;\n    _nextPaginator: ElementRef<HTMLElement>;\n    _previousPaginator: ElementRef<HTMLElement>;\n    constructor(elementRef: ElementRef, changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, dir: Directionality, ngZone: NgZone, platform: Platform, animationMode?: string);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabHeader, [null, null, null, { optional: true; }, null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTabHeader, \"mat-tab-header\", never, { \"selectedIndex\": \"selectedIndex\"; }, { \"selectFocusedIndex\": \"selectFocusedIndex\"; \"indexFocused\": \"indexFocused\"; }, [\"_items\"], [\"*\"], false>;\n}\n\n/**\n * Base class with all of the `MatTabHeader` functionality.\n * @docs-private\n */\nexport declare abstract class _MatTabHeaderBase extends MatPaginatedTabHeader implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy {\n    /** Whether the ripple effect is disabled or not. */\n    get disableRipple(): boolean;\n    set disableRipple(value: BooleanInput);\n    private _disableRipple;\n    constructor(elementRef: ElementRef, changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, dir: Directionality, ngZone: NgZone, platform: Platform, animationMode?: string);\n    protected _itemSelected(event: KeyboardEvent): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatTabHeaderBase, [null, null, null, { optional: true; }, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatTabHeaderBase, never, never, { \"disableRipple\": \"disableRipple\"; }, {}, never, never, false>;\n}\n\n/** Possible positions for the tab header. */\nexport declare type MatTabHeaderPosition = 'above' | 'below';\n\n/** Used to flag tab labels for use with the portal directive */\nexport declare class MatTabLabel extends CdkPortal {\n    _closestTab: any;\n    constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef, _closestTab: any);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabLabel, [null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTabLabel, \"[mat-tab-label], [matTabLabel]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Used in the `mat-tab-group` view to display tab labels.\n * @docs-private\n */\nexport declare class MatTabLabelWrapper extends _MatTabLabelWrapperBase implements CanDisable {\n    elementRef: ElementRef;\n    constructor(elementRef: ElementRef);\n    /** Sets focus on the wrapper element */\n    focus(): void;\n    getOffsetLeft(): number;\n    getOffsetWidth(): number;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabLabelWrapper, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTabLabelWrapper, \"[matTabLabelWrapper]\", never, { \"disabled\": \"disabled\"; }, {}, never, never, false>;\n}\n\n/** @docs-private */\ndeclare const _MatTabLabelWrapperBase: _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (): {};\n};\n\n/**\n * Link inside of a `mat-tab-nav-bar`.\n */\nexport declare class MatTabLink extends _MatTabLinkBase implements OnDestroy {\n    /** Reference to the RippleRenderer for the tab-link. */\n    private _tabLinkRipple;\n    constructor(tabNavBar: MatTabNav, elementRef: ElementRef, ngZone: NgZone, platform: Platform, globalRippleOptions: RippleGlobalOptions | null, tabIndex: string, focusMonitor: FocusMonitor, animationMode?: string);\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabLink, [null, null, null, null, { optional: true; }, { attribute: \"tabindex\"; }, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTabLink, \"[mat-tab-link], [matTabLink]\", [\"matTabLink\"], { \"disabled\": \"disabled\"; \"disableRipple\": \"disableRipple\"; \"tabIndex\": \"tabIndex\"; }, {}, never, never, false>;\n}\n\n/** Base class with all of the `MatTabLink` functionality. */\nexport declare class _MatTabLinkBase extends _MatTabLinkMixinBase implements AfterViewInit, OnDestroy, CanDisable, CanDisableRipple, HasTabIndex, RippleTarget, FocusableOption {\n    private _tabNavBar;\n    /** @docs-private */ elementRef: ElementRef;\n    private _focusMonitor;\n    /** Whether the tab link is active or not. */\n    protected _isActive: boolean;\n    /** Whether the link is active. */\n    get active(): boolean;\n    set active(value: BooleanInput);\n    /**\n     * Ripple configuration for ripples that are launched on pointer down. The ripple config\n     * is set to the global ripple options since we don't have any configurable options for\n     * the tab link ripples.\n     * @docs-private\n     */\n    rippleConfig: RippleConfig & RippleGlobalOptions;\n    /**\n     * Whether ripples are disabled on interaction.\n     * @docs-private\n     */\n    get rippleDisabled(): boolean;\n    /** Unique id for the tab. */\n    id: string;\n    constructor(_tabNavBar: _MatTabNavBase, \n    /** @docs-private */ elementRef: ElementRef, globalRippleOptions: RippleGlobalOptions | null, tabIndex: string, _focusMonitor: FocusMonitor, animationMode?: string);\n    /** Focuses the tab link. */\n    focus(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    _handleFocus(): void;\n    _handleKeydown(event: KeyboardEvent): void;\n    _getAriaControls(): string | null;\n    _getAriaSelected(): string | null;\n    _getAriaCurrent(): string | null;\n    _getRole(): string | null;\n    _getTabIndex(): number;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatTabLinkBase, [null, null, { optional: true; }, { attribute: \"tabindex\"; }, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatTabLinkBase, never, never, { \"active\": \"active\"; \"id\": \"id\"; }, {}, never, never, false>;\n}\n\ndeclare const _MatTabLinkMixinBase: _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & _Constructor<CanDisableRipple> & _AbstractConstructor<CanDisableRipple> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & {\n    new (): {};\n};\n\n/**\n * Navigation component matching the styles of the tab group header.\n * Provides anchored navigation with animated ink bar.\n */\nexport declare class MatTabNav extends _MatTabNavBase {\n    _items: QueryList<MatTabLink>;\n    _inkBar: MatInkBar;\n    _tabListContainer: ElementRef;\n    _tabList: ElementRef;\n    _tabListInner: ElementRef;\n    _nextPaginator: ElementRef<HTMLElement>;\n    _previousPaginator: ElementRef<HTMLElement>;\n    constructor(elementRef: ElementRef, dir: Directionality, ngZone: NgZone, changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, platform: Platform, animationMode?: string);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabNav, [null, { optional: true; }, null, null, null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTabNav, \"[mat-tab-nav-bar]\", [\"matTabNavBar\", \"matTabNav\"], { \"color\": \"color\"; }, {}, [\"_items\"], [\"*\"], false>;\n}\n\n/**\n * Base class with all of the `MatTabNav` functionality.\n * @docs-private\n */\nexport declare abstract class _MatTabNavBase extends MatPaginatedTabHeader implements AfterContentChecked, AfterContentInit, OnDestroy {\n    /** Query list of all tab links of the tab navigation. */\n    abstract _items: QueryList<MatPaginatedTabHeaderItem & {\n        active: boolean;\n        id: string;\n    }>;\n    /** Background color of the tab nav. */\n    get backgroundColor(): ThemePalette;\n    set backgroundColor(value: ThemePalette);\n    private _backgroundColor;\n    /** Whether the ripple effect is disabled or not. */\n    get disableRipple(): boolean;\n    set disableRipple(value: BooleanInput);\n    private _disableRipple;\n    /** Theme color of the nav bar. */\n    color: ThemePalette;\n    /**\n     * Associated tab panel controlled by the nav bar. If not provided, then the nav bar\n     * follows the ARIA link / navigation landmark pattern. If provided, it follows the\n     * ARIA tabs design pattern.\n     */\n    tabPanel?: MatTabNavPanel;\n    constructor(elementRef: ElementRef, dir: Directionality, ngZone: NgZone, changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, platform: Platform, animationMode?: string);\n    protected _itemSelected(): void;\n    ngAfterContentInit(): void;\n    /** Notifies the component that the active link has been changed. */\n    updateActiveLink(): void;\n    _getRole(): string | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatTabNavBase, [null, { optional: true; }, null, null, null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatTabNavBase, never, never, { \"backgroundColor\": \"backgroundColor\"; \"disableRipple\": \"disableRipple\"; \"color\": \"color\"; \"tabPanel\": \"tabPanel\"; }, {}, never, never, false>;\n}\n\n/**\n * Tab panel component associated with MatTabNav.\n */\nexport declare class MatTabNavPanel {\n    /** Unique id for the tab panel. */\n    id: string;\n    /** Id of the active tab in the nav bar. */\n    _activeTabId?: string;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabNavPanel, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTabNavPanel, \"mat-tab-nav-panel\", [\"matTabNavPanel\"], { \"id\": \"id\"; }, {}, never, [\"*\"], false>;\n}\n\n/**\n * Animations used by the Material tabs.\n * @docs-private\n */\nexport declare const matTabsAnimations: {\n    readonly translateTab: AnimationTriggerMetadata;\n};\n\n/** Object that can be used to configure the default options for the tabs module. */\nexport declare interface MatTabsConfig {\n    /** Duration for the tab animation. Must be a valid CSS value (e.g. 600ms). */\n    animationDuration?: string;\n    /**\n     * Whether pagination should be disabled. This can be used to avoid unnecessary\n     * layout recalculations if it's known that pagination won't be required.\n     */\n    disablePagination?: boolean;\n    /**\n     * Whether the ink bar should fit its width to the size of the tab label content.\n     * This only applies to the MDC-based tabs.\n     */\n    fitInkBarToContent?: boolean;\n    /** Whether the tab group should grow to the size of the active tab. */\n    dynamicHeight?: boolean;\n    /** `tabindex` to be set on the inner element that wraps the tab content. */\n    contentTabIndex?: number;\n    /**\n     * By default tabs remove their content from the DOM while it's off-screen.\n     * Setting this to `true` will keep it in the DOM which will prevent elements\n     * like iframes and videos from reloading next time it comes back into the view.\n     */\n    preserveContent?: boolean;\n}\n\nexport declare class MatTabsModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTabsModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatTabsModule, [typeof i1.MatTabGroup, typeof i2.MatTabLabel, typeof i3.MatTab, typeof i4.MatInkBar, typeof i5.MatTabLabelWrapper, typeof i6.MatTabNav, typeof i6.MatTabNavPanel, typeof i6.MatTabLink, typeof i7.MatTabBody, typeof i7.MatTabBodyPortal, typeof i8.MatTabHeader, typeof i9.MatTabContent], [typeof i10.CommonModule, typeof i11.MatCommonModule, typeof i12.PortalModule, typeof i11.MatRippleModule, typeof i13.ObserversModule, typeof i14.A11yModule], [typeof i11.MatCommonModule, typeof i1.MatTabGroup, typeof i2.MatTabLabel, typeof i3.MatTab, typeof i6.MatTabNav, typeof i6.MatTabNavPanel, typeof i6.MatTabLink, typeof i9.MatTabContent]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatTabsModule>;\n}\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport declare type ScrollDirection = 'after' | 'before';\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/tabs/testing/index.d.ts",
      "node_modules/@angular/material/tabs/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessLoader } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-tab-group in tests. */\nexport declare class MatTabGroupHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatTabGroup` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatTabGroupHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which tab group instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TabGroupHarnessFilters): HarnessPredicate<MatTabGroupHarness>;\n    /**\n     * Gets the list of tabs in the tab group.\n     * @param filter Optionally filters which tabs are included.\n     */\n    getTabs(filter?: TabHarnessFilters): Promise<MatTabHarness[]>;\n    /** Gets the selected tab of the tab group. */\n    getSelectedTab(): Promise<MatTabHarness>;\n    /**\n     * Selects a tab in this tab group.\n     * @param filter An optional filter to apply to the child tabs. The first tab matching the filter\n     *     will be selected.\n     */\n    selectTab(filter?: TabHarnessFilters): Promise<void>;\n}\n\n/** Harness for interacting with a standard Angular Material tab-label in tests. */\nexport declare class MatTabHarness extends ContentContainerComponentHarness<string> {\n    /** The selector for the host element of a `MatTab` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatTabHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which tab instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TabHarnessFilters): HarnessPredicate<MatTabHarness>;\n    /** Gets the label of the tab. */\n    getLabel(): Promise<string>;\n    /** Gets the aria-label of the tab. */\n    getAriaLabel(): Promise<string | null>;\n    /** Gets the value of the \"aria-labelledby\" attribute. */\n    getAriaLabelledby(): Promise<string | null>;\n    /** Whether the tab is selected. */\n    isSelected(): Promise<boolean>;\n    /** Whether the tab is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Selects the given tab by clicking on the label. Tab cannot be selected if disabled. */\n    select(): Promise<void>;\n    /** Gets the text content of the tab. */\n    getTextContent(): Promise<string>;\n    protected getRootHarnessLoader(): Promise<HarnessLoader>;\n    /** Gets the element id for the content of the current tab. */\n    private _getContentId;\n}\n\n/** Harness for interacting with a standard Angular Material tab link in tests. */\nexport declare class MatTabLinkHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatTabLink` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatTabLinkHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which tab link instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TabLinkHarnessFilters): HarnessPredicate<MatTabLinkHarness>;\n    /** Gets the label of the link. */\n    getLabel(): Promise<string>;\n    /** Whether the link is active. */\n    isActive(): Promise<boolean>;\n    /** Whether the link is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Clicks on the link. */\n    click(): Promise<void>;\n}\n\n/** Harness for interacting with a standard mat-tab-nav-bar in tests. */\nexport declare class MatTabNavBarHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatTabNavBar` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatTabNavBar` that meets\n     * certain criteria.\n     * @param options Options for filtering which tab nav bar instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TabNavBarHarnessFilters): HarnessPredicate<MatTabNavBarHarness>;\n    /**\n     * Gets the list of links in the nav bar.\n     * @param filter Optionally filters which links are included.\n     */\n    getLinks(filter?: TabLinkHarnessFilters): Promise<MatTabLinkHarness[]>;\n    /** Gets the active link in the nav bar. */\n    getActiveLink(): Promise<MatTabLinkHarness>;\n    /**\n     * Clicks a link inside the nav bar.\n     * @param filter An optional filter to apply to the child link. The first link matching the filter\n     *     will be clicked.\n     */\n    clickLink(filter?: TabLinkHarnessFilters): Promise<void>;\n    /** Gets the panel associated with the nav bar. */\n    getPanel(): Promise<MatTabNavPanelHarness>;\n}\n\n/** Harness for interacting with a standard mat-tab-nav-panel in tests. */\ndeclare class MatTabNavPanelHarness extends ContentContainerComponentHarness {\n    /** The selector for the host element of a `MatTabNavPanel` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatTabNavPanel` that meets\n     * certain criteria.\n     * @param options Options for filtering which tab nav panel instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TabNavPanelHarnessFilters): HarnessPredicate<MatTabNavPanelHarness>;\n    /** Gets the tab panel text content. */\n    getTextContent(): Promise<string>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatTabGroupHarness` instances. */\nexport declare interface TabGroupHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose selected tab label matches the given value. */\n    selectedTabLabel?: string | RegExp;\n}\n\n/** A set of criteria that can be used to filter a list of `MatTabHarness` instances. */\nexport declare interface TabHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose label matches the given value. */\n    label?: string | RegExp;\n}\n\n/** A set of criteria that can be used to filter a list of `MatTabLinkHarness` instances. */\nexport declare interface TabLinkHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose label matches the given value. */\n    label?: string | RegExp;\n}\n\n/** A set of criteria that can be used to filter a list of `MatTabNavBarHarness` instances. */\nexport declare interface TabNavBarHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of `MatTabNavBarHarness` instances. */\nexport declare interface TabNavPanelHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/toolbar/index.d.ts",
      "node_modules/@angular/material/toolbar/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterViewInit } from '@angular/core';\nimport { CanColor } from '@angular/material/core';\nimport { _Constructor } from '@angular/material/core';\nimport { ElementRef } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { QueryList } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        throwToolbarMixedModesError,\n        MatToolbarRow,\n        MatToolbar\n    }\n}\n\nexport declare class MatToolbar extends _MatToolbarBase implements CanColor, AfterViewInit {\n    private _platform;\n    private _document;\n    /** Reference to all toolbar row elements that have been projected. */\n    _toolbarRows: QueryList<MatToolbarRow>;\n    constructor(elementRef: ElementRef, _platform: Platform, document?: any);\n    ngAfterViewInit(): void;\n    /**\n     * Throws an exception when developers are attempting to combine the different toolbar row modes.\n     */\n    private _checkToolbarMixedModes;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatToolbar, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatToolbar, \"mat-toolbar\", [\"matToolbar\"], { \"color\": \"color\"; }, {}, [\"_toolbarRows\"], [\"*\", \"mat-toolbar-row\"], false>;\n}\n\n/** @docs-private */\ndeclare const _MatToolbarBase: _Constructor<CanColor> & _AbstractConstructor<CanColor> & {\n    new (_elementRef: ElementRef): {\n        _elementRef: ElementRef;\n    };\n};\n\nexport declare class MatToolbarModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatToolbarModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatToolbarModule, [typeof i1.MatToolbar, typeof i1.MatToolbarRow], [typeof i2.MatCommonModule], [typeof i1.MatToolbar, typeof i1.MatToolbarRow, typeof i2.MatCommonModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatToolbarModule>;\n}\n\nexport declare class MatToolbarRow {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatToolbarRow, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatToolbarRow, \"mat-toolbar-row\", [\"matToolbarRow\"], {}, {}, never, never, false>;\n}\n\n/**\n * Throws an exception when attempting to combine the different toolbar row modes.\n * @docs-private\n */\nexport declare function throwToolbarMixedModesError(): void;\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/toolbar/testing/index.d.ts",
      "node_modules/@angular/material/toolbar/testing/index.d.ts"
    ],
    "content": "import { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-toolbar in tests. */\nexport declare class MatToolbarHarness extends ContentContainerComponentHarness<MatToolbarSection> {\n    static hostSelector: string;\n    private _getRows;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatToolbarHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which card instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: ToolbarHarnessFilters): HarnessPredicate<MatToolbarHarness>;\n    /** Whether the toolbar has multiple rows. */\n    hasMultipleRows(): Promise<boolean>;\n    /** Gets all of the toolbar's content as text. */\n    private _getText;\n    /** Gets the text of each row in the toolbar. */\n    getRowsAsText(): Promise<string[]>;\n}\n\n/** Selectors for different sections of the mat-toolbar that contain user content. */\nexport declare const enum MatToolbarSection {\n    ROW = \".mat-toolbar-row\"\n}\n\n/** A set of criteria that can be used to filter a list of `MatToolbarHarness` instances. */\nexport declare interface ToolbarHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/tooltip/index.d.ts",
      "node_modules/@angular/material/tooltip/index.d.ts"
    ],
    "content": "import { AfterViewInit } from '@angular/core';\nimport { AnimationTriggerMetadata } from '@angular/animations';\nimport { AriaDescriber } from '@angular/cdk/a11y';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { BreakpointObserver } from '@angular/cdk/layout';\nimport { BreakpointState } from '@angular/cdk/layout';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ComponentType } from '@angular/cdk/portal';\nimport { ConnectedPosition } from '@angular/cdk/overlay';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ElementRef } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport * as i2 from '@angular/cdk/a11y';\nimport * as i3 from '@angular/common';\nimport * as i4 from '@angular/cdk/overlay';\nimport * as i5 from '@angular/material/core';\nimport * as i6 from '@angular/cdk/scrolling';\nimport { InjectionToken } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { OriginConnectionPosition } from '@angular/cdk/overlay';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { OverlayConnectionPosition } from '@angular/cdk/overlay';\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { Platform } from '@angular/cdk/platform';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { ScrollStrategy } from '@angular/cdk/overlay';\nimport { ViewContainerRef } from '@angular/core';\n\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @docs-private\n */\nexport declare function getMatTooltipInvalidPositionError(position: string): Error;\n\ndeclare namespace i1 {\n    export {\n        getMatTooltipInvalidPositionError,\n        MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,\n        MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY,\n        TooltipPosition,\n        TooltipTouchGestures,\n        TooltipVisibility,\n        SCROLL_THROTTLE_MS,\n        TOOLTIP_PANEL_CLASS,\n        MAT_TOOLTIP_SCROLL_STRATEGY,\n        MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER,\n        MatTooltipDefaultOptions,\n        MAT_TOOLTIP_DEFAULT_OPTIONS,\n        _MatTooltipBase,\n        MatTooltip,\n        _TooltipComponentBase,\n        TooltipComponent\n    }\n}\n\n/** Injection token to be used to override the default options for `matTooltip`. */\nexport declare const MAT_TOOLTIP_DEFAULT_OPTIONS: InjectionToken<MatTooltipDefaultOptions>;\n\n/** @docs-private */\nexport declare function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY(): MatTooltipDefaultOptions;\n\n/** Injection token that determines the scroll handling while a tooltip is visible. */\nexport declare const MAT_TOOLTIP_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n\n/** @docs-private */\nexport declare function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\n\n/** @docs-private */\nexport declare const MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY;\n};\n\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.io/design/components/tooltips.html\n */\nexport declare class MatTooltip extends _MatTooltipBase<TooltipComponent> {\n    protected readonly _tooltipComponent: typeof TooltipComponent;\n    constructor(overlay: Overlay, elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, viewContainerRef: ViewContainerRef, ngZone: NgZone, platform: Platform, ariaDescriber: AriaDescriber, focusMonitor: FocusMonitor, scrollStrategy: any, dir: Directionality, defaultOptions: MatTooltipDefaultOptions, _document: any);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTooltip, [null, null, null, null, null, null, null, null, null, { optional: true; }, { optional: true; }, null]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTooltip, \"[matTooltip]\", [\"matTooltip\"], {}, {}, never, never, false>;\n}\n\n/**\n * Animations used by MatTooltip.\n * @docs-private\n */\nexport declare const matTooltipAnimations: {\n    readonly tooltipState: AnimationTriggerMetadata;\n};\n\nexport declare abstract class _MatTooltipBase<T extends _TooltipComponentBase> implements OnDestroy, AfterViewInit {\n    private _overlay;\n    private _elementRef;\n    private _scrollDispatcher;\n    private _viewContainerRef;\n    private _ngZone;\n    private _platform;\n    private _ariaDescriber;\n    private _focusMonitor;\n    protected _dir: Directionality;\n    private _defaultOptions;\n    _overlayRef: OverlayRef | null;\n    _tooltipInstance: T | null;\n    private _portal;\n    private _position;\n    private _disabled;\n    private _tooltipClass;\n    private _scrollStrategy;\n    private _viewInitialized;\n    private _pointerExitEventsInitialized;\n    protected abstract readonly _tooltipComponent: ComponentType<T>;\n    protected _viewportMargin: number;\n    private _currentPosition;\n    protected readonly _cssClassPrefix: string;\n    /** Allows the user to define the position of the tooltip relative to the parent element */\n    get position(): TooltipPosition;\n    set position(value: TooltipPosition);\n    /** Disables the display of the tooltip. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    /** The default delay in ms before showing the tooltip after show is called */\n    get showDelay(): number;\n    set showDelay(value: NumberInput);\n    private _showDelay;\n    /** The default delay in ms before hiding the tooltip after hide is called */\n    get hideDelay(): number;\n    set hideDelay(value: NumberInput);\n    private _hideDelay;\n    /**\n     * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive\n     * uses a long press gesture to show and hide, however it can conflict with the native browser\n     * gestures. To work around the conflict, Angular Material disables native gestures on the\n     * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable\n     * elements). The different values for this option configure the touch event handling as follows:\n     * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native\n     *   browser gestures on particular elements. In particular, it allows text selection on inputs\n     *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.\n     * - `on` - Enables touch gestures for all elements and disables native\n     *   browser gestures with no exceptions.\n     * - `off` - Disables touch gestures. Note that this will prevent the tooltip from\n     *   showing on touch devices.\n     */\n    touchGestures: TooltipTouchGestures;\n    /** The message to be displayed in the tooltip */\n    get message(): string;\n    set message(value: string);\n    private _message;\n    /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\n    get tooltipClass(): string | string[] | Set<string> | {\n        [key: string]: any;\n    };\n    set tooltipClass(value: string | string[] | Set<string> | {\n        [key: string]: any;\n    });\n    /** Manually-bound passive event listeners. */\n    private readonly _passiveListeners;\n    /** Reference to the current document. */\n    private _document;\n    /** Timer started at the last `touchstart` event. */\n    private _touchstartTimeout;\n    /** Emits when the component is destroyed. */\n    private readonly _destroyed;\n    constructor(_overlay: Overlay, _elementRef: ElementRef<HTMLElement>, _scrollDispatcher: ScrollDispatcher, _viewContainerRef: ViewContainerRef, _ngZone: NgZone, _platform: Platform, _ariaDescriber: AriaDescriber, _focusMonitor: FocusMonitor, scrollStrategy: any, _dir: Directionality, _defaultOptions: MatTooltipDefaultOptions, _document: any);\n    ngAfterViewInit(): void;\n    /**\n     * Dispose the tooltip when destroyed.\n     */\n    ngOnDestroy(): void;\n    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\n    show(delay?: number): void;\n    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\n    hide(delay?: number): void;\n    /** Shows/hides the tooltip */\n    toggle(): void;\n    /** Returns true if the tooltip is currently visible to the user */\n    _isTooltipVisible(): boolean;\n    /** Create the overlay config and position strategy */\n    private _createOverlay;\n    /** Detaches the currently-attached tooltip. */\n    private _detach;\n    /** Updates the position of the current tooltip. */\n    private _updatePosition;\n    /** Adds the configured offset to a position. Used as a hook for child classes. */\n    protected _addOffset(position: ConnectedPosition): ConnectedPosition;\n    /**\n     * Returns the origin position and a fallback position based on the user's position preference.\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n     */\n    _getOrigin(): {\n        main: OriginConnectionPosition;\n        fallback: OriginConnectionPosition;\n    };\n    /** Returns the overlay position and a fallback position based on the user's preference */\n    _getOverlayPosition(): {\n        main: OverlayConnectionPosition;\n        fallback: OverlayConnectionPosition;\n    };\n    /** Updates the tooltip message and repositions the overlay according to the new message length */\n    private _updateTooltipMessage;\n    /** Updates the tooltip class */\n    private _setTooltipClass;\n    /** Inverts an overlay position. */\n    private _invertPosition;\n    /** Updates the class on the overlay panel based on the current position of the tooltip. */\n    private _updateCurrentPositionClass;\n    /** Binds the pointer events to the tooltip trigger. */\n    private _setupPointerEnterEventsIfNeeded;\n    private _setupPointerExitEventsIfNeeded;\n    private _addListeners;\n    private _platformSupportsMouseEvents;\n    /** Listener for the `wheel` event on the element. */\n    private _wheelListener;\n    /** Disables the native browser gestures, based on how the tooltip has been configured. */\n    private _disableNativeGesturesIfNecessary;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_MatTooltipBase<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatTooltipBase<any>, never, never, { \"position\": \"matTooltipPosition\"; \"disabled\": \"matTooltipDisabled\"; \"showDelay\": \"matTooltipShowDelay\"; \"hideDelay\": \"matTooltipHideDelay\"; \"touchGestures\": \"matTooltipTouchGestures\"; \"message\": \"matTooltip\"; \"tooltipClass\": \"matTooltipClass\"; }, {}, never, never, false>;\n}\n\n/** Default `matTooltip` options that can be overridden. */\nexport declare interface MatTooltipDefaultOptions {\n    /** Default delay when the tooltip is shown. */\n    showDelay: number;\n    /** Default delay when the tooltip is hidden. */\n    hideDelay: number;\n    /** Default delay when hiding the tooltip on a touch device. */\n    touchendHideDelay: number;\n    /** Default touch gesture handling for tooltips. */\n    touchGestures?: TooltipTouchGestures;\n    /** Default position for tooltips. */\n    position?: TooltipPosition;\n    /** Disables the ability for the user to interact with the tooltip element. */\n    disableTooltipInteractivity?: boolean;\n}\n\nexport declare class MatTooltipModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTooltipModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatTooltipModule, [typeof i1.MatTooltip, typeof i1.TooltipComponent], [typeof i2.A11yModule, typeof i3.CommonModule, typeof i4.OverlayModule, typeof i5.MatCommonModule], [typeof i1.MatTooltip, typeof i1.TooltipComponent, typeof i5.MatCommonModule, typeof i6.CdkScrollableModule]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatTooltipModule>;\n}\n\n/** Time in ms to throttle repositioning after scroll events. */\nexport declare const SCROLL_THROTTLE_MS = 20;\n\n/**\n * CSS class that will be attached to the overlay panel.\n * @deprecated\n * @breaking-change 13.0.0 remove this variable\n */\nexport declare const TOOLTIP_PANEL_CLASS = \"mat-tooltip-panel\";\n\n/**\n * Internal component that wraps the tooltip's content.\n * @docs-private\n */\nexport declare class TooltipComponent extends _TooltipComponentBase {\n    private _breakpointObserver;\n    /** Stream that emits whether the user has a handset-sized display.  */\n    _isHandset: Observable<BreakpointState>;\n    _showAnimation: string;\n    _hideAnimation: string;\n    _tooltip: ElementRef<HTMLElement>;\n    constructor(changeDetectorRef: ChangeDetectorRef, _breakpointObserver: BreakpointObserver, animationMode?: string);\n    static ɵfac: i0.ɵɵFactoryDeclaration<TooltipComponent, [null, null, { optional: true; }]>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<TooltipComponent, \"mat-tooltip-component\", never, {}, {}, never, never, false>;\n}\n\nexport declare abstract class _TooltipComponentBase implements OnDestroy {\n    private _changeDetectorRef;\n    /** Message to display in the tooltip */\n    message: string;\n    /** Classes to be added to the tooltip. Supports the same syntax as `ngClass`. */\n    tooltipClass: string | string[] | Set<string> | {\n        [key: string]: any;\n    };\n    /** The timeout ID of any current timer set to show the tooltip */\n    private _showTimeoutId;\n    /** The timeout ID of any current timer set to hide the tooltip */\n    private _hideTimeoutId;\n    /** Element that caused the tooltip to open. */\n    _triggerElement: HTMLElement;\n    /** Amount of milliseconds to delay the closing sequence. */\n    _mouseLeaveHideDelay: number;\n    /** Whether animations are currently disabled. */\n    private _animationsDisabled;\n    /** Reference to the internal tooltip element. */\n    abstract _tooltip: ElementRef<HTMLElement>;\n    /** Whether interactions on the page should close the tooltip */\n    private _closeOnInteraction;\n    /** Whether the tooltip is currently visible. */\n    private _isVisible;\n    /** Subject for notifying that the tooltip has been hidden from the view */\n    private readonly _onHide;\n    /** Name of the show animation and the class that toggles it. */\n    protected abstract readonly _showAnimation: string;\n    /** Name of the hide animation and the class that toggles it. */\n    protected abstract readonly _hideAnimation: string;\n    constructor(_changeDetectorRef: ChangeDetectorRef, animationMode?: string);\n    /**\n     * Shows the tooltip with an animation originating from the provided origin\n     * @param delay Amount of milliseconds to the delay showing the tooltip.\n     */\n    show(delay: number): void;\n    /**\n     * Begins the animation to hide the tooltip after the provided delay in ms.\n     * @param delay Amount of milliseconds to delay showing the tooltip.\n     */\n    hide(delay: number): void;\n    /** Returns an observable that notifies when the tooltip has been hidden from view. */\n    afterHidden(): Observable<void>;\n    /** Whether the tooltip is being displayed. */\n    isVisible(): boolean;\n    ngOnDestroy(): void;\n    /**\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\n     * material design spec.\n     * https://material.io/design/components/tooltips.html#behavior\n     */\n    _handleBodyInteraction(): void;\n    /**\n     * Marks that the tooltip needs to be checked in the next change detection run.\n     * Mainly used for rendering the initial text before positioning a tooltip, which\n     * can be problematic in components with OnPush change detection.\n     */\n    _markForCheck(): void;\n    _handleMouseLeave({ relatedTarget }: MouseEvent): void;\n    /**\n     * Callback for when the timeout in this.show() gets completed.\n     * This method is only needed by the mdc-tooltip, and so it is only implemented\n     * in the mdc-tooltip, not here.\n     */\n    protected _onShow(): void;\n    /** Event listener dispatched when an animation on the tooltip finishes. */\n    _handleAnimationEnd({ animationName }: AnimationEvent): void;\n    /** Cancels any pending animation sequences. */\n    _cancelPendingAnimations(): void;\n    /** Handles the cleanup after an animation has finished. */\n    private _finalizeAnimation;\n    /** Toggles the visibility of the tooltip element. */\n    private _toggleVisibility;\n    static ɵfac: i0.ɵɵFactoryDeclaration<_TooltipComponentBase, [null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<_TooltipComponentBase, never, never, {}, {}, never, never, false>;\n}\n\n/** Possible positions for a tooltip. */\nexport declare type TooltipPosition = 'left' | 'right' | 'above' | 'below' | 'before' | 'after';\n\n/**\n * Options for how the tooltip trigger should handle touch gestures.\n * See `MatTooltip.touchGestures` for more information.\n */\nexport declare type TooltipTouchGestures = 'auto' | 'on' | 'off';\n\n/** Possible visibility states of a tooltip. */\nexport declare type TooltipVisibility = 'initial' | 'visible' | 'hidden';\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/tooltip/testing/index.d.ts",
      "node_modules/@angular/material/tooltip/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-tooltip in tests. */\nexport declare class MatTooltipHarness extends _MatTooltipHarnessBase {\n    protected _optionalPanel: AsyncFactoryFn<TestElement | null>;\n    protected _hiddenClass: string;\n    protected _showAnimationName: string;\n    protected _hideAnimationName: string;\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search\n     * for a tooltip trigger with specific attributes.\n     * @param options Options for narrowing the search.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TooltipHarnessFilters): HarnessPredicate<MatTooltipHarness>;\n}\n\nexport declare abstract class _MatTooltipHarnessBase extends ComponentHarness {\n    protected abstract _optionalPanel: AsyncFactoryFn<TestElement | null>;\n    protected abstract _hiddenClass: string;\n    protected abstract _showAnimationName: string;\n    protected abstract _hideAnimationName: string;\n    /** Shows the tooltip. */\n    show(): Promise<void>;\n    /** Hides the tooltip. */\n    hide(): Promise<void>;\n    /** Gets whether the tooltip is open. */\n    isOpen(): Promise<boolean>;\n    /** Gets a promise for the tooltip panel's text. */\n    getTooltipText(): Promise<string>;\n}\n\n/** A set of criteria that can be used to filter a list of `MatTooltipHarness` instances. */\nexport declare interface TooltipHarnessFilters extends BaseHarnessFilters {\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/tree/index.d.ts",
      "node_modules/@angular/material/tree/index.d.ts"
    ],
    "content": "import { _AbstractConstructor } from '@angular/material/core';\nimport { AfterContentInit } from '@angular/core';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { CanDisable } from '@angular/material/core';\nimport { CdkNestedTreeNode } from '@angular/cdk/tree';\nimport { CdkTree } from '@angular/cdk/tree';\nimport { CdkTreeNode } from '@angular/cdk/tree';\nimport { CdkTreeNodeDef } from '@angular/cdk/tree';\nimport { CdkTreeNodeOutlet } from '@angular/cdk/tree';\nimport { CdkTreeNodePadding } from '@angular/cdk/tree';\nimport { CdkTreeNodeToggle } from '@angular/cdk/tree';\nimport { CollectionViewer } from '@angular/cdk/collections';\nimport { _Constructor } from '@angular/material/core';\nimport { DataSource } from '@angular/cdk/collections';\nimport { ElementRef } from '@angular/core';\nimport { FlatTreeControl } from '@angular/cdk/tree';\nimport { HasTabIndex } from '@angular/material/core';\nimport * as i0 from '@angular/core';\nimport * as i6 from '@angular/cdk/tree';\nimport * as i7 from '@angular/material/core';\nimport { IterableDiffers } from '@angular/core';\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { Observable } from 'rxjs';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { TreeControl } from '@angular/cdk/tree';\nimport { ViewContainerRef } from '@angular/core';\n\ndeclare namespace i1 {\n    export {\n        MatTreeNode,\n        MatTreeNodeDef,\n        MatNestedTreeNode\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        MatTreeNodePadding\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        MatTreeNodeToggle\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        MatTree\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        MatTreeNodeOutlet\n    }\n}\n\n/**\n * Wrapper for the CdkTree nested node with Material design styles.\n */\nexport declare class MatNestedTreeNode<T, K = T> extends CdkNestedTreeNode<T, K> implements AfterContentInit, OnDestroy, OnInit {\n    node: T;\n    /** Whether the node is disabled. */\n    get disabled(): boolean;\n    set disabled(value: BooleanInput);\n    private _disabled;\n    /** Tabindex for the node. */\n    get tabIndex(): number;\n    set tabIndex(value: number);\n    private _tabIndex;\n    constructor(elementRef: ElementRef<HTMLElement>, tree: CdkTree<T, K>, differs: IterableDiffers, tabIndex: string);\n    ngOnInit(): void;\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatNestedTreeNode<any, any>, [null, null, null, { attribute: \"tabindex\"; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatNestedTreeNode<any, any>, \"mat-nested-tree-node\", [\"matNestedTreeNode\"], { \"role\": \"role\"; \"disabled\": \"disabled\"; \"tabIndex\": \"tabIndex\"; \"node\": \"matNestedTreeNode\"; }, {}, never, never, false>;\n}\n\n/**\n * Wrapper for the CdkTable with Material design styles.\n */\nexport declare class MatTree<T, K = T> extends CdkTree<T, K> {\n    _nodeOutlet: MatTreeNodeOutlet;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTree<any, any>, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<MatTree<any, any>, \"mat-tree\", [\"matTree\"], {}, {}, never, never, false>;\n}\n\n/**\n * Data source for flat tree.\n * The data source need to handle expansion/collapsion of the tree node and change the data feed\n * to `MatTree`.\n * The nested tree nodes of type `T` are flattened through `MatTreeFlattener`, and converted\n * to type `F` for `MatTree` to consume.\n */\nexport declare class MatTreeFlatDataSource<T, F, K = F> extends DataSource<F> {\n    private _treeControl;\n    private _treeFlattener;\n    private readonly _flattenedData;\n    private readonly _expandedData;\n    get data(): T[];\n    set data(value: T[]);\n    private readonly _data;\n    constructor(_treeControl: FlatTreeControl<F, K>, _treeFlattener: MatTreeFlattener<T, F, K>, initialData?: T[]);\n    connect(collectionViewer: CollectionViewer): Observable<F[]>;\n    disconnect(): void;\n}\n\n/**\n * Tree flattener to convert a normal type of node to node with children & level information.\n * Transform nested nodes of type `T` to flattened nodes of type `F`.\n *\n * For example, the input data of type `T` is nested, and contains its children data:\n *   SomeNode: {\n *     key: 'Fruits',\n *     children: [\n *       NodeOne: {\n *         key: 'Apple',\n *       },\n *       NodeTwo: {\n *        key: 'Pear',\n *      }\n *    ]\n *  }\n *  After flattener flatten the tree, the structure will become\n *  SomeNode: {\n *    key: 'Fruits',\n *    expandable: true,\n *    level: 1\n *  },\n *  NodeOne: {\n *    key: 'Apple',\n *    expandable: false,\n *    level: 2\n *  },\n *  NodeTwo: {\n *   key: 'Pear',\n *   expandable: false,\n *   level: 2\n * }\n * and the output flattened type is `F` with additional information.\n */\nexport declare class MatTreeFlattener<T, F, K = F> {\n    transformFunction: (node: T, level: number) => F;\n    getLevel: (node: F) => number;\n    isExpandable: (node: F) => boolean;\n    getChildren: (node: T) => Observable<T[]> | T[] | undefined | null;\n    constructor(transformFunction: (node: T, level: number) => F, getLevel: (node: F) => number, isExpandable: (node: F) => boolean, getChildren: (node: T) => Observable<T[]> | T[] | undefined | null);\n    _flattenNode(node: T, level: number, resultNodes: F[], parentMap: boolean[]): F[];\n    _flattenChildren(children: T[], level: number, resultNodes: F[], parentMap: boolean[]): void;\n    /**\n     * Flatten a list of node type T to flattened version of node F.\n     * Please note that type T may be nested, and the length of `structuredData` may be different\n     * from that of returned list `F[]`.\n     */\n    flattenNodes(structuredData: T[]): F[];\n    /**\n     * Expand flattened node with current expansion status.\n     * The returned list may have different length.\n     */\n    expandFlattenedNodes(nodes: F[], treeControl: TreeControl<F, K>): F[];\n}\n\nexport declare class MatTreeModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTreeModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<MatTreeModule, [typeof i1.MatNestedTreeNode, typeof i1.MatTreeNodeDef, typeof i2.MatTreeNodePadding, typeof i3.MatTreeNodeToggle, typeof i4.MatTree, typeof i1.MatTreeNode, typeof i5.MatTreeNodeOutlet], [typeof i6.CdkTreeModule, typeof i7.MatCommonModule], [typeof i7.MatCommonModule, typeof i1.MatNestedTreeNode, typeof i1.MatTreeNodeDef, typeof i2.MatTreeNodePadding, typeof i3.MatTreeNodeToggle, typeof i4.MatTree, typeof i1.MatTreeNode, typeof i5.MatTreeNodeOutlet]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<MatTreeModule>;\n}\n\n/**\n * Data source for nested tree.\n *\n * The data source for nested tree doesn't have to consider node flattener, or the way to expand\n * or collapse. The expansion/collapsion will be handled by TreeControl and each non-leaf node.\n */\nexport declare class MatTreeNestedDataSource<T> extends DataSource<T> {\n    /**\n     * Data for the nested tree\n     */\n    get data(): T[];\n    set data(value: T[]);\n    private readonly _data;\n    connect(collectionViewer: CollectionViewer): Observable<T[]>;\n    disconnect(): void;\n}\n\n/**\n * Wrapper for the CdkTree node with Material design styles.\n */\nexport declare class MatTreeNode<T, K = T> extends _MatTreeNodeBase<T, K> implements CanDisable, HasTabIndex, OnInit, OnDestroy {\n    constructor(elementRef: ElementRef<HTMLElement>, tree: CdkTree<T, K>, tabIndex: string);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTreeNode<any, any>, [null, null, { attribute: \"tabindex\"; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTreeNode<any, any>, \"mat-tree-node\", [\"matTreeNode\"], { \"role\": \"role\"; \"disabled\": \"disabled\"; \"tabIndex\": \"tabIndex\"; }, {}, never, never, false>;\n}\n\ndeclare const _MatTreeNodeBase: _Constructor<HasTabIndex> & _AbstractConstructor<HasTabIndex> & _Constructor<CanDisable> & _AbstractConstructor<CanDisable> & typeof CdkTreeNode;\n\n/**\n * Wrapper for the CdkTree node definition with Material design styles.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nexport declare class MatTreeNodeDef<T> extends CdkTreeNodeDef<T> {\n    data: T;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTreeNodeDef<any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTreeNodeDef<any>, \"[matTreeNodeDef]\", never, { \"when\": \"matTreeNodeDefWhen\"; \"data\": \"matTreeNode\"; }, {}, never, never, false>;\n}\n\n/**\n * Outlet for nested CdkNode. Put `[matTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nexport declare class MatTreeNodeOutlet implements CdkTreeNodeOutlet {\n    viewContainer: ViewContainerRef;\n    _node?: any;\n    constructor(viewContainer: ViewContainerRef, _node?: any);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTreeNodeOutlet, [null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTreeNodeOutlet, \"[matTreeNodeOutlet]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * Wrapper for the CdkTree padding with Material design styles.\n */\nexport declare class MatTreeNodePadding<T, K = T> extends CdkTreeNodePadding<T, K> {\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level(): number;\n    set level(value: NumberInput);\n    /** The indent for each level. Default number 40px from material design menu sub-menu spec. */\n    get indent(): number | string;\n    set indent(indent: number | string);\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTreeNodePadding<any, any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTreeNodePadding<any, any>, \"[matTreeNodePadding]\", never, { \"level\": \"matTreeNodePadding\"; \"indent\": \"matTreeNodePaddingIndent\"; }, {}, never, never, false>;\n}\n\n/**\n * Wrapper for the CdkTree's toggle with Material design styles.\n */\nexport declare class MatTreeNodeToggle<T, K = T> extends CdkTreeNodeToggle<T, K> {\n    static ɵfac: i0.ɵɵFactoryDeclaration<MatTreeNodeToggle<any, any>, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MatTreeNodeToggle<any, any>, \"[matTreeNodeToggle]\", never, { \"recursive\": \"matTreeNodeToggleRecursive\"; }, {}, never, never, false>;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/material/tree/testing/index.d.ts",
      "node_modules/@angular/material/tree/testing/index.d.ts"
    ],
    "content": "import { AsyncFactoryFn } from '@angular/cdk/testing';\nimport { BaseHarnessFilters } from '@angular/cdk/testing';\nimport { ComponentHarness } from '@angular/cdk/testing';\nimport { ContentContainerComponentHarness } from '@angular/cdk/testing';\nimport { HarnessPredicate } from '@angular/cdk/testing';\nimport { TestElement } from '@angular/cdk/testing';\n\n/** Harness for interacting with a standard mat-tree in tests. */\nexport declare class MatTreeHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatTableHarness` instance. */\n    static hostSelector: string;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a tree with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TreeHarnessFilters): HarnessPredicate<MatTreeHarness>;\n    /** Gets all of the nodes in the tree. */\n    getNodes(filter?: TreeNodeHarnessFilters): Promise<MatTreeNodeHarness[]>;\n    /**\n     * Gets an object representation for the visible tree structure\n     * If a node is under an unexpanded node it will not be included.\n     * Eg.\n     * Tree (all nodes expanded):\n     * `\n     * <mat-tree>\n     *   <mat-tree-node>Node 1<mat-tree-node>\n     *   <mat-nested-tree-node>\n     *     Node 2\n     *     <mat-nested-tree-node>\n     *       Node 2.1\n     *       <mat-tree-node>\n     *         Node 2.1.1\n     *       <mat-tree-node>\n     *     <mat-nested-tree-node>\n     *     <mat-tree-node>\n     *       Node 2.2\n     *     <mat-tree-node>\n     *   <mat-nested-tree-node>\n     * </mat-tree>`\n     *\n     * Tree structure:\n     * {\n     *  children: [\n     *    {\n     *      text: 'Node 1',\n     *      children: [\n     *        {\n     *          text: 'Node 2',\n     *          children: [\n     *            {\n     *              text: 'Node 2.1',\n     *              children: [{text: 'Node 2.1.1'}]\n     *            },\n     *            {text: 'Node 2.2'}\n     *          ]\n     *        }\n     *      ]\n     *    }\n     *  ]\n     * };\n     */\n    getTreeStructure(): Promise<TextTree>;\n    /**\n     * Recursively collect the structured text of the tree nodes.\n     * @param nodes A list of tree nodes\n     * @param level The level of nodes that are being accounted for during this iteration\n     * @param parentExpanded Whether the parent of the first node in param nodes is expanded\n     */\n    private _getTreeStructure;\n    private _addChildToNode;\n}\n\n/** Harness for interacting with a standard Angular Material tree node. */\nexport declare class MatTreeNodeHarness extends ContentContainerComponentHarness<string> {\n    /** The selector of the host element of a `MatTreeNode` instance. */\n    static hostSelector: string;\n    _toggle: AsyncFactoryFn<TestElement | null>;\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a tree node with specific attributes.\n     * @param options Options for narrowing the search\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options?: TreeNodeHarnessFilters): HarnessPredicate<MatTreeNodeHarness>;\n    /** Whether the tree node is expanded. */\n    isExpanded(): Promise<boolean>;\n    /** Whether the tree node is disabled. */\n    isDisabled(): Promise<boolean>;\n    /** Gets the level of the tree node. Note that this gets the aria-level and is 1 indexed. */\n    getLevel(): Promise<number>;\n    /** Gets the tree node's text. */\n    getText(): Promise<string>;\n    /** Toggles node between expanded/collapsed. Only works when node is not disabled. */\n    toggle(): Promise<void>;\n    /** Expands the node if it is collapsed. Only works when node is not disabled. */\n    expand(): Promise<void>;\n    /** Collapses the node if it is expanded. Only works when node is not disabled. */\n    collapse(): Promise<void>;\n}\n\nexport declare type TextTree = {\n    text?: string;\n    children?: TextTree[];\n};\n\n/** A set of criteria that can be used to filter a list of tree harness instances */\nexport declare interface TreeHarnessFilters extends BaseHarnessFilters {\n}\n\n/** A set of criteria that can be used to filter a list of node harness instances. */\nexport declare interface TreeNodeHarnessFilters extends BaseHarnessFilters {\n    /** Only find instances whose text matches the given value. */\n    text?: string | RegExp;\n    /** Only find instances whose disabled state matches the given value. */\n    disabled?: boolean;\n    /** Only find instances whose expansion state matches the given value. */\n    expanded?: boolean;\n    /** Only find instances whose level matches the given value. */\n    level?: number;\n}\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/@angular/forms/index.d.ts",
      "node_modules/@angular/forms/index.d.ts"
    ],
    "content": "/**\n * @license Angular v14.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\nimport { AfterViewInit } from '@angular/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { ModuleWithProviders } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { StaticProvider } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { Version } from '@angular/core';\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * The first type parameter TValue represents the value type of the control (`control.value`).\n * The optional type parameter TRawValue  represents the raw value type (`control.getRawValue()`).\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n * @publicApi\n */\nexport declare abstract class AbstractControl<TValue = any, TRawValue extends TValue = TValue> {\n    private _parent;\n    private _asyncValidationSubscription;\n    /**\n     * The current value of the control.\n     *\n     * * For a `FormControl`, the current value.\n     * * For an enabled `FormGroup`, the values of enabled controls as an object\n     * with a key-value pair for each member of the group.\n     * * For a disabled `FormGroup`, the values of all controls as an object\n     * with a key-value pair for each member of the group.\n     * * For a `FormArray`, the values of enabled controls as an array.\n     *\n     */\n    readonly value: TValue;\n    /**\n     * Initialize the AbstractControl instance.\n     *\n     * @param validators The function or array of functions that is used to determine the validity of\n     *     this control synchronously.\n     * @param asyncValidators The function or array of functions that is used to determine validity of\n     *     this control asynchronously.\n     */\n    constructor(validators: ValidatorFn | ValidatorFn[] | null, asyncValidators: AsyncValidatorFn | AsyncValidatorFn[] | null);\n    /**\n     * Returns the function that is used to determine the validity of this control synchronously.\n     * If multiple validators have been added, this will be a single composed function.\n     * See `Validators.compose()` for additional information.\n     */\n    get validator(): ValidatorFn | null;\n    set validator(validatorFn: ValidatorFn | null);\n    /**\n     * Returns the function that is used to determine the validity of this control asynchronously.\n     * If multiple validators have been added, this will be a single composed function.\n     * See `Validators.compose()` for additional information.\n     */\n    get asyncValidator(): AsyncValidatorFn | null;\n    set asyncValidator(asyncValidatorFn: AsyncValidatorFn | null);\n    /**\n     * The parent control.\n     */\n    get parent(): FormGroup | FormArray | null;\n    /**\n     * The validation status of the control.\n     *\n     * @see `FormControlStatus`\n     *\n     * These status values are mutually exclusive, so a control cannot be\n     * both valid AND invalid or invalid AND disabled.\n     */\n    readonly status: FormControlStatus;\n    /**\n     * A control is `valid` when its `status` is `VALID`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if the control has passed all of its validation tests,\n     * false otherwise.\n     */\n    get valid(): boolean;\n    /**\n     * A control is `invalid` when its `status` is `INVALID`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if this control has failed one or more of its validation checks,\n     * false otherwise.\n     */\n    get invalid(): boolean;\n    /**\n     * A control is `pending` when its `status` is `PENDING`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if this control is in the process of conducting a validation check,\n     * false otherwise.\n     */\n    get pending(): boolean;\n    /**\n     * A control is `disabled` when its `status` is `DISABLED`.\n     *\n     * Disabled controls are exempt from validation checks and\n     * are not included in the aggregate value of their ancestor\n     * controls.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if the control is disabled, false otherwise.\n     */\n    get disabled(): boolean;\n    /**\n     * A control is `enabled` as long as its `status` is not `DISABLED`.\n     *\n     * @returns True if the control has any status other than 'DISABLED',\n     * false if the status is 'DISABLED'.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     */\n    get enabled(): boolean;\n    /**\n     * An object containing any errors generated by failing validation,\n     * or null if there are no errors.\n     */\n    readonly errors: ValidationErrors | null;\n    /**\n     * A control is `pristine` if the user has not yet changed\n     * the value in the UI.\n     *\n     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n     * Programmatic changes to a control's value do not mark it dirty.\n     */\n    readonly pristine: boolean;\n    /**\n     * A control is `dirty` if the user has changed the value\n     * in the UI.\n     *\n     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n     * Programmatic changes to a control's value do not mark it dirty.\n     */\n    get dirty(): boolean;\n    /**\n     * True if the control is marked as `touched`.\n     *\n     * A control is marked `touched` once the user has triggered\n     * a `blur` event on it.\n     */\n    readonly touched: boolean;\n    /**\n     * True if the control has not been marked as touched\n     *\n     * A control is `untouched` if the user has not yet triggered\n     * a `blur` event on it.\n     */\n    get untouched(): boolean;\n    /**\n     * A multicasting observable that emits an event every time the value of the control changes, in\n     * the UI or programmatically. It also emits an event each time you call enable() or disable()\n     * without passing along {emitEvent: false} as a function argument.\n     */\n    readonly valueChanges: Observable<TValue>;\n    /**\n     * A multicasting observable that emits an event every time the validation `status` of the control\n     * recalculates.\n     *\n     * @see `FormControlStatus`\n     * @see {@link AbstractControl.status}\n     *\n     */\n    readonly statusChanges: Observable<FormControlStatus>;\n    /**\n     * Reports the update strategy of the `AbstractControl` (meaning\n     * the event on which the control updates itself).\n     * Possible values: `'change'` | `'blur'` | `'submit'`\n     * Default value: `'change'`\n     */\n    get updateOn(): FormHooks;\n    /**\n     * Sets the synchronous validators that are active on this control.  Calling\n     * this overwrites any existing synchronous validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * If you want to add a new validator without affecting existing ones, consider\n     * using `addValidators()` method instead.\n     */\n    setValidators(validators: ValidatorFn | ValidatorFn[] | null): void;\n    /**\n     * Sets the asynchronous validators that are active on this control. Calling this\n     * overwrites any existing asynchronous validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * If you want to add a new validator without affecting existing ones, consider\n     * using `addAsyncValidators()` method instead.\n     */\n    setAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[] | null): void;\n    /**\n     * Add a synchronous validator or validators to this control, without affecting other validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * Adding a validator that already exists will have no effect. If duplicate validator functions\n     * are present in the `validators` array, only the first instance would be added to a form\n     * control.\n     *\n     * @param validators The new validator function or functions to add to this control.\n     */\n    addValidators(validators: ValidatorFn | ValidatorFn[]): void;\n    /**\n     * Add an asynchronous validator or validators to this control, without affecting other\n     * validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * Adding a validator that already exists will have no effect.\n     *\n     * @param validators The new asynchronous validator function or functions to add to this control.\n     */\n    addAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;\n    /**\n     * Remove a synchronous validator from this control, without affecting other validators.\n     * Validators are compared by function reference; you must pass a reference to the exact same\n     * validator function as the one that was originally set. If a provided validator is not found,\n     * it is ignored.\n     *\n     * @usageNotes\n     *\n     * ### Reference to a ValidatorFn\n     *\n     * ```\n     * // Reference to the RequiredValidator\n     * const ctrl = new FormControl<string | null>('', Validators.required);\n     * ctrl.removeValidators(Validators.required);\n     *\n     * // Reference to anonymous function inside MinValidator\n     * const minValidator = Validators.min(3);\n     * const ctrl = new FormControl<string | null>('', minValidator);\n     * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n     * expect(ctrl.hasValidator(Validators.min(3)).toEqual(false)\n     *\n     * ctrl.removeValidators(minValidator);\n     * ```\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * @param validators The validator or validators to remove.\n     */\n    removeValidators(validators: ValidatorFn | ValidatorFn[]): void;\n    /**\n     * Remove an asynchronous validator from this control, without affecting other validators.\n     * Validators are compared by function reference; you must pass a reference to the exact same\n     * validator function as the one that was originally set. If a provided validator is not found, it\n     * is ignored.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * @param validators The asynchronous validator or validators to remove.\n     */\n    removeAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;\n    /**\n     * Check whether a synchronous validator function is present on this control. The provided\n     * validator must be a reference to the exact same function that was provided.\n     *\n     * @usageNotes\n     *\n     * ### Reference to a ValidatorFn\n     *\n     * ```\n     * // Reference to the RequiredValidator\n     * const ctrl = new FormControl<number | null>(0, Validators.required);\n     * expect(ctrl.hasValidator(Validators.required)).toEqual(true)\n     *\n     * // Reference to anonymous function inside MinValidator\n     * const minValidator = Validators.min(3);\n     * const ctrl = new FormControl<number | null>(0, minValidator);\n     * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n     * expect(ctrl.hasValidator(Validators.min(3)).toEqual(false)\n     * ```\n     *\n     * @param validator The validator to check for presence. Compared by function reference.\n     * @returns Whether the provided validator was found on this control.\n     */\n    hasValidator(validator: ValidatorFn): boolean;\n    /**\n     * Check whether an asynchronous validator function is present on this control. The provided\n     * validator must be a reference to the exact same function that was provided.\n     *\n     * @param validator The asynchronous validator to check for presence. Compared by function\n     *     reference.\n     * @returns Whether the provided asynchronous validator was found on this control.\n     */\n    hasAsyncValidator(validator: AsyncValidatorFn): boolean;\n    /**\n     * Empties out the synchronous validator list.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     */\n    clearValidators(): void;\n    /**\n     * Empties out the async validator list.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     */\n    clearAsyncValidators(): void;\n    /**\n     * Marks the control as `touched`. A control is touched by focus and\n     * blur events that do not change the value.\n     *\n     * @see `markAsUntouched()`\n     * @see `markAsDirty()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsTouched(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control and all its descendant controls as `touched`.\n     * @see `markAsTouched()`\n     */\n    markAllAsTouched(): void;\n    /**\n     * Marks the control as `untouched`.\n     *\n     * If the control has any children, also marks all children as `untouched`\n     * and recalculates the `touched` status of all parent controls.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsDirty()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after the marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsUntouched(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control as `dirty`. A control becomes dirty when\n     * the control's value is changed through the UI; compare `markAsTouched`.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsUntouched()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsDirty(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control as `pristine`.\n     *\n     * If the control has any children, marks all children as `pristine`,\n     * and recalculates the `pristine` status of all parent\n     * controls.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsUntouched()`\n     * @see `markAsDirty()`\n     *\n     * @param opts Configuration options that determine how the control emits events after\n     * marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsPristine(opts?: {\n        onlySelf?: boolean;\n    }): void;\n    /**\n     * Marks the control as `pending`.\n     *\n     * A control is pending while the control performs async validation.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configuration options that determine how the control propagates changes and\n     * emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n     * observable emits an event with the latest status the control is marked pending.\n     * When false, no events are emitted.\n     *\n     */\n    markAsPending(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Disables the control. This means the control is exempt from validation checks and\n     * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n     *\n     * If the control has children, all children are also disabled.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configuration options that determine how the control propagates\n     * changes and emits events after the control is disabled.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is disabled.\n     * When false, no events are emitted.\n     */\n    disable(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Enables the control. This means the control is included in validation checks and\n     * the aggregate value of its parent. Its status recalculates based on its value and\n     * its validators.\n     *\n     * By default, if the control has children, all children are enabled.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configure options that control how the control propagates changes and\n     * emits events when marked as untouched\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is enabled.\n     * When false, no events are emitted.\n     */\n    enable(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    private _updateAncestors;\n    /**\n     * Sets the parent of the control\n     *\n     * @param parent The new parent.\n     */\n    setParent(parent: FormGroup | FormArray | null): void;\n    /**\n     * Sets the value of the control. Abstract method (implemented in sub-classes).\n     */\n    abstract setValue(value: TRawValue, options?: Object): void;\n    /**\n     * Patches the value of the control. Abstract method (implemented in sub-classes).\n     */\n    abstract patchValue(value: TValue, options?: Object): void;\n    /**\n     * Resets the control. Abstract method (implemented in sub-classes).\n     */\n    abstract reset(value?: TValue, options?: Object): void;\n    /**\n     * The raw value of this control. For most control implementations, the raw value will include\n     * disabled children.\n     */\n    getRawValue(): any;\n    /**\n     * Recalculates the value and validation status of the control.\n     *\n     * By default, it also updates the value and validity of its ancestors.\n     *\n     * @param opts Configuration options determine how the control propagates changes and emits events\n     * after updates and validity checks are applied.\n     * * `onlySelf`: When true, only update this control. When false or not supplied,\n     * update all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is updated.\n     * When false, no events are emitted.\n     */\n    updateValueAndValidity(opts?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    private _setInitialStatus;\n    private _runValidator;\n    private _runAsyncValidator;\n    private _cancelExistingSubscription;\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * @param opts Configuration options that determine how the control propagates\n     * changes and emits events after the control errors are set.\n     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n     * observable emits an event after the errors are set.\n     *\n     * @usageNotes\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    setErrors(errors: ValidationErrors | null, opts?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Retrieves a child control given the control's name or path.\n     *\n     * This signature for get supports strings and `const` arrays (`.get(['foo', 'bar'] as const)`).\n     */\n    get<P extends string | (readonly (string | number)[])>(path: P): AbstractControl<ɵGetProperty<TRawValue, P>> | null;\n    /**\n     * Retrieves a child control given the control's name or path.\n     *\n     * This signature for `get` supports non-const (mutable) arrays. Inferred type\n     * information will not be as robust, so prefer to pass a `readonly` array if possible.\n     */\n    get<P extends string | Array<string | number>>(path: P): AbstractControl<ɵGetProperty<TRawValue, P>> | null;\n    /**\n     * @description\n     * Reports error data for the control with the given path.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode: string, path?: Array<string | number> | string): any;\n    /**\n     * @description\n     * Reports whether the control with the given path has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * If no path is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given path.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\n    /**\n     * Retrieves the top-level ancestor of this control.\n     */\n    get root(): AbstractControl;\n    private _calculateStatus;\n}\n\n/**\n * @description\n * Base class for control directives.\n *\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\n *\n * @publicApi\n */\nexport declare abstract class AbstractControlDirective {\n    /**\n     * @description\n     * A reference to the underlying control.\n     *\n     * @returns the control that backs this directive. Most properties fall through to that instance.\n     */\n    abstract get control(): AbstractControl | null;\n    /**\n     * @description\n     * Reports the value of the control if it is present, otherwise null.\n     */\n    get value(): any;\n    /**\n     * @description\n     * Reports whether the control is valid. A control is considered valid if no\n     * validation errors exist with the current value.\n     * If the control is not present, null is returned.\n     */\n    get valid(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is invalid, meaning that an error exists in the input value.\n     * If the control is not present, null is returned.\n     */\n    get invalid(): boolean | null;\n    /**\n     * @description\n     * Reports whether a control is pending, meaning that that async validation is occurring and\n     * errors are not yet available for the input value. If the control is not present, null is\n     * returned.\n     */\n    get pending(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is disabled, meaning that the control is disabled\n     * in the UI and is exempt from validation checks and excluded from aggregate\n     * values of ancestor controls. If the control is not present, null is returned.\n     */\n    get disabled(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is enabled, meaning that the control is included in ancestor\n     * calculations of validity or value. If the control is not present, null is returned.\n     */\n    get enabled(): boolean | null;\n    /**\n     * @description\n     * Reports the control's validation errors. If the control is not present, null is returned.\n     */\n    get errors(): ValidationErrors | null;\n    /**\n     * @description\n     * Reports whether the control is pristine, meaning that the user has not yet changed\n     * the value in the UI. If the control is not present, null is returned.\n     */\n    get pristine(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is dirty, meaning that the user has changed\n     * the value in the UI. If the control is not present, null is returned.\n     */\n    get dirty(): boolean | null;\n    /**\n     * @description\n     * Reports whether the control is touched, meaning that the user has triggered\n     * a `blur` event on it. If the control is not present, null is returned.\n     */\n    get touched(): boolean | null;\n    /**\n     * @description\n     * Reports the validation status of the control. Possible values include:\n     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\n     * If the control is not present, null is returned.\n     */\n    get status(): string | null;\n    /**\n     * @description\n     * Reports whether the control is untouched, meaning that the user has not yet triggered\n     * a `blur` event on it. If the control is not present, null is returned.\n     */\n    get untouched(): boolean | null;\n    /**\n     * @description\n     * Returns a multicasting observable that emits a validation status whenever it is\n     * calculated for the control. If the control is not present, null is returned.\n     */\n    get statusChanges(): Observable<any> | null;\n    /**\n     * @description\n     * Returns a multicasting observable of value changes for the control that emits every time the\n     * value of the control changes in the UI or programmatically.\n     * If the control is not present, null is returned.\n     */\n    get valueChanges(): Observable<any> | null;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[] | null;\n    /**\n     * Contains the result of merging synchronous validators into a single validator function\n     * (combined using `Validators.compose`).\n     */\n    private _composedValidatorFn;\n    /**\n     * Contains the result of merging asynchronous validators into a single validator function\n     * (combined using `Validators.composeAsync`).\n     */\n    private _composedAsyncValidatorFn;\n    /**\n     * @description\n     * Synchronous validator function composed of all the synchronous validators registered with this\n     * directive.\n     */\n    get validator(): ValidatorFn | null;\n    /**\n     * @description\n     * Asynchronous validator function composed of all the asynchronous validators registered with\n     * this directive.\n     */\n    get asyncValidator(): AsyncValidatorFn | null;\n    private _onDestroyCallbacks;\n    /**\n     * @description\n     * Resets the control with the provided value if the control is present.\n     */\n    reset(value?: any): void;\n    /**\n     * @description\n     * Reports whether the control with the given path has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * If no path is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given path.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\n    /**\n     * @description\n     * Reports error data for the control with the given path.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode: string, path?: Array<string | number> | string): any;\n}\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @publicApi\n */\nexport declare interface AbstractControlOptions {\n    /**\n     * @description\n     * The list of validators applied to a control.\n     */\n    validators?: ValidatorFn | ValidatorFn[] | null;\n    /**\n     * @description\n     * The list of async validators applied to control.\n     */\n    asyncValidators?: AsyncValidatorFn | AsyncValidatorFn[] | null;\n    /**\n     * @description\n     * The event name for control to update upon.\n     */\n    updateOn?: 'change' | 'blur' | 'submit';\n}\n\ndeclare class AbstractControlStatus {\n    private _cd;\n    constructor(cd: AbstractControlDirective | null);\n    protected get isTouched(): boolean;\n    protected get isUntouched(): boolean;\n    protected get isPristine(): boolean;\n    protected get isDirty(): boolean;\n    protected get isValid(): boolean;\n    protected get isInvalid(): boolean;\n    protected get isPending(): boolean;\n    protected get isSubmitted(): boolean;\n}\n\n/**\n * @description\n * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.\n *\n * @publicApi\n */\nexport declare class AbstractFormGroupDirective extends ControlContainer implements OnInit, OnDestroy {\n    /** @nodoc */\n    ngOnInit(): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * The `FormGroup` bound to this directive.\n     */\n    get control(): FormGroup;\n    /**\n     * @description\n     * The path to this group from the top-level directive.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The top-level directive for this group if present, otherwise null.\n     */\n    get formDirective(): Form | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<AbstractFormGroupDirective, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<AbstractFormGroupDirective, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * A base class for Validator-based Directives. The class contains common logic shared across such\n * Directives.\n *\n * For internal use only, this class is not intended for use outside of the Forms package.\n */\ndeclare abstract class AbstractValidatorDirective implements Validator, OnChanges {\n    private _validator;\n    private _onChange;\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /** @nodoc */\n    registerOnValidatorChange(fn: () => void): void;\n    /**\n     * @description\n     * Determines whether this validator should be active or not based on an input.\n     * Base class implementation checks whether an input is defined (if the value is different from\n     * `null` and `undefined`). Validator classes that extend this base class can override this\n     * function with the logic specific to a particular validator directive.\n     */\n    enabled(input: unknown): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<AbstractValidatorDirective, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<AbstractValidatorDirective, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * @description\n * An interface implemented by classes that perform asynchronous validation.\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```typescript\n * import { of } from 'rxjs';\n *\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Observable<ValidationErrors|null> {\n *     return of({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare interface AsyncValidator extends Validator {\n    /**\n     * @description\n     * Method that performs async validation against the provided control.\n     *\n     * @param control The control to validate against.\n     *\n     * @returns A promise or observable that resolves a map of validation errors\n     * if validation fails, otherwise null.\n     */\n    validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\n}\n\n/**\n * @description\n * A function that receives a control and returns a Promise or observable\n * that emits validation errors if present, otherwise null.\n *\n * @publicApi\n */\nexport declare interface AsyncValidatorFn {\n    (control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\n}\n\n/**\n * Base class for all ControlValueAccessor classes defined in Forms package.\n * Contains common logic and utility functions.\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\ndeclare class BaseControlValueAccessor {\n    private _renderer;\n    private _elementRef;\n    /**\n     * The registered callback function called when a change or input event occurs on the input\n     * element.\n     * @nodoc\n     */\n    onChange: (_: any) => void;\n    /**\n     * The registered callback function called when a blur event occurs on the input element.\n     * @nodoc\n     */\n    onTouched: () => void;\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\n    /**\n     * Helper method that sets a property on a target element using the current Renderer\n     * implementation.\n     * @nodoc\n     */\n    protected setProperty(key: string, value: any): void;\n    /**\n     * Registers a function called when the control is touched.\n     * @nodoc\n     */\n    registerOnTouched(fn: () => void): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: any) => {}): void;\n    /**\n     * Sets the \"disabled\" property on the range input element.\n     * @nodoc\n     */\n    setDisabledState(isDisabled: boolean): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<BaseControlValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<BaseControlValueAccessor, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is\n * used in case no other CVAs can be found). We use this class to distinguish between default CVA,\n * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom\n * ones with higher priority (when both built-in and custom CVAs are present).\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\ndeclare class BuiltInControlValueAccessor extends BaseControlValueAccessor {\n    static ɵfac: i0.ɵɵFactoryDeclaration<BuiltInControlValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<BuiltInControlValueAccessor, never, never, {}, {}, never, never, false>;\n}\n\n/**\n * @description\n * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const CHECKBOX_REQUIRED_VALIDATOR: StaticProvider;\n\ndeclare const CHECKBOX_VALUE_ACCESSOR: any;\n\n/**\n * @description\n * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input\n * element.\n *\n * @usageNotes\n *\n * ### Using a checkbox with a reactive form.\n *\n * The following example shows how to use a checkbox with a reactive form.\n *\n * ```ts\n * const rememberLoginControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"checkbox\" [formControl]=\"rememberLoginControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class CheckboxControlValueAccessor extends BuiltInControlValueAccessor implements ControlValueAccessor {\n    /**\n     * Sets the \"checked\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<CheckboxControlValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CheckboxControlValueAccessor, \"input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * A Directive that adds the `required` validator to checkbox controls marked with the\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a required checkbox validator using template-driven forms\n *\n * The following example shows how to add a checkbox required validator to an input attached to an\n * ngModel binding.\n *\n * ```\n * <input type=\"checkbox\" name=\"active\" ngModel required>\n * ```\n *\n * @publicApi\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n */\nexport declare class CheckboxRequiredValidator extends RequiredValidator {\n    static ɵfac: i0.ɵɵFactoryDeclaration<CheckboxRequiredValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<CheckboxRequiredValidator, \"input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * @description\n * Provide this token to control if form directives buffer IME input until\n * the \"compositionend\" event occurs.\n * @publicApi\n */\nexport declare const COMPOSITION_BUFFER_MODE: InjectionToken<boolean>;\n\n/**\n * ControlConfig<T> is a tuple containing a value of type T, plus optional validators and async\n * validators.\n *\n * @publicApi\n */\nexport declare type ControlConfig<T> = [T | FormControlState<T>, (ValidatorFn | (ValidatorFn[]))?, (AsyncValidatorFn | AsyncValidatorFn[])?];\n\n/**\n * @description\n * A base class for directives that contain multiple registered instances of `NgControl`.\n * Only used by the forms module.\n *\n * @publicApi\n */\nexport declare abstract class ControlContainer extends AbstractControlDirective {\n    /**\n     * @description\n     * The name for the control\n     */\n    name: string | number | null;\n    /**\n     * @description\n     * The top-level form directive for the control.\n     */\n    get formDirective(): Form | null;\n    /**\n     * @description\n     * The path to this group.\n     */\n    get path(): string[] | null;\n}\n\ndeclare const controlNameBinding: any;\n\n/**\n * @description\n * Defines an interface that acts as a bridge between the Angular forms API and a\n * native element in the DOM.\n *\n * Implement this interface to create a custom form control directive\n * that integrates with Angular forms.\n *\n * @see DefaultValueAccessor\n *\n * @publicApi\n */\nexport declare interface ControlValueAccessor {\n    /**\n     * @description\n     * Writes a new value to the element.\n     *\n     * This method is called by the forms API to write to the view when programmatic\n     * changes from model to view are requested.\n     *\n     * @usageNotes\n     * ### Write a value to the element\n     *\n     * The following example writes a value to the native DOM element.\n     *\n     * ```ts\n     * writeValue(value: any): void {\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\n     * }\n     * ```\n     *\n     * @param obj The new value for the element\n     */\n    writeValue(obj: any): void;\n    /**\n     * @description\n     * Registers a callback function that is called when the control's value\n     * changes in the UI.\n     *\n     * This method is called by the forms API on initialization to update the form\n     * model when values propagate from the view to the model.\n     *\n     * When implementing the `registerOnChange` method in your own value accessor,\n     * save the given function so your class calls it at the appropriate time.\n     *\n     * @usageNotes\n     * ### Store the change function\n     *\n     * The following example stores the provided function as an internal method.\n     *\n     * ```ts\n     * registerOnChange(fn: (_: any) => void): void {\n     *   this._onChange = fn;\n     * }\n     * ```\n     *\n     * When the value changes in the UI, call the registered\n     * function to allow the forms API to update itself:\n     *\n     * ```ts\n     * host: {\n     *    '(change)': '_onChange($event.target.value)'\n     * }\n     * ```\n     *\n     * @param fn The callback function to register\n     */\n    registerOnChange(fn: any): void;\n    /**\n     * @description\n     * Registers a callback function that is called by the forms API on initialization\n     * to update the form model on blur.\n     *\n     * When implementing `registerOnTouched` in your own value accessor, save the given\n     * function so your class calls it when the control should be considered\n     * blurred or \"touched\".\n     *\n     * @usageNotes\n     * ### Store the callback function\n     *\n     * The following example stores the provided function as an internal method.\n     *\n     * ```ts\n     * registerOnTouched(fn: any): void {\n     *   this._onTouched = fn;\n     * }\n     * ```\n     *\n     * On blur (or equivalent), your class should call the registered function to allow\n     * the forms API to update itself:\n     *\n     * ```ts\n     * host: {\n     *    '(blur)': '_onTouched()'\n     * }\n     * ```\n     *\n     * @param fn The callback function to register\n     */\n    registerOnTouched(fn: any): void;\n    /**\n     * @description\n     * Function that is called by the forms API when the control status changes to\n     * or from 'DISABLED'. Depending on the status, it enables or disables the\n     * appropriate DOM element.\n     *\n     * @usageNotes\n     * The following is an example of writing the disabled property to a native DOM element:\n     *\n     * ```ts\n     * setDisabledState(isDisabled: boolean): void {\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n     * }\n     * ```\n     *\n     * @param isDisabled The disabled status to set on the element\n     */\n    setDisabledState?(isDisabled: boolean): void;\n}\n\ndeclare const DEFAULT_VALUE_ACCESSOR: any;\n\n/**\n * The default `ControlValueAccessor` for writing a value and listening to changes on input\n * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * {@searchKeywords ngDefaultControl}\n *\n * @usageNotes\n *\n * ### Using the default value accessor\n *\n * The following example shows how to use an input element that activates the default value accessor\n * (in this case, a text field).\n *\n * ```ts\n * const firstNameControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"text\" [formControl]=\"firstNameControl\">\n * ```\n *\n * This value accessor is used by default for `<input type=\"text\">` and `<textarea>` elements, but\n * you could also use it for custom components that have similar behavior and do not require special\n * processing. In order to attach the default value accessor to a custom element, add the\n * `ngDefaultControl` attribute as shown below.\n *\n * ```\n * <custom-input-component ngDefaultControl [(ngModel)]=\"value\"></custom-input-component>\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class DefaultValueAccessor extends BaseControlValueAccessor implements ControlValueAccessor {\n    private _compositionMode;\n    /** Whether the user is creating a composition string (IME events). */\n    private _composing;\n    constructor(renderer: Renderer2, elementRef: ElementRef, _compositionMode: boolean);\n    /**\n     * Sets the \"value\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultValueAccessor, [null, null, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<DefaultValueAccessor, \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * @description\n * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const EMAIL_VALIDATOR: any;\n\n/**\n * A directive that adds the `email` validator to controls marked with the\n * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * The email validation is based on the WHATWG HTML specification with some enhancements to\n * incorporate more RFC rules. More information can be found on the [Validators.email\n * page](api/forms/Validators#email).\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding an email validator\n *\n * The following example shows how to add an email validator to an input attached to an ngModel\n * binding.\n *\n * ```\n * <input type=\"email\" name=\"email\" ngModel email>\n * <input type=\"email\" name=\"email\" ngModel email=\"true\">\n * <input type=\"email\" name=\"email\" ngModel [email]=\"true\">\n * ```\n *\n * @publicApi\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n */\nexport declare class EmailValidator extends AbstractValidatorDirective {\n    /**\n     * @description\n     * Tracks changes to the email attribute bound to this directive.\n     */\n    email: boolean | string;\n    /** @nodoc */\n    enabled(input: boolean): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<EmailValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<EmailValidator, \"[email][formControlName],[email][formControl],[email][ngModel]\", never, { \"email\": \"email\"; }, {}, never, never, false>;\n}\n\n/**\n * @description\n * An interface implemented by `FormGroupDirective` and `NgForm` directives.\n *\n * Only used by the `ReactiveFormsModule` and `FormsModule`.\n *\n * @publicApi\n */\nexport declare interface Form {\n    /**\n     * @description\n     * Add a control to this form.\n     *\n     * @param dir The control directive to add to the form.\n     */\n    addControl(dir: NgControl): void;\n    /**\n     * @description\n     * Remove a control from this form.\n     *\n     * @param dir: The control directive to remove from the form.\n     */\n    removeControl(dir: NgControl): void;\n    /**\n     * @description\n     * The control directive from which to get the `FormControl`.\n     *\n     * @param dir: The control directive.\n     */\n    getControl(dir: NgControl): FormControl;\n    /**\n     * @description\n     * Add a group of controls to this form.\n     *\n     * @param dir: The control group directive to add.\n     */\n    addFormGroup(dir: AbstractFormGroupDirective): void;\n    /**\n     * @description\n     * Remove a group of controls to this form.\n     *\n     * @param dir: The control group directive to remove.\n     */\n    removeFormGroup(dir: AbstractFormGroupDirective): void;\n    /**\n     * @description\n     * The `FormGroup` associated with a particular `AbstractFormGroupDirective`.\n     *\n     * @param dir: The form group directive from which to get the `FormGroup`.\n     */\n    getFormGroup(dir: AbstractFormGroupDirective): FormGroup;\n    /**\n     * @description\n     * Update the model for a particular control with a new value.\n     *\n     * @param dir: The control directive to update.\n     * @param value: The new value for the control.\n     */\n    updateModel(dir: NgControl, value: any): void;\n}\n\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` accepts one generic argument, which is the type of the controls inside.\n * If you need a heterogenous array, use {@link UntypedFormArray}.\n *\n * `FormArray` is one of the four fundamental building blocks used to define forms in Angular,\n * along with `FormControl`, `FormGroup`, and `FormRecord`.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n * @publicApi\n */\nexport declare class FormArray<TControl extends AbstractControl<any> = any> extends AbstractControl<ɵTypedOrUntyped<TControl, ɵFormArrayValue<TControl>, any>, ɵTypedOrUntyped<TControl, ɵFormArrayRawValue<TControl>, any>> {\n    /**\n     * Creates a new `FormArray` instance.\n     *\n     * @param controls An array of child controls. Each child control is given an index\n     * where it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(controls: Array<TControl>, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\n    controls: ɵTypedOrUntyped<TControl, Array<TControl>, Array<AbstractControl<any>>>;\n    /**\n     * Get the `AbstractControl` at the given `index` in the array.\n     *\n     * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap\n     *     around from the back, and if index is greatly negative (less than `-length`), the result is\n     * undefined. This behavior is the same as `Array.at(index)`.\n     */\n    at(index: number): ɵTypedOrUntyped<TControl, TControl, AbstractControl<any>>;\n    /**\n     * Insert a new `AbstractControl` at the end of the array.\n     *\n     * @param control Form control to be inserted\n     * @param options Specifies whether this FormArray instance should emit events after a new\n     *     control is added.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * inserted. When false, no events are emitted.\n     */\n    push(control: TControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Insert a new `AbstractControl` at the given `index` in the array.\n     *\n     * @param index Index in the array to insert the control. If `index` is negative, wraps around\n     *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.\n     * This behavior is the same as `Array.splice(index, 0, control)`.\n     * @param control Form control to be inserted\n     * @param options Specifies whether this FormArray instance should emit events after a new\n     *     control is inserted.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * inserted. When false, no events are emitted.\n     */\n    insert(index: number, control: TControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Remove the control at the given `index` in the array.\n     *\n     * @param index Index in the array to remove the control.  If `index` is negative, wraps around\n     *     from the back. If `index` is greatly negative (less than `-length`), removes the first\n     *     element. This behavior is the same as `Array.splice(index, 1)`.\n     * @param options Specifies whether this FormArray instance should emit events after a\n     *     control is removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * removed. When false, no events are emitted.\n     */\n    removeAt(index: number, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Replace an existing control.\n     *\n     * @param index Index in the array to replace the control. If `index` is negative, wraps around\n     *     from the back. If `index` is greatly negative (less than `-length`), replaces the first\n     *     element. This behavior is the same as `Array.splice(index, 1, control)`.\n     * @param control The `AbstractControl` control to replace the existing control\n     * @param options Specifies whether this FormArray instance should emit events after an\n     *     existing control is replaced with a new one.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * replaced with a new one. When false, no events are emitted.\n     */\n    setControl(index: number, control: TControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Length of the control array.\n     */\n    get length(): number;\n    /**\n     * Sets the value of the `FormArray`. It accepts an array that matches\n     * the structure of the control.\n     *\n     * This method performs strict checks, and throws an error if you try\n     * to set the value of a control that doesn't exist or if you exclude the\n     * value of a control.\n     *\n     * @usageNotes\n     * ### Set the values for the controls in the form array\n     *\n     * ```\n     * const arr = new FormArray([\n     *   new FormControl(),\n     *   new FormControl()\n     * ]);\n     * console.log(arr.value);   // [null, null]\n     *\n     * arr.setValue(['Nancy', 'Drew']);\n     * console.log(arr.value);   // ['Nancy', 'Drew']\n     * ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     */\n    setValue(value: ɵFormArrayRawValue<TControl>, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Patches the value of the `FormArray`. It accepts an array that matches the\n     * structure of the control, and does its best to match the values to the correct\n     * controls in the group.\n     *\n     * It accepts both super-sets and sub-sets of the array without throwing an error.\n     *\n     * @usageNotes\n     * ### Patch the values for controls in a form array\n     *\n     * ```\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * console.log(arr.value);   // [null, null]\n     *\n     * arr.patchValue(['Nancy']);\n     * console.log(arr.value);   // ['Nancy', null]\n     * ```\n     *\n     * @param value Array of latest values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control\n     * value is updated. When false, no events are emitted. The configuration options are passed to\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n     */\n    patchValue(value: ɵFormArrayValue<TControl>, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n     * value of all descendants to null or null maps.\n     *\n     * You reset to a specific form state by passing in an array of states\n     * that matches the structure of the control. The state is a standalone value\n     * or a form state object with both a value and a disabled status.\n     *\n     * @usageNotes\n     * ### Reset the values in a form array\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * arr.reset(['name', 'last name']);\n     *\n     * console.log(arr.value);  // ['name', 'last name']\n     * ```\n     *\n     * ### Reset the values in a form array and the disabled status for the first control\n     *\n     * ```\n     * arr.reset([\n     *   {value: 'name', disabled: true},\n     *   'last'\n     * ]);\n     *\n     * console.log(arr.value);  // ['last']\n     * console.log(arr.at(0).status);  // 'DISABLED'\n     * ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     */\n    reset(value?: ɵTypedOrUntyped<TControl, ɵFormArrayValue<TControl>, any>, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * The aggregate value of the array, including any disabled controls.\n     *\n     * Reports all values regardless of disabled status.\n     */\n    getRawValue(): ɵFormArrayRawValue<TControl>;\n    /**\n     * Remove all controls in the `FormArray`.\n     *\n     * @param options Specifies whether this FormArray instance should emit events after all\n     *     controls are removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when all controls\n     * in this FormArray instance are removed. When false, no events are emitted.\n     *\n     * @usageNotes\n     * ### Remove all elements from a FormArray\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * console.log(arr.length);  // 2\n     *\n     * arr.clear();\n     * console.log(arr.length);  // 0\n     * ```\n     *\n     * It's a simpler and more efficient alternative to removing all elements one by one:\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     *\n     * while (arr.length) {\n     *    arr.removeAt(0);\n     * }\n     * ```\n     */\n    clear(options?: {\n        emitEvent?: boolean;\n    }): void;\n    private _registerControl;\n}\n\n/**\n * @description\n *\n * Syncs a nested `FormArray` to a DOM element.\n *\n * This directive is designed to be used with a parent `FormGroupDirective` (selector:\n * `[formGroup]`).\n *\n * It accepts the string name of the nested `FormArray` you want to link, and\n * will look for a `FormArray` registered with that name in the parent\n * `FormGroup` instance you passed into `FormGroupDirective`.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormArrayName extends ControlContainer implements OnInit, OnDestroy {\n    /**\n     * @description\n     * Tracks the name of the `FormArray` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     * Accepts a name as a string or a number.\n     * The name in the form of a string is useful for individual forms,\n     * while the numerical form allows for form arrays to be bound\n     * to indices when iterating over arrays in a `FormArray`.\n     */\n    name: string | number | null;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    /**\n     * A lifecycle method called when the directive's inputs are initialized. For internal use only.\n     * @throws If the directive does not have a valid parent.\n     * @nodoc\n     */\n    ngOnInit(): void;\n    /**\n     * A lifecycle method called before the directive's instance is destroyed. For internal use only.\n     * @nodoc\n     */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * The `FormArray` bound to this directive.\n     */\n    get control(): FormArray;\n    /**\n     * @description\n     * The top-level directive for this group if present, otherwise null.\n     */\n    get formDirective(): FormGroupDirective | null;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    private _checkParentType;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FormArrayName, [{ optional: true; host: true; skipSelf: true; }, { optional: true; self: true; }, { optional: true; self: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<FormArrayName, \"[formArrayName]\", never, { \"name\": \"formArrayName\"; }, {}, never, never, false>;\n}\n\ndeclare const formArrayNameProvider: any;\n\n/**\n * @description\n * Creates an `AbstractControl` from a user-specified configuration.\n *\n * The `FormBuilder` provides syntactic sugar that shortens creating instances of a\n * `FormControl`, `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to\n * build complex forms.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @publicApi\n */\nexport declare class FormBuilder {\n    private useNonNullable;\n    /**\n     * @description\n     * Returns a FormBuilder in which automatically constructed @see FormControl} elements\n     * have `{nonNullable: true}` and are non-nullable.\n     *\n     * **Constructing non-nullable controls**\n     *\n     * When constructing a control, it will be non-nullable, and will reset to its initial value.\n     *\n     * ```ts\n     * let nnfb = new FormBuilder().nonNullable;\n     * let name = nnfb.control('Alex'); // FormControl<string>\n     * name.reset();\n     * console.log(name); // 'Alex'\n     * ```\n     *\n     * **Constructing non-nullable groups or arrays**\n     *\n     * When constructing a group or array, all automatically created inner controls will be\n     * non-nullable, and will reset to their initial values.\n     *\n     * ```ts\n     * let nnfb = new FormBuilder().nonNullable;\n     * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>\n     * name.reset();\n     * console.log(name); // {who: 'Alex'}\n     * ```\n     * **Constructing *nullable* fields on groups or arrays**\n     *\n     * It is still possible to have a nullable field. In particular, any `FormControl` which is\n     * *already* constructed will not be altered. For example:\n     *\n     * ```ts\n     * let nnfb = new FormBuilder().nonNullable;\n     * // FormGroup<{who: FormControl<string|null>}>\n     * let name = nnfb.group({who: new FormControl('Alex')});\n     * name.reset(); console.log(name); // {who: null}\n     * ```\n     *\n     * Because the inner control is constructed explicitly by the caller, the builder has\n     * no control over how it is created, and cannot exclude the `null`.\n     */\n    get nonNullable(): NonNullableFormBuilder;\n    /**\n     * @description\n     * Constructs a new `FormGroup` instance. Accepts a single generic argument, which is an object\n     * containing all the keys and corresponding inner control types.\n     *\n     * @param controls A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param options Configuration options object for the `FormGroup`. The object should have the\n     * `AbstractControlOptions` type and might contain the following fields:\n     * * `validators`: A synchronous validator function, or an array of validator functions.\n     * * `asyncValidators`: A single async validator or array of async validator functions.\n     * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'\n     * | submit').\n     */\n    group<T extends {}>(controls: T, options?: AbstractControlOptions | null): FormGroup<{\n        [K in keyof T]: ɵElement<T[K], null>;\n    }>;\n    /**\n     * @description\n     * Constructs a new `FormGroup` instance.\n     *\n     * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n     * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n     * Note that `AbstractControlOptions` expects `validators` and `asyncValidators` to be valid\n     * validators. If you have custom validators, make sure their validation function parameter is\n     * `AbstractControl` and not a sub-class, such as `FormGroup`. These functions will be called\n     * with an object of type `AbstractControl` and that cannot be automatically downcast to a\n     * subclass, so TypeScript sees this as an error. For example, change the `(group: FormGroup) =>\n     * ValidationErrors|null` signature to be `(group: AbstractControl) => ValidationErrors|null`.\n     *\n     * @param controls A record of child controls. The key for each child is the name\n     * under which the control is registered.\n     *\n     * @param options Configuration options object for the `FormGroup`. The legacy configuration\n     * object consists of:\n     * * `validator`: A synchronous validator function, or an array of validator functions.\n     * * `asyncValidator`: A single async validator or array of async validator functions\n     * Note: the legacy format is deprecated and might be removed in one of the next major versions\n     * of Angular.\n     */\n    group(controls: {\n        [key: string]: any;\n    }, options: {\n        [key: string]: any;\n    }): FormGroup;\n    /**\n     * @description\n     * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object\n     * containing all the keys and corresponding inner control types.\n     *\n     * @param controls A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param options Configuration options object for the `FormRecord`. The object should have the\n     * `AbstractControlOptions` type and might contain the following fields:\n     * * `validators`: A synchronous validator function, or an array of validator functions.\n     * * `asyncValidators`: A single async validator or array of async validator functions.\n     * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'\n     * | submit').\n     */\n    record<T>(controls: {\n        [key: string]: T;\n    }, options?: AbstractControlOptions | null): FormRecord<ɵElement<T, null>>;\n    /** @deprecated Use `nonNullable` instead. */\n    control<T>(formState: T | FormControlState<T>, opts: FormControlOptions & {\n        initialValueIsDefault: true;\n    }): FormControl<T>;\n    control<T>(formState: T | FormControlState<T>, opts: FormControlOptions & {\n        nonNullable: true;\n    }): FormControl<T>;\n    /**\n     * @deprecated When passing an `options` argument, the `asyncValidator` argument has no effect.\n     */\n    control<T>(formState: T | FormControlState<T>, opts: FormControlOptions, asyncValidator: AsyncValidatorFn | AsyncValidatorFn[]): FormControl<T | null>;\n    control<T>(formState: T | FormControlState<T>, validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormControl<T | null>;\n    /**\n     * Constructs a new `FormArray` from the given array of configurations,\n     * validators and options. Accepts a single generic argument, which is the type of each control\n     * inside the array.\n     *\n     * @param controls An array of child controls or control configs. Each child control is given an\n     *     index when it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an\n     *     `AbstractControlOptions` object that contains\n     * validation functions and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions.\n     */\n    array<T>(controls: Array<T>, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormArray<ɵElement<T, null>>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FormBuilder, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<FormBuilder>;\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the four fundamental building blocks of Angular forms, along with\n * `FormGroup`, `FormArray` and `FormRecord`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events.\n *\n * `FormControl` takes a single generic argument, which describes the type of its value. This\n * argument always implicitly includes `null` because the control can be reset. To change this\n * behavior, set `nonNullable` or see the usage notes below.\n *\n * See [usage examples below](#usage-notes).\n *\n * @see `AbstractControl`\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @publicApi\n *\n * @overriddenImplementation ɵFormControlCtor\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n * ```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a synchronous validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### The single type argument\n *\n * `FormControl` accepts a generic argument, which describes the type of its value.\n * In most cases, this argument will be inferred.\n *\n * If you are initializing the control to `null`, or you otherwise wish to provide a\n * wider type, you may specify the argument explicitly:\n *\n * ```\n * let fc = new FormControl<string|null>(null);\n * fc.setValue('foo');\n * ```\n *\n * You might notice that `null` is always added to the type of the control.\n * This is because the control will become `null` if you call `reset`. You can change\n * this behavior by setting `{nonNullable: true}`.\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to a specific value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control to its initial value\n *\n * If you wish to always reset the control to its initial value (instead of null),\n * you can pass the `nonNullable` option:\n *\n * ```\n * const control = new FormControl('Nancy', {nonNullable: true});\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset();\n *\n * console.log(control.value); // 'Nancy'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n * ```\n */\nexport declare interface FormControl<TValue = any> extends AbstractControl<TValue> {\n    /**\n     * The default value of this FormControl, used whenever the control is reset without an explicit\n     * value. See {@link FormControlOptions#nonNullable} for more information on configuring\n     * a default value.\n     */\n    readonly defaultValue: TValue;\n    /**\n     * Sets a new value for the form control.\n     *\n     * @param value The new value for the control.\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events when the value changes.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n     * `onChange` event to\n     * update the view.\n     * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n     * `ngModelChange`\n     * event to update the model.\n     *\n     */\n    setValue(value: TValue, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n        emitModelToViewChange?: boolean;\n        emitViewToModelChange?: boolean;\n    }): void;\n    /**\n     * Patches the value of a control.\n     *\n     * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n     * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n     * `FormArrays`, where it does behave differently.\n     *\n     * @see `setValue` for options\n     */\n    patchValue(value: TValue, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n        emitModelToViewChange?: boolean;\n        emitViewToModelChange?: boolean;\n    }): void;\n    /**\n     * Resets the form control, marking it `pristine` and `untouched`, and resetting\n     * the value. The new value will be the provided value (if passed), `null`, or the initial value\n     * if `nonNullable` was set in the constructor via {@link FormControlOptions}.\n     *\n     * ```ts\n     * // By default, the control will reset to null.\n     * const dog = new FormControl('spot');\n     * dog.reset(); // dog.value is null\n     *\n     * // If this flag is set, the control will instead reset to the initial value.\n     * const cat = new FormControl('tabby', {nonNullable: true});\n     * cat.reset(); // cat.value is \"tabby\"\n     *\n     * // A value passed to reset always takes precedence.\n     * const fish = new FormControl('finn', {nonNullable: true});\n     * fish.reset('bubble'); // fish.value is \"bubble\"\n     * ```\n     *\n     * @param formState Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     *\n     */\n    reset(formState?: TValue | FormControlState<TValue>, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * For a simple FormControl, the raw value is equivalent to the value.\n     */\n    getRawValue(): TValue;\n    /**\n     * Register a listener for change events.\n     *\n     * @param fn The method that is called when the value changes\n     */\n    registerOnChange(fn: Function): void;\n    /**\n     * Register a listener for disabled events.\n     *\n     * @param fn The method that is called when the disabled status changes.\n     */\n    registerOnDisabledChange(fn: (isDisabled: boolean) => void): void;\n}\n\nexport declare const FormControl: ɵFormControlCtor;\n\ndeclare const formControlBinding: any;\n\ndeclare const formControlBinding_2: any;\n\n/**\n * @description\n * Synchronizes a standalone `FormControl` instance to a form control element.\n *\n * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives was deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `FormControl`\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * The following example shows how to register a standalone control and set its value.\n *\n * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormControlDirective extends NgControl implements OnChanges, OnDestroy {\n    private _ngModelWarningConfig;\n    /**\n     * Internal reference to the view model value.\n     * @nodoc\n     */\n    viewModel: any;\n    /**\n     * @description\n     * Tracks the `FormControl` instance bound to the directive.\n     */\n    form: FormControl;\n    /**\n     * @description\n     * Triggers a warning in dev mode that this input should not be used with reactive forms.\n     */\n    set isDisabled(isDisabled: boolean);\n    /** @deprecated as of v6 */\n    model: any;\n    /** @deprecated as of v6 */\n    update: EventEmitter<any>;\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The `FormControl` bound to this directive.\n     */\n    get control(): FormControl;\n    /**\n     * @description\n     * Sets the new value for the view model and emits an `ngModelChange` event.\n     *\n     * @param newValue The new value for the view model.\n     */\n    viewToModelUpdate(newValue: any): void;\n    private _isControlChanged;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FormControlDirective, [{ optional: true; self: true; }, { optional: true; self: true; }, { optional: true; self: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<FormControlDirective, \"[formControl]\", [\"ngForm\"], { \"form\": \"formControl\"; \"isDisabled\": \"disabled\"; \"model\": \"ngModel\"; }, { \"update\": \"ngModelChange\"; }, never, never, false>;\n}\n\n/**\n * @description\n * Syncs a `FormControl` in an existing `FormGroup` to a form control\n * element by name.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `FormControl`\n * @see `AbstractControl`\n *\n * @usageNotes\n *\n * ### Register `FormControl` within a group\n *\n * The following example shows how to register multiple form controls within a form group\n * and set their value.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * To see `formControlName` examples with different form control types, see:\n *\n * * Radio buttons: `RadioControlValueAccessor`\n * * Selects: `SelectControlValueAccessor`\n *\n * ### Use with ngModel is deprecated\n *\n * Support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives has been deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n *\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormControlName extends NgControl implements OnChanges, OnDestroy {\n    private _ngModelWarningConfig;\n    private _added;\n    /**\n     * @description\n     * Tracks the `FormControl` instance bound to the directive.\n     */\n    readonly control: FormControl;\n    /**\n     * @description\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     * Accepts a name as a string or a number.\n     * The name in the form of a string is useful for individual forms,\n     * while the numerical form allows for form controls to be bound\n     * to indices when iterating over controls in a `FormArray`.\n     */\n    name: string | number | null;\n    /**\n     * @description\n     * Triggers a warning in dev mode that this input should not be used with reactive forms.\n     */\n    set isDisabled(isDisabled: boolean);\n    /** @deprecated as of v6 */\n    model: any;\n    /** @deprecated as of v6 */\n    update: EventEmitter<any>;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Sets the new value for the view model and emits an `ngModelChange` event.\n     *\n     * @param newValue The new value for the view model.\n     */\n    viewToModelUpdate(newValue: any): void;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The top-level directive for this group if present, otherwise null.\n     */\n    get formDirective(): any;\n    private _checkParentType;\n    private _setUpControl;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FormControlName, [{ optional: true; host: true; skipSelf: true; }, { optional: true; self: true; }, { optional: true; self: true; }, { optional: true; self: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<FormControlName, \"[formControlName]\", never, { \"name\": \"formControlName\"; \"isDisabled\": \"disabled\"; \"model\": \"ngModel\"; }, { \"update\": \"ngModelChange\"; }, never, never, false>;\n}\n\n/**\n * Interface for options provided to a `FormControl`.\n *\n * This interface extends all options from {@link AbstractControlOptions}, plus some options\n * unique to `FormControl`.\n *\n * @publicApi\n */\nexport declare interface FormControlOptions extends AbstractControlOptions {\n    /**\n     * @description\n     * Whether to use the initial value used to construct the `FormControl` as its default value\n     * as well. If this option is false or not provided, the default value of a FormControl is `null`.\n     * When a FormControl is reset without an explicit value, its value reverts to\n     * its default value.\n     */\n    nonNullable?: boolean;\n    /**\n     * @deprecated Use `nonNullable` instead.\n     */\n    initialValueIsDefault?: boolean;\n}\n\n/**\n * FormControlState is a boxed form value. It is an object with a `value` key and a `disabled` key.\n *\n * @publicApi\n */\nexport declare interface FormControlState<T> {\n    value: T;\n    disabled: boolean;\n}\n\n/**\n * A form can have several different statuses. Each\n * possible status is returned as a string literal.\n *\n * * **VALID**: Reports that a control is valid, meaning that no errors exist in the input\n * value.\n * * **INVALID**: Reports that a control is invalid, meaning that an error exists in the input\n * value.\n * * **PENDING**: Reports that a control is pending, meaning that that async validation is\n * occurring and errors are not yet available for the input value.\n * * **DISABLED**: Reports that a control is\n * disabled, meaning that the control is exempt from ancestor calculations of validity or value.\n *\n * @publicApi\n */\nexport declare type FormControlStatus = 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED';\n\ndeclare const formDirectiveProvider: any;\n\ndeclare const formDirectiveProvider_2: any;\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the four fundamental building blocks used to define forms in Angular,\n * along with `FormControl`, `FormArray`, and `FormRecord`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * `FormGroup` is intended for use cases where the keys are known ahead of time.\n * If you need to dynamically add and remove controls, use {@link FormRecord} instead.\n *\n * `FormGroup` accepts an optional type parameter `TControl`, which is an object type with inner\n * control types as values.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### The type argument, and optional controls\n *\n * `FormGroup` accepts one generic argument, which is an object containing its inner controls.\n * This type will usually be inferred automatically, but you can always specify it explicitly if you\n * wish.\n *\n * If you have controls that are optional (i.e. they can be removed, you can use the `?` in the\n * type):\n *\n * ```\n * const form = new FormGroup<{\n *   first: FormControl<string|null>,\n *   middle?: FormControl<string|null>, // Middle name is optional.\n *   last: FormControl<string|null>,\n * }>({\n *   first: new FormControl('Nancy'),\n *   last: new FormControl('Drew'),\n * });\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * ### Using a FormGroup with optional controls\n *\n * It is possible to have optional controls in a FormGroup. An optional control can be removed later\n * using `removeControl`, and can be omitted when calling `reset`. Optional controls must be\n * declared optional in the group's type.\n *\n * ```ts\n * const c = new FormGroup<{one?: FormControl<string>}>({\n *   one: new FormControl('')\n * });\n * ```\n *\n * Notice that `c.value.one` has type `string|null|undefined`. This is because calling `c.reset({})`\n * without providing the optional key `one` will cause it to become `null`.\n *\n * @publicApi\n */\nexport declare class FormGroup<TControl extends {\n    [K in keyof TControl]: AbstractControl<any>;\n} = any> extends AbstractControl<ɵTypedOrUntyped<TControl, ɵFormGroupValue<TControl>, any>, ɵTypedOrUntyped<TControl, ɵFormGroupRawValue<TControl>, any>> {\n    /**\n     * Creates a new `FormGroup` instance.\n     *\n     * @param controls A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(controls: TControl, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\n    controls: ɵTypedOrUntyped<TControl, TControl, {\n        [key: string]: AbstractControl<any>;\n    }>;\n    /**\n     * Registers a control with the group's list of controls. In a strongly-typed group, the control\n     * must be in the group's type (possibly as an optional key).\n     *\n     * This method does not update the value or validity of the control.\n     * Use {@link FormGroup#addControl addControl} instead.\n     *\n     * @param name The control name to register in the collection\n     * @param control Provides the control for the given name\n     */\n    registerControl<K extends string & keyof TControl>(name: K, control: TControl[K]): TControl[K];\n    registerControl(this: FormGroup<{\n        [key: string]: AbstractControl<any>;\n    }>, name: string, control: AbstractControl<any>): AbstractControl<any>;\n    /**\n     * Add a control to this group. In a strongly-typed group, the control must be in the group's type\n     * (possibly as an optional key).\n     *\n     * If a control with a given name already exists, it would *not* be replaced with a new one.\n     * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}\n     * method instead. This method also updates the value and validity of the control.\n     *\n     * @param name The control name to add to the collection\n     * @param control Provides the control for the given name\n     * @param options Specifies whether this FormGroup instance should emit events after a new\n     *     control is added.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * added. When false, no events are emitted.\n     */\n    addControl(this: FormGroup<{\n        [key: string]: AbstractControl<any>;\n    }>, name: string, control: AbstractControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    addControl<K extends string & keyof TControl>(name: K, control: Required<TControl>[K], options?: {\n        emitEvent?: boolean;\n    }): void;\n    removeControl(this: FormGroup<{\n        [key: string]: AbstractControl<any>;\n    }>, name: string, options?: {\n        emitEvent?: boolean;\n    }): void;\n    removeControl<S extends string>(name: ɵOptionalKeys<TControl> & S, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Replace an existing control. In a strongly-typed group, the control must be in the group's type\n     * (possibly as an optional key).\n     *\n     * If a control with a given name does not exist in this `FormGroup`, it will be added.\n     *\n     * @param name The control name to replace in the collection\n     * @param control Provides the control for the given name\n     * @param options Specifies whether this FormGroup instance should emit events after an\n     *     existing control is replaced.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * replaced with a new one. When false, no events are emitted.\n     */\n    setControl<K extends string & keyof TControl>(name: K, control: TControl[K], options?: {\n        emitEvent?: boolean;\n    }): void;\n    setControl(this: FormGroup<{\n        [key: string]: AbstractControl<any>;\n    }>, name: string, control: AbstractControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Check whether there is an enabled control with the given name in the group.\n     *\n     * Reports false for disabled controls. If you'd like to check for existence in the group\n     * only, use {@link AbstractControl#get get} instead.\n     *\n     * @param controlName The control name to check for existence in the collection\n     *\n     * @returns false for disabled controls, true otherwise.\n     */\n    contains<K extends string>(controlName: K): boolean;\n    contains(this: FormGroup<{\n        [key: string]: AbstractControl<any>;\n    }>, controlName: string): boolean;\n    /**\n     * Sets the value of the `FormGroup`. It accepts an object that matches\n     * the structure of the group, with control names as keys.\n     *\n     * @usageNotes\n     * ### Set the complete value for the form group\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl(),\n     *   last: new FormControl()\n     * });\n     *\n     * console.log(form.value);   // {first: null, last: null}\n     *\n     * form.setValue({first: 'Nancy', last: 'Drew'});\n     * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n     * ```\n     *\n     * @throws When strict checks fail, such as setting the value of a control\n     * that doesn't exist or if you exclude a value of a control that does exist.\n     *\n     * @param value The new value for the control that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     */\n    setValue(value: ɵFormGroupRawValue<TControl>, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Patches the value of the `FormGroup`. It accepts an object with control\n     * names as keys, and does its best to match the values to the correct controls\n     * in the group.\n     *\n     * It accepts both super-sets and sub-sets of the group without throwing an error.\n     *\n     * @usageNotes\n     * ### Patch the value for a form group\n     *\n     * ```\n     * const form = new FormGroup({\n     *    first: new FormControl(),\n     *    last: new FormControl()\n     * });\n     * console.log(form.value);   // {first: null, last: null}\n     *\n     * form.patchValue({first: 'Nancy'});\n     * console.log(form.value);   // {first: 'Nancy', last: null}\n     * ```\n     *\n     * @param value The object that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes and\n     * emits events after the value is patched.\n     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n     * true.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control value\n     * is updated. When false, no events are emitted. The configuration options are passed to\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n     */\n    patchValue(value: ɵFormGroupValue<TControl>, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n     * the value of all descendants to their default values, or null if no defaults were provided.\n     *\n     * You reset to a specific form state by passing in a map of states\n     * that matches the structure of your form, with control names as keys. The state\n     * is a standalone value or a form state object with both a value and a disabled\n     * status.\n     *\n     * @param value Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events when the group is reset.\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * @usageNotes\n     *\n     * ### Reset the form group values\n     *\n     * ```ts\n     * const form = new FormGroup({\n     *   first: new FormControl('first name'),\n     *   last: new FormControl('last name')\n     * });\n     *\n     * console.log(form.value);  // {first: 'first name', last: 'last name'}\n     *\n     * form.reset({ first: 'name', last: 'last name' });\n     *\n     * console.log(form.value);  // {first: 'name', last: 'last name'}\n     * ```\n     *\n     * ### Reset the form group values and disabled status\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl('first name'),\n     *   last: new FormControl('last name')\n     * });\n     *\n     * form.reset({\n     *   first: {value: 'name', disabled: true},\n     *   last: 'last'\n     * });\n     *\n     * console.log(form.value);  // {last: 'last'}\n     * console.log(form.get('first').status);  // 'DISABLED'\n     * ```\n     */\n    reset(value?: ɵTypedOrUntyped<TControl, ɵFormGroupValue<TControl>, any>, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * The aggregate value of the `FormGroup`, including any disabled controls.\n     *\n     * Retrieves all values regardless of disabled status.\n     */\n    getRawValue(): ɵTypedOrUntyped<TControl, ɵFormGroupRawValue<TControl>, any>;\n}\n\n/**\n * @description\n *\n * Binds an existing `FormGroup` or `FormRecord` to a DOM element.\n *\n * This directive accepts an existing `FormGroup` instance. It will then use this\n * `FormGroup` instance to match any child `FormControl`, `FormGroup`/`FormRecord`,\n * and `FormArray` instances to child `FormControlName`, `FormGroupName`,\n * and `FormArrayName` directives.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see `AbstractControl`\n *\n * @usageNotes\n * ### Register Form Group\n *\n * The following example registers a `FormGroup` with first name and last name controls,\n * and listens for the *ngSubmit* event when the button is clicked.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormGroupDirective extends ControlContainer implements Form, OnChanges, OnDestroy {\n    /**\n     * @description\n     * Reports whether the form submission has been triggered.\n     */\n    readonly submitted: boolean;\n    /**\n     * Reference to an old form group input value, which is needed to cleanup old instance in case it\n     * was replaced with a new one.\n     */\n    private _oldForm;\n    /**\n     * Callback that should be invoked when controls in FormGroup or FormArray collection change\n     * (added or removed). This callback triggers corresponding DOM updates.\n     */\n    private readonly _onCollectionChange;\n    /**\n     * @description\n     * Tracks the list of added `FormControlName` instances\n     */\n    directives: FormControlName[];\n    /**\n     * @description\n     * Tracks the `FormGroup` bound to this directive.\n     */\n    form: FormGroup;\n    /**\n     * @description\n     * Emits an event when the form submission has been triggered.\n     */\n    ngSubmit: EventEmitter<any>;\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Returns this directive's instance.\n     */\n    get formDirective(): Form;\n    /**\n     * @description\n     * Returns the `FormGroup` bound to this directive.\n     */\n    get control(): FormGroup;\n    /**\n     * @description\n     * Returns an array representing the path to this group. Because this directive\n     * always lives at the top level of a form, it always an empty array.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * Method that sets up the control directive in this group, re-calculates its value\n     * and validity, and adds the instance to the internal list of directives.\n     *\n     * @param dir The `FormControlName` directive instance.\n     */\n    addControl(dir: FormControlName): FormControl;\n    /**\n     * @description\n     * Retrieves the `FormControl` instance from the provided `FormControlName` directive\n     *\n     * @param dir The `FormControlName` directive instance.\n     */\n    getControl(dir: FormControlName): FormControl;\n    /**\n     * @description\n     * Removes the `FormControlName` instance from the internal list of directives\n     *\n     * @param dir The `FormControlName` directive instance.\n     */\n    removeControl(dir: FormControlName): void;\n    /**\n     * Adds a new `FormGroupName` directive instance to the form.\n     *\n     * @param dir The `FormGroupName` directive instance.\n     */\n    addFormGroup(dir: FormGroupName): void;\n    /**\n     * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the\n     * view.\n     *\n     * @param dir The `FormGroupName` directive instance.\n     */\n    removeFormGroup(dir: FormGroupName): void;\n    /**\n     * @description\n     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance\n     *\n     * @param dir The `FormGroupName` directive instance.\n     */\n    getFormGroup(dir: FormGroupName): FormGroup;\n    /**\n     * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.\n     *\n     * @param dir The `FormArrayName` directive instance.\n     */\n    addFormArray(dir: FormArrayName): void;\n    /**\n     * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the\n     * view.\n     *\n     * @param dir The `FormArrayName` directive instance.\n     */\n    removeFormArray(dir: FormArrayName): void;\n    /**\n     * @description\n     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.\n     *\n     * @param dir The `FormArrayName` directive instance.\n     */\n    getFormArray(dir: FormArrayName): FormArray;\n    /**\n     * Sets the new value for the provided `FormControlName` directive.\n     *\n     * @param dir The `FormControlName` directive instance.\n     * @param value The new value for the directive's control.\n     */\n    updateModel(dir: FormControlName, value: any): void;\n    /**\n     * @description\n     * Method called with the \"submit\" event is triggered on the form.\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n     *\n     * @param $event The \"submit\" event object\n     */\n    onSubmit($event: Event): boolean;\n    /**\n     * @description\n     * Method called when the \"reset\" event is triggered on the form.\n     */\n    onReset(): void;\n    /**\n     * @description\n     * Resets the form to an initial value and resets its submitted status.\n     *\n     * @param value The new value for the form.\n     */\n    resetForm(value?: any): void;\n    private _setUpFormContainer;\n    private _cleanUpFormContainer;\n    private _updateRegistrations;\n    private _updateValidators;\n    private _checkFormPresent;\n    static ɵfac: i0.ɵɵFactoryDeclaration<FormGroupDirective, [{ optional: true; self: true; }, { optional: true; self: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<FormGroupDirective, \"[formGroup]\", [\"ngForm\"], { \"form\": \"formGroup\"; }, { \"ngSubmit\": \"ngSubmit\"; }, never, never, false>;\n}\n\n/**\n * @description\n *\n * Syncs a nested `FormGroup` or `FormRecord` to a DOM element.\n *\n * This directive can only be used with a parent `FormGroupDirective`.\n *\n * It accepts the string name of the nested `FormGroup` or `FormRecord` to link, and\n * looks for a `FormGroup` or `FormRecord` registered with that name in the parent\n * `FormGroup` instance you passed into `FormGroupDirective`.\n *\n * Use nested form groups to validate a sub-group of a\n * form separately from the rest or to group the values of certain\n * controls into their own nested object.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @usageNotes\n *\n * ### Access the group by name\n *\n * The following example uses the `AbstractControl.get` method to access the\n * associated `FormGroup`\n *\n * ```ts\n *   this.form.get('name');\n * ```\n *\n * ### Access individual controls in the group\n *\n * The following example uses the `AbstractControl.get` method to access\n * individual controls within the group using dot syntax.\n *\n * ```ts\n *   this.form.get('name.first');\n * ```\n *\n * ### Register a nested `FormGroup`.\n *\n * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,\n * and provides methods to retrieve the nested `FormGroup` and individual controls.\n *\n * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class FormGroupName extends AbstractFormGroupDirective implements OnInit, OnDestroy {\n    /**\n     * @description\n     * Tracks the name of the `FormGroup` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     * Accepts a name as a string or a number.\n     * The name in the form of a string is useful for individual forms,\n     * while the numerical form allows for form groups to be bound\n     * to indices when iterating over groups in a `FormArray`.\n     */\n    name: string | number | null;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    static ɵfac: i0.ɵɵFactoryDeclaration<FormGroupName, [{ optional: true; host: true; skipSelf: true; }, { optional: true; self: true; }, { optional: true; self: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<FormGroupName, \"[formGroupName]\", never, { \"name\": \"formGroupName\"; }, {}, never, never, false>;\n}\n\ndeclare const formGroupNameProvider: any;\n\ndeclare type FormHooks = 'change' | 'blur' | 'submit';\n\n/**\n * Tracks the value and validity state of a collection of `FormControl` instances, each of which has\n * the same value type.\n *\n * `FormRecord` is very similar to {@link FormGroup}, except it can be used with a dynamic keys,\n * with controls added and removed as needed.\n *\n * `FormRecord` accepts one generic argument, which describes the type of the controls it contains.\n *\n * @usageNotes\n *\n * ```\n * let numbers = new FormRecord({bill: new FormControl('415-123-456')});\n * numbers.addControl('bob', new FormControl('415-234-567'));\n * numbers.removeControl('bill');\n * ```\n *\n * @publicApi\n */\nexport declare class FormRecord<TControl extends AbstractControl = AbstractControl> extends FormGroup<{\n    [key: string]: TControl;\n}> {\n}\n\nexport declare interface FormRecord<TControl> {\n    /**\n     * Registers a control with the records's list of controls.\n     *\n     * See `FormGroup#registerControl` for additional information.\n     */\n    registerControl(name: string, control: TControl): TControl;\n    /**\n     * Add a control to this group.\n     *\n     * See `FormGroup#addControl` for additional information.\n     */\n    addControl(name: string, control: TControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Remove a control from this group.\n     *\n     * See `FormGroup#removeControl` for additional information.\n     */\n    removeControl(name: string, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Replace an existing control.\n     *\n     * See `FormGroup#setControl` for additional information.\n     */\n    setControl(name: string, control: TControl, options?: {\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Check whether there is an enabled control with the given name in the group.\n     *\n     * See `FormGroup#contains` for additional information.\n     */\n    contains(controlName: string): boolean;\n    /**\n     * Sets the value of the `FormRecord`. It accepts an object that matches\n     * the structure of the group, with control names as keys.\n     *\n     * See `FormGroup#setValue` for additional information.\n     */\n    setValue(value: {\n        [key: string]: ɵValue<TControl>;\n    }, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Patches the value of the `FormRecord`. It accepts an object with control\n     * names as keys, and does its best to match the values to the correct controls\n     * in the group.\n     *\n     * See `FormGroup#patchValue` for additional information.\n     */\n    patchValue(value: {\n        [key: string]: ɵValue<TControl>;\n    }, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * Resets the `FormRecord`, marks all descendants `pristine` and `untouched` and sets\n     * the value of all descendants to null.\n     *\n     * See `FormGroup#reset` for additional information.\n     */\n    reset(value?: {\n        [key: string]: ɵValue<TControl>;\n    }, options?: {\n        onlySelf?: boolean;\n        emitEvent?: boolean;\n    }): void;\n    /**\n     * The aggregate value of the `FormRecord`, including any disabled controls.\n     *\n     * See `FormGroup#getRawValue` for additional information.\n     */\n    getRawValue(): {\n        [key: string]: ɵRawValue<TControl>;\n    };\n}\n\n/**\n * Exports the required providers and directives for template-driven forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](/guide/forms-overview)\n * @see [Template-driven Forms Guide](/guide/forms)\n *\n * @publicApi\n */\nexport declare class FormsModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<FormsModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<FormsModule, [typeof i1_2.NgModel, typeof i2_2.NgModelGroup, typeof i3_2.NgForm], never, [typeof i4_2.ɵInternalFormsSharedModule, typeof i1_2.NgModel, typeof i2_2.NgModelGroup, typeof i3_2.NgForm]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<FormsModule>;\n}\n\ndeclare namespace i1 {\n    export {\n        ɵNgNoValidate,\n        ɵNgNoValidate as NgNoValidate\n    }\n}\n\ndeclare namespace i10 {\n    export {\n        ValidationErrors,\n        Validator,\n        MAX_VALIDATOR,\n        MaxValidator,\n        MIN_VALIDATOR,\n        MinValidator,\n        AsyncValidator,\n        REQUIRED_VALIDATOR,\n        CHECKBOX_REQUIRED_VALIDATOR,\n        RequiredValidator,\n        CheckboxRequiredValidator,\n        EMAIL_VALIDATOR,\n        EmailValidator,\n        ValidatorFn,\n        AsyncValidatorFn,\n        MIN_LENGTH_VALIDATOR,\n        MinLengthValidator,\n        MAX_LENGTH_VALIDATOR,\n        MaxLengthValidator,\n        PATTERN_VALIDATOR,\n        PatternValidator\n    }\n}\n\ndeclare namespace i1_2 {\n    export {\n        formControlBinding,\n        NgModel\n    }\n}\n\ndeclare namespace i2 {\n    export {\n        SELECT_VALUE_ACCESSOR,\n        SelectControlValueAccessor,\n        NgSelectOption\n    }\n}\n\ndeclare namespace i2_2 {\n    export {\n        modelGroupProvider,\n        NgModelGroup\n    }\n}\n\ndeclare namespace i3 {\n    export {\n        SELECT_MULTIPLE_VALUE_ACCESSOR,\n        SelectMultipleControlValueAccessor,\n        ɵNgSelectMultipleOption,\n        ɵNgSelectMultipleOption as NgSelectMultipleOption\n    }\n}\n\ndeclare namespace i3_2 {\n    export {\n        formDirectiveProvider,\n        NgForm\n    }\n}\n\ndeclare namespace i4 {\n    export {\n        DEFAULT_VALUE_ACCESSOR,\n        COMPOSITION_BUFFER_MODE,\n        DefaultValueAccessor\n    }\n}\n\ndeclare namespace i4_2 {\n    export {\n        CheckboxControlValueAccessor,\n        ControlValueAccessor,\n        DefaultValueAccessor,\n        NgControl,\n        NgControlStatus,\n        NgControlStatusGroup,\n        NgForm,\n        NgModel,\n        NgModelGroup,\n        NumberValueAccessor,\n        RadioControlValueAccessor,\n        RangeValueAccessor,\n        FormControlDirective,\n        NG_MODEL_WITH_FORM_CONTROL_WARNING,\n        FormControlName,\n        FormGroupDirective,\n        FormArrayName,\n        FormGroupName,\n        NgSelectOption,\n        SelectControlValueAccessor,\n        ɵNgSelectMultipleOption as NgSelectMultipleOption,\n        SelectMultipleControlValueAccessor,\n        SHARED_FORM_DIRECTIVES,\n        TEMPLATE_DRIVEN_DIRECTIVES,\n        REACTIVE_DRIVEN_DIRECTIVES,\n        ɵInternalFormsSharedModule,\n        ɵInternalFormsSharedModule as InternalFormsSharedModule\n    }\n}\n\ndeclare namespace i5 {\n    export {\n        NUMBER_VALUE_ACCESSOR,\n        NumberValueAccessor\n    }\n}\n\ndeclare namespace i5_2 {\n    export {\n        NG_MODEL_WITH_FORM_CONTROL_WARNING,\n        formControlBinding_2 as formControlBinding,\n        FormControlDirective\n    }\n}\n\ndeclare namespace i6 {\n    export {\n        RANGE_VALUE_ACCESSOR,\n        RangeValueAccessor\n    }\n}\n\ndeclare namespace i6_2 {\n    export {\n        formDirectiveProvider_2 as formDirectiveProvider,\n        FormGroupDirective\n    }\n}\n\ndeclare namespace i7 {\n    export {\n        CHECKBOX_VALUE_ACCESSOR,\n        CheckboxControlValueAccessor\n    }\n}\n\ndeclare namespace i7_2 {\n    export {\n        controlNameBinding,\n        FormControlName\n    }\n}\n\ndeclare namespace i8 {\n    export {\n        RADIO_VALUE_ACCESSOR,\n        RadioControlRegistryModule,\n        RadioControlRegistry,\n        RadioControlValueAccessor\n    }\n}\n\ndeclare namespace i8_2 {\n    export {\n        formGroupNameProvider,\n        FormGroupName,\n        formArrayNameProvider,\n        FormArrayName\n    }\n}\n\ndeclare namespace i9 {\n    export {\n        AbstractControlStatus,\n        ngControlStatusHost,\n        ngGroupStatusHost,\n        NgControlStatus,\n        NgControlStatusGroup\n    }\n}\n\n/**\n * @description\n * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const MAX_LENGTH_VALIDATOR: any;\n\n/**\n * @description\n * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const MAX_VALIDATOR: StaticProvider;\n\n/**\n * A directive that adds max length validation to controls marked with the\n * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a maximum length validator\n *\n * The following example shows how to add a maximum length validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel maxlength=\"25\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MaxLengthValidator extends AbstractValidatorDirective {\n    /**\n     * @description\n     * Tracks changes to the minimum length bound to this directive.\n     */\n    maxlength: string | number | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MaxLengthValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MaxLengthValidator, \"[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]\", never, { \"maxlength\": \"maxlength\"; }, {}, never, never, false>;\n}\n\n/**\n * A directive which installs the {@link MaxValidator} for any `formControlName`,\n * `formControl`, or control with `ngModel` that also has a `max` attribute.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a max validator\n *\n * The following example shows how to add a max validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input type=\"number\" ngModel max=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MaxValidator extends AbstractValidatorDirective {\n    /**\n     * @description\n     * Tracks changes to the max bound to this directive.\n     */\n    max: string | number | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MaxValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MaxValidator, \"input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]\", never, { \"max\": \"max\"; }, {}, never, never, false>;\n}\n\n/**\n * @description\n * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const MIN_LENGTH_VALIDATOR: any;\n\n/**\n * @description\n * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const MIN_VALIDATOR: StaticProvider;\n\n/**\n * A directive that adds minimum length validation to controls marked with the\n * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a minimum length validator\n *\n * The following example shows how to add a minimum length validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel minlength=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MinLengthValidator extends AbstractValidatorDirective {\n    /**\n     * @description\n     * Tracks changes to the minimum length bound to this directive.\n     */\n    minlength: string | number | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MinLengthValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MinLengthValidator, \"[minlength][formControlName],[minlength][formControl],[minlength][ngModel]\", never, { \"minlength\": \"minlength\"; }, {}, never, never, false>;\n}\n\n/**\n * A directive which installs the {@link MinValidator} for any `formControlName`,\n * `formControl`, or control with `ngModel` that also has a `min` attribute.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a min validator\n *\n * The following example shows how to add a min validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input type=\"number\" ngModel min=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class MinValidator extends AbstractValidatorDirective {\n    /**\n     * @description\n     * Tracks changes to the min bound to this directive.\n     */\n    min: string | number | null;\n    static ɵfac: i0.ɵɵFactoryDeclaration<MinValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<MinValidator, \"input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]\", never, { \"min\": \"min\"; }, {}, never, never, false>;\n}\n\ndeclare const modelGroupProvider: any;\n\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Promise<ValidationErrors|null> {\n *     return Promise.resolve({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare const NG_ASYNC_VALIDATORS: InjectionToken<(Function | Validator)[]>;\n\n/**\n * Token to provide to turn off the ngModel warning on formControl and formControlName.\n */\ndeclare const NG_MODEL_WITH_FORM_CONTROL_WARNING: InjectionToken<unknown>;\n\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_ASYNC_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare const NG_VALIDATORS: InjectionToken<(Function | Validator)[]>;\n\n/**\n * Used to provide a `ControlValueAccessor` for form controls.\n *\n * See `DefaultValueAccessor` for how to implement one.\n *\n * @publicApi\n */\nexport declare const NG_VALUE_ACCESSOR: InjectionToken<readonly ControlValueAccessor[]>;\n\n/**\n * @description\n * A base class that all `FormControl`-based directives extend. It binds a `FormControl`\n * object to a DOM element.\n *\n * @publicApi\n */\nexport declare abstract class NgControl extends AbstractControlDirective {\n    /**\n     * @description\n     * The name for the control\n     */\n    name: string | number | null;\n    /**\n     * @description\n     * The value accessor for the control\n     */\n    valueAccessor: ControlValueAccessor | null;\n    /**\n     * @description\n     * The callback method to update the model from the view when requested\n     *\n     * @param newValue The new value for the view\n     */\n    abstract viewToModelUpdate(newValue: any): void;\n}\n\n/**\n * @description\n * Directive automatically applied to Angular form controls that sets CSS classes\n * based on control status.\n *\n * @usageNotes\n *\n * ### CSS classes applied\n *\n * The following classes are applied as the properties become true:\n *\n * * ng-valid\n * * ng-invalid\n * * ng-pending\n * * ng-pristine\n * * ng-dirty\n * * ng-untouched\n * * ng-touched\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgControlStatus extends AbstractControlStatus {\n    constructor(cd: NgControl);\n    static ɵfac: i0.ɵɵFactoryDeclaration<NgControlStatus, [{ self: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NgControlStatus, \"[formControlName],[ngModel],[formControl]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * @description\n * Directive automatically applied to Angular form groups that sets CSS classes\n * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional\n * class ng-submitted.\n *\n * @see `NgControlStatus`\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgControlStatusGroup extends AbstractControlStatus {\n    constructor(cd: ControlContainer);\n    static ɵfac: i0.ɵɵFactoryDeclaration<NgControlStatusGroup, [{ optional: true; self: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NgControlStatusGroup, \"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]\", never, {}, {}, never, never, false>;\n}\n\ndeclare const ngControlStatusHost: {\n    '[class.ng-untouched]': string;\n    '[class.ng-touched]': string;\n    '[class.ng-pristine]': string;\n    '[class.ng-dirty]': string;\n    '[class.ng-valid]': string;\n    '[class.ng-invalid]': string;\n    '[class.ng-pending]': string;\n};\n\n/**\n * @description\n * Creates a top-level `FormGroup` instance and binds it to a form\n * to track aggregate form value and validation status.\n *\n * As soon as you import the `FormsModule`, this directive becomes active by default on\n * all `<form>` tags.  You don't need to add a special selector.\n *\n * You optionally export the directive into a local template variable using `ngForm` as the key\n * (ex: `#myForm=\"ngForm\"`). This is optional, but useful.  Many properties from the underlying\n * `FormGroup` instance are duplicated on the directive itself, so a reference to it\n * gives you access to the aggregate value and validity status of the form, as well as\n * user interaction properties like `dirty` and `touched`.\n *\n * To register child controls with the form, use `NgModel` with a `name`\n * attribute. You may use `NgModelGroup` to create sub-groups within the form.\n *\n * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has\n * triggered a form submission. The `ngSubmit` event emits the original form\n * submission event.\n *\n * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.\n * To import the `FormsModule` but skip its usage in some forms,\n * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`\n * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is\n * unnecessary because the `<form>` tags are inert. In that case, you would\n * refrain from using the `formGroup` directive.\n *\n * @usageNotes\n *\n * ### Listening for form submission\n *\n * The following example shows how to capture the form values from the \"ngSubmit\" event.\n *\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n *\n * ### Setting the update options\n *\n * The following example shows you how to change the \"updateOn\" option from its default using\n * ngFormOptions.\n *\n * ```html\n * <form [ngFormOptions]=\"{updateOn: 'blur'}\">\n *    <input name=\"one\" ngModel>  <!-- this ngModel will update on blur -->\n * </form>\n * ```\n *\n * ### Native DOM validation UI\n *\n * In order to prevent the native DOM form validation UI from interfering with Angular's form\n * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever\n * `FormModule` or `ReactiveFormModule` are imported into the application.\n * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the\n * `ngNativeValidate` attribute to the `<form>` element:\n *\n * ```html\n * <form ngNativeValidate>\n *   ...\n * </form>\n * ```\n *\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgForm extends ControlContainer implements Form, AfterViewInit {\n    /**\n     * @description\n     * Returns whether the form submission has been triggered.\n     */\n    readonly submitted: boolean;\n    private _directives;\n    /**\n     * @description\n     * The `FormGroup` instance created for this form.\n     */\n    form: FormGroup;\n    /**\n     * @description\n     * Event emitter for the \"ngSubmit\" event\n     */\n    ngSubmit: EventEmitter<any>;\n    /**\n     * @description\n     * Tracks options for the `NgForm` instance.\n     *\n     * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it\n     * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.\n     * Possible values: `'change'` | `'blur'` | `'submit'`.\n     *\n     */\n    options: {\n        updateOn?: FormHooks;\n    };\n    constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    /** @nodoc */\n    ngAfterViewInit(): void;\n    /**\n     * @description\n     * The directive instance.\n     */\n    get formDirective(): Form;\n    /**\n     * @description\n     * The internal `FormGroup` instance.\n     */\n    get control(): FormGroup;\n    /**\n     * @description\n     * Returns an array representing the path to this group. Because this directive\n     * always lives at the top level of a form, it is always an empty array.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * Returns a map of the controls in this group.\n     */\n    get controls(): {\n        [key: string]: AbstractControl;\n    };\n    /**\n     * @description\n     * Method that sets up the control directive in this group, re-calculates its value\n     * and validity, and adds the instance to the internal list of directives.\n     *\n     * @param dir The `NgModel` directive instance.\n     */\n    addControl(dir: NgModel): void;\n    /**\n     * @description\n     * Retrieves the `FormControl` instance from the provided `NgModel` directive.\n     *\n     * @param dir The `NgModel` directive instance.\n     */\n    getControl(dir: NgModel): FormControl;\n    /**\n     * @description\n     * Removes the `NgModel` instance from the internal list of directives\n     *\n     * @param dir The `NgModel` directive instance.\n     */\n    removeControl(dir: NgModel): void;\n    /**\n     * @description\n     * Adds a new `NgModelGroup` directive instance to the form.\n     *\n     * @param dir The `NgModelGroup` directive instance.\n     */\n    addFormGroup(dir: NgModelGroup): void;\n    /**\n     * @description\n     * Removes the `NgModelGroup` directive instance from the form.\n     *\n     * @param dir The `NgModelGroup` directive instance.\n     */\n    removeFormGroup(dir: NgModelGroup): void;\n    /**\n     * @description\n     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance\n     *\n     * @param dir The `NgModelGroup` directive instance.\n     */\n    getFormGroup(dir: NgModelGroup): FormGroup;\n    /**\n     * Sets the new value for the provided `NgControl` directive.\n     *\n     * @param dir The `NgControl` directive instance.\n     * @param value The new value for the directive's control.\n     */\n    updateModel(dir: NgControl, value: any): void;\n    /**\n     * @description\n     * Sets the value for this `FormGroup`.\n     *\n     * @param value The new value\n     */\n    setValue(value: {\n        [key: string]: any;\n    }): void;\n    /**\n     * @description\n     * Method called when the \"submit\" event is triggered on the form.\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n     *\n     * @param $event The \"submit\" event object\n     */\n    onSubmit($event: Event): boolean;\n    /**\n     * @description\n     * Method called when the \"reset\" event is triggered on the form.\n     */\n    onReset(): void;\n    /**\n     * @description\n     * Resets the form to an initial value and resets its submitted status.\n     *\n     * @param value The new value for the form.\n     */\n    resetForm(value?: any): void;\n    private _setUpdateStrategy;\n    private _findContainer;\n    static ɵfac: i0.ɵɵFactoryDeclaration<NgForm, [{ optional: true; self: true; }, { optional: true; self: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NgForm, \"form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]\", [\"ngForm\"], { \"options\": \"ngFormOptions\"; }, { \"ngSubmit\": \"ngSubmit\"; }, never, never, false>;\n}\n\ndeclare const ngGroupStatusHost: {\n    '[class.ng-submitted]': string;\n    '[class.ng-untouched]': string;\n    '[class.ng-touched]': string;\n    '[class.ng-pristine]': string;\n    '[class.ng-dirty]': string;\n    '[class.ng-valid]': string;\n    '[class.ng-invalid]': string;\n    '[class.ng-pending]': string;\n};\n\n/**\n * @description\n * Creates a `FormControl` instance from a domain model and binds it\n * to a form control element.\n *\n * The `FormControl` instance tracks the value, user interaction, and\n * validation status of the control and keeps the view synced with the model. If used\n * within a parent form, the directive also registers itself with the form as a child\n * control.\n *\n * This directive is used by itself or as part of a larger form. Use the\n * `ngModel` selector to activate it.\n *\n * It accepts a domain model as an optional `Input`. If you have a one-way binding\n * to `ngModel` with `[]` syntax, changing the domain model's value in the component\n * class sets the value in the view. If you have a two-way binding with `[()]` syntax\n * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to\n * the domain model in your class.\n *\n * To inspect the properties of the associated `FormControl` (like the validity state),\n * export the directive into a local template variable using `ngModel` as the key (ex:\n * `#myVar=\"ngModel\"`). You can then access the control using the directive's `control` property.\n * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control\n * for direct access. See a full list of properties directly available in\n * `AbstractControlDirective`.\n *\n * @see `RadioControlValueAccessor`\n * @see `SelectControlValueAccessor`\n *\n * @usageNotes\n *\n * ### Using ngModel on a standalone control\n *\n * The following examples show a simple standalone control using `ngModel`:\n *\n * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}\n *\n * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute\n * so that the control can be registered with the parent form under that name.\n *\n * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,\n * as the parent form syncs the value for you. You access its properties by exporting it into a\n * local template variable using `ngForm` such as (`#f=\"ngForm\"`). Use the variable where\n * needed on form submission.\n *\n * If you do need to populate initial values into your form, using a one-way binding for\n * `ngModel` tends to be sufficient as long as you use the exported form's value rather\n * than the domain model's value on submit.\n *\n * ### Using ngModel within a form\n *\n * The following example shows controls using `ngModel` within a form:\n *\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n *\n * ### Using a standalone ngModel within a group\n *\n * The following example shows you how to use a standalone ngModel control\n * within a form. This controls the display of the form, but doesn't contain form data.\n *\n * ```html\n * <form>\n *   <input name=\"login\" ngModel placeholder=\"Login\">\n *   <input type=\"checkbox\" ngModel [ngModelOptions]=\"{standalone: true}\"> Show more options?\n * </form>\n * <!-- form value: {login: ''} -->\n * ```\n *\n * ### Setting the ngModel `name` attribute through options\n *\n * The following example shows you an alternate way to set the name attribute. Here,\n * an attribute identified as name is used within a custom form control component. To still be able\n * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.\n *\n * ```html\n * <form>\n *   <my-custom-form-control name=\"Nancy\" ngModel [ngModelOptions]=\"{name: 'user'}\">\n *   </my-custom-form-control>\n * </form>\n * <!-- form value: {user: ''} -->\n * ```\n *\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgModel extends NgControl implements OnChanges, OnDestroy {\n    private _changeDetectorRef?;\n    readonly control: FormControl;\n    /** @nodoc */\n    static ngAcceptInputType_isDisabled: boolean | string;\n    /**\n     * Internal reference to the view model value.\n     * @nodoc\n     */\n    viewModel: any;\n    /**\n     * @description\n     * Tracks the name bound to the directive. If a parent form exists, it\n     * uses this name as a key to retrieve this control's value.\n     */\n    name: string;\n    /**\n     * @description\n     * Tracks whether the control is disabled.\n     */\n    isDisabled: boolean;\n    /**\n     * @description\n     * Tracks the value bound to this directive.\n     */\n    model: any;\n    /**\n     * @description\n     * Tracks the configuration options for this `ngModel` instance.\n     *\n     * **name**: An alternative to setting the name attribute on the form control element. See\n     * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`\n     * as a standalone control.\n     *\n     * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,\n     * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option\n     * has no effect.\n     *\n     * **updateOn**: Defines the event upon which the form control value and validity update.\n     * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.\n     *\n     */\n    options: {\n        name?: string;\n        standalone?: boolean;\n        updateOn?: FormHooks;\n    };\n    /**\n     * @description\n     * Event emitter for producing the `ngModelChange` event after\n     * the view model updates.\n     */\n    update: EventEmitter<any>;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _changeDetectorRef?: ChangeDetectorRef | null | undefined);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path(): string[];\n    /**\n     * @description\n     * The top-level directive for this control if present, otherwise null.\n     */\n    get formDirective(): any;\n    /**\n     * @description\n     * Sets the new value for the view model and emits an `ngModelChange` event.\n     *\n     * @param newValue The new value emitted by `ngModelChange`.\n     */\n    viewToModelUpdate(newValue: any): void;\n    private _setUpControl;\n    private _setUpdateStrategy;\n    private _isStandalone;\n    private _setUpStandalone;\n    private _checkForErrors;\n    private _checkParentType;\n    private _checkName;\n    private _updateValue;\n    private _updateDisabled;\n    private _getPath;\n    static ɵfac: i0.ɵɵFactoryDeclaration<NgModel, [{ optional: true; host: true; }, { optional: true; self: true; }, { optional: true; self: true; }, { optional: true; self: true; }, { optional: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NgModel, \"[ngModel]:not([formControlName]):not([formControl])\", [\"ngModel\"], { \"name\": \"name\"; \"isDisabled\": \"disabled\"; \"model\": \"ngModel\"; \"options\": \"ngModelOptions\"; }, { \"update\": \"ngModelChange\"; }, never, never, false>;\n}\n\n/**\n * @description\n * Creates and binds a `FormGroup` instance to a DOM element.\n *\n * This directive can only be used as a child of `NgForm` (within `<form>` tags).\n *\n * Use this directive to validate a sub-group of your form separately from the\n * rest of your form, or if some values in your domain model make more sense\n * to consume together in a nested object.\n *\n * Provide a name for the sub-group and it will become the key\n * for the sub-group in the form's full value. If you need direct access, export the directive into\n * a local template variable using `ngModelGroup` (ex: `#myGroup=\"ngModelGroup\"`).\n *\n * @usageNotes\n *\n * ### Consuming controls in a grouping\n *\n * The following example shows you how to combine controls together in a sub-group\n * of the form.\n *\n * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}\n *\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgModelGroup extends AbstractFormGroupDirective implements OnInit, OnDestroy {\n    /**\n     * @description\n     * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds\n     * to a key in the parent `NgForm`.\n     */\n    name: string;\n    constructor(parent: ControlContainer, validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[]);\n    static ɵfac: i0.ɵɵFactoryDeclaration<NgModelGroup, [{ host: true; skipSelf: true; }, { optional: true; self: true; }, { optional: true; self: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NgModelGroup, \"[ngModelGroup]\", [\"ngModelGroup\"], { \"name\": \"ngModelGroup\"; }, {}, never, never, false>;\n}\n\n/**\n * @description\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * @see `SelectControlValueAccessor`\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NgSelectOption implements OnDestroy {\n    private _element;\n    private _renderer;\n    private _select;\n    /**\n     * @description\n     * ID of the option element\n     */\n    id: string;\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectControlValueAccessor);\n    /**\n     * @description\n     * Tracks the value bound to the option element. Unlike the value binding,\n     * ngValue supports binding to objects.\n     */\n    set ngValue(value: any);\n    /**\n     * @description\n     * Tracks simple string values bound to the option element.\n     * For objects, use the `ngValue` input binding.\n     */\n    set value(value: any);\n    /** @nodoc */\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<NgSelectOption, [null, null, { optional: true; host: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NgSelectOption, \"option\", never, { \"ngValue\": \"ngValue\"; \"value\": \"value\"; }, {}, never, never, false>;\n}\n\n/**\n * @description\n * `NonNullableFormBuilder` is similar to {@link FormBuilder}, but automatically constructed\n * {@link FormControl} elements have `{nonNullable: true}` and are non-nullable.\n *\n * @publicApi\n */\nexport declare abstract class NonNullableFormBuilder {\n    /**\n     * Similar to `FormBuilder#group`, except any implicitly constructed `FormControl`\n     * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n     * that already-constructed controls will not be altered.\n     */\n    abstract group<T extends {}>(controls: T, options?: AbstractControlOptions | null): FormGroup<{\n        [K in keyof T]: ɵElement<T[K], never>;\n    }>;\n    /**\n     * Similar to `FormBuilder#record`, except any implicitly constructed `FormControl`\n     * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n     * that already-constructed controls will not be altered.\n     */\n    abstract record<T>(controls: {\n        [key: string]: T;\n    }, options?: AbstractControlOptions | null): FormRecord<ɵElement<T, never>>;\n    /**\n     * Similar to `FormBuilder#array`, except any implicitly constructed `FormControl`\n     * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n     * that already-constructed controls will not be altered.\n     */\n    abstract array<T>(controls: Array<T>, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormArray<ɵElement<T, never>>;\n    /**\n     * Similar to `FormBuilder#control`, except this overridden version of `control` forces\n     * `nonNullable` to be `true`, resulting in the control always being non-nullable.\n     */\n    abstract control<T>(formState: T | FormControlState<T>, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormControl<T>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<NonNullableFormBuilder, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<NonNullableFormBuilder>;\n}\n\ndeclare const NUMBER_VALUE_ACCESSOR: any;\n\n/**\n * @description\n * The `ControlValueAccessor` for writing a number value and listening to number input changes.\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`\n * directives.\n *\n * @usageNotes\n *\n * ### Using a number input with a reactive form.\n *\n * The following example shows how to use a number input with a reactive form.\n *\n * ```ts\n * const totalCountControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"number\" [formControl]=\"totalCountControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class NumberValueAccessor extends BuiltInControlValueAccessor implements ControlValueAccessor {\n    /**\n     * Sets the \"value\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: number): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: number | null) => void): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<NumberValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<NumberValueAccessor, \"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]\", never, {}, {}, never, never, false>;\n}\n\n/**\n * @description\n * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const PATTERN_VALIDATOR: any;\n\n/**\n * @description\n * A directive that adds regex pattern validation to controls marked with the\n * `pattern` attribute. The regex must match the entire control value.\n * The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a pattern validator\n *\n * The following example shows how to add a pattern validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel pattern=\"[a-zA-Z ]*\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class PatternValidator extends AbstractValidatorDirective {\n    /**\n     * @description\n     * Tracks changes to the pattern bound to this directive.\n     */\n    pattern: string | RegExp;\n    static ɵfac: i0.ɵɵFactoryDeclaration<PatternValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<PatternValidator, \"[pattern][formControlName],[pattern][formControl],[pattern][ngModel]\", never, { \"pattern\": \"pattern\"; }, {}, never, never, false>;\n}\n\n/**\n * The compiler may not always be able to prove that the elements of the control config are a tuple\n * (i.e. occur in a fixed order). This slightly looser type is used for inference, to catch cases\n * where the compiler cannot prove order and position.\n *\n * For example, consider the simple case `fb.group({foo: ['bar', Validators.required]})`. The\n * compiler will infer this as an array, not as a tuple.\n */\ndeclare type PermissiveControlConfig<T> = Array<T | FormControlState<T> | ValidatorConfig>;\n\ndeclare const RADIO_VALUE_ACCESSOR: any;\n\n/**\n * @description\n * Class used by Angular to track radio buttons. For internal use only.\n */\ndeclare class RadioControlRegistry {\n    private _accessors;\n    /**\n     * @description\n     * Adds a control to the internal registry. For internal use only.\n     */\n    add(control: NgControl, accessor: RadioControlValueAccessor): void;\n    /**\n     * @description\n     * Removes a control from the internal registry. For internal use only.\n     */\n    remove(accessor: RadioControlValueAccessor): void;\n    /**\n     * @description\n     * Selects a radio button. For internal use only.\n     */\n    select(accessor: RadioControlValueAccessor): void;\n    private _isSameGroup;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RadioControlRegistry, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<RadioControlRegistry>;\n}\n\n/**\n * Internal-only NgModule that works as a host for the `RadioControlRegistry` tree-shakable\n * provider. Note: the `InternalFormsSharedModule` can not be used here directly, since it's\n * declared *after* the `RadioControlRegistry` class and the `providedIn` doesn't support\n * `forwardRef` logic.\n */\ndeclare class RadioControlRegistryModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<RadioControlRegistryModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<RadioControlRegistryModule, never, never, never>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<RadioControlRegistryModule>;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing radio control values and listening to radio control\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using radio buttons with reactive form directives\n *\n * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in\n * a reactive form, radio buttons in the same group should have the same `formControlName`.\n * Providing a `name` attribute is optional.\n *\n * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class RadioControlValueAccessor extends BuiltInControlValueAccessor implements ControlValueAccessor, OnDestroy, OnInit {\n    private _registry;\n    private _injector;\n    /**\n     * The registered callback function called when a change event occurs on the input element.\n     * Note: we declare `onChange` here (also used as host listener) as a function with no arguments\n     * to override the `onChange` function (which expects 1 argument) in the parent\n     * `BaseControlValueAccessor` class.\n     * @nodoc\n     */\n    onChange: () => void;\n    /**\n     * @description\n     * Tracks the name of the radio input element.\n     */\n    name: string;\n    /**\n     * @description\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n     * to a key in the parent `FormGroup` or `FormArray`.\n     */\n    formControlName: string;\n    /**\n     * @description\n     * Tracks the value of the radio input element\n     */\n    value: any;\n    constructor(renderer: Renderer2, elementRef: ElementRef, _registry: RadioControlRegistry, _injector: Injector);\n    /** @nodoc */\n    ngOnInit(): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /**\n     * Sets the \"checked\" property value on the radio input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: any) => {}): void;\n    /**\n     * Sets the \"value\" on the radio input element and unchecks it.\n     *\n     * @param value\n     */\n    fireUncheck(value: any): void;\n    private _checkName;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RadioControlValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<RadioControlValueAccessor, \"input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]\", never, { \"name\": \"name\"; \"formControlName\": \"formControlName\"; \"value\": \"value\"; }, {}, never, never, false>;\n}\n\ndeclare const RANGE_VALUE_ACCESSOR: StaticProvider;\n\n/**\n * @description\n * The `ControlValueAccessor` for writing a range value and listening to range input changes.\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`\n * directives.\n *\n * @usageNotes\n *\n * ### Using a range input with a reactive form\n *\n * The following example shows how to use a range input with a reactive form.\n *\n * ```ts\n * const ageControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"range\" [formControl]=\"ageControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class RangeValueAccessor extends BuiltInControlValueAccessor implements ControlValueAccessor {\n    /**\n     * Sets the \"value\" property on the input element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (_: number | null) => void): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RangeValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<RangeValueAccessor, \"input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]\", never, {}, {}, never, never, false>;\n}\n\ndeclare const REACTIVE_DRIVEN_DIRECTIVES: Type<any>[];\n\n/**\n * Exports the required infrastructure and directives for reactive forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `FormBuilder`\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](guide/forms-overview)\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @publicApi\n */\nexport declare class ReactiveFormsModule {\n    /**\n     * @description\n     * Provides options for configuring the reactive forms module.\n     *\n     * @param opts An object of configuration options\n     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`\n     * binding is used with reactive form directives.\n     */\n    static withConfig(opts: {\n        /** @deprecated as of v6 */ warnOnNgModelWithFormControl: 'never' | 'once' | 'always';\n    }): ModuleWithProviders<ReactiveFormsModule>;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ReactiveFormsModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<ReactiveFormsModule, [typeof i5_2.FormControlDirective, typeof i6_2.FormGroupDirective, typeof i7_2.FormControlName, typeof i8_2.FormGroupName, typeof i8_2.FormArrayName], never, [typeof i4_2.ɵInternalFormsSharedModule, typeof i5_2.FormControlDirective, typeof i6_2.FormGroupDirective, typeof i7_2.FormControlName, typeof i8_2.FormGroupName, typeof i8_2.FormArrayName]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<ReactiveFormsModule>;\n}\n\n/**\n * @description\n * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.\n */\ndeclare const REQUIRED_VALIDATOR: StaticProvider;\n\n/**\n * @description\n * A directive that adds the `required` validator to any controls marked with the\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a required validator using template-driven forms\n *\n * ```\n * <input name=\"fullName\" ngModel required>\n * ```\n *\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\nexport declare class RequiredValidator extends AbstractValidatorDirective {\n    /**\n     * @description\n     * Tracks changes to the required attribute bound to this directive.\n     */\n    required: boolean | string;\n    /** @nodoc */\n    enabled(input: boolean): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<RequiredValidator, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<RequiredValidator, \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\", never, { \"required\": \"required\"; }, {}, never, never, false>;\n}\n\ndeclare const SELECT_MULTIPLE_VALUE_ACCESSOR: StaticProvider;\n\ndeclare const SELECT_VALUE_ACCESSOR: StaticProvider;\n\n/**\n * @description\n * The `ControlValueAccessor` for writing select control values and listening to select control\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using select controls in a reactive form\n *\n * The following examples show how to use a select control in a reactive form.\n *\n * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}\n *\n * ### Using select controls in a template-driven form\n *\n * To use a select in a template-driven form, simply add an `ngModel` and a `name`\n * attribute to the main `<select>` tag.\n *\n * {@example forms/ts/selectControl/select_control_example.ts region='Component'}\n *\n * ### Customizing option selection\n *\n * Angular uses object identity to select option. It's possible for the identities of items\n * to change while the data does not. This can happen, for example, if the items are produced\n * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the\n * second response will produce objects with different identities.\n *\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\n * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.\n * If `compareWith` is given, Angular selects option by the return value of the function.\n *\n * ```ts\n * const selectedCountriesControl = new FormControl();\n * ```\n *\n * ```\n * <select [compareWith]=\"compareFn\"  [formControl]=\"selectedCountriesControl\">\n *     <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *         {{country.name}}\n *     </option>\n * </select>\n *\n * compareFn(c1: Country, c2: Country): boolean {\n *     return c1 && c2 ? c1.id === c2.id : c1 === c2;\n * }\n * ```\n *\n * **Note:** We listen to the 'change' event because 'input' events aren't fired\n * for selects in IE, see:\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class SelectControlValueAccessor extends BuiltInControlValueAccessor implements ControlValueAccessor {\n    /** @nodoc */\n    value: any;\n    /**\n     * @description\n     * Tracks the option comparison algorithm for tracking identities when\n     * checking for changes.\n     */\n    set compareWith(fn: (o1: any, o2: any) => boolean);\n    private _compareWith;\n    /**\n     * Sets the \"value\" property on the select element.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes.\n     * @nodoc\n     */\n    registerOnChange(fn: (value: any) => any): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<SelectControlValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<SelectControlValueAccessor, \"select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]\", never, { \"compareWith\": \"compareWith\"; }, {}, never, never, false>;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select\n * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @see `SelectControlValueAccessor`\n *\n * @usageNotes\n *\n * ### Using a multi-select control\n *\n * The follow example shows you how to use a multi-select control with a reactive form.\n *\n * ```ts\n * const countryControl = new FormControl();\n * ```\n *\n * ```\n * <select multiple name=\"countries\" [formControl]=\"countryControl\">\n *   <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *     {{ country.name }}\n *   </option>\n * </select>\n * ```\n *\n * ### Customizing option selection\n *\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\n * See the `SelectControlValueAccessor` for usage.\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor implements ControlValueAccessor {\n    /**\n     * The current value.\n     * @nodoc\n     */\n    value: any;\n    /**\n     * @description\n     * Tracks the option comparison algorithm for tracking identities when\n     * checking for changes.\n     */\n    set compareWith(fn: (o1: any, o2: any) => boolean);\n    private _compareWith;\n    /**\n     * Sets the \"value\" property on one or of more of the select's options.\n     * @nodoc\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a function called when the control value changes\n     * and writes an array of the selected options.\n     * @nodoc\n     */\n    registerOnChange(fn: (value: any) => any): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<SelectMultipleControlValueAccessor, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<SelectMultipleControlValueAccessor, \"select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]\", never, { \"compareWith\": \"compareWith\"; }, {}, never, never, false>;\n}\n\ndeclare const SHARED_FORM_DIRECTIVES: Type<any>[];\n\ndeclare const TEMPLATE_DRIVEN_DIRECTIVES: Type<any>[];\n\n/**\n * UntypedFormArray is a non-strongly-typed version of @see FormArray, which\n * permits heterogenous controls.\n */\nexport declare type UntypedFormArray = FormArray<any>;\n\nexport declare const UntypedFormArray: UntypedFormArrayCtor;\n\ndeclare interface UntypedFormArrayCtor {\n    new (controls: AbstractControl[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): UntypedFormArray;\n    /**\n     * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n     * manually inspect the prototype chain.\n     */\n    prototype: FormArray<any>;\n}\n\n/**\n * UntypedFormBuilder is the same as @see FormBuilder, but it provides untyped controls.\n */\nexport declare class UntypedFormBuilder extends FormBuilder {\n    /**\n     * Like `FormBuilder#group`, except the resulting group is untyped.\n     */\n    group(controlsConfig: {\n        [key: string]: any;\n    }, options?: AbstractControlOptions | null): UntypedFormGroup;\n    /**\n     * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n     * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n     */\n    group(controlsConfig: {\n        [key: string]: any;\n    }, options: {\n        [key: string]: any;\n    }): UntypedFormGroup;\n    /**\n     * Like `FormBuilder#control`, except the resulting control is untyped.\n     */\n    control(formState: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): UntypedFormControl;\n    /**\n     * Like `FormBuilder#array`, except the resulting array is untyped.\n     */\n    array(controlsConfig: any[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): UntypedFormArray;\n    static ɵfac: i0.ɵɵFactoryDeclaration<UntypedFormBuilder, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<UntypedFormBuilder>;\n}\n\n/**\n * UntypedFormControl is a non-strongly-typed version of @see FormControl.\n */\nexport declare type UntypedFormControl = FormControl<any>;\n\nexport declare const UntypedFormControl: UntypedFormControlCtor;\n\ndeclare interface UntypedFormControlCtor {\n    new (): UntypedFormControl;\n    new (formState?: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): UntypedFormControl;\n    /**\n     * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n     * manually inspect the prototype chain.\n     */\n    prototype: FormControl<any>;\n}\n\n/**\n * UntypedFormGroup is a non-strongly-typed version of @see FormGroup.\n */\nexport declare type UntypedFormGroup = FormGroup<any>;\n\nexport declare const UntypedFormGroup: UntypedFormGroupCtor;\n\ndeclare interface UntypedFormGroupCtor {\n    new (controls: {\n        [key: string]: AbstractControl;\n    }, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): UntypedFormGroup;\n    /**\n     * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n     * manually inspect the prototype chain.\n     */\n    prototype: FormGroup<any>;\n}\n\n/**\n * @description\n * Defines the map of errors returned from failed validation checks.\n *\n * @publicApi\n */\nexport declare type ValidationErrors = {\n    [key: string]: any;\n};\n\n/**\n * @description\n * An interface implemented by classes that perform synchronous validation.\n *\n * @usageNotes\n *\n * ### Provide a custom validator\n *\n * The following example implements the `Validator` interface to create a\n * validator directive with a custom error key.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors|null {\n *     return {'custom': true};\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare interface Validator {\n    /**\n     * @description\n     * Method that performs synchronous validation against the provided control.\n     *\n     * @param control The control to validate against.\n     *\n     * @returns A map of validation errors if validation fails,\n     * otherwise null.\n     */\n    validate(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Registers a callback function to call when the validator inputs change.\n     *\n     * @param fn The callback function\n     */\n    registerOnValidatorChange?(fn: () => void): void;\n}\n\n/**\n * The union of all validator types that can be accepted by a ControlConfig.\n */\ndeclare type ValidatorConfig = ValidatorFn | AsyncValidatorFn | ValidatorFn[] | AsyncValidatorFn[];\n\n/**\n * @description\n * A function that receives a control and synchronously returns a map of\n * validation errors if present, otherwise null.\n *\n * @publicApi\n */\nexport declare interface ValidatorFn {\n    (control: AbstractControl): ValidationErrors | null;\n}\n\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](/guide/form-validation)\n *\n * @publicApi\n */\nexport declare class Validators {\n    /**\n     * @description\n     * Validator that requires the control's value to be greater than or equal to the provided number.\n     *\n     * @usageNotes\n     *\n     * ### Validate against a minimum of 3\n     *\n     * ```typescript\n     * const control = new FormControl(2, Validators.min(3));\n     *\n     * console.log(control.errors); // {min: {min: 3, actual: 2}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `min` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static min(min: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the control's value to be less than or equal to the provided number.\n     *\n     * @usageNotes\n     *\n     * ### Validate against a maximum of 15\n     *\n     * ```typescript\n     * const control = new FormControl(16, Validators.max(15));\n     *\n     * console.log(control.errors); // {max: {max: 15, actual: 16}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `max` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static max(max: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the control have a non-empty value.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field is non-empty\n     *\n     * ```typescript\n     * const control = new FormControl('', Validators.required);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map with the `required` property\n     * if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static required(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Validator that requires the control's value be true. This validator is commonly\n     * used for required checkboxes.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field value is true\n     *\n     * ```typescript\n     * const control = new FormControl('some value', Validators.requiredTrue);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map that contains the `required` property\n     * set to `true` if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static requiredTrue(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Validator that requires the control's value pass an email validation test.\n     *\n     * Tests the value using a [regular\n     * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n     * pattern suitable for common use cases. The pattern is based on the definition of a valid email\n     * address in the [WHATWG HTML\n     * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n     * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n     * lengths of different parts of the address).\n     *\n     * The differences from the WHATWG version include:\n     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n     * - Disallow `local-part` to be longer than 64 characters.\n     * - Disallow the whole address to be longer than 254 characters.\n     *\n     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n     * validate the value against a different pattern.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field matches a valid email pattern\n     *\n     * ```typescript\n     * const control = new FormControl('bad@', Validators.email);\n     *\n     * console.log(control.errors); // {email: true}\n     * ```\n     *\n     * @returns An error map with the `email` property\n     * if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static email(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Validator that requires the length of the control's value to be greater than or equal\n     * to the provided minimum length. This validator is also provided by default if you use the\n     * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n     * only for types that have a numeric `length` property, such as strings or arrays. The\n     * `minLength` validator logic is also not invoked for values when their `length` property is 0\n     * (for example in case of an empty string or an empty array), to support optional controls. You\n     * can use the standard `required` validator if empty values should not be considered valid.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field has a minimum of 3 characters\n     *\n     * ```typescript\n     * const control = new FormControl('ng', Validators.minLength(3));\n     *\n     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n     * ```\n     *\n     * ```html\n     * <input minlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `minlength` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static minLength(minLength: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the length of the control's value to be less than or equal\n     * to the provided maximum length. This validator is also provided by default if you use the\n     * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n     * only for types that have a numeric `length` property, such as strings or arrays.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field has maximum of 5 characters\n     *\n     * ```typescript\n     * const control = new FormControl('Angular', Validators.maxLength(5));\n     *\n     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n     * ```\n     *\n     * ```html\n     * <input maxlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `maxlength` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static maxLength(maxLength: number): ValidatorFn;\n    /**\n     * @description\n     * Validator that requires the control's value to match a regex pattern. This validator is also\n     * provided by default if you use the HTML5 `pattern` attribute.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field only contains letters or spaces\n     *\n     * ```typescript\n     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n     *\n     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n     * ```\n     *\n     * ```html\n     * <input pattern=\"[a-zA-Z ]*\">\n     * ```\n     *\n     * ### Pattern matching with the global or sticky flag\n     *\n     * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n     * can produce different results on the same input when validations are run consecutively. This is\n     * due to how the behavior of `RegExp.prototype.test` is\n     * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n     * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n     * Due to this behavior, it is recommended that when using\n     * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n     * flag enabled.\n     *\n     * ```typescript\n     * // Not recommended (since the `g` flag is used)\n     * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n     *\n     * // Good\n     * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n     * ```\n     *\n     * @param pattern A regular expression to be used as is to test the values, or a string.\n     * If a string is passed, the `^` character is prepended and the `$` character is\n     * appended to the provided string (if not already present), and the resulting regular\n     * expression is used to test the values.\n     *\n     * @returns A validator function that returns an error map with the\n     * `pattern` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static pattern(pattern: string | RegExp): ValidatorFn;\n    /**\n     * @description\n     * Validator that performs no operation.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static nullValidator(control: AbstractControl): ValidationErrors | null;\n    /**\n     * @description\n     * Compose multiple validators into a single function that returns the union\n     * of the individual error maps for the provided control.\n     *\n     * @returns A validator function that returns an error map with the\n     * merged error maps of the validators if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static compose(validators: null): null;\n    static compose(validators: (ValidatorFn | null | undefined)[]): ValidatorFn | null;\n    /**\n     * @description\n     * Compose multiple async validators into a single function that returns the union\n     * of the individual error objects for the provided control.\n     *\n     * @returns A validator function that returns an error map with the\n     * merged error objects of the async validators if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null;\n}\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\n/**\n * CoerceStrArrToNumArr accepts an array of strings, and converts any numeric string to a number.\n */\nexport declare type ɵCoerceStrArrToNumArr<S> = S extends [infer Head, ...infer Tail] ? Head extends `${number}` ? [\nnumber,\n...ɵCoerceStrArrToNumArr<Tail>\n] : [\nHead,\n...ɵCoerceStrArrToNumArr<Tail>\n] : [\n];\n\n/**\n * FormBuilder accepts values in various container shapes, as well as raw values.\n * Element returns the appropriate corresponding model class, given the container T.\n * The flag N, if not never, makes the resulting `FormControl` have N in its type.\n */\nexport declare type ɵElement<T, N extends null> = [\nT\n] extends [FormControl<infer U>] ? FormControl<U> : [\nT\n] extends [FormControl<infer U> | undefined] ? FormControl<U> : [\nT\n] extends [FormGroup<infer U>] ? FormGroup<U> : [\nT\n] extends [FormGroup<infer U> | undefined] ? FormGroup<U> : [\nT\n] extends [FormRecord<infer U>] ? FormRecord<U> : [\nT\n] extends [FormRecord<infer U> | undefined] ? FormRecord<U> : [\nT\n] extends [FormArray<infer U>] ? FormArray<U> : [\nT\n] extends [FormArray<infer U> | undefined] ? FormArray<U> : [\nT\n] extends [AbstractControl<infer U>] ? AbstractControl<U> : [\nT\n] extends [AbstractControl<infer U> | undefined] ? AbstractControl<U> : [\nT\n] extends [FormControlState<infer U>] ? FormControl<U | N> : [\nT\n] extends [PermissiveControlConfig<infer U>] ? FormControl<Exclude<U, ValidatorConfig> | N> : FormControl<T | N>;\n\n/**\n * FormArrayRawValue extracts the type of `.getRawValue()` from a FormArray's element type, and\n * wraps it in an array. The untyped case falls back to any[].\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n */\nexport declare type ɵFormArrayRawValue<T extends AbstractControl<any>> = ɵTypedOrUntyped<T, Array<ɵRawValue<T>>, any[]>;\n\n/**\n * FormArrayValue extracts the type of `.value` from a FormArray's element type, and wraps it in an\n * array.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly. The untyped\n * case falls back to any[].\n */\nexport declare type ɵFormArrayValue<T extends AbstractControl<any>> = ɵTypedOrUntyped<T, Array<ɵValue<T>>, any[]>;\n\n/**\n * Various available constructors for `FormControl`.\n * Do not use this interface directly. Instead, use `FormControl`:\n * ```\n * const fc = new FormControl('foo');\n * ```\n * This symbol is prefixed with ɵ to make plain that it is an internal symbol.\n */\nexport declare interface ɵFormControlCtor {\n    /**\n     * Construct a FormControl with no initial value or validators.\n     */\n    new (): FormControl<any>;\n    /**\n     * Creates a new `FormControl` instance.\n     *\n     * @param formState Initializes the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or a `FormControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     */\n    new <T = any>(value: FormControlState<T> | T, opts: FormControlOptions & {\n        nonNullable: true;\n    }): FormControl<T>;\n    /**\n     * @deprecated Use `nonNullable` instead.\n     */\n    new <T = any>(value: FormControlState<T> | T, opts: FormControlOptions & {\n        initialValueIsDefault: true;\n    }): FormControl<T>;\n    /**\n     * @deprecated When passing an `options` argument, the `asyncValidator` argument has no effect.\n     */\n    new <T = any>(value: FormControlState<T> | T, opts: FormControlOptions, asyncValidator: AsyncValidatorFn | AsyncValidatorFn[]): FormControl<T | null>;\n    new <T = any>(value: FormControlState<T> | T, validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormControl<T | null>;\n    /**\n     * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n     * manually inspect the prototype chain.\n     */\n    prototype: FormControl<any>;\n}\n\n/**\n * FormGroupRawValue extracts the type of `.getRawValue()` from a FormGroup's inner object type. The\n * untyped case falls back to {[key: string]: any}.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n *\n * For internal use only.\n */\nexport declare type ɵFormGroupRawValue<T extends {\n    [K in keyof T]?: AbstractControl<any>;\n}> = ɵTypedOrUntyped<T, {\n    [K in keyof T]: ɵRawValue<T[K]>;\n}, {\n    [key: string]: any;\n}>;\n\n/**\n * FormGroupValue extracts the type of `.value` from a FormGroup's inner object type. The untyped\n * case falls back to {[key: string]: any}.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n *\n * For internal use only.\n */\nexport declare type ɵFormGroupValue<T extends {\n    [K in keyof T]?: AbstractControl<any>;\n}> = ɵTypedOrUntyped<T, Partial<{\n    [K in keyof T]: ɵValue<T[K]>;\n}>, {\n    [key: string]: any;\n}>;\n\n/**\n * GetProperty takes a type T and some property names or indices K.\n * If K is a dot-separated string, it is tokenized into an array before proceeding.\n * Then, the type of the nested property at K is computed: T[K[0]][K[1]][K[2]]...\n * This works with both objects, which are indexed by property name, and arrays, which are indexed\n * numerically.\n *\n * For internal use only.\n */\nexport declare type ɵGetProperty<T, K> = K extends string ? ɵGetProperty<T, ɵCoerceStrArrToNumArr<ɵTokenize<K, '.'>>> : ɵWriteable<K> extends Array<string | number> ? ɵNavigate<T, ɵWriteable<K>> : any;\n\n/**\n * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\n */\nexport declare class ɵInternalFormsSharedModule {\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵInternalFormsSharedModule, never>;\n    static ɵmod: i0.ɵɵNgModuleDeclaration<ɵInternalFormsSharedModule, [typeof i1.ɵNgNoValidate, typeof i2.NgSelectOption, typeof i3.ɵNgSelectMultipleOption, typeof i4.DefaultValueAccessor, typeof i5.NumberValueAccessor, typeof i6.RangeValueAccessor, typeof i7.CheckboxControlValueAccessor, typeof i2.SelectControlValueAccessor, typeof i3.SelectMultipleControlValueAccessor, typeof i8.RadioControlValueAccessor, typeof i9.NgControlStatus, typeof i9.NgControlStatusGroup, typeof i10.RequiredValidator, typeof i10.MinLengthValidator, typeof i10.MaxLengthValidator, typeof i10.PatternValidator, typeof i10.CheckboxRequiredValidator, typeof i10.EmailValidator, typeof i10.MinValidator, typeof i10.MaxValidator], [typeof i8.RadioControlRegistryModule], [typeof i1.ɵNgNoValidate, typeof i2.NgSelectOption, typeof i3.ɵNgSelectMultipleOption, typeof i4.DefaultValueAccessor, typeof i5.NumberValueAccessor, typeof i6.RangeValueAccessor, typeof i7.CheckboxControlValueAccessor, typeof i2.SelectControlValueAccessor, typeof i3.SelectMultipleControlValueAccessor, typeof i8.RadioControlValueAccessor, typeof i9.NgControlStatus, typeof i9.NgControlStatusGroup, typeof i10.RequiredValidator, typeof i10.MinLengthValidator, typeof i10.MaxLengthValidator, typeof i10.PatternValidator, typeof i10.CheckboxRequiredValidator, typeof i10.EmailValidator, typeof i10.MinValidator, typeof i10.MaxValidator]>;\n    static ɵinj: i0.ɵɵInjectorDeclaration<ɵInternalFormsSharedModule>;\n}\n\ndeclare type ɵIsAny<T, Y, N> = 0 extends (1 & T) ? Y : N;\n\n/**\n * Navigate takes a type T and an array K, and returns the type of T[K[0]][K[1]][K[2]]...\n */\nexport declare type ɵNavigate<T, K extends (Array<string | number>)> = T extends object ? (K extends [infer Head, ...infer Tail] ? (Head extends keyof T ? (Tail extends (string | number)[] ? [\n] extends Tail ? T[Head] : (ɵNavigate<T[Head], Tail>) : any) : never) : any) : any;\n\n/**\n * @description\n *\n * Adds `novalidate` attribute to all forms by default.\n *\n * `novalidate` is used to disable browser's native form validation.\n *\n * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:\n *\n * ```\n * <form ngNativeValidate></form>\n * ```\n *\n * @publicApi\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n */\nexport declare class ɵNgNoValidate {\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵNgNoValidate, never>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<ɵNgNoValidate, \"form:not([ngNoForm]):not([ngNativeValidate])\", never, {}, {}, never, never, false>;\n}\n\n/**\n * @description\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * @see `SelectMultipleControlValueAccessor`\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\nexport declare class ɵNgSelectMultipleOption implements OnDestroy {\n    private _element;\n    private _renderer;\n    private _select;\n    id: string;\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectMultipleControlValueAccessor);\n    /**\n     * @description\n     * Tracks the value bound to the option element. Unlike the value binding,\n     * ngValue supports binding to objects.\n     */\n    set ngValue(value: any);\n    /**\n     * @description\n     * Tracks simple string values bound to the option element.\n     * For objects, use the `ngValue` input binding.\n     */\n    set value(value: any);\n    /** @nodoc */\n    ngOnDestroy(): void;\n    static ɵfac: i0.ɵɵFactoryDeclaration<ɵNgSelectMultipleOption, [null, null, { optional: true; host: true; }]>;\n    static ɵdir: i0.ɵɵDirectiveDeclaration<ɵNgSelectMultipleOption, \"option\", never, { \"ngValue\": \"ngValue\"; \"value\": \"value\"; }, {}, never, never, false>;\n}\n\n/**\n * OptionalKeys returns the union of all optional keys in the object.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n */\nexport declare type ɵOptionalKeys<T> = {\n    [K in keyof T]-?: undefined extends T[K] ? K : never;\n}[keyof T];\n\n/**\n * RawValue gives the raw value type corresponding to a control type.\n *\n * Note that the resulting type will follow the same rules as `.getRawValue()` on your control,\n * group, or array. This means that all controls inside a group will be required, not optional,\n * regardless of their disabled state.\n *\n * You may also wish to use {@link ɵValue}, which will have `undefined` in group keys (which can be\n * disabled).\n *\n * @usageNotes\n *\n * ### `FormGroup` raw value type\n *\n * Imagine you have an interface defining the controls in your group. You can extract the shape of\n * the raw values as follows:\n *\n * ```ts\n * interface PartyFormControls {\n *   address: FormControl<string>;\n * }\n *\n * // RawValue operates on controls; the object must be wrapped in a FormGroup.\n * type PartyFormValues = RawValue<FormGroup<PartyFormControls>>;\n * ```\n *\n * The resulting type is `{address: string}`. (Note the absence of `undefined`.)\n *\n *  **Internal: not for public use.**\n */\nexport declare type ɵRawValue<T extends AbstractControl | undefined> = T extends AbstractControl<any, any> ? (T['setValue'] extends ((v: infer R) => void) ? R : never) : never;\n\n/**\n * Tokenize splits a string literal S by a delimiter D.\n */\nexport declare type ɵTokenize<S extends string, D extends string> = string extends S ? string[] : S extends `${infer T}${D}${infer U}` ? [T, ...ɵTokenize<U, D>] : [\nS\n];\n\n/**\n * `TypedOrUntyped` allows one of two different types to be selected, depending on whether the Forms\n * class it's applied to is typed or not.\n *\n * This is for internal Angular usage to support typed forms; do not directly use it.\n */\nexport declare type ɵTypedOrUntyped<T, Typed, Untyped> = ɵIsAny<T, Untyped, Typed>;\n\n/**\n * Value gives the value type corresponding to a control type.\n *\n * Note that the resulting type will follow the same rules as `.value` on your control, group, or\n * array, including `undefined` for each group element which might be disabled.\n *\n * If you are trying to extract a value type for a data model, you probably want {@link RawValue},\n * which will not have `undefined` in group keys.\n *\n * @usageNotes\n *\n * ### `FormControl` value type\n *\n * You can extract the value type of a single control:\n *\n * ```ts\n * type NameControl = FormControl<string>;\n * type NameValue = Value<NameControl>;\n * ```\n *\n * The resulting type is `string`.\n *\n * ### `FormGroup` value type\n *\n * Imagine you have an interface defining the controls in your group. You can extract the shape of\n * the values as follows:\n *\n * ```ts\n * interface PartyFormControls {\n *   address: FormControl<string>;\n * }\n *\n * // Value operates on controls; the object must be wrapped in a FormGroup.\n * type PartyFormValues = Value<FormGroup<PartyFormControls>>;\n * ```\n *\n * The resulting type is `{address: string|undefined}`.\n *\n * ### `FormArray` value type\n *\n * You can extract values from FormArrays as well:\n *\n * ```ts\n * type GuestNamesControls = FormArray<FormControl<string>>;\n *\n * type NamesValues = Value<GuestNamesControls>;\n * ```\n *\n * The resulting type is `string[]`.\n *\n * **Internal: not for public use.**\n */\nexport declare type ɵValue<T extends AbstractControl | undefined> = T extends AbstractControl<any, any> ? T['value'] : never;\n\n/**\n * ɵWriteable removes readonly from all keys.\n */\nexport declare type ɵWriteable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\nexport { }\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/bindCallback.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/bindCallback';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/bindNodeCallback.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/bindNodeCallback';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/combineLatest.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/combineLatest';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/concat.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/concat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/defer.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/defer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/dom/ajax.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/dom/ajax';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/dom/webSocket.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/dom/webSocket';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/empty.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/empty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/forkJoin.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/forkJoin';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/from.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/from';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/fromEvent.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/fromEvent';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/fromEventPattern.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/fromEventPattern';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/fromPromise.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/fromPromise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/generate.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/generate';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/if.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/if';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/interval.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/interval';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/merge.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/merge';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/never.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/never';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/of.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/of';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/onErrorResumeNext.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/onErrorResumeNext';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/pairs.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/pairs';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/race.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/race';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/range.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/range';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/throw.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/throw';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/timer.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/timer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/using.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/using';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/observable/zip.d.ts"
    ],
    "content": "import 'rxjs-compat/add/observable/zip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/audit.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/audit';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/auditTime.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/auditTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/buffer.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/buffer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/bufferCount.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/bufferCount';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/bufferTime.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/bufferTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/bufferToggle.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/bufferToggle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/bufferWhen.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/bufferWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/catch.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/catch';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/combineAll.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/combineAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/combineLatest.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/combineLatest';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/concat.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/concat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/concatAll.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/concatAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/concatMap.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/concatMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/concatMapTo.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/concatMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/count.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/count';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/debounce.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/debounce';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/debounceTime.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/debounceTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/defaultIfEmpty.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/defaultIfEmpty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/delay.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/delay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/delayWhen.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/delayWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/dematerialize.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/dematerialize';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/distinct.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/distinct';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/distinctUntilChanged.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/distinctUntilChanged';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/distinctUntilKeyChanged.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/distinctUntilKeyChanged';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/do.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/do';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/elementAt.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/elementAt';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/every.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/every';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/exhaust.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/exhaust';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/exhaustMap.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/exhaustMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/expand.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/expand';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/filter.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/filter';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/finally.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/finally';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/find.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/find';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/findIndex.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/findIndex';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/first.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/first';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/groupBy.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/groupBy';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/ignoreElements.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/ignoreElements';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/isEmpty.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/isEmpty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/last.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/last';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/let.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/let';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/map.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/map';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/mapTo.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/mapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/materialize.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/materialize';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/max.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/max';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/merge.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/merge';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/mergeAll.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/mergeAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/mergeMap.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/mergeMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/mergeMapTo.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/mergeMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/mergeScan.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/mergeScan';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/min.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/min';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/multicast.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/multicast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/observeOn.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/observeOn';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/onErrorResumeNext.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/onErrorResumeNext';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/pairwise.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/pairwise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/partition.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/partition';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/pluck.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/pluck';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/publish.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/publish';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/publishBehavior.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/publishBehavior';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/publishLast.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/publishLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/publishReplay.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/publishReplay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/race.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/race';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/reduce.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/reduce';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/repeat.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/repeat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/repeatWhen.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/repeatWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/retry.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/retry';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/retryWhen.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/retryWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/sample.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/sample';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/sampleTime.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/sampleTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/scan.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/scan';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/sequenceEqual.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/sequenceEqual';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/share.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/share';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/shareReplay.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/shareReplay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/single.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/single';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/skip.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/skip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/skipLast.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/skipLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/skipUntil.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/skipUntil';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/skipWhile.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/skipWhile';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/startWith.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/startWith';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/subscribeOn.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/subscribeOn';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/switch.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/switch';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/switchMap.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/switchMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/switchMapTo.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/switchMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/take.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/take';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/takeLast.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/takeLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/takeUntil.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/takeUntil';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/takeWhile.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/takeWhile';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/throttle.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/throttle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/throttleTime.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/throttleTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/timeInterval.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/timeInterval';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/timeout.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/timeout';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/timeoutWith.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/timeoutWith';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/timestamp.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/timestamp';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/toArray.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/toArray';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/toPromise.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/toPromise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/window.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/window';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/windowCount.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/windowCount';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/windowTime.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/windowTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/windowToggle.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/windowToggle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/windowWhen.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/windowWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/withLatestFrom.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/withLatestFrom';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/zip.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/zip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/add/operator/zipAll.d.ts"
    ],
    "content": "import 'rxjs-compat/add/operator/zipAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/ajax/index.d.ts",
      "node_modules/rxjs/ajax/index.d.ts"
    ],
    "content": "export { ajax } from '../internal/observable/dom/ajax';\nexport { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/AsyncSubject.d.ts"
    ],
    "content": "export * from 'rxjs-compat/AsyncSubject';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/BehaviorSubject.d.ts"
    ],
    "content": "export * from 'rxjs-compat/BehaviorSubject';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/fetch/index.d.ts",
      "node_modules/rxjs/fetch/index.d.ts"
    ],
    "content": "export { fromFetch } from '../internal/observable/dom/fetch';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/index.d.ts",
      "node_modules/rxjs/index.d.ts"
    ],
    "content": "export { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { Operator } from './internal/Operator';\nexport { observable } from './internal/symbol/observable';\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\nexport { Notification, NotificationKind } from './internal/Notification';\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\nexport { TimeoutError } from './internal/util/TimeoutError';\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\nexport * from './internal/types';\nexport { config } from './internal/config';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/InnerSubscriber.d.ts"
    ],
    "content": "export * from 'rxjs-compat/InnerSubscriber';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/interfaces.d.ts"
    ],
    "content": "export * from 'rxjs-compat/interfaces';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal-compatibility/index.d.ts",
      "node_modules/rxjs/internal-compatibility/index.d.ts"
    ],
    "content": "export { config } from '../internal/config';\nexport { InnerSubscriber } from '../internal/InnerSubscriber';\nexport { OuterSubscriber } from '../internal/OuterSubscriber';\nexport { Scheduler } from '../internal/Scheduler';\nexport { AnonymousSubject } from '../internal/Subject';\nexport { SubjectSubscription } from '../internal/SubjectSubscription';\nexport { Subscriber } from '../internal/Subscriber';\nexport { fromPromise } from '../internal/observable/fromPromise';\nexport { fromIterable } from '../internal/observable/fromIterable';\nexport { ajax } from '../internal/observable/dom/ajax';\nexport { webSocket } from '../internal/observable/dom/webSocket';\nexport { AjaxRequest, AjaxCreationMethod, ajaxGet, ajaxPost, ajaxDelete, ajaxPut, ajaxPatch, ajaxGetJSON, AjaxObservable, AjaxSubscriber, AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';\nexport { WebSocketSubjectConfig, WebSocketSubject } from '../internal/observable/dom/WebSocketSubject';\nexport { CombineLatestOperator } from '../internal/observable/combineLatest';\nexport { EventTargetLike } from '../internal/observable/fromEvent';\nexport { ConditionFunc, IterateFunc, ResultFunc, GenerateBaseOptions, GenerateOptions } from '../internal/observable/generate';\nexport { dispatch } from '../internal/observable/range';\nexport { SubscribeOnObservable } from '../internal/observable/SubscribeOnObservable';\nexport { Timestamp } from '../internal/operators/timestamp';\nexport { TimeInterval } from '../internal/operators/timeInterval';\nexport { GroupedObservable } from '../internal/operators/groupBy';\nexport { ShareReplayConfig } from '../internal/operators/shareReplay';\nexport { ThrottleConfig, defaultThrottleConfig } from '../internal/operators/throttle';\nexport { rxSubscriber } from '../internal/symbol/rxSubscriber';\nexport { iterator } from '../internal/symbol/iterator';\nexport { observable } from '../internal/symbol/observable';\nexport { ArgumentOutOfRangeError } from '../internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from '../internal/util/EmptyError';\nexport { Immediate } from '../internal/util/Immediate';\nexport { ObjectUnsubscribedError } from '../internal/util/ObjectUnsubscribedError';\nexport { TimeoutError } from '../internal/util/TimeoutError';\nexport { UnsubscriptionError } from '../internal/util/UnsubscriptionError';\nexport { applyMixins } from '../internal/util/applyMixins';\nexport { errorObject } from '../internal/util/errorObject';\nexport { hostReportError } from '../internal/util/hostReportError';\nexport { identity } from '../internal/util/identity';\nexport { isArray } from '../internal/util/isArray';\nexport { isArrayLike } from '../internal/util/isArrayLike';\nexport { isDate } from '../internal/util/isDate';\nexport { isFunction } from '../internal/util/isFunction';\nexport { isIterable } from '../internal/util/isIterable';\nexport { isNumeric } from '../internal/util/isNumeric';\nexport { isObject } from '../internal/util/isObject';\nexport { isInteropObservable as isObservable } from '../internal/util/isInteropObservable';\nexport { isPromise } from '../internal/util/isPromise';\nexport { isScheduler } from '../internal/util/isScheduler';\nexport { noop } from '../internal/util/noop';\nexport { not } from '../internal/util/not';\nexport { pipe } from '../internal/util/pipe';\nexport { root } from '../internal/util/root';\nexport { subscribeTo } from '../internal/util/subscribeTo';\nexport { subscribeToArray } from '../internal/util/subscribeToArray';\nexport { subscribeToIterable } from '../internal/util/subscribeToIterable';\nexport { subscribeToObservable } from '../internal/util/subscribeToObservable';\nexport { subscribeToPromise } from '../internal/util/subscribeToPromise';\nexport { subscribeToResult } from '../internal/util/subscribeToResult';\nexport { toSubscriber } from '../internal/util/toSubscriber';\nexport { tryCatch } from '../internal/util/tryCatch';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/AsyncSubject.d.ts"
    ],
    "content": "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport declare class AsyncSubject<T> extends Subject<T> {\n    private value;\n    private hasNext;\n    private hasCompleted;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<any>): Subscription;\n    next(value: T): void;\n    error(error: any): void;\n    complete(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/BehaviorSubject.d.ts"
    ],
    "content": "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport declare class BehaviorSubject<T> extends Subject<T> {\n    private _value;\n    constructor(_value: T);\n    readonly value: T;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    getValue(): T;\n    next(value: T): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/config.d.ts"
    ],
    "content": "/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport declare const config: {\n    /**\n     * The promise constructor used by default for methods such as\n     * {@link toPromise} and {@link forEach}\n     */\n    Promise: PromiseConstructorLike;\n    /**\n     * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n     * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n     * call in a try/catch block. It also enables producer interference, a nasty bug\n     * where a multicast can be broken for all observers by a downstream consumer with\n     * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n     * FOR MIGRATION REASONS.\n     */\n    useDeprecatedSynchronousErrorHandling: boolean;\n};\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/innerSubscribe.d.ts"
    ],
    "content": "/** @prettier */\nimport { Subscription } from './Subscription';\nimport { Subscriber } from './Subscriber';\ninterface SimpleOuterSubscriberLike<T> {\n    /**\n     * A handler for inner next notifications from the inner subscription\n     * @param innerValue the value nexted by the inner producer\n     */\n    notifyNext(innerValue: T): void;\n    /**\n     * A handler for inner error notifications from the inner subscription\n     * @param err the error from the inner producer\n     */\n    notifyError(err: any): void;\n    /**\n     * A handler for inner complete notifications from the inner subscription.\n     */\n    notifyComplete(): void;\n}\nexport declare class SimpleInnerSubscriber<T> extends Subscriber<T> {\n    private parent;\n    constructor(parent: SimpleOuterSubscriberLike<any>);\n    protected _next(value: T): void;\n    protected _error(error: any): void;\n    protected _complete(): void;\n}\nexport declare class ComplexInnerSubscriber<T, R> extends Subscriber<R> {\n    private parent;\n    outerValue: T;\n    outerIndex: number;\n    constructor(parent: ComplexOuterSubscriber<T, R>, outerValue: T, outerIndex: number);\n    protected _next(value: R): void;\n    protected _error(error: any): void;\n    protected _complete(): void;\n}\nexport declare class SimpleOuterSubscriber<T, R> extends Subscriber<T> implements SimpleOuterSubscriberLike<R> {\n    notifyNext(innerValue: R): void;\n    notifyError(err: any): void;\n    notifyComplete(): void;\n}\n/**\n * DO NOT USE (formerly \"OuterSubscriber\")\n * TODO: We want to refactor this and remove it. It is retaining values it shouldn't for long\n * periods of time.\n */\nexport declare class ComplexOuterSubscriber<T, R> extends Subscriber<T> {\n    /**\n     * @param _outerValue Used by: bufferToggle, delayWhen, windowToggle\n     * @param innerValue Used by: subclass default, combineLatest, race, bufferToggle, windowToggle, withLatestFrom\n     * @param _outerIndex Used by: combineLatest, race, withLatestFrom\n     * @param _innerSub Used by: delayWhen\n     */\n    notifyNext(_outerValue: T, innerValue: R, _outerIndex: number, _innerSub: ComplexInnerSubscriber<T, R>): void;\n    notifyError(error: any): void;\n    /**\n     * @param _innerSub Used by: race, bufferToggle, delayWhen, windowToggle, windowWhen\n     */\n    notifyComplete(_innerSub: ComplexInnerSubscriber<T, R>): void;\n}\nexport declare function innerSubscribe(result: any, innerSubscriber: Subscriber<any>): Subscription | undefined;\nexport {};\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/InnerSubscriber.d.ts"
    ],
    "content": "import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class InnerSubscriber<T, R> extends Subscriber<R> {\n    private parent;\n    outerValue: T;\n    outerIndex: number;\n    private index;\n    constructor(parent: OuterSubscriber<T, R>, outerValue: T, outerIndex: number);\n    protected _next(value: R): void;\n    protected _error(error: any): void;\n    protected _complete(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Notification.d.ts"
    ],
    "content": "import { PartialObserver } from './types';\nimport { Observable } from './Observable';\n/**\n * @deprecated NotificationKind is deprecated as const enums are not compatible with isolated modules. Use a string literal instead.\n */\nexport declare enum NotificationKind {\n    NEXT = \"N\",\n    ERROR = \"E\",\n    COMPLETE = \"C\"\n}\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport declare class Notification<T> {\n    kind: 'N' | 'E' | 'C';\n    value?: T;\n    error?: any;\n    hasValue: boolean;\n    constructor(kind: 'N' | 'E' | 'C', value?: T, error?: any);\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    observe(observer: PartialObserver<T>): any;\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any;\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void): any;\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    toObservable(): Observable<T>;\n    private static completeNotification;\n    private static undefinedValueNotification;\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     * @nocollapse\n     */\n    static createNext<T>(value: T): Notification<T>;\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     * @nocollapse\n     */\n    static createError<T>(err?: any): Notification<T>;\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     * @nocollapse\n     */\n    static createComplete(): Notification<any>;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Observable.d.ts"
    ],
    "content": "import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport declare class Observable<T> implements Subscribable<T> {\n    /** Internal implementation detail, do not use directly. */\n    _isScalar: boolean;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    source: Observable<any>;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    operator: Operator<any, T>;\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic);\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     * @nocollapse\n     * @deprecated use new Observable() instead\n     */\n    static create: Function;\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    lift<R>(operator: Operator<T, R>): Observable<R>;\n    subscribe(observer?: PartialObserver<T>): Subscription;\n    /** @deprecated Use an observer instead of a complete callback */\n    subscribe(next: null | undefined, error: null | undefined, complete: () => void): Subscription;\n    /** @deprecated Use an observer instead of an error callback */\n    subscribe(next: null | undefined, error: (error: any) => void, complete?: () => void): Subscription;\n    /** @deprecated Use an observer instead of a complete callback */\n    subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Subscription;\n    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _trySubscribe(sink: Subscriber<T>): TeardownLogic;\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void>;\n    /** @internal This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<any>): TeardownLogic;\n    /**\n     * @nocollapse\n     * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n     */\n    static if: typeof iif;\n    /**\n     * @nocollapse\n     * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n     */\n    static throw: typeof throwError;\n    pipe(): Observable<T>;\n    pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n    pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n    pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n    pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n    pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n    pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n    pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n    pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n    pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n    pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;\n    toPromise<T>(this: Observable<T>): Promise<T>;\n    toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n    toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/bindCallback.d.ts"
    ],
    "content": "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\n/** @deprecated resultSelector is no longer supported, use a mapping function. */\nexport declare function bindCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\nexport declare function bindCallback<R1, R2, R3, R4>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): () => Observable<any[]>;\nexport declare function bindCallback<R1, R2, R3>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<R1, R2>(callbackFunc: (callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;\nexport declare function bindCallback<R1>(callbackFunc: (callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;\nexport declare function bindCallback(callbackFunc: (callback: () => any) => any, scheduler?: SchedulerLike): () => Observable<void>;\nexport declare function bindCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<any[]>;\nexport declare function bindCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;\nexport declare function bindCallback<A1>(callbackFunc: (arg1: A1, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;\nexport declare function bindCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;\nexport declare function bindCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;\nexport declare function bindCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;\nexport declare function bindCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;\nexport declare function bindCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;\nexport declare function bindCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<any[]>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;\nexport declare function bindCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;\nexport declare function bindCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;\nexport declare function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((result: R) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R>;\nexport declare function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((...results: R[]) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R[]>;\nexport declare function bindCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/bindNodeCallback.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport declare function bindNodeCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\nexport declare function bindNodeCallback<R1, R2, R3, R4>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<R1, R2, R3>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<R1, R2>(callbackFunc: (callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<R1>(callbackFunc: (callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;\nexport declare function bindNodeCallback(callbackFunc: (callback: (err: any) => any) => any, scheduler?: SchedulerLike): () => Observable<void>;\nexport declare function bindNodeCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;\nexport declare function bindNodeCallback<A1>(callbackFunc: (arg1: A1, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;\nexport declare function bindNodeCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;\nexport declare function bindNodeCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/combineLatest.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Operator } from '../Operator';\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, R>(sources: [O1], resultSelector: (v1: ObservedValueOf<O1>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(sources: [O1, O2], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(sources: [O1, O2, O3], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(sources: [O1, O2, O3, O4], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(sources: [O1, O2, O3, O4, O5], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(sources: [O1, O2, O3, O4, O5, O6], resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O extends ObservableInput<any>, R>(sources: O[], resultSelector: (...args: ObservedValueOf<O>[]) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, R>(v1: O1, resultSelector: (v1: ObservedValueOf<O1>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(v1: O1, v2: O2, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>>(sources: [O1], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(sources: [O1, O2], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(sources: [O1, O2, O3], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(sources: [O1, O2, O3, O4], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5, O6], scheduler: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O extends ObservableInput<any>>(sources: O[], scheduler: SchedulerLike): Observable<ObservedValueOf<O>[]>;\nexport declare function combineLatest<O1 extends ObservableInput<any>>(sources: [O1]): Observable<[ObservedValueOf<O1>]>;\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(sources: [O1, O2]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(sources: [O1, O2, O3]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(sources: [O1, O2, O3, O4]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(sources: [O1, O2, O3, O4, O5, O6]): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\nexport declare function combineLatest<O extends ObservableInput<any>>(sources: O[]): Observable<ObservedValueOf<O>[]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O1 extends ObservableInput<any>>(v1: O1, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, scheduler?: SchedulerLike): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O extends ObservableInput<any>>(...observables: O[]): Observable<any[]>;\n/** @deprecated Pass arguments in a single array instead `combineLatest([a, b, c])` */\nexport declare function combineLatest<O extends ObservableInput<any>, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function combineLatest<O extends ObservableInput<any>, R>(array: O[], resultSelector: (...values: ObservedValueOf<O>[]) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O extends ObservableInput<any>>(...observables: Array<O | SchedulerLike>): Observable<any[]>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<O extends ObservableInput<any>, R>(...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R) | SchedulerLike>): Observable<R>;\n/** @deprecated Passing a scheduler here is deprecated, use {@link subscribeOn} and/or {@link observeOn} instead */\nexport declare function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;\nexport declare class CombineLatestOperator<T, R> implements Operator<T, R> {\n    private resultSelector?;\n    constructor(resultSelector?: (...values: Array<any>) => R);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n    private resultSelector?;\n    private active;\n    private values;\n    private observables;\n    private toRespond?;\n    constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R);\n    protected _next(observable: any): void;\n    protected _complete(): void;\n    notifyComplete(unused: Subscriber<R>): void;\n    notifyNext(_outerValue: T, innerValue: R, outerIndex: number): void;\n    private _tryResultSelector;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/concat.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<O1 extends ObservableInput<any>>(v1: O1, scheduler: SchedulerLike): Observable<ObservedValueOf<O1>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, scheduler: SchedulerLike): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5> | ObservedValueOf<O6>>;\nexport declare function concat<O1 extends ObservableInput<any>>(v1: O1): Observable<ObservedValueOf<O1>>;\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2): Observable<ObservedValueOf<O1> | ObservedValueOf<O2>>;\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3>>;\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4>>;\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5>>;\nexport declare function concat<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): Observable<ObservedValueOf<O1> | ObservedValueOf<O2> | ObservedValueOf<O3> | ObservedValueOf<O4> | ObservedValueOf<O5> | ObservedValueOf<O6>>;\nexport declare function concat<O extends ObservableInput<any>>(...observables: O[]): Observable<ObservedValueOf<O>>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<O extends ObservableInput<any>>(...observables: (O | SchedulerLike)[]): Observable<ObservedValueOf<O>>;\nexport declare function concat<R>(...observables: ObservableInput<any>[]): Observable<R>;\n/** @deprecated Use {@link scheduled} and {@link concatAll} (e.g. `scheduled([o1, o2, o3], scheduler).pipe(concatAll())`) */\nexport declare function concat<R>(...observables: (ObservableInput<any> | SchedulerLike)[]): Observable<R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/ConnectableObservable.d.ts"
    ],
    "content": "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n/**\n * @class ConnectableObservable<T>\n */\nexport declare class ConnectableObservable<T> extends Observable<T> {\n    source: Observable<T>;\n    protected subjectFactory: () => Subject<T>;\n    protected _subject: Subject<T>;\n    protected _refCount: number;\n    protected _connection: Subscription;\n    /** @internal */\n    _isComplete: boolean;\n    constructor(source: Observable<T>, subjectFactory: () => Subject<T>);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    protected getSubject(): Subject<T>;\n    connect(): Subscription;\n    refCount(): Observable<T>;\n}\nexport declare const connectableObservableDescriptor: PropertyDescriptorMap;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/defer.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInput } from '../types';\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create the Observable only when the Observer\n * subscribes, and create a fresh Observable for each Observer. It waits until\n * an Observer subscribes to it, and then it generates an Observable,\n * typically with an Observable factory function. It does this afresh for each\n * subscriber, so although each subscriber may think it is subscribing to the\n * same Observable, in fact each subscriber gets its own individual\n * Observable.\n *\n * ## Example\n * ### Subscribe to either an Observable of clicks or an Observable of interval, at random\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(function () {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param {function(): SubscribableOrPromise} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n * @static true\n * @name defer\n * @owner Observable\n */\nexport declare function defer<R extends ObservableInput<any> | void>(observableFactory: () => R): Observable<ObservedValueOf<R>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/dom/ajax.d.ts"
    ],
    "content": "import { AjaxCreationMethod } from './AjaxObservable';\n/**\n * There is an ajax operator on the Rx object.\n *\n * It creates an observable for an Ajax request with either a request object with\n * url, headers, etc or a string for a URL.\n *\n *\n * ## Using ajax() to fetch the response object that is being returned from API.\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError } from 'rxjs/operators';\n * import { of } from 'rxjs';\n *\n * const obs$ = ajax(`https://api.github.com/users?per_page=5`).pipe(\n *   map(userResponse => console.log('users: ', userResponse)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * ```\n *\n * ## Using ajax.getJSON() to fetch data from API.\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError } from 'rxjs/operators';\n * import { of } from 'rxjs';\n *\n * const obs$ = ajax.getJSON(`https://api.github.com/users?per_page=5`).pipe(\n *   map(userResponse => console.log('users: ', userResponse)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * ```\n *\n * ## Using ajax() with object as argument and method POST with a two seconds delay.\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { of } from 'rxjs';\n *\n * const users = ajax({\n *   url: 'https://httpbin.org/delay/2',\n *   method: 'POST',\n *   headers: {\n *     'Content-Type': 'application/json',\n *     'rxjs-custom-header': 'Rxjs'\n *   },\n *   body: {\n *     rxjs: 'Hello World!'\n *   }\n * }).pipe(\n *   map(response => console.log('response: ', response)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * ```\n *\n * ## Using ajax() to fetch. An error object that is being returned from the request.\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError } from 'rxjs/operators';\n * import { of } from 'rxjs';\n *\n * const obs$ = ajax(`https://api.github.com/404`).pipe(\n *   map(userResponse => console.log('users: ', userResponse)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * ```\n */\nexport declare const ajax: AjaxCreationMethod;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/dom/AjaxObservable.d.ts"
    ],
    "content": "import { Observable } from '../../Observable';\nimport { Subscriber } from '../../Subscriber';\nimport { TeardownLogic } from '../../types';\nexport interface AjaxRequest {\n    url?: string;\n    body?: any;\n    user?: string;\n    async?: boolean;\n    method?: string;\n    headers?: Object;\n    timeout?: number;\n    password?: string;\n    hasContent?: boolean;\n    crossDomain?: boolean;\n    withCredentials?: boolean;\n    createXHR?: () => XMLHttpRequest;\n    progressSubscriber?: Subscriber<any>;\n    responseType?: string;\n}\nexport interface AjaxCreationMethod {\n    (urlOrRequest: string | AjaxRequest): Observable<AjaxResponse>;\n    get(url: string, headers?: Object): Observable<AjaxResponse>;\n    post(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n    put(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n    patch(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n    delete(url: string, headers?: Object): Observable<AjaxResponse>;\n    getJSON<T>(url: string, headers?: Object): Observable<T>;\n}\nexport declare function ajaxGet(url: string, headers?: Object): AjaxObservable<AjaxResponse>;\nexport declare function ajaxPost(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxDelete(url: string, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxPut(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxPatch(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\nexport declare function ajaxGetJSON<T>(url: string, headers?: Object): Observable<T>;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport declare class AjaxObservable<T> extends Observable<T> {\n    /**\n     * Creates an observable for an Ajax request with either a request object with\n     * url, headers, etc or a string for a URL.\n     *\n     * ## Example\n     * ```ts\n     * import { ajax } from 'rxjs/ajax';\n   *\n     * const source1 = ajax('/products');\n     * const source2 = ajax({ url: 'products', method: 'GET' });\n     * ```\n     *\n     * @param {string|Object} request Can be one of the following:\n     *   A string of the URL to make the Ajax call.\n     *   An object with the following properties\n     *   - url: URL of the request\n     *   - body: The body of the request\n     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n     *   - async: Whether the request is async\n     *   - headers: Optional headers\n     *   - crossDomain: true if a cross domain request, else false\n     *   - createXHR: a function to override if you need to use an alternate\n     *   XMLHttpRequest implementation.\n     *   - resultSelector: a function to use to alter the output value type of\n     *   the Observable. Gets {@link AjaxResponse} as an argument.\n     * @return {Observable} An observable sequence containing the XMLHttpRequest.\n     * @static true\n     * @name ajax\n     * @owner Observable\n     * @nocollapse\n    */\n    static create: AjaxCreationMethod;\n    private request;\n    constructor(urlOrRequest: string | AjaxRequest);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): TeardownLogic;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AjaxSubscriber<T> extends Subscriber<Event> {\n    request: AjaxRequest;\n    private xhr;\n    private done;\n    constructor(destination: Subscriber<T>, request: AjaxRequest);\n    next(e: Event): void;\n    private send;\n    private serializeBody;\n    private setHeaders;\n    private getHeader;\n    private setupEvents;\n    unsubscribe(): void;\n}\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\nexport declare class AjaxResponse {\n    originalEvent: Event;\n    xhr: XMLHttpRequest;\n    request: AjaxRequest;\n    /** @type {number} The HTTP status code */\n    status: number;\n    /** @type {string|ArrayBuffer|Document|object|any} The response data */\n    response: any;\n    /** @type {string} The raw responseText */\n    responseText: string;\n    /** @type {string} The responseType (e.g. 'json', 'arraybuffer', or 'xml') */\n    responseType: string;\n    constructor(originalEvent: Event, xhr: XMLHttpRequest, request: AjaxRequest);\n}\nexport declare type AjaxErrorNames = 'AjaxError' | 'AjaxTimeoutError';\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\nexport interface AjaxError extends Error {\n    /** @type {XMLHttpRequest} The XHR instance associated with the error */\n    xhr: XMLHttpRequest;\n    /** @type {AjaxRequest} The AjaxRequest associated with the error */\n    request: AjaxRequest;\n    /** @type {number} The HTTP status code */\n    status: number;\n    /** @type {string} The responseType (e.g. 'json', 'arraybuffer', or 'xml') */\n    responseType: string;\n    /** @type {string|ArrayBuffer|Document|object|any} The response data */\n    response: any;\n}\nexport interface AjaxErrorCtor {\n    new (message: string, xhr: XMLHttpRequest, request: AjaxRequest): AjaxError;\n}\nexport declare const AjaxError: AjaxErrorCtor;\nexport interface AjaxTimeoutError extends AjaxError {\n}\nexport interface AjaxTimeoutErrorCtor {\n    new (xhr: XMLHttpRequest, request: AjaxRequest): AjaxTimeoutError;\n}\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\nexport declare const AjaxTimeoutError: AjaxTimeoutErrorCtor;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/dom/fetch.d.ts"
    ],
    "content": "import { Observable } from '../../Observable';\nimport { ObservableInput } from '../../types';\nexport declare function fromFetch<T>(input: string | Request, init: RequestInit & {\n    selector: (response: Response) => ObservableInput<T>;\n}): Observable<T>;\nexport declare function fromFetch(input: string | Request, init?: RequestInit): Observable<Response>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/dom/webSocket.d.ts"
    ],
    "content": "import { WebSocketSubject, WebSocketSubjectConfig } from './WebSocketSubject';\n/**\n * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n *\n * <span class=\"informal\">{@link Subject} that communicates with a server via WebSocket</span>\n *\n * `webSocket` is a factory function that produces a `WebSocketSubject`,\n * which can be used to make WebSocket connection with an arbitrary endpoint.\n * `webSocket` accepts as an argument either a string with url of WebSocket endpoint, or an\n * {@link WebSocketSubjectConfig} object for providing additional configuration, as\n * well as Observers for tracking lifecycle of WebSocket connection.\n *\n * When `WebSocketSubject` is subscribed, it attempts to make a socket connection,\n * unless there is one made already. This means that many subscribers will always listen\n * on the same socket, thus saving resources. If however, two instances are made of `WebSocketSubject`,\n * even if these two were provided with the same url, they will attempt to make separate\n * connections. When consumer of a `WebSocketSubject` unsubscribes, socket connection is closed,\n * only if there are no more subscribers still listening. If after some time a consumer starts\n * subscribing again, connection is reestablished.\n *\n * Once connection is made, whenever a new message comes from the server, `WebSocketSubject` will emit that\n * message as a value in the stream. By default, a message from the socket is parsed via `JSON.parse`. If you\n * want to customize how deserialization is handled (if at all), you can provide custom `resultSelector`\n * function in {@link WebSocketSubject}. When connection closes, stream will complete, provided it happened without\n * any errors. If at any point (starting, maintaining or closing a connection) there is an error,\n * stream will also error with whatever WebSocket API has thrown.\n *\n * By virtue of being a {@link Subject}, `WebSocketSubject` allows for receiving and sending messages from the server. In order\n * to communicate with a connected endpoint, use `next`, `error` and `complete` methods. `next` sends a value to the server, so bear in mind\n * that this value will not be serialized beforehand. Because of This, `JSON.stringify` will have to be called on a value by hand,\n * before calling `next` with a result. Note also that if at the moment of nexting value\n * there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection\n * is finally established. `complete` method closes socket connection. `error` does the same,\n * as well as notifying the server that something went wrong via status code and string with details of what happened.\n * Since status code is required in WebSocket API, `WebSocketSubject` does not allow, like regular `Subject`,\n * arbitrary values being passed to the `error` method. It needs to be called with an object that has `code`\n * property with status code number and optional `reason` property with string describing details\n * of an error.\n *\n * Calling `next` does not affect subscribers of `WebSocketSubject` - they have no\n * information that something was sent to the server (unless of course the server\n * responds somehow to a message). On the other hand, since calling `complete` triggers\n * an attempt to close socket connection. If that connection is closed without any errors, stream will\n * complete, thus notifying all subscribers. And since calling `error` closes\n * socket connection as well, just with a different status code for the server, if closing itself proceeds\n * without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases\n * (calling `complete` or `error`), if process of closing socket connection results in some errors, *then* stream\n * will error.\n *\n * **Multiplexing**\n *\n * `WebSocketSubject` has an additional operator, not found in other Subjects. It is called `multiplex` and it is\n * used to simulate opening several socket connections, while in reality maintaining only one.\n * For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,\n * it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket\n * endpoints, running on separate machines with only GUI combining them together. Having a socket connection\n * for each functionality could become too resource expensive. It is a common pattern to have single\n * WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).\n * Even though there is a single connection in a client app, having the ability to manipulate streams as if it\n * were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for\n * given service and filter out messages of interest. This is exactly what `multiplex` method is for.\n *\n * Method accepts three parameters. First two are functions returning subscription and unsubscription messages\n * respectively. These are messages that will be sent to the server, whenever consumer of resulting Observable\n * subscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop\n * being forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,\n * gateway server can decide that it should connect to real sport news service and start forwarding messages from it.\n * Note that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just\n * as messages pushed via `next`. Also bear in mind that these messages will be sent on *every* subscription and\n * unsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server\n * might stop sending messages, since it got unsubscription message. This needs to be handled\n * on the server or using {@link publish} on a Observable returned from 'multiplex'.\n *\n * Last argument to `multiplex` is a `messageFilter` function which should return a boolean. It is used to filter out messages\n * sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these\n * messages with some kind of string identifier on a message object and `messageFilter` would return `true`\n * if there is such identifier on an object emitted by the socket. Messages which returns `false` in `messageFilter` are simply skipped,\n * and are not passed down the stream.\n *\n * Return value of `multiplex` is an Observable with messages incoming from emulated socket connection. Note that this\n * is not a `WebSocketSubject`, so calling `next` or `multiplex` again will fail. For pushing values to the\n * server, use root `WebSocketSubject`.\n *\n * ### Examples\n * #### Listening for messages from the server\n * ```ts\n * import { webSocket } from \"rxjs/webSocket\";\n * const subject = webSocket(\"ws://localhost:8081\");\n *\n * subject.subscribe(\n *    msg => console.log('message received: ' + msg), // Called whenever there is a message from the server.\n *    err => console.log(err), // Called if at any point WebSocket API signals some kind of error.\n *    () => console.log('complete') // Called when connection is closed (for whatever reason).\n *  );\n * ```\n *\n * #### Pushing messages to the server\n * ```ts\n * import { webSocket } from \"rxjs/webSocket\";\n * const subject = webSocket('ws://localhost:8081');\n *\n * subject.subscribe();\n * // Note that at least one consumer has to subscribe to the created subject - otherwise \"nexted\" values will be just buffered and not sent,\n * // since no connection was established!\n *\n * subject.next({message: 'some message'});\n * // This will send a message to the server once a connection is made. Remember value is serialized with JSON.stringify by default!\n *\n * subject.complete(); // Closes the connection.\n *\n * subject.error({code: 4000, reason: 'I think our app just broke!'});\n * // Also closes the connection, but let's the server know that this closing is caused by some error.\n * ```\n *\n * #### Multiplexing WebSocket\n * ```ts\n * import { webSocket } from \"rxjs/webSocket\";\n * const subject = webSocket('ws://localhost:8081');\n *\n * const observableA = subject.multiplex(\n *   () => ({subscribe: 'A'}), // When server gets this message, it will start sending messages for 'A'...\n *   () => ({unsubscribe: 'A'}), // ...and when gets this one, it will stop.\n *   message => message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.\n * );\n *\n * const observableB = subject.multiplex( // And the same goes for 'B'.\n *   () => ({subscribe: 'B'}),\n *   () => ({unsubscribe: 'B'}),\n *   message => message.type === 'B'\n * );\n *\n * const subA = observableA.subscribe(messageForA => console.log(messageForA));\n * // At this moment WebSocket connection is established. Server gets '{\"subscribe\": \"A\"}' message and starts sending messages for 'A',\n * // which we log here.\n *\n * const subB = observableB.subscribe(messageForB => console.log(messageForB));\n * // Since we already have a connection, we just send '{\"subscribe\": \"B\"}' message to the server. It starts sending messages for 'B',\n * // which we log here.\n *\n * subB.unsubscribe();\n * // Message '{\"unsubscribe\": \"B\"}' is sent to the server, which stops sending 'B' messages.\n *\n * subA.unsubscribe();\n * // Message '{\"unsubscribe\": \"A\"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root Subject,\n * // socket connection closes.\n * ```\n *\n *\n * @param {string|WebSocketSubjectConfig} urlConfigOrSource The WebSocket endpoint as an url or an object with\n * configuration and additional Observers.\n * @return {WebSocketSubject} Subject which allows to both send and receive messages via WebSocket connection.\n */\nexport declare function webSocket<T>(urlConfigOrSource: string | WebSocketSubjectConfig<T>): WebSocketSubject<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/dom/WebSocketSubject.d.ts"
    ],
    "content": "import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { Operator } from '../../Operator';\nimport { Observer, NextObserver } from '../../types';\n/**\n * WebSocketSubjectConfig is a plain Object that allows us to make our\n * webSocket configurable.\n *\n * <span class=\"informal\">Provides flexibility to {@link webSocket}</span>\n *\n * It defines a set of properties to provide custom behavior in specific\n * moments of the socket's lifecycle. When the connection opens we can\n * use `openObserver`, when the connection is closed `closeObserver`, if we\n * are interested in listening for data comming from server: `deserializer`,\n * which allows us to customize the deserialization strategy of data before passing it\n * to the socket client. By default `deserializer` is going to apply `JSON.parse` to each message comming\n * from the Server.\n *\n * ## Example\n * **deserializer**, the default for this property is `JSON.parse` but since there are just two options\n * for incomming data, either be text or binarydata. We can apply a custom deserialization strategy\n * or just simply skip the default behaviour.\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *     url: 'ws://localhost:8081',\n * //Apply any transformation of your choice.\n *     deserializer: ({data}) => data\n * });\n *\n * wsSubject.subscribe(console.log);\n *\n * // Let's suppose we have this on the Server: ws.send(\"This is a msg from the server\")\n * //output\n * //\n * // This is a msg from the server\n * ```\n *\n * **serializer** allows us tom apply custom serialization strategy but for the outgoing messages\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *     url: 'ws://localhost:8081',\n * //Apply any transformation of your choice.\n *     serializer: msg => JSON.stringify({channel: \"webDevelopment\", msg: msg})\n * });\n *\n * wsSubject.subscribe(() => subject.next(\"msg to the server\"));\n *\n * // Let's suppose we have this on the Server: ws.send(\"This is a msg from the server\")\n * //output\n * //\n * // {\"channel\":\"webDevelopment\",\"msg\":\"msg to the server\"}\n * ```\n *\n * **closeObserver** allows us to set a custom error when an error raise up.\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *     url: 'ws://localhost:8081',\n *     closeObserver: {\n        next(closeEvent) {\n            const customError = { code: 6666, reason: \"Custom evil reason\" }\n            console.log(`code: ${customError.code}, reason: ${customError.reason}`);\n        }\n    }\n * });\n *\n * //output\n * // code: 6666, reason: Custom evil reason\n * ```\n *\n * **openObserver**, Let's say we need to make some kind of init task before sending/receiving msgs to the\n * webSocket or sending notification that the connection was successful, this is when\n * openObserver is usefull for.\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *     url: 'ws://localhost:8081',\n *     openObserver: {\n *         next: () => {\n *             console.log('connetion ok');\n *         }\n *     },\n * });\n *\n * //output\n * // connetion ok`\n * ```\n * */\nexport interface WebSocketSubjectConfig<T> {\n    /** The url of the socket server to connect to */\n    url: string;\n    /** The protocol to use to connect */\n    protocol?: string | Array<string>;\n    /** @deprecated use {@link deserializer} */\n    resultSelector?: (e: MessageEvent) => T;\n    /**\n     * A serializer used to create messages from passed values before the\n     * messages are sent to the server. Defaults to JSON.stringify.\n     */\n    serializer?: (value: T) => WebSocketMessage;\n    /**\n     * A deserializer used for messages arriving on the socket from the\n     * server. Defaults to JSON.parse.\n     */\n    deserializer?: (e: MessageEvent) => T;\n    /**\n     * An Observer that watches when open events occur on the underlying web socket.\n     */\n    openObserver?: NextObserver<Event>;\n    /**\n     * An Observer than watches when close events occur on the underlying webSocket\n     */\n    closeObserver?: NextObserver<CloseEvent>;\n    /**\n     * An Observer that watches when a close is about to occur due to\n     * unsubscription.\n     */\n    closingObserver?: NextObserver<void>;\n    /**\n     * A WebSocket constructor to use. This is useful for situations like using a\n     * WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket\n     * for testing purposes\n     */\n    WebSocketCtor?: {\n        new (url: string, protocols?: string | string[]): WebSocket;\n    };\n    /** Sets the `binaryType` property of the underlying WebSocket. */\n    binaryType?: 'blob' | 'arraybuffer';\n}\nexport declare type WebSocketMessage = string | ArrayBuffer | Blob | ArrayBufferView;\nexport declare class WebSocketSubject<T> extends AnonymousSubject<T> {\n    private _config;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _output: Subject<T>;\n    private _socket;\n    constructor(urlConfigOrSource: string | WebSocketSubjectConfig<T> | Observable<T>, destination?: Observer<T>);\n    lift<R>(operator: Operator<T, R>): WebSocketSubject<R>;\n    private _resetState;\n    /**\n     * Creates an {@link Observable}, that when subscribed to, sends a message,\n     * defined by the `subMsg` function, to the server over the socket to begin a\n     * subscription to data over that socket. Once data arrives, the\n     * `messageFilter` argument will be used to select the appropriate data for\n     * the resulting Observable. When teardown occurs, either due to\n     * unsubscription, completion or error, a message defined by the `unsubMsg`\n     * argument will be send to the server over the WebSocketSubject.\n     *\n     * @param subMsg A function to generate the subscription message to be sent to\n     * the server. This will still be processed by the serializer in the\n     * WebSocketSubject's config. (Which defaults to JSON serialization)\n     * @param unsubMsg A function to generate the unsubscription message to be\n     * sent to the server at teardown. This will still be processed by the\n     * serializer in the WebSocketSubject's config.\n     * @param messageFilter A predicate for selecting the appropriate messages\n     * from the server for the output stream.\n     */\n    multiplex(subMsg: () => any, unsubMsg: () => any, messageFilter: (value: T) => boolean): Observable<any>;\n    private _connectSocket;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    unsubscribe(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/empty.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * `scheduler`. It is preferrable to use this over `empty()`.\n */\nexport declare const EMPTY: Observable<never>;\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * ![](empty.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then complete\n * ```ts\n * import { empty } from 'rxjs';\n * import { startWith } from 'rxjs/operators';\n *\n * const result = empty().pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'\n * ```ts\n * import { empty, interval, of } from 'rxjs';\n * import { mergeMap } from 'rxjs/operators';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throwError}\n *\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @return An \"empty\" Observable: emits only the complete\n * notification.\n * @deprecated Deprecated in favor of using {@link EMPTY} constant, or {@link scheduled} (e.g. `scheduled([], scheduler)`)\n */\nexport declare function empty(scheduler?: SchedulerLike): Observable<never>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/forkJoin.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, ObservedValuesFromArray, ObservedValueOf, SubscribableOrPromise } from '../types';\n/** @deprecated Use the version that takes an array of Observables instead */\nexport declare function forkJoin<T>(v1: SubscribableOrPromise<T>): Observable<[T]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport declare function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport declare function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport declare function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport declare function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport declare function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\nexport declare function forkJoin<A>(sources: [ObservableInput<A>]): Observable<[A]>;\nexport declare function forkJoin<A, B>(sources: [ObservableInput<A>, ObservableInput<B>]): Observable<[A, B]>;\nexport declare function forkJoin<A, B, C>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>]): Observable<[A, B, C]>;\nexport declare function forkJoin<A, B, C, D>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>]): Observable<[A, B, C, D]>;\nexport declare function forkJoin<A, B, C, D, E>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>]): Observable<[A, B, C, D, E]>;\nexport declare function forkJoin<A, B, C, D, E, F>(sources: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>, ObservableInput<F>]): Observable<[A, B, C, D, E, F]>;\nexport declare function forkJoin<A extends ObservableInput<any>[]>(sources: A): Observable<ObservedValuesFromArray<A>[]>;\nexport declare function forkJoin(sourcesObject: {}): Observable<never>;\nexport declare function forkJoin<T, K extends keyof T>(sourcesObject: T): Observable<{\n    [K in keyof T]: ObservedValueOf<T[K]>;\n}>;\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport declare function forkJoin(...args: Array<ObservableInput<any> | Function>): Observable<any>;\n/** @deprecated Use the version that takes an array of Observables instead */\nexport declare function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/from.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nexport declare function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated use {@link scheduled} instead. */\nexport declare function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike): Observable<ObservedValueOf<O>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/fromArray.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/fromEvent.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nexport interface NodeStyleEventEmitter {\n    addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n    removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n}\nexport declare type NodeEventHandler = (...args: any[]) => void;\nexport interface NodeCompatibleEventEmitter {\n    addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n    removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n}\nexport interface JQueryStyleEventEmitter {\n    on: (eventName: string, handler: Function) => void;\n    off: (eventName: string, handler: Function) => void;\n}\nexport interface HasEventTargetAddRemove<E> {\n    addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: EventListenerOptions | boolean): void;\n}\nexport declare type EventTargetLike<T> = HasEventTargetAddRemove<T> | NodeStyleEventEmitter | NodeCompatibleEventEmitter | JQueryStyleEventEmitter;\nexport declare type FromEventTarget<T> = EventTargetLike<T> | ArrayLike<EventTargetLike<T>>;\nexport interface EventListenerOptions {\n    capture?: boolean;\n    passive?: boolean;\n    once?: boolean;\n}\nexport interface AddEventListenerOptions extends EventListenerOptions {\n    once?: boolean;\n    passive?: boolean;\n}\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, resultSelector: (...args: any[]) => T): Observable<T>;\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions, resultSelector: (...args: any[]) => T): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/fromEventPattern.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { NodeEventHandler } from './fromEvent';\nexport declare function fromEventPattern<T>(addHandler: (handler: NodeEventHandler) => any, removeHandler?: (handler: NodeEventHandler, signal?: any) => void): Observable<T>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport declare function fromEventPattern<T>(addHandler: (handler: NodeEventHandler) => any, removeHandler?: (handler: NodeEventHandler, signal?: any) => void, resultSelector?: (...args: any[]) => T): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/fromIterable.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function fromIterable<T>(input: Iterable<T>, scheduler?: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/fromPromise.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function fromPromise<T>(input: PromiseLike<T>, scheduler?: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/generate.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare type ConditionFunc<S> = (state: S) => boolean;\nexport declare type IterateFunc<S> = (state: S) => S;\nexport declare type ResultFunc<S, T> = (state: S) => T;\nexport interface GenerateBaseOptions<S> {\n    /**\n     * Initial state.\n     */\n    initialState: S;\n    /**\n     * Condition function that accepts state and returns boolean.\n     * When it returns false, the generator stops.\n     * If not specified, a generator never stops.\n     */\n    condition?: ConditionFunc<S>;\n    /**\n     * Iterate function that accepts state and returns new state.\n     */\n    iterate: IterateFunc<S>;\n    /**\n     * SchedulerLike to use for generation process.\n     * By default, a generator starts immediately.\n     */\n    scheduler?: SchedulerLike;\n}\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n    /**\n     * Result selection function that accepts state and returns a value to emit.\n     */\n    resultSelector: ResultFunc<S, T>;\n}\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate(0, x => x < 10, x => x + 1, x => x);\n *\n * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>\n * const res = generate(1, x => x < 5, x => x * 2, x => x + 1, asap);\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\n * @returns {Observable<T>} The generated sequence.\n */\nexport declare function generate<T, S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, resultSelector: ResultFunc<S, T>, scheduler?: SchedulerLike): Observable<T>;\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * <img src=\"./img/generate.png\" width=\"100%\">\n *\n * `generate` allows you to create stream of values generated with a loop very similar to\n * traditional for loop. First argument of `generate` is a beginning value. Second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * loop continues, if not, it stops. Third value is a function which takes previously defined\n * value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in regular for loop: first expression\n * initializes some state (for example numeric index), second tests if loop can make next\n * iteration (for example if index is lower than 10) and third states how defined value\n * will be modified on every step (index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First, condition function is ran. If it returned true, Observable\n * emits currently stored value (initial value at the first iteration) and then updates\n * that value with iterate function. If at some point condition returned false, Observable\n * completes at that moment.\n *\n * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you\n * to immediately map value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * single object to the operator instead. That object has properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, so output Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is resultSelector\n * function or not). In case of single-parameter call, you can provide it as a\n * `scheduler` property on object passed to the operator. In both cases scheduler decides when\n * next iteration of the loop will happen and therefore when next value will be emitted\n * by the Observable. For example to ensure that each value is pushed to the observer\n * on separate task in event loop, you could use `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * @example <caption>Use with condition and iterate functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with condition, iterate and resultSelector functions.</caption>\n * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n *\n * @example <caption>Use with options object.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!')\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // \"Yo!\"\n *\n * @example <caption>Use options object without condition function.</caption>\n * const generated = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * generated.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('Yo!') // This will never run.\n * );\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n *\n *\n * @see {@link from}\n * @see {@link index/Observable.create}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\n * @return {Observable<T>} The generated sequence.\n */\nexport declare function generate<S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, scheduler?: SchedulerLike): Observable<S>;\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns {Observable<S>} The generated sequence.\n */\nexport declare function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n * const res = generate({\n *   initialState: 0,\n *   condition: x => x < 10,\n *   iterate: x => x + 1,\n *   resultSelector: x => x,\n * });\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns {Observable<T>} The generated sequence.\n */\nexport declare function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/iif.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SubscribableOrPromise } from '../types';\n/**\n * Decides at subscription time which Observable will actually be subscribed.\n *\n * <span class=\"informal\">`If` statement for Observables.</span>\n *\n * `iif` accepts a condition function and two Observables. When\n * an Observable returned by the operator is subscribed, condition function will be called.\n * Based on what boolean it returns at that moment, consumer will subscribe either to\n * the first Observable (if condition was true) or to the second (if condition was false). Condition\n * function may also not return anything - in that case condition will be evaluated as false and\n * second Observable will be subscribed.\n *\n * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that\n * was left undefined, resulting stream will simply complete immediately. That allows you to, rather\n * than controlling which Observable will be subscribed, decide at runtime if consumer should have access\n * to given Observable or not.\n *\n * If you have more complex logic that requires decision between more than two Observables, {@link defer}\n * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}\n * and exists only for convenience and readability reasons.\n *\n *\n * ## Examples\n * ### Change at runtime which Observable will be subscribed\n * ```ts\n * import { iif, of } from 'rxjs';\n *\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second'),\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"first\"\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"second\"\n *\n * ```\n *\n * ### Control an access to an Observable\n * ```ts\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"It seems you have an access...\"\n * // \"The end\"\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"The end\"\n * ```\n *\n * @see {@link defer}\n *\n * @param {function(): boolean} condition Condition which Observable should be chosen.\n * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.\n * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.\n * @return {Observable} Either first or second Observable, depending on condition.\n * @static true\n * @name iif\n * @owner Observable\n*/\nexport declare function iif<T = never, F = never>(condition: () => boolean, trueResult?: SubscribableOrPromise<T>, falseResult?: SubscribableOrPromise<F>): Observable<T | F>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/interval.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.\n * </span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n * ```ts\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n * @static true\n * @name interval\n * @owner Observable\n */\nexport declare function interval(period?: number, scheduler?: SchedulerLike): Observable<number>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/merge.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T>(v1: ObservableInput<T>, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T>(v1: ObservableInput<T>, concurrent: number, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function merge<T>(v1: ObservableInput<T>): Observable<T>;\nexport declare function merge<T>(v1: ObservableInput<T>, concurrent?: number): Observable<T>;\nexport declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<T | T2>;\nexport declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number): Observable<T | T2>;\nexport declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<T | T2 | T3>;\nexport declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number): Observable<T | T2 | T3>;\nexport declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<T | T2 | T3 | T4>;\nexport declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number): Observable<T | T2 | T3 | T4>;\nexport declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<T | T2 | T3 | T4 | T5>;\nexport declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number): Observable<T | T2 | T3 | T4 | T5>;\nexport declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function merge<T>(...observables: (ObservableInput<T> | number)[]): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;\nexport declare function merge<T, R>(...observables: (ObservableInput<any> | number)[]): Observable<R>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport declare function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/never.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n * ### Emit the number 7, then never emit anything else (not even complete)\n * ```ts\n * import { NEVER } from 'rxjs';\n * import { startWith } from 'rxjs/operators';\n *\n * function info() {\n *   console.log('Will not be called');\n * }\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe(x => console.log(x), info, info);\n *\n * ```\n *\n * @see {@link Observable}\n * @see {@link index/EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport declare const NEVER: Observable<never>;\n/**\n * @deprecated Deprecated in favor of using {@link NEVER} constant.\n */\nexport declare function never(): Observable<never>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/of.d.ts"
    ],
    "content": "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T>(a: T, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2>(a: T, b: T2, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n/** @deprecated use {@link scheduled} instead `scheduled([a, b, c], scheduler)` */\nexport declare function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport declare function of<T>(...args: (T | SchedulerLike)[]): Observable<T>;\nexport declare function of<T>(a: T): Observable<T>;\nexport declare function of<T, T2>(a: T, b: T2): Observable<T | T2>;\nexport declare function of<T, T2, T3>(a: T, b: T2, c: T3): Observable<T | T2 | T3>;\nexport declare function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4): Observable<T | T2 | T3 | T4>;\nexport declare function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5): Observable<T | T2 | T3 | T4 | T5>;\nexport declare function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport declare function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7): Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport declare function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\nexport declare function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport declare function of<T>(...args: T[]): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/onErrorResumeNext.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nexport declare function onErrorResumeNext<R>(v: ObservableInput<R>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport declare function onErrorResumeNext<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\nexport declare function onErrorResumeNext<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport declare function onErrorResumeNext<R>(array: ObservableInput<any>[]): Observable<R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/pairs.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerAction, SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * <img src=\"./img/pairs.png\" width=\"100%\">\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * @example <caption>Converts a javascript object to an Observable</caption>\n * ```ts\n * import { pairs } from 'rxjs';\n *\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj)\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n *\n * // Logs:\n * // [\"foo\", 42],\n * // [\"bar\", 56],\n * // [\"baz\", 78],\n * // \"the end!\"\n * ```\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @param {Scheduler} [scheduler] An optional IScheduler to schedule\n * when resulting Observable will emit values.\n * @returns {(Observable<Array<string|T>>)} An observable sequence of\n * [key, value] pairs from the object.\n */\nexport declare function pairs<T>(obj: Object, scheduler?: SchedulerLike): Observable<[string, T]>;\n/** @internal */\nexport declare function dispatch<T>(this: SchedulerAction<any>, state: {\n    keys: string[];\n    index: number;\n    subscriber: Subscriber<[string, T]>;\n    subscription: Subscription;\n    obj: Object;\n}): void;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/partition.d.ts"
    ],
    "content": "import { ObservableInput } from '../types';\nimport { Observable } from '../Observable';\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n * Partition a set of numbers into odds and evens observables\n * ```ts\n * import { of, partition } from 'rxjs';\n *\n * const observableValues = of(1, 2, 3, 4, 5, 6);\n * const [evens$, odds$] = partition(observableValues, (value, index) => value % 2 === 0);\n *\n * odds$.subscribe(x => console.log('odds', x));\n * evens$.subscribe(x => console.log('evens', x));\n *\n * // Logs:\n * // odds 1\n * // odds 3\n * // odds 5\n * // evens 2\n * // evens 4\n * // evens 6\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n */\nexport declare function partition<T>(source: ObservableInput<T>, predicate: (value: T, index: number) => boolean, thisArg?: any): [Observable<T>, Observable<T>];\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/race.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic, ObservableInput } from '../types';\nimport { OuterSubscriber } from '../OuterSubscriber';\nexport declare function race<A>(arg: [ObservableInput<A>]): Observable<A>;\nexport declare function race<A, B>(arg: [ObservableInput<A>, ObservableInput<B>]): Observable<A | B>;\nexport declare function race<A, B, C>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>]): Observable<A | B | C>;\nexport declare function race<A, B, C, D>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>]): Observable<A | B | C | D>;\nexport declare function race<A, B, C, D, E>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>]): Observable<A | B | C | D | E>;\nexport declare function race<T>(arg: ObservableInput<T>[]): Observable<T>;\nexport declare function race(arg: ObservableInput<any>[]): Observable<{}>;\nexport declare function race<A>(a: ObservableInput<A>): Observable<A>;\nexport declare function race<A, B>(a: ObservableInput<A>, b: ObservableInput<B>): Observable<A | B>;\nexport declare function race<A, B, C>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>): Observable<A | B | C>;\nexport declare function race<A, B, C, D>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>, d: ObservableInput<D>): Observable<A | B | C | D>;\nexport declare function race<A, B, C, D, E>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>, d: ObservableInput<D>, e: ObservableInput<E>): Observable<A | B | C | D | E>;\nexport declare function race<T>(observables: ObservableInput<T>[]): Observable<T>;\nexport declare function race(observables: ObservableInput<any>[]): Observable<{}>;\nexport declare function race<T>(...observables: ObservableInput<T>[]): Observable<T>;\nexport declare function race(...observables: ObservableInput<any>[]): Observable<{}>;\nexport declare class RaceOperator<T> implements Operator<T, T> {\n    call(subscriber: Subscriber<T>, source: any): TeardownLogic;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class RaceSubscriber<T> extends OuterSubscriber<T, T> {\n    private hasFirst;\n    private observables;\n    private subscriptions;\n    constructor(destination: Subscriber<T>);\n    protected _next(observable: any): void;\n    protected _complete(): void;\n    notifyNext(_outerValue: T, innerValue: T, outerIndex: number): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/range.d.ts"
    ],
    "content": "import { SchedulerAction, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n * Emits the numbers 1 to 10</caption>\n * ```ts\n * import { range } from 'rxjs';\n *\n * const numbers = range(1, 10);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link timer}\n * @see {@link index/interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} count The number of sequential integers to generate.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emissions of the notifications.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n * @static true\n * @name range\n * @owner Observable\n */\nexport declare function range(start?: number, count?: number, scheduler?: SchedulerLike): Observable<number>;\n/** @internal */\nexport declare function dispatch(this: SchedulerAction<any>, state: any): void;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/SubscribeOnObservable.d.ts"
    ],
    "content": "import { SchedulerLike, SchedulerAction } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nexport interface DispatchArg<T> {\n    source: Observable<T>;\n    subscriber: Subscriber<T>;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport declare class SubscribeOnObservable<T> extends Observable<T> {\n    source: Observable<T>;\n    private delayTime;\n    private scheduler;\n    /** @nocollapse */\n    static create<T>(source: Observable<T>, delay?: number, scheduler?: SchedulerLike): Observable<T>;\n    /** @nocollapse */\n    static dispatch<T>(this: SchedulerAction<T>, arg: DispatchArg<T>): Subscription;\n    constructor(source: Observable<T>, delayTime?: number, scheduler?: SchedulerLike);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/throwError.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits an error notification.\n *\n * <span class=\"informal\">Just emits 'error', and nothing else.\n * </span>\n *\n * ![](throw.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the error notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then emit an error\n * ```ts\n * import { throwError, concat, of } from 'rxjs';\n *\n * const result = concat(of(7), throwError(new Error('oops!')));\n * result.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Logs:\n * // 7\n * // Error: oops!\n * ```\n *\n * ---\n *\n * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 2\n * ```ts\n * import { throwError, interval, of } from 'rxjs';\n * import { mergeMap } from 'rxjs/operators';\n *\n * interval(1000).pipe(\n *   mergeMap(x => x === 2\n *     ? throwError('Twos are bad')\n *     : of('a', 'b', 'c')\n *   ),\n * ).subscribe(x => console.log(x), e => console.error(e));\n *\n * // Logs:\n * // a\n * // b\n * // c\n * // a\n * // b\n * // c\n * // Twos are bad\n * ```\n *\n * @see {@link Observable}\n * @see {@link empty}\n * @see {@link never}\n * @see {@link of}\n *\n * @param {any} error The particular Error to pass to the error notification.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the error notification.\n * @return {Observable} An error Observable: emits only the error notification\n * using the given error argument.\n * @static true\n * @name throwError\n * @owner Observable\n */\nexport declare function throwError(error: any, scheduler?: SchedulerLike): Observable<never>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/timer.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```ts\n * import { timer } from 'rxjs';\n *\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @name timer\n * @owner Observable\n */\nexport declare function timer(dueTime?: number | Date, periodOrScheduler?: number | SchedulerLike, scheduler?: SchedulerLike): Observable<number>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/using.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { Unsubscribable, ObservableInput } from '../types';\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport declare function using<T>(resourceFactory: () => Unsubscribable | void, observableFactory: (resource: Unsubscribable | void) => ObservableInput<T> | void): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/observable/zip.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { ObservableInput, ObservedValueOf } from '../types';\nimport { Subscriber } from '../Subscriber';\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<O1 extends ObservableInput<any>, R>(v1: O1, resultSelector: (v1: ObservedValueOf<O1>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, R>(v1: O1, v2: O2, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, resultSelector: (v1: ObservedValueOf<O1>, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R): Observable<R>;\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>>(v1: O1, v2: O2): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>]>;\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport declare function zip<O1 extends ObservableInput<any>, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v1: O1, v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): Observable<[ObservedValueOf<O1>, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\nexport declare function zip<O extends ObservableInput<any>>(array: O[]): Observable<ObservedValueOf<O>[]>;\nexport declare function zip<R>(array: ObservableInput<any>[]): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<O extends ObservableInput<any>, R>(array: O[], resultSelector: (...values: ObservedValueOf<O>[]) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport declare function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: any[]) => R): Observable<R>;\nexport declare function zip<O extends ObservableInput<any>>(...observables: O[]): Observable<ObservedValueOf<O>[]>;\nexport declare function zip<O extends ObservableInput<any>, R>(...observables: Array<O | ((...values: ObservedValueOf<O>[]) => R)>): Observable<R>;\nexport declare function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport declare class ZipOperator<T, R> implements Operator<T, R> {\n    resultSelector?: (...values: Array<any>) => R;\n    constructor(resultSelector?: (...values: Array<any>) => R);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ZipSubscriber<T, R> extends Subscriber<T> {\n    private resultSelector?;\n    private iterators;\n    private active;\n    constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R, values?: any);\n    protected _next(value: any): void;\n    protected _complete(): void;\n    notifyInactive(): void;\n    checkIterators(): void;\n    protected _tryresultSelector(args: any[]): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Observer.d.ts"
    ],
    "content": "import { Observer } from './types';\nexport declare const empty: Observer<any>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Operator.d.ts"
    ],
    "content": "import { Subscriber } from './Subscriber';\nimport { TeardownLogic } from './types';\nexport interface Operator<T, R> {\n    call(subscriber: Subscriber<R>, source: any): TeardownLogic;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/audit.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SubscribableOrPromise } from '../types';\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.png)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { audit } from 'rxjs/operators'\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport declare function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/auditTime.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { auditTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nexport declare function auditTime<T>(duration: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/buffer.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { buffer } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const intervalEvents = interval(1000);\n * const buffered = intervalEvents.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nexport declare function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/bufferCount.d.ts"
    ],
    "content": "import { OperatorFunction } from '../types';\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferCount } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferCount } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nexport declare function bufferCount<T>(bufferSize: number, startBufferEvery?: number): OperatorFunction<T, T[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/bufferTime.d.ts"
    ],
    "content": "import { OperatorFunction, SchedulerLike } from '../types';\nexport declare function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport declare function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport declare function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, maxBufferSize: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/bufferToggle.d.ts"
    ],
    "content": "import { OperatorFunction, SubscribableOrPromise } from '../types';\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, EMPTY } from 'rxjs';\n * import { bufferToggle } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : EMPTY\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport declare function bufferToggle<T, O>(openings: SubscribableOrPromise<O>, closingSelector: (value: O) => SubscribableOrPromise<any>): OperatorFunction<T, T[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/bufferWhen.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.png)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { bufferWhen } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferWhen(() =>\n *   interval(1000 + Math.random() * 4000)\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nexport declare function bufferWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, T[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/catchError.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nexport declare function catchError<T, O extends ObservableInput<any>>(selector: (err: any, caught: Observable<T>) => O): OperatorFunction<T, T | ObservedValueOf<O>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/combineAll.d.ts"
    ],
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function combineAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport declare function combineAll<T>(): OperatorFunction<any, T[]>;\nexport declare function combineAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport declare function combineAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/combineLatest.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction } from '../types';\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport declare function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/concat.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport declare function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/concatAll.d.ts"
    ],
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function concatAll<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport declare function concatAll<R>(): OperatorFunction<any, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/concatMap.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nexport declare function concatMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function concatMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function concatMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/concatMapTo.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nexport declare function concatMapTo<T, O extends ObservableInput<any>>(observable: O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated */\nexport declare function concatMapTo<T, O extends ObservableInput<any>>(observable: O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated */\nexport declare function concatMapTo<T, R, O extends ObservableInput<any>>(observable: O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/count.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { count, takeUntil } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n * ```ts\n * import { range } from 'rxjs';\n * import { count } from 'rxjs/operators';\n *\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nexport declare function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/debounce.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SubscribableOrPromise } from '../types';\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.png)\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { debounce } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounce(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nexport declare function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/debounceTime.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { debounceTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport declare function debounceTime<T>(dueTime: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/defaultIfEmpty.d.ts"
    ],
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function defaultIfEmpty<T>(defaultValue?: T): MonoTypeOperatorFunction<T>;\nexport declare function defaultIfEmpty<T, R>(defaultValue?: R): OperatorFunction<T, T | R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/delay.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.png)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n * Delay each click by one second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport declare function delay<T>(delay: number | Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/delayWhen.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/** @deprecated In future versions, empty notifiers will no longer re-emit the source value on the output observable. */\nexport declare function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<never>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\nexport declare function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/dematerialize.d.ts"
    ],
    "content": "import { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n * Convert an Observable of Notifications to an actual Observable\n * ```ts\n * import { of, Notification } from 'rxjs';\n * import { dematerialize } from 'rxjs/operators';\n *\n * const notifA = new Notification('N', 'A');\n * const notifB = new Notification('N', 'B');\n * const notifE = new Notification('E', undefined,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * const materialized = of(notifA, notifB, notifE);\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nexport declare function dematerialize<T>(): OperatorFunction<Notification<T>, T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/distinct.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { SimpleOuterSubscriber } from '../innerSubscribe';\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n * A simple example with numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { distinct } from 'rxjs/operators';\n *\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1).pipe(\n *     distinct(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n * ```\n *\n * An example using a keySelector function\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinct } from 'rxjs/operators';\n *\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *   ).pipe(\n *     distinct((p: Person) => p.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nexport declare function distinct<T, K>(keySelector?: (value: T) => K, flushes?: Observable<any>): MonoTypeOperatorFunction<T>;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class DistinctSubscriber<T, K> extends SimpleOuterSubscriber<T, T> {\n    private keySelector?;\n    private values;\n    constructor(destination: Subscriber<T>, keySelector?: (value: T) => K, flushes?: Observable<any>);\n    notifyNext(): void;\n    notifyError(error: any): void;\n    protected _next(value: T): void;\n    private _useKeySelector;\n    private _finalizeNext;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/distinctUntilChanged.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\nexport declare function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;\nexport declare function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/distinctUntilKeyChanged.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\nexport declare function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport declare function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/elementAt.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n * Emit only the third click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { elementAt } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nexport declare function elementAt<T>(index: number, defaultValue?: T): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/endWith.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction } from '../types';\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T, A>(v1: A, scheduler: SchedulerLike): OperatorFunction<T, T | A>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T, A, B>(v1: A, v2: B, scheduler: SchedulerLike): OperatorFunction<T, T | A | B>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T, A, B, C>(v1: A, v2: B, v3: C, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T, A, B, C, D>(v1: A, v2: B, v3: C, v4: D, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T, A, B, C, D, E>(v1: A, v2: B, v3: C, v4: D, v5: E, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D | E>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T, A, B, C, D, E, F>(v1: A, v2: B, v3: C, v4: D, v5: E, v6: F, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D | E | F>;\nexport declare function endWith<T, A>(v1: A): OperatorFunction<T, T | A>;\nexport declare function endWith<T, A, B>(v1: A, v2: B): OperatorFunction<T, T | A | B>;\nexport declare function endWith<T, A, B, C>(v1: A, v2: B, v3: C): OperatorFunction<T, T | A | B | C>;\nexport declare function endWith<T, A, B, C, D>(v1: A, v2: B, v3: C, v4: D): OperatorFunction<T, T | A | B | C | D>;\nexport declare function endWith<T, A, B, C, D, E>(v1: A, v2: B, v3: C, v4: D, v5: E): OperatorFunction<T, T | A | B | C | D | E>;\nexport declare function endWith<T, A, B, C, D, E, F>(v1: A, v2: B, v3: C, v4: D, v5: E, v6: F): OperatorFunction<T, T | A | B | C | D | E | F>;\nexport declare function endWith<T, Z = T>(...array: Z[]): OperatorFunction<T, T | Z>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport declare function endWith<T, Z = T>(...array: Array<Z | SchedulerLike>): OperatorFunction<T, T | Z>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/every.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * ## Example\n * A simple example emitting true if all elements are less than 5, false otherwise\n * ```ts\n * import { of } from 'rxjs';\n * import { every } from 'rxjs/operators';\n *\n *  of(1, 2, 3, 4, 5, 6).pipe(\n *     every(x => x < 5),\n * )\n * .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nexport declare function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, boolean>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/exhaust.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function exhaust<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport declare function exhaust<R>(): OperatorFunction<any, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/exhaustMap.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nexport declare function exhaustMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport declare function exhaustMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport declare function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/expand.d.ts"
    ],
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, OperatorFunction, ObservableInput, SchedulerLike } from '../types';\nimport { SimpleOuterSubscriber } from '../innerSubscribe';\nexport declare function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport declare function expand<T>(project: (value: T, index: number) => ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare class ExpandOperator<T, R> implements Operator<T, R> {\n    private project;\n    private concurrent;\n    private scheduler?;\n    constructor(project: (value: T, index: number) => ObservableInput<R>, concurrent: number, scheduler?: SchedulerLike);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ExpandSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n    private project;\n    private concurrent;\n    private scheduler?;\n    private index;\n    private active;\n    private hasCompleted;\n    private buffer?;\n    constructor(destination: Subscriber<R>, project: (value: T, index: number) => ObservableInput<R>, concurrent: number, scheduler?: SchedulerLike);\n    private static dispatch;\n    protected _next(value: any): void;\n    private subscribeToProjection;\n    protected _complete(): void;\n    notifyNext(innerValue: R): void;\n    notifyComplete(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/filter.d.ts"
    ],
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function filter<T, S extends T>(predicate: (value: T, index: number) => value is S, thisArg?: any): OperatorFunction<T, S>;\nexport declare function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/finalize.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nexport declare function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/find.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nexport declare function find<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S, thisArg?: any): OperatorFunction<T, S | undefined>;\nexport declare function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, T | undefined>;\nexport declare class FindValueOperator<T> implements Operator<T, T | number | undefined> {\n    private predicate;\n    private source;\n    private yieldIndex;\n    private thisArg?;\n    constructor(predicate: (value: T, index: number, source: Observable<T>) => boolean, source: Observable<T>, yieldIndex: boolean, thisArg?: any);\n    call(observer: Subscriber<T>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class FindValueSubscriber<T> extends Subscriber<T> {\n    private predicate;\n    private source;\n    private yieldIndex;\n    private thisArg?;\n    private index;\n    constructor(destination: Subscriber<T>, predicate: (value: T, index: number, source: Observable<T>) => boolean, source: Observable<T>, yieldIndex: boolean, thisArg?: any);\n    private notifyComplete;\n    protected _next(value: T): void;\n    protected _complete(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/findIndex.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n * Emit the index of first click that happens on a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { findIndex } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nexport declare function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, number>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/first.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../../internal/types';\nexport declare function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport declare function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S, defaultValue?: S): OperatorFunction<T, S>;\nexport declare function first<T, D = T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: D): OperatorFunction<T, T | D>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/groupBy.d.ts"
    ],
    "content": "import { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\nexport declare function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\nexport declare function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;\nexport declare function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;\nexport declare function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;\nexport interface RefCountSubscription {\n    count: number;\n    unsubscribe: () => void;\n    closed: boolean;\n    attemptedToUnsubscribe: boolean;\n}\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nexport declare class GroupedObservable<K, T> extends Observable<T> {\n    key: K;\n    private groupSubject;\n    private refCountSubscription?;\n    /** @deprecated Do not construct this type. Internal use only */\n    constructor(key: K, groupSubject: Subject<T>, refCountSubscription?: RefCountSubscription);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/ignoreElements.d.ts"
    ],
    "content": "import { OperatorFunction } from '../types';\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * ## Examples\n * ### Ignores emitted values, reacts to observable's completion.\n * ```ts\n * import { of } from 'rxjs';\n * import { ignoreElements } from 'rxjs/operators';\n *\n * of('you', 'talking', 'to', 'me').pipe(\n *   ignoreElements(),\n * )\n * .subscribe(\n *   word => console.log(word),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'the end'\n * ```\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nexport declare function ignoreElements(): OperatorFunction<any, never>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/index.d.ts",
      "node_modules/rxjs/internal/operators/index.d.ts"
    ],
    "content": "export { audit } from './audit';\nexport { auditTime } from './auditTime';\nexport { buffer } from './buffer';\nexport { bufferCount } from './bufferCount';\nexport { bufferTime } from './bufferTime';\nexport { bufferToggle } from './bufferToggle';\nexport { bufferWhen } from './bufferWhen';\nexport { catchError } from './catchError';\nexport { combineAll } from './combineAll';\nexport { combineLatest } from './combineLatest';\nexport { concat } from './concat';\nexport { concatAll } from './concatAll';\nexport { concatMap } from './concatMap';\nexport { concatMapTo } from './concatMapTo';\nexport { count } from './count';\nexport { debounce } from './debounce';\nexport { debounceTime } from './debounceTime';\nexport { defaultIfEmpty } from './defaultIfEmpty';\nexport { delay } from './delay';\nexport { delayWhen } from './delayWhen';\nexport { dematerialize } from './dematerialize';\nexport { distinct } from './distinct';\nexport { distinctUntilChanged } from './distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './distinctUntilKeyChanged';\nexport { elementAt } from './elementAt';\nexport { every } from './every';\nexport { exhaust } from './exhaust';\nexport { exhaustMap } from './exhaustMap';\nexport { expand } from './expand';\nexport { filter } from './filter';\nexport { finalize } from './finalize';\nexport { find } from './find';\nexport { findIndex } from './findIndex';\nexport { first } from './first';\nexport { groupBy } from './groupBy';\nexport { ignoreElements } from './ignoreElements';\nexport { isEmpty } from './isEmpty';\nexport { last } from './last';\nexport { map } from './map';\nexport { mapTo } from './mapTo';\nexport { materialize } from './materialize';\nexport { max } from './max';\nexport { merge } from './merge';\nexport { mergeAll } from './mergeAll';\nexport { mergeMap } from './mergeMap';\nexport { mergeMap as flatMap } from './mergeMap';\nexport { mergeMapTo } from './mergeMapTo';\nexport { mergeScan } from './mergeScan';\nexport { min } from './min';\nexport { multicast } from './multicast';\nexport { observeOn } from './observeOn';\nexport { onErrorResumeNext } from './onErrorResumeNext';\nexport { pairwise } from './pairwise';\nexport { partition } from './partition';\nexport { pluck } from './pluck';\nexport { publish } from './publish';\nexport { publishBehavior } from './publishBehavior';\nexport { publishLast } from './publishLast';\nexport { publishReplay } from './publishReplay';\nexport { race } from './race';\nexport { reduce } from './reduce';\nexport { repeat } from './repeat';\nexport { repeatWhen } from './repeatWhen';\nexport { retry } from './retry';\nexport { retryWhen } from './retryWhen';\nexport { refCount } from './refCount';\nexport { sample } from './sample';\nexport { sampleTime } from './sampleTime';\nexport { scan } from './scan';\nexport { sequenceEqual } from './sequenceEqual';\nexport { share } from './share';\nexport { shareReplay } from './shareReplay';\nexport { single } from './single';\nexport { skip } from './skip';\nexport { skipLast } from './skipLast';\nexport { skipUntil } from './skipUntil';\nexport { skipWhile } from './skipWhile';\nexport { startWith } from './startWith';\nexport { subscribeOn } from './subscribeOn';\nexport { switchAll } from './switchAll';\nexport { switchMap } from './switchMap';\nexport { switchMapTo } from './switchMapTo';\nexport { take } from './take';\nexport { takeLast } from './takeLast';\nexport { takeUntil } from './takeUntil';\nexport { takeWhile } from './takeWhile';\nexport { tap } from './tap';\nexport { throttle } from './throttle';\nexport { throttleTime } from './throttleTime';\nexport { timeInterval } from './timeInterval';\nexport { timeout } from './timeout';\nexport { timeoutWith } from './timeoutWith';\nexport { timestamp } from './timestamp';\nexport { toArray } from './toArray';\nexport { window } from './window';\nexport { windowCount } from './windowCount';\nexport { windowTime } from './windowTime';\nexport { windowToggle } from './windowToggle';\nexport { windowWhen } from './windowWhen';\nexport { withLatestFrom } from './withLatestFrom';\nexport { zip } from './zip';\nexport { zipAll } from './zipAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/isEmpty.d.ts"
    ],
    "content": "import { OperatorFunction } from '../types';\n/**\n * Emits false if the input observable emits any values, or emits true if the\n * input observable completes without emitting any values.\n *\n * <span class=\"informal\">Tells whether any values are emitted by an observable</span>\n *\n * ![](isEmpty.png)\n *\n * `isEmpty` transforms an Observable that emits values into an Observable that\n * emits a single boolean value representing whether or not any values were\n * emitted by the source Observable. As soon as the source Observable emits a\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\n * completes having not emitted anything, `isEmpty` will emit a `true` and\n * complete.\n *\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\n * a `false` value sooner.\n *\n * ## Examples\n *\n * Emit `false` for a non-empty Observable\n * ```javascript\n * import { Subject } from 'rxjs';\n * import { isEmpty } from 'rxjs/operators';\n *\n * const source = new Subject<string>();\n * const result = source.pipe(isEmpty());\n * source.subscribe(x => console.log(x));\n * result.subscribe(x => console.log(x));\n * source.next('a');\n * source.next('b');\n * source.next('c');\n * source.complete();\n *\n * // Results in:\n * // a\n * // false\n * // b\n * // c\n * ```\n *\n * Emit `true` for an empty Observable\n * ```javascript\n * import { EMPTY } from 'rxjs';\n * import { isEmpty } from 'rxjs/operators';\n *\n * const result = EMPTY.pipe(isEmpty());\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // true\n * ```\n *\n * @see {@link count}\n * @see {@link EMPTY}\n *\n * @return {OperatorFunction<T, boolean>} An Observable of a boolean value indicating whether observable was empty or not\n * @method isEmpty\n * @owner Observable\n */\nexport declare function isEmpty<T>(): OperatorFunction<T, boolean>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/last.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../../internal/types';\nexport declare function last<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport declare function last<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S, defaultValue?: S): OperatorFunction<T, S>;\nexport declare function last<T, D = T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: D): OperatorFunction<T, T | D>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/map.d.ts"
    ],
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport declare function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R>;\nexport declare class MapOperator<T, R> implements Operator<T, R> {\n    private project;\n    private thisArg;\n    constructor(project: (value: T, index: number) => R, thisArg: any);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/mapTo.d.ts"
    ],
    "content": "import { OperatorFunction } from '../types';\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport declare function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/materialize.d.ts"
    ],
    "content": "import { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n * Convert a faulty Observable to an Observable of Notifications\n * ```ts\n * import { of } from 'rxjs';\n * import { materialize, map } from 'rxjs/operators';\n *\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map(x => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nexport declare function materialize<T>(): OperatorFunction<T, Notification<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/max.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n * Get the maximal value of a series of numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { max } from 'rxjs/operators';\n *\n * of(5, 4, 7, 2, 8).pipe(\n *   max(),\n * )\n * .subscribe(x => console.log(x)); // -> 8\n * ```\n *\n * Use a comparer function to get the maximal item\n * ```typescript\n * import { of } from 'rxjs';\n * import { max } from 'rxjs/operators';\n *\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nexport declare function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/merge.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T>(concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T>(...observables: Array<ObservableInput<T> | SchedulerLike | number>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport declare function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/mergeAll.d.ts"
    ],
    "content": "import { OperatorFunction, ObservableInput } from '../types';\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { map, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map((ev) => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { take, map, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map((ev) => interval(1000).pipe(take(10))),\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nexport declare function mergeAll<T>(concurrent?: number): OperatorFunction<ObservableInput<T>, T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/mergeMap.d.ts"
    ],
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { SimpleOuterSubscriber } from '../innerSubscribe';\nexport declare function mergeMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, concurrent?: number): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function mergeMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined, concurrent?: number): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport declare function mergeMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\nexport declare class MergeMapOperator<T, R> implements Operator<T, R> {\n    private project;\n    private concurrent;\n    constructor(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number);\n    call(observer: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class MergeMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n    private project;\n    private concurrent;\n    private hasCompleted;\n    private buffer;\n    private active;\n    protected index: number;\n    constructor(destination: Subscriber<R>, project: (value: T, index: number) => ObservableInput<R>, concurrent?: number);\n    protected _next(value: T): void;\n    protected _tryNext(value: T): void;\n    private _innerSub;\n    protected _complete(): void;\n    notifyNext(innerValue: R): void;\n    notifyComplete(): void;\n}\n/**\n * @deprecated renamed. Use {@link mergeMap}\n */\nexport declare const flatMap: typeof mergeMap;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/mergeMapTo.d.ts"
    ],
    "content": "import { OperatorFunction, ObservedValueOf } from '../../internal/types';\nimport { ObservableInput } from '../types';\nexport declare function mergeMapTo<T, O extends ObservableInput<any>>(innerObservable: O, concurrent?: number): OperatorFunction<any, ObservedValueOf<O>>;\n/** @deprecated */\nexport declare function mergeMapTo<T, R, O extends ObservableInput<any>>(innerObservable: O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/mergeScan.d.ts"
    ],
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber } from '../innerSubscribe';\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * ## Example\n * Count the number of click events\n * ```ts\n * import { fromEvent, of } from 'rxjs';\n * import { mapTo, mergeScan } from 'rxjs/operators';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(mapTo(1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed),\n * );\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport declare function mergeScan<T, R>(accumulator: (acc: R, value: T, index: number) => ObservableInput<R>, seed: R, concurrent?: number): OperatorFunction<T, R>;\nexport declare class MergeScanOperator<T, R> implements Operator<T, R> {\n    private accumulator;\n    private seed;\n    private concurrent;\n    constructor(accumulator: (acc: R, value: T, index: number) => ObservableInput<R>, seed: R, concurrent: number);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class MergeScanSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n    private accumulator;\n    private acc;\n    private concurrent;\n    private hasValue;\n    private hasCompleted;\n    private buffer;\n    private active;\n    protected index: number;\n    constructor(destination: Subscriber<R>, accumulator: (acc: R, value: T, index: number) => ObservableInput<R>, acc: R, concurrent: number);\n    protected _next(value: any): void;\n    private _innerSub;\n    protected _complete(): void;\n    notifyNext(innerValue: R): void;\n    notifyComplete(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/min.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n * Get the minimal value of a series of numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { min } from 'rxjs/operators';\n *\n * of(5, 4, 7, 2, 8).pipe(\n *   min(),\n * )\n * .subscribe(x => console.log(x)); // -> 2\n * ```\n *\n * Use a comparer function to get the minimal item\n * ```typescript\n * import { of } from 'rxjs';\n * import { min } from 'rxjs/operators';\n *\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * ```\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nexport declare function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/multicast.d.ts"
    ],
    "content": "import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\nexport declare function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport declare function multicast<T, O extends ObservableInput<any>>(subject: Subject<T>, selector: (shared: Observable<T>) => O): UnaryFunction<Observable<T>, ConnectableObservable<ObservedValueOf<O>>>;\nexport declare function multicast<T>(subjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport declare function multicast<T, O extends ObservableInput<any>>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\nexport declare class MulticastOperator<T, R> implements Operator<T, R> {\n    private subjectFactory;\n    private selector;\n    constructor(subjectFactory: () => Subject<T>, selector: (source: Observable<T>) => Observable<R>);\n    call(subscriber: Subscriber<R>, source: any): any;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/observeOn.d.ts"
    ],
    "content": "import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n * Ensure values in subscribe are called just before browser repaint.\n * ```ts\n * import { interval } from 'rxjs';\n * import { observeOn } from 'rxjs/operators';\n *\n * const intervals = interval(10);                // Intervals are scheduled\n *                                                // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler),          // ...but we will observe on animationFrame\n * )                                              // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport declare function observeOn<T>(scheduler: SchedulerLike, delay?: number): MonoTypeOperatorFunction<T>;\nexport declare class ObserveOnOperator<T> implements Operator<T, T> {\n    private scheduler;\n    private delay;\n    constructor(scheduler: SchedulerLike, delay?: number);\n    call(subscriber: Subscriber<T>, source: any): TeardownLogic;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ObserveOnSubscriber<T> extends Subscriber<T> {\n    private scheduler;\n    private delay;\n    /** @nocollapse */\n    static dispatch(this: SchedulerAction<ObserveOnMessage>, arg: ObserveOnMessage): void;\n    constructor(destination: Subscriber<T>, scheduler: SchedulerLike, delay?: number);\n    private scheduleMessage;\n    protected _next(value: T): void;\n    protected _error(err: any): void;\n    protected _complete(): void;\n}\nexport declare class ObserveOnMessage {\n    notification: Notification<any>;\n    destination: PartialObserver<any>;\n    constructor(notification: Notification<any>, destination: PartialObserver<any>);\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/onErrorResumeNext.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\nexport declare function onErrorResumeNext<T>(): OperatorFunction<T, T>;\nexport declare function onErrorResumeNext<T, T2>(v: ObservableInput<T2>): OperatorFunction<T, T | T2>;\nexport declare function onErrorResumeNext<T, T2, T3>(v: ObservableInput<T2>, v2: ObservableInput<T3>): OperatorFunction<T, T | T2 | T3>;\nexport declare function onErrorResumeNext<T, T2, T3, T4>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>): OperatorFunction<T, T | T2 | T3 | T4>;\nexport declare function onErrorResumeNext<T, T2, T3, T4, T5>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport declare function onErrorResumeNext<T, T2, T3, T4, T5, T6>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport declare function onErrorResumeNext<T, T2, T3, T4, T5, T6, T7>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>, v6: ObservableInput<T7>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport declare function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any>>): OperatorFunction<T, T | R>;\nexport declare function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, T | R>;\nexport declare function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport declare function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\nexport declare function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport declare function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/pairwise.d.ts"
    ],
    "content": "import { OperatorFunction } from '../types';\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n * On every click (starting from the second), emit the relative distance to the previous click\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { pairwise, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(pair => {\n *     const x0 = pair[0].clientX;\n *     const y0 = pair[0].clientY;\n *     const x1 = pair[1].clientX;\n *     const y1 = pair[1].clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   }),\n * );\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nexport declare function pairwise<T>(): OperatorFunction<T, [T, T]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/partition.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { UnaryFunction } from '../types';\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n * Partition click events into those on DIV elements and those elsewhere\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { partition } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const parts = clicks.pipe(partition(ev => ev.target.tagName === 'DIV'));\n * const clicksOnDivs = parts[0];\n * const clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n * @deprecated use `partition` static creation function instead\n */\nexport declare function partition<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): UnaryFunction<Observable<T>, [Observable<T>, Observable<T>]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/pluck.d.ts"
    ],
    "content": "import { OperatorFunction } from '../types';\nexport declare function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\nexport declare function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\nexport declare function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\nexport declare function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\nexport declare function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\nexport declare function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\nexport declare function pluck<T, R>(...properties: string[]): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/publish.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\nexport declare function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport declare function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\nexport declare function publish<T>(selector: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/publishBehavior.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nexport declare function publishBehavior<T>(value: T): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/publishLast.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```ts\n * import { interval } from 'rxjs';\n * import { publishLast, tap, take } from 'rxjs/operators';\n *\n * const connectable =\n *   interval(1000)\n *     .pipe(\n *       tap(x => console.log(\"side effect\", x)),\n *       take(3),\n *       publishLast());\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. A\", x),\n *   err => console.log(\"Sub. A Error\", err),\n *   () => console.log( \"Sub. A Complete\"));\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. B\", x),\n *   err => console.log(\"Sub. B Error\", err),\n *   () => console.log( \"Sub. B Complete\"));\n *\n * connectable.connect();\n *\n * // Results:\n * //    \"side effect 0\"\n * //    \"side effect 1\"\n * //    \"side effect 2\"\n * //    \"Sub. A 2\"\n * //    \"Sub. B 2\"\n * //    \"Sub. A Complete\"\n * //    \"Sub. B Complete\"\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return {ConnectableObservable} An observable sequence that contains the elements of a\n * sequence produced by multicasting the source sequence.\n * @method publishLast\n * @owner Observable\n */\nexport declare function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/publishReplay.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, OperatorFunction, SchedulerLike, ObservableInput, ObservedValueOf } from '../types';\nexport declare function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport declare function publishReplay<T, O extends ObservableInput<any>>(bufferSize?: number, windowTime?: number, selector?: (shared: Observable<T>) => O, scheduler?: SchedulerLike): OperatorFunction<T, ObservedValueOf<O>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/race.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, OperatorFunction } from '../types';\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T>(observables: Array<Observable<T>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T, R>(observables: Array<Observable<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport declare function race<T, R>(...observables: Array<Observable<any> | Array<Observable<any>>>): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/reduce.d.ts"
    ],
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function reduce<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed: R): OperatorFunction<T, R>;\nexport declare function reduce<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport declare function reduce<T, R>(accumulator: (acc: R, value: T, index: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/refCount.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the *publish* operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval } from 'rxjs';\n * import { tap, publish, refCount } from 'rxjs/operators';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap((num) => console.log(`refCount ${num}`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap((num) => console.log(`publish ${num}`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the publish operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n */\nexport declare function refCount<T>(): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/repeat.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes, at most count times.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Similar to {@link retry}, this operator repeats the stream of items emitted by the source for non error cases.\n * Repeat can be useful for creating observables that are meant to have some repeated pattern or rhythm.\n *\n * Note: `repeat(0)` returns an empty observable and `repeat()` will repeat forever\n *\n * ## Example\n * Repeat a message stream\n * ```ts\n * import { of } from 'rxjs';\n * import { repeat, delay } from 'rxjs/operators';\n *\n * const source = of('Repeat message');\n * const example = source.pipe(repeat(3));\n * example.subscribe(x => console.log(x));\n *\n * // Results\n * // Repeat message\n * // Repeat message\n * // Repeat message\n * ```\n *\n * Repeat 3 values, 2 times\n * ```ts\n * import { interval } from 'rxjs';\n * import { repeat, take } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(take(3), repeat(2));\n * example.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that will resubscribe to the source stream when the source stream completes\n * , at most count times.\n * @method repeat\n * @owner Observable\n */\nexport declare function repeat<T>(count?: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/repeatWhen.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * ## Example\n * Repeat a message stream on click\n * ```ts\n * import { of, fromEvent } from 'rxjs';\n * import { repeatWhen } from 'rxjs/operators';\n *\n * const source = of('Repeat message');\n * const documentClick$ = fromEvent(document, 'click');\n *\n * source.pipe(repeatWhen(() => documentClick$)\n * ).subscribe(data => console.log(data))\n * ```\n * @see {@link repeat}\n * @see {@link retry}\n * @see {@link retryWhen}\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nexport declare function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/retry.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n *\n * ## Example\n * ```ts\n * import { interval, of, throwError } from 'rxjs';\n * import { mergeMap, retry } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   mergeMap(val => {\n *     if(val > 5){\n *       return throwError('Error!');\n *     }\n *     return of(val);\n *   }),\n *   //retry 2 times on error\n *   retry(2)\n * );\n *\n * const subscribe = example.subscribe({\n *   next: val => console.log(val),\n *   error: val => console.log(`${val}: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // \"Error!: Retried 2 times then quit!\"\n * ```\n *\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport declare function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/retryWhen.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nexport declare function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/sample.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n * On every click, sample the most recent \"seconds\" timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { sample } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nexport declare function sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/sampleTime.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n * Every second, emit the most recent click at most once\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { sampleTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nexport declare function sampleTime<T>(period: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/scan.d.ts"
    ],
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed: R): OperatorFunction<T, R>;\nexport declare function scan<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport declare function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/sequenceEqual.d.ts"
    ],
    "content": "import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Observer, OperatorFunction } from '../types';\n/**\n * Compares all values of two observables in sequence using an optional comparator function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * ## Example\n * figure out if the Konami code matches\n * ```ts\n * import { from, fromEvent } from 'rxjs';\n * import { sequenceEqual, bufferCount, mergeMap, map } from 'rxjs/operators';\n *\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(\n *     last11 => from(last11).pipe(sequenceEqual(codes)),\n *   ),\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparator] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nexport declare function sequenceEqual<T>(compareTo: Observable<T>, comparator?: (a: T, b: T) => boolean): OperatorFunction<T, boolean>;\nexport declare class SequenceEqualOperator<T> implements Operator<T, boolean> {\n    private compareTo;\n    private comparator;\n    constructor(compareTo: Observable<T>, comparator: (a: T, b: T) => boolean);\n    call(subscriber: Subscriber<boolean>, source: any): any;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class SequenceEqualSubscriber<T, R> extends Subscriber<T> {\n    private compareTo;\n    private comparator;\n    private _a;\n    private _b;\n    private _oneComplete;\n    constructor(destination: Observer<R>, compareTo: Observable<T>, comparator: (a: T, b: T) => boolean);\n    protected _next(value: T): void;\n    _complete(): void;\n    checkValues(): void;\n    emit(value: boolean): void;\n    nextB(value: T): void;\n    completeB(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/share.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * ![](share.png)\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nexport declare function share<T>(): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/shareReplay.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nexport interface ShareReplayConfig {\n    bufferSize?: number;\n    windowTime?: number;\n    refCount: boolean;\n    scheduler?: SchedulerLike;\n}\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplayed observable` forever,\n * but an errored source can be retried.\n *\n * ## Why use shareReplay?\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ![](shareReplay.png)\n *\n * ## Example\n * ```ts\n * import { interval } from 'rxjs';\n * import { shareReplay, take } from 'rxjs/operators';\n *\n * const obs$ = interval(1000);\n * const shared$ = obs$.pipe(\n *   take(4),\n *   shareReplay(3)\n * );\n * shared$.subscribe(x => console.log('source A: ', x));\n * shared$.subscribe(y => console.log('source B: ', y));\n *\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param {Number} [bufferSize=Number.POSITIVE_INFINITY] Maximum element count of the replay buffer.\n * @param {Number} [windowTime=Number.POSITIVE_INFINITY] Maximum time length of the replay buffer in milliseconds.\n * @param {Scheduler} [scheduler] Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return {Observable} An observable sequence that contains the elements of a sequence produced\n * by multicasting the source sequence within a selector function.\n * @method shareReplay\n * @owner Observable\n */\nexport declare function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\nexport declare function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/single.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable\n * emits items but none match the specified predicate then `undefined` is emitted.\n *\n * <span class=\"informal\">Like {@link first}, but emit with error notification if there is more than one value.</span>\n * ![](single.png)\n *\n * ## Example\n * emits 'error'\n * ```ts\n * import { range } from 'rxjs';\n * import { single } from 'rxjs/operators';\n *\n * const numbers = range(1,5).pipe(single());\n * numbers.subscribe(x => console.log('never get called'), e => console.log('error'));\n * // result\n * // 'error'\n * ```\n *\n * emits 'undefined'\n * ```ts\n * import { range } from 'rxjs';\n * import { single } from 'rxjs/operators';\n *\n * const numbers = range(1,5).pipe(single(x => x === 10));\n * numbers.subscribe(x => console.log(x));\n * // result\n * // 'undefined'\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate or `undefined` when no items match.\n *\n * @method single\n * @owner Observable\n */\nexport declare function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/skip.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nexport declare function skip<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/skipLast.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * ![](skipLast.png)\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * ## Example\n * Skip the last 2 values of an Observable with many values\n * ```ts\n * import { range } from 'rxjs';\n * import { skipLast } from 'rxjs/operators';\n *\n * const many = range(1, 5);\n * const skipLastTwo = many.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport declare function skipLast<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/skipUntil.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * The `skipUntil` operator causes the observable stream to skip the emission of values ​​until the passed in observable emits the first value.\n * This can be particularly useful in combination with user interactions, responses of http requests or waiting for specific times to pass by.\n *\n * ![](skipUntil.png)\n *\n * Internally the `skipUntil` operator subscribes to the passed in observable (in the following called *notifier*) in order to recognize the emission\n * of its first value. When this happens, the operator unsubscribes from the *notifier* and starts emitting the values of the *source*\n * observable. It will never let the *source* observable emit any values if the *notifier* completes or throws an error without emitting\n * a value before.\n *\n * ## Example\n *\n * In the following example, all emitted values ​​of the interval observable are skipped until the user clicks anywhere within the page.\n *\n * ```ts\n * import { interval, fromEvent } from 'rxjs';\n * import { skipUntil } from 'rxjs/operators';\n *\n * const intervalObservable = interval(1000);\n * const click = fromEvent(document, 'click');\n *\n * const emitAfterClick = intervalObservable.pipe(\n *   skipUntil(click)\n * );\n * // clicked at 4.6s. output: 5...6...7...8........ or\n * // clicked at 7.3s. output: 8...9...10..11.......\n * const subscribe = emitAfterClick.subscribe(value => console.log(value));\n * ```\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nexport declare function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/skipWhile.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nexport declare function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/startWith.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types';\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T, D>(v1: D, scheduler: SchedulerLike): OperatorFunction<T, T | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T, D, E>(v1: D, v2: E, scheduler: SchedulerLike): OperatorFunction<T, T | D | E>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T, D, E, F>(v1: D, v2: E, v3: F, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T, D, E, F, G>(v1: D, v2: E, v3: F, v4: G, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T, D, E, F, G, H>(v1: D, v2: E, v3: F, v4: G, v5: H, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T, D, E, F, G, H, I>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H | I>;\nexport declare function startWith<T, D>(v1: D): OperatorFunction<T, T | D>;\nexport declare function startWith<T, D, E>(v1: D, v2: E): OperatorFunction<T, T | D | E>;\nexport declare function startWith<T, D, E, F>(v1: D, v2: E, v3: F): OperatorFunction<T, T | D | E | F>;\nexport declare function startWith<T, D, E, F, G>(v1: D, v2: E, v3: F, v4: G): OperatorFunction<T, T | D | E | F | G>;\nexport declare function startWith<T, D, E, F, G, H>(v1: D, v2: E, v3: F, v4: G, v5: H): OperatorFunction<T, T | D | E | F | G | H>;\nexport declare function startWith<T, D, E, F, G, H, I>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I): OperatorFunction<T, T | D | E | F | G | H | I>;\nexport declare function startWith<T, D = T>(...array: D[]): OperatorFunction<T, T | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport declare function startWith<T, D = T>(...array: Array<D | SchedulerLike>): OperatorFunction<T, T | D>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/subscribeOn.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n * Given the following code:\n * ```javascript\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3, 4);\n * const b = of(5, 6, 7, 8, 9);\n * merge(a, b).subscribe(console.log);\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n * This will result in the output of `1 2 3 4 5 6 7 8 9`.\n *\n * But if we instead us the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emited by Observable `a`:\n * ```javascript\n * import { of, merge, asyncScheduler } from 'rxjs';\n * import { subscribeOn } from 'rxjs/operators';\n *\n * const a = of(1, 2, 3, 4).pipe(subscribeOn(asyncScheduler));\n * const b = of(5, 6, 7, 8, 9);\n * merge(a, b).subscribe(console.log);\n * ```\n *\n * The output will instead be `5 6 7 8 9 1 2 3 4`.\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param {SchedulerLike} scheduler - The {@link SchedulerLike} to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified {@link SchedulerLike}.\n .\n * @method subscribeOn\n * @owner Observable\n */\nexport declare function subscribeOn<T>(scheduler: SchedulerLike, delay?: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/switchAll.d.ts"
    ],
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function switchAll<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport declare function switchAll<R>(): OperatorFunction<any, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/switchMap.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nexport declare function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport declare function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport declare function switchMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/switchMapTo.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction } from '../types';\nexport declare function switchMapTo<R>(observable: ObservableInput<R>): OperatorFunction<any, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport declare function switchMapTo<T, R>(observable: ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport declare function switchMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/take.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```ts\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport declare function take<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/takeLast.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * ![](takeLast.png)\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * ## Example\n * Take the last 3 values of an Observable with many values\n * ```ts\n * import { range } from 'rxjs';\n * import { takeLast } from 'rxjs/operators';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nexport declare function takeLast<T>(count: number): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/takeUntil.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction } from '../types';\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n * Tick every second until the first click happens\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { takeUntil } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport declare function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/takeWhile.d.ts"
    ],
    "content": "import { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nexport declare function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport declare function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport declare function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/tap.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, PartialObserver } from '../types';\n/** @deprecated Use an observer instead of a complete callback */\nexport declare function tap<T>(next: null | undefined, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of an error callback */\nexport declare function tap<T>(next: null | undefined, error: (error: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of a complete callback */\nexport declare function tap<T>(next: (value: T) => void, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\nexport declare function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport declare function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/throttle.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SubscribableOrPromise } from '../types';\nexport interface ThrottleConfig {\n    leading?: boolean;\n    trailing?: boolean;\n}\nexport declare const defaultThrottleConfig: ThrottleConfig;\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.png)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { throttle } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nexport declare function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/throttleTime.d.ts"
    ],
    "content": "import { ThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Examples\n *\n * #### Limit click rate\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { throttleTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * #### Double Click\n *\n * The following example only emits clicks which happen within a subsequent\n * delay of 400ms of the previous click. This for example can emulate a double\n * click. It makes use of the `trailing` parameter of the throttle configuration.\n *\n * ```ts\n * import { fromEvent, asyncScheduler } from 'rxjs';\n * import { throttleTime, withLatestFrom } from 'rxjs/operators';\n *\n * // defaultThottleConfig = { leading: true, trailing: false }\n * const throttleConfig = {\n *   leading: false,\n *   trailing: true\n * }\n *\n * const click = fromEvent(document, 'click');\n * const doubleClick = click.pipe(\n *   throttleTime(400, asyncScheduler, throttleConfig)\n * );\n *\n * doubleClick.subscribe((throttleValue: Event) => {\n *   console.log(`Double-clicked! Timestamp: ${throttleValue.timeStamp}`);\n * });\n * ```\n *\n * If you enable the `leading` parameter in this example, the output would be the primary click and\n * the double click, but restricts additional clicks within 400ms.\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling.\n * @param {Object} config a configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport declare function throttleTime<T>(duration: number, scheduler?: SchedulerLike, config?: ThrottleConfig): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/throwIfEmpty.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction } from '../types';\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n * ```ts\n * import { fromEvent, timer } from 'rxjs';\n * import { throwIfEmpty, takeUntil } from 'rxjs/operators';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(\n *     () => new Error('the document was not clicked within 1 second')\n *   ),\n * )\n * .subscribe({\n *   next() { console.log('The button was clicked'); },\n *   error(err) { console.error(err); }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n */\nexport declare function throwIfEmpty<T>(errorFactory?: (() => any)): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/timeInterval.d.ts"
    ],
    "content": "import { SchedulerLike, OperatorFunction } from '../types';\n/**\n *\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeinterval.png)\n *\n * ## Examples\n * Emit inteval between current value with the last value\n *\n * ```ts\n * const seconds = interval(1000);\n *\n * seconds.pipe(timeInterval())\n * .subscribe(\n *     value => console.log(value),\n *     err => console.log(err),\n * );\n *\n * seconds.pipe(timeout(900))\n * .subscribe(\n *     value => console.log(value),\n *     err => console.log(err),\n * );\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // {value: 0, interval: 1000}\n * // {value: 1, interval: 1000}\n * // {value: 2, interval: 1000}\n * ```\n *\n * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.\n * @return {Observable<{ interval: number, value: T }>} Observable that emit infomation about value and interval\n * @method timeInterval\n */\nexport declare function timeInterval<T>(scheduler?: SchedulerLike): OperatorFunction<T, TimeInterval<T>>;\n/**\n * @deprecated exposed API, use as interface only.\n */\nexport declare class TimeInterval<T> {\n    value: T;\n    interval: number;\n    constructor(value: T, interval: number);\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/timeout.d.ts"
    ],
    "content": "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * ## Examples\n * Check if ticks are emitted within certain timespan\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeout } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n *\n * seconds.pipe(timeout(1100))      // Let's use bigger timespan to be safe,\n *                                  // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err),     // Will never be called.\n * );\n *\n * seconds.pipe(timeout(900))\n * .subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err),     // Will emit error before even first value is emitted,\n *                                  // since it did not arrive within 900ms period.\n * );\n * ```\n *\n * Use Date to check if Observable completed\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeout } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n *\n * seconds.pipe(\n *   timeout(new Date(\"December 17, 2020 03:24:00\")),\n * )\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err)      // On December 17, 2020 at 03:24:00 it will emit an error,\n *                                  // since Observable did not complete by then.\n * );\n * ```\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nexport declare function timeout<T>(due: number | Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/timeoutWith.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\nexport declare function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/timestamp.d.ts"
    ],
    "content": "import { OperatorFunction, SchedulerLike, Timestamp as TimestampInterface } from '../types';\n/**\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\n *\n * The `timestamp` operator maps the *source* observable stream to an object of type\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\n * default it uses the *async* scheduler which simply returns `Date.now()` (milliseconds since 1970/01/01\n * 00:00:00:000) and therefore is of type `number`.\n *\n * ![](timestamp.png)\n *\n * ## Example\n *\n * In this example there is a timestamp attached to the documents click event.\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { timestamp } from 'rxjs/operators';\n *\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\n *   timestamp()\n * );\n *\n * // Emits data of type {value: MouseEvent, timestamp: number}\n * clickWithTimestamp.subscribe(data => {\n *   console.log(data);\n * });\n * ```\n *\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nexport declare function timestamp<T>(scheduler?: SchedulerLike): OperatorFunction<T, Timestamp<T>>;\nexport declare class Timestamp<T> implements TimestampInterface<T> {\n    value: T;\n    timestamp: number;\n    constructor(value: T, timestamp: number);\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/toArray.d.ts"
    ],
    "content": "import { OperatorFunction } from '../types';\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * ![](toArray.png)\n *\n * `toArray` will wait until the source Observable completes before emitting\n * the array containing all emissions. When the source Observable errors no\n * array will be emitted.\n *\n *  ## Example\n * ```ts\n * import { interval } from 'rxjs';\n * import { toArray, take } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(10),\n *   toArray()\n * );\n *\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n *\n * ```\n* @return An array from an observable sequence.\n* @method toArray\n* @owner Observable\n*/\nexport declare function toArray<T>(): OperatorFunction<T, T[]>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/window.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * ## Example\n * In every window of 1 second each, emit at most 2 click events\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { window, mergeAll, map, take } from 'rxjs/operators';\n *\n *  const clicks = fromEvent(document, 'click');\n *  const sec = interval(1000);\n *  const result = clicks.pipe(\n *      window(sec),\n *      map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *      mergeAll(),              // flatten the Observable-of-Observables\n *  );\n *  result.subscribe(x => console.log(x));\n * ```\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nexport declare function window<T>(windowBoundaries: Observable<any>): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/windowCount.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n * Ignore every 3rd click event, starting from the first one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, map, mergeAll, skip } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport declare function windowCount<T>(windowSize: number, startWindowEvery?: number): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/windowTime.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction, SchedulerLike } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n * In every window of 1 second each, emit at most 2 click events\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with maxWindowCount instead of take\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // each window has still at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport declare function windowTime<T>(windowTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport declare function windowTime<T>(windowTimeSpan: number, windowCreationInterval: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport declare function windowTime<T>(windowTimeSpan: number, windowCreationInterval: number, maxWindowSize: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/windowToggle.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n * Every other second, emit the click events from the next 500ms\n * ```ts\n * import { fromEvent, interval, EMPTY } from 'rxjs';\n * import { windowToggle, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\n *   mergeAll()\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport declare function windowToggle<T, O>(openings: Observable<O>, closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/windowWhen.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n * Emit only the first two clicks events in every window of [1-5] random seconds\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { windowWhen, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))),     // each window has at most 2 emissions\n *   mergeAll()                         // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nexport declare function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/withLatestFrom.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nexport declare function withLatestFrom<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, R>(source2: O2, project: (v1: T, v2: ObservedValueOf<O2>) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v2: O2, v3: O3, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, v5: O5, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>>(source2: O2): OperatorFunction<T, [T, ObservedValueOf<O2>]>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v2: O2, v3: O3): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4, v5: O5): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport declare function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\nexport declare function withLatestFrom<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\nexport declare function withLatestFrom<T, R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/zip.d.ts"
    ],
    "content": "import { ObservableInput, OperatorFunction } from '../types';\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, R>(array: Array<ObservableInput<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport declare function zip<T, TOther, R>(array: Array<ObservableInput<TOther>>, project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/operators/zipAll.d.ts"
    ],
    "content": "import { OperatorFunction, ObservableInput } from '../types';\nexport declare function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport declare function zipAll<T>(): OperatorFunction<any, T[]>;\nexport declare function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport declare function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/OuterSubscriber.d.ts"
    ],
    "content": "import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class OuterSubscriber<T, R> extends Subscriber<T> {\n    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;\n    notifyError(error: any, innerSub: InnerSubscriber<T, R>): void;\n    notifyComplete(innerSub: InnerSubscriber<T, R>): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/ReplaySubject.d.ts"
    ],
    "content": "import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n/**\n * A variant of Subject that \"replays\" or emits old values to new subscribers.\n * It buffers a set number of values and will emit those values immediately to\n * any new subscribers in addition to emitting new values to existing subscribers.\n *\n * @class ReplaySubject<T>\n */\nexport declare class ReplaySubject<T> extends Subject<T> {\n    private scheduler?;\n    private _events;\n    private _bufferSize;\n    private _windowTime;\n    private _infiniteTimeWindow;\n    constructor(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike);\n    private nextInfiniteTimeWindow;\n    private nextTimeWindow;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    _getNow(): number;\n    private _trimBufferThenGetEvents;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Rx.d.ts"
    ],
    "content": "export { Subject, AnonymousSubject } from './Subject';\nexport { Observable } from './Observable';\nexport { config } from './config';\nimport 'rxjs-compat/add/observable/bindCallback';\nimport 'rxjs-compat/add/observable/bindNodeCallback';\nimport 'rxjs-compat/add/observable/combineLatest';\nimport 'rxjs-compat/add/observable/concat';\nimport 'rxjs-compat/add/observable/defer';\nimport 'rxjs-compat/add/observable/empty';\nimport 'rxjs-compat/add/observable/forkJoin';\nimport 'rxjs-compat/add/observable/from';\nimport 'rxjs-compat/add/observable/fromEvent';\nimport 'rxjs-compat/add/observable/fromEventPattern';\nimport 'rxjs-compat/add/observable/fromPromise';\nimport 'rxjs-compat/add/observable/generate';\nimport 'rxjs-compat/add/observable/if';\nimport 'rxjs-compat/add/observable/interval';\nimport 'rxjs-compat/add/observable/merge';\nimport 'rxjs-compat/add/observable/race';\nimport 'rxjs-compat/add/observable/never';\nimport 'rxjs-compat/add/observable/of';\nimport 'rxjs-compat/add/observable/onErrorResumeNext';\nimport 'rxjs-compat/add/observable/pairs';\nimport 'rxjs-compat/add/observable/range';\nimport 'rxjs-compat/add/observable/using';\nimport 'rxjs-compat/add/observable/throw';\nimport 'rxjs-compat/add/observable/timer';\nimport 'rxjs-compat/add/observable/zip';\nimport 'rxjs-compat/add/observable/dom/ajax';\nimport 'rxjs-compat/add/observable/dom/webSocket';\nimport 'rxjs-compat/add/operator/buffer';\nimport 'rxjs-compat/add/operator/bufferCount';\nimport 'rxjs-compat/add/operator/bufferTime';\nimport 'rxjs-compat/add/operator/bufferToggle';\nimport 'rxjs-compat/add/operator/bufferWhen';\nimport 'rxjs-compat/add/operator/catch';\nimport 'rxjs-compat/add/operator/combineAll';\nimport 'rxjs-compat/add/operator/combineLatest';\nimport 'rxjs-compat/add/operator/concat';\nimport 'rxjs-compat/add/operator/concatAll';\nimport 'rxjs-compat/add/operator/concatMap';\nimport 'rxjs-compat/add/operator/concatMapTo';\nimport 'rxjs-compat/add/operator/count';\nimport 'rxjs-compat/add/operator/dematerialize';\nimport 'rxjs-compat/add/operator/debounce';\nimport 'rxjs-compat/add/operator/debounceTime';\nimport 'rxjs-compat/add/operator/defaultIfEmpty';\nimport 'rxjs-compat/add/operator/delay';\nimport 'rxjs-compat/add/operator/delayWhen';\nimport 'rxjs-compat/add/operator/distinct';\nimport 'rxjs-compat/add/operator/distinctUntilChanged';\nimport 'rxjs-compat/add/operator/distinctUntilKeyChanged';\nimport 'rxjs-compat/add/operator/do';\nimport 'rxjs-compat/add/operator/exhaust';\nimport 'rxjs-compat/add/operator/exhaustMap';\nimport 'rxjs-compat/add/operator/expand';\nimport 'rxjs-compat/add/operator/elementAt';\nimport 'rxjs-compat/add/operator/filter';\nimport 'rxjs-compat/add/operator/finally';\nimport 'rxjs-compat/add/operator/find';\nimport 'rxjs-compat/add/operator/findIndex';\nimport 'rxjs-compat/add/operator/first';\nimport 'rxjs-compat/add/operator/groupBy';\nimport 'rxjs-compat/add/operator/ignoreElements';\nimport 'rxjs-compat/add/operator/isEmpty';\nimport 'rxjs-compat/add/operator/audit';\nimport 'rxjs-compat/add/operator/auditTime';\nimport 'rxjs-compat/add/operator/last';\nimport 'rxjs-compat/add/operator/let';\nimport 'rxjs-compat/add/operator/every';\nimport 'rxjs-compat/add/operator/map';\nimport 'rxjs-compat/add/operator/mapTo';\nimport 'rxjs-compat/add/operator/materialize';\nimport 'rxjs-compat/add/operator/max';\nimport 'rxjs-compat/add/operator/merge';\nimport 'rxjs-compat/add/operator/mergeAll';\nimport 'rxjs-compat/add/operator/mergeMap';\nimport 'rxjs-compat/add/operator/mergeMapTo';\nimport 'rxjs-compat/add/operator/mergeScan';\nimport 'rxjs-compat/add/operator/min';\nimport 'rxjs-compat/add/operator/multicast';\nimport 'rxjs-compat/add/operator/observeOn';\nimport 'rxjs-compat/add/operator/onErrorResumeNext';\nimport 'rxjs-compat/add/operator/pairwise';\nimport 'rxjs-compat/add/operator/partition';\nimport 'rxjs-compat/add/operator/pluck';\nimport 'rxjs-compat/add/operator/publish';\nimport 'rxjs-compat/add/operator/publishBehavior';\nimport 'rxjs-compat/add/operator/publishReplay';\nimport 'rxjs-compat/add/operator/publishLast';\nimport 'rxjs-compat/add/operator/race';\nimport 'rxjs-compat/add/operator/reduce';\nimport 'rxjs-compat/add/operator/repeat';\nimport 'rxjs-compat/add/operator/repeatWhen';\nimport 'rxjs-compat/add/operator/retry';\nimport 'rxjs-compat/add/operator/retryWhen';\nimport 'rxjs-compat/add/operator/sample';\nimport 'rxjs-compat/add/operator/sampleTime';\nimport 'rxjs-compat/add/operator/scan';\nimport 'rxjs-compat/add/operator/sequenceEqual';\nimport 'rxjs-compat/add/operator/share';\nimport 'rxjs-compat/add/operator/shareReplay';\nimport 'rxjs-compat/add/operator/single';\nimport 'rxjs-compat/add/operator/skip';\nimport 'rxjs-compat/add/operator/skipLast';\nimport 'rxjs-compat/add/operator/skipUntil';\nimport 'rxjs-compat/add/operator/skipWhile';\nimport 'rxjs-compat/add/operator/startWith';\nimport 'rxjs-compat/add/operator/subscribeOn';\nimport 'rxjs-compat/add/operator/switch';\nimport 'rxjs-compat/add/operator/switchMap';\nimport 'rxjs-compat/add/operator/switchMapTo';\nimport 'rxjs-compat/add/operator/take';\nimport 'rxjs-compat/add/operator/takeLast';\nimport 'rxjs-compat/add/operator/takeUntil';\nimport 'rxjs-compat/add/operator/takeWhile';\nimport 'rxjs-compat/add/operator/throttle';\nimport 'rxjs-compat/add/operator/throttleTime';\nimport 'rxjs-compat/add/operator/timeInterval';\nimport 'rxjs-compat/add/operator/timeout';\nimport 'rxjs-compat/add/operator/timeoutWith';\nimport 'rxjs-compat/add/operator/timestamp';\nimport 'rxjs-compat/add/operator/toArray';\nimport 'rxjs-compat/add/operator/toPromise';\nimport 'rxjs-compat/add/operator/window';\nimport 'rxjs-compat/add/operator/windowCount';\nimport 'rxjs-compat/add/operator/windowTime';\nimport 'rxjs-compat/add/operator/windowToggle';\nimport 'rxjs-compat/add/operator/windowWhen';\nimport 'rxjs-compat/add/operator/withLatestFrom';\nimport 'rxjs-compat/add/operator/zip';\nimport 'rxjs-compat/add/operator/zipAll';\nexport { Operator } from './Operator';\nexport { Observer } from './types';\nexport { Subscription } from './Subscription';\nexport { Subscriber } from './Subscriber';\nexport { AsyncSubject } from './AsyncSubject';\nexport { ReplaySubject } from './ReplaySubject';\nexport { BehaviorSubject } from './BehaviorSubject';\nexport { ConnectableObservable } from './observable/ConnectableObservable';\nexport { Notification, NotificationKind } from './Notification';\nexport { EmptyError } from './util/EmptyError';\nexport { ArgumentOutOfRangeError } from './util/ArgumentOutOfRangeError';\nexport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nexport { TimeoutError } from './util/TimeoutError';\nexport { UnsubscriptionError } from './util/UnsubscriptionError';\nexport { TimeInterval } from './operators/timeInterval';\nexport { Timestamp } from './operators/timestamp';\nexport { TestScheduler } from './testing/TestScheduler';\nexport { VirtualTimeScheduler } from './scheduler/VirtualTimeScheduler';\nexport { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from './observable/dom/AjaxObservable';\nexport { pipe } from './util/pipe';\nimport { AsapScheduler } from './scheduler/AsapScheduler';\nimport { AsyncScheduler } from './scheduler/AsyncScheduler';\nimport { QueueScheduler } from './scheduler/QueueScheduler';\nimport { AnimationFrameScheduler } from './scheduler/AnimationFrameScheduler';\nimport * as _operators from './operators/index';\nexport declare const operators: typeof _operators;\n/**\n * @typedef {Object} Rx.Scheduler\n * @property {SchedulerLike} asap Schedules on the micro task queue, which is the same\n * queue used for promises. Basically after the current job, but before the next job.\n * Use this for asynchronous conversions.\n * @property {SchedulerLike} queue Schedules on a queue in the current event frame\n * (trampoline scheduler). Use this for iteration operations.\n * @property {SchedulerLike} animationFrame Schedules work with `requestAnimationFrame`.\n * Use this for synchronizing with the platform's painting.\n * @property {SchedulerLike} async Schedules work with `setInterval`. Use this for\n * time-based operations.\n */\ndeclare let Scheduler: {\n    asap: AsapScheduler;\n    queue: QueueScheduler;\n    animationFrame: AnimationFrameScheduler;\n    async: AsyncScheduler;\n};\n/**\n * @typedef {Object} Rx.Symbol\n * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n * an object that has all of the traits of an Rx Subscriber, including the\n * ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription,\n * etc).\n * @property {Symbol|string} observable A symbol to use as a property name to\n * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n * to retrieve an iterator from an object.\n */\ndeclare let Symbol: {\n    rxSubscriber: string | symbol;\n    observable: string | symbol;\n    iterator: symbol;\n};\nexport { Scheduler, Symbol };\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduled/scheduleArray.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduled/scheduled.d.ts"
    ],
    "content": "import { ObservableInput, SchedulerLike, Observable } from 'rxjs';\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see from\n * @see of\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport declare function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduled/scheduleIterable.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduled/scheduleObservable.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { InteropObservable, SchedulerLike } from '../types';\nexport declare function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduled/schedulePromise.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nexport declare function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike): Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Scheduler.d.ts"
    ],
    "content": "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport declare class Scheduler implements SchedulerLike {\n    private SchedulerAction;\n    /**\n     * Note: the extra arrow function wrapper is to make testing by overriding\n     * Date.now easier.\n     * @nocollapse\n     */\n    static now: () => number;\n    constructor(SchedulerAction: typeof Action, now?: () => number);\n    /**\n     * A getter method that returns a number representing the current time\n     * (at the time this function was called) according to the scheduler's own\n     * internal clock.\n     * @return {number} A number that represents the current time. May or may not\n     * have a relation to wall-clock time. May or may not refer to a time unit\n     * (e.g. milliseconds).\n     */\n    now: () => number;\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/Action.d.ts"
    ],
    "content": "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport declare class Action<T> extends Subscription {\n    constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    /**\n     * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    schedule(state?: T, delay?: number): Subscription;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/animationFrame.d.ts"
    ],
    "content": "import { AnimationFrameScheduler } from './AnimationFrameScheduler';\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\nexport declare const animationFrameScheduler: AnimationFrameScheduler;\n/**\n * @deprecated renamed. Use {@link animationFrameScheduler}\n */\nexport declare const animationFrame: AnimationFrameScheduler;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/AnimationFrameAction.d.ts"
    ],
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AnimationFrameAction<T> extends AsyncAction<T> {\n    protected scheduler: AnimationFrameScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    constructor(scheduler: AnimationFrameScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay?: number): any;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/AnimationFrameScheduler.d.ts"
    ],
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport declare class AnimationFrameScheduler extends AsyncScheduler {\n    flush(action?: AsyncAction<any>): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/asap.d.ts"
    ],
    "content": "import { AsapScheduler } from './AsapScheduler';\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\nexport declare const asapScheduler: AsapScheduler;\n/**\n * @deprecated renamed. Use {@link asapScheduler}\n */\nexport declare const asap: AsapScheduler;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/AsapAction.d.ts"
    ],
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AsapAction<T> extends AsyncAction<T> {\n    protected scheduler: AsapScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    constructor(scheduler: AsapScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    protected requestAsyncId(scheduler: AsapScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: AsapScheduler, id?: any, delay?: number): any;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/AsapScheduler.d.ts"
    ],
    "content": "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport declare class AsapScheduler extends AsyncScheduler {\n    flush(action?: AsyncAction<any>): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/async.d.ts"
    ],
    "content": "import { AsyncScheduler } from './AsyncScheduler';\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\nexport declare const asyncScheduler: AsyncScheduler;\n/**\n * @deprecated renamed. Use {@link asyncScheduler}\n */\nexport declare const async: AsyncScheduler;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/AsyncAction.d.ts"
    ],
    "content": "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class AsyncAction<T> extends Action<T> {\n    protected scheduler: AsyncScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    id: any;\n    state: T;\n    delay: number;\n    protected pending: boolean;\n    constructor(scheduler: AsyncScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    schedule(state?: T, delay?: number): Subscription;\n    protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay?: number): any;\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    execute(state: T, delay: number): any;\n    protected _execute(state: T, delay: number): any;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribe(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/AsyncScheduler.d.ts"
    ],
    "content": "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nexport declare class AsyncScheduler extends Scheduler {\n    static delegate?: Scheduler;\n    actions: Array<AsyncAction<any>>;\n    /**\n     * A flag to indicate whether the Scheduler is currently executing a batch of\n     * queued actions.\n     * @type {boolean}\n     * @deprecated internal use only\n     */\n    active: boolean;\n    /**\n     * An internal ID used to track the latest asynchronous task such as those\n     * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n     * others.\n     * @type {any}\n     * @deprecated internal use only\n     */\n    scheduled: any;\n    constructor(SchedulerAction: typeof Action, now?: () => number);\n    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n    flush(action: AsyncAction<any>): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/queue.d.ts"
    ],
    "content": "import { QueueScheduler } from './QueueScheduler';\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\nexport declare const queueScheduler: QueueScheduler;\n/**\n * @deprecated renamed. Use {@link queueScheduler}\n */\nexport declare const queue: QueueScheduler;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/QueueAction.d.ts"
    ],
    "content": "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class QueueAction<T> extends AsyncAction<T> {\n    protected scheduler: QueueScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    constructor(scheduler: QueueScheduler, work: (this: SchedulerAction<T>, state?: T) => void);\n    schedule(state?: T, delay?: number): Subscription;\n    execute(state: T, delay: number): any;\n    protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay?: number): any;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/QueueScheduler.d.ts"
    ],
    "content": "import { AsyncScheduler } from './AsyncScheduler';\nexport declare class QueueScheduler extends AsyncScheduler {\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/scheduler/VirtualTimeScheduler.d.ts"
    ],
    "content": "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nexport declare class VirtualTimeScheduler extends AsyncScheduler {\n    maxFrames: number;\n    protected static frameTimeFactor: number;\n    frame: number;\n    index: number;\n    constructor(SchedulerAction?: typeof AsyncAction, maxFrames?: number);\n    /**\n     * Prompt the Scheduler to execute all of its queued actions, therefore\n     * clearing its queue.\n     * @return {void}\n     */\n    flush(): void;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @nodoc\n */\nexport declare class VirtualAction<T> extends AsyncAction<T> {\n    protected scheduler: VirtualTimeScheduler;\n    protected work: (this: SchedulerAction<T>, state?: T) => void;\n    protected index: number;\n    protected active: boolean;\n    constructor(scheduler: VirtualTimeScheduler, work: (this: SchedulerAction<T>, state?: T) => void, index?: number);\n    schedule(state?: T, delay?: number): Subscription;\n    protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;\n    protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;\n    protected _execute(state: T, delay: number): any;\n    static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>): 1 | 0 | -1;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Subject.d.ts"
    ],
    "content": "import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\n/**\n * @class SubjectSubscriber<T>\n */\nexport declare class SubjectSubscriber<T> extends Subscriber<T> {\n    protected destination: Subject<T>;\n    constructor(destination: Subject<T>);\n}\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n *\n * @class Subject<T>\n */\nexport declare class Subject<T> extends Observable<T> implements SubscriptionLike {\n    observers: Observer<T>[];\n    closed: boolean;\n    isStopped: boolean;\n    hasError: boolean;\n    thrownError: any;\n    constructor();\n    /**@nocollapse\n     * @deprecated use new Subject() instead\n    */\n    static create: Function;\n    lift<R>(operator: Operator<T, R>): Observable<R>;\n    next(value?: T): void;\n    error(err: any): void;\n    complete(): void;\n    unsubscribe(): void;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _trySubscribe(subscriber: Subscriber<T>): TeardownLogic;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n    /**\n     * Creates a new Observable with this Subject as the source. You can do this\n     * to create customize Observer-side logic of the Subject and conceal it from\n     * code that uses the Observable.\n     * @return {Observable} Observable that the Subject casts to\n     */\n    asObservable(): Observable<T>;\n}\n/**\n * @class AnonymousSubject<T>\n */\nexport declare class AnonymousSubject<T> extends Subject<T> {\n    protected destination?: Observer<T>;\n    constructor(destination?: Observer<T>, source?: Observable<T>);\n    next(value: T): void;\n    error(err: any): void;\n    complete(): void;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<T>): Subscription;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/SubjectSubscription.d.ts"
    ],
    "content": "import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class SubjectSubscription<T> extends Subscription {\n    subject: Subject<T>;\n    subscriber: Observer<T>;\n    closed: boolean;\n    constructor(subject: Subject<T>, subscriber: Observer<T>);\n    unsubscribe(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Subscriber.d.ts"
    ],
    "content": "import { Observer, PartialObserver } from './types';\nimport { Subscription } from './Subscription';\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport declare class Subscriber<T> extends Subscription implements Observer<T> {\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     * @nocollapse\n     */\n    static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>;\n    /** @internal */ syncErrorValue: any;\n    /** @internal */ syncErrorThrown: boolean;\n    /** @internal */ syncErrorThrowable: boolean;\n    protected isStopped: boolean;\n    protected destination: PartialObserver<any> | Subscriber<any>;\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    next(value?: T): void;\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached `Error`. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    error(err?: any): void;\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    complete(): void;\n    unsubscribe(): void;\n    protected _next(value: T): void;\n    protected _error(err: any): void;\n    protected _complete(): void;\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribeAndRecycle(): Subscriber<T>;\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class SafeSubscriber<T> extends Subscriber<T> {\n    private _parentSubscriber;\n    private _context;\n    constructor(_parentSubscriber: Subscriber<T>, observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);\n    next(value?: T): void;\n    error(err?: any): void;\n    complete(): void;\n    private __tryOrUnsub;\n    private __tryOrSetError;\n    /** @internal This is an internal implementation detail, do not use. */\n    _unsubscribe(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/Subscription.d.ts"
    ],
    "content": "import { SubscriptionLike, TeardownLogic } from './types';\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport declare class Subscription implements SubscriptionLike {\n    /** @nocollapse */\n    static EMPTY: Subscription;\n    /**\n     * A flag to indicate whether this Subscription has already been unsubscribed.\n     * @type {boolean}\n     */\n    closed: boolean;\n    /** @internal */\n    protected _parentOrParents: Subscription | Subscription[];\n    /** @internal */\n    private _subscriptions;\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    constructor(unsubscribe?: () => void);\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    unsubscribe(): void;\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription. Can also be used to add a child subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * When a parent subscription is unsubscribed, any child subscriptions that were added to it are also unsubscribed.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    add(teardown: TeardownLogic): Subscription;\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    remove(subscription: Subscription): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/symbol/iterator.d.ts"
    ],
    "content": "export declare function getSymbolIterator(): symbol;\nexport declare const iterator: symbol;\n/**\n * @deprecated use {@link iterator} instead\n */\nexport declare const $$iterator: symbol;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/symbol/observable.d.ts"
    ],
    "content": "/** Symbol.observable or a string \"@@observable\". Used for interop */\nexport declare const observable: string | symbol;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/symbol/rxSubscriber.d.ts"
    ],
    "content": "/** @deprecated do not use, this is no longer checked by RxJS internals */\nexport declare const rxSubscriber: string | symbol;\n/**\n * @deprecated use rxSubscriber instead\n */\nexport declare const $$rxSubscriber: string | symbol;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/testing/ColdObservable.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { Scheduler } from '../Scheduler';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { SubscriptionLoggable } from './SubscriptionLoggable';\nimport { Subscriber } from '../Subscriber';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class ColdObservable<T> extends Observable<T> implements SubscriptionLoggable {\n    messages: TestMessage[];\n    subscriptions: SubscriptionLog[];\n    scheduler: Scheduler;\n    logSubscribedFrame: () => number;\n    logUnsubscribedFrame: (index: number) => void;\n    constructor(messages: TestMessage[], scheduler: Scheduler);\n    scheduleMessages(subscriber: Subscriber<any>): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/testing/HotObservable.d.ts"
    ],
    "content": "import { Subject } from '../Subject';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Scheduler } from '../Scheduler';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { SubscriptionLoggable } from './SubscriptionLoggable';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport declare class HotObservable<T> extends Subject<T> implements SubscriptionLoggable {\n    messages: TestMessage[];\n    subscriptions: SubscriptionLog[];\n    scheduler: Scheduler;\n    logSubscribedFrame: () => number;\n    logUnsubscribedFrame: (index: number) => void;\n    constructor(messages: TestMessage[], scheduler: Scheduler);\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber: Subscriber<any>): Subscription;\n    setup(): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/testing/SubscriptionLog.d.ts"
    ],
    "content": "export declare class SubscriptionLog {\n    subscribedFrame: number;\n    unsubscribedFrame: number;\n    constructor(subscribedFrame: number, unsubscribedFrame?: number);\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/testing/SubscriptionLoggable.d.ts"
    ],
    "content": "import { Scheduler } from '../Scheduler';\nimport { SubscriptionLog } from './SubscriptionLog';\nexport declare class SubscriptionLoggable {\n    subscriptions: SubscriptionLog[];\n    scheduler: Scheduler;\n    logSubscribedFrame(): number;\n    logUnsubscribedFrame(index: number): void;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/testing/TestMessage.d.ts"
    ],
    "content": "import { Notification } from '../Notification';\nexport interface TestMessage {\n    frame: number;\n    notification: Notification<any>;\n    isGhost?: boolean;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/testing/TestScheduler.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler } from '../scheduler/VirtualTimeScheduler';\nexport interface RunHelpers {\n    cold: typeof TestScheduler.prototype.createColdObservable;\n    hot: typeof TestScheduler.prototype.createHotObservable;\n    flush: typeof TestScheduler.prototype.flush;\n    expectObservable: typeof TestScheduler.prototype.expectObservable;\n    expectSubscriptions: typeof TestScheduler.prototype.expectSubscriptions;\n}\nexport declare type observableToBeFn = (marbles: string, values?: any, errorValue?: any) => void;\nexport declare type subscriptionLogsToBeFn = (marbles: string | string[]) => void;\nexport declare class TestScheduler extends VirtualTimeScheduler {\n    assertDeepEqual: (actual: any, expected: any) => boolean | void;\n    readonly hotObservables: HotObservable<any>[];\n    readonly coldObservables: ColdObservable<any>[];\n    private flushTests;\n    private runMode;\n    constructor(assertDeepEqual: (actual: any, expected: any) => boolean | void);\n    createTime(marbles: string): number;\n    /**\n     * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n     * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.\n     * @param error The error to use for the `#` marble (if present).\n     */\n    createColdObservable<T = string>(marbles: string, values?: {\n        [marble: string]: T;\n    }, error?: any): ColdObservable<T>;\n    /**\n     * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.\n     * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.\n     * @param error The error to use for the `#` marble (if present).\n     */\n    createHotObservable<T = string>(marbles: string, values?: {\n        [marble: string]: T;\n    }, error?: any): HotObservable<T>;\n    private materializeInnerObservable;\n    expectObservable(observable: Observable<any>, subscriptionMarbles?: string): ({\n        toBe: observableToBeFn;\n    });\n    expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): ({\n        toBe: subscriptionLogsToBeFn;\n    });\n    flush(): void;\n    /** @nocollapse */\n    static parseMarblesAsSubscriptions(marbles: string, runMode?: boolean): SubscriptionLog;\n    /** @nocollapse */\n    static parseMarbles(marbles: string, values?: any, errorValue?: any, materializeInnerObservables?: boolean, runMode?: boolean): TestMessage[];\n    run<T>(callback: (helpers: RunHelpers) => T): T;\n}\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/types.d.ts"
    ],
    "content": "import { Observable } from './Observable';\nimport { Subscription } from './Subscription';\n/**\n * Note: This will add Symbol.observable globally for all TypeScript users,\n * however, we are no longer polyfilling Symbol.observable\n */\ndeclare global {\n    interface SymbolConstructor {\n        readonly observable: symbol;\n    }\n}\n/** OPERATOR INTERFACES */\nexport interface UnaryFunction<T, R> {\n    (source: T): R;\n}\nexport interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {\n}\nexport declare type FactoryOrValue<T> = T | (() => T);\nexport interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {\n}\nexport interface Timestamp<T> {\n    value: T;\n    timestamp: number;\n}\nexport interface TimeInterval<T> {\n    value: T;\n    interval: number;\n}\n/** SUBSCRIPTION INTERFACES */\nexport interface Unsubscribable {\n    unsubscribe(): void;\n}\nexport declare type TeardownLogic = Unsubscribable | Function | void;\nexport interface SubscriptionLike extends Unsubscribable {\n    unsubscribe(): void;\n    readonly closed: boolean;\n}\nexport declare type SubscribableOrPromise<T> = Subscribable<T> | Subscribable<never> | PromiseLike<T> | InteropObservable<T>;\n/** OBSERVABLE INTERFACES */\nexport interface Subscribable<T> {\n    subscribe(observer?: PartialObserver<T>): Unsubscribable;\n    /** @deprecated Use an observer instead of a complete callback */\n    subscribe(next: null | undefined, error: null | undefined, complete: () => void): Unsubscribable;\n    /** @deprecated Use an observer instead of an error callback */\n    subscribe(next: null | undefined, error: (error: any) => void, complete?: () => void): Unsubscribable;\n    /** @deprecated Use an observer instead of a complete callback */\n    subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Unsubscribable;\n    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Unsubscribable;\n}\nexport declare type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T> | Iterable<T>;\n/** @deprecated use {@link InteropObservable } */\nexport declare type ObservableLike<T> = InteropObservable<T>;\nexport declare type InteropObservable<T> = {\n    [Symbol.observable]: () => Subscribable<T>;\n};\n/** OBSERVER INTERFACES */\nexport interface NextObserver<T> {\n    closed?: boolean;\n    next: (value: T) => void;\n    error?: (err: any) => void;\n    complete?: () => void;\n}\nexport interface ErrorObserver<T> {\n    closed?: boolean;\n    next?: (value: T) => void;\n    error: (err: any) => void;\n    complete?: () => void;\n}\nexport interface CompletionObserver<T> {\n    closed?: boolean;\n    next?: (value: T) => void;\n    error?: (err: any) => void;\n    complete: () => void;\n}\nexport declare type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\nexport interface Observer<T> {\n    closed?: boolean;\n    next: (value: T) => void;\n    error: (err: any) => void;\n    complete: () => void;\n}\n/** SCHEDULER INTERFACES */\nexport interface SchedulerLike {\n    now(): number;\n    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\nexport interface SchedulerAction<T> extends Subscription {\n    schedule(state?: T, delay?: number): Subscription;\n}\nexport declare type ObservedValueOf<O> = O extends ObservableInput<infer T> ? T : never;\nexport declare type ObservedValuesFromArray<X> = X extends Array<ObservableInput<infer T>> ? T : never;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/applyMixins.d.ts"
    ],
    "content": "export declare function applyMixins(derivedCtor: any, baseCtors: any[]): void;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/ArgumentOutOfRangeError.d.ts"
    ],
    "content": "export interface ArgumentOutOfRangeError extends Error {\n}\nexport interface ArgumentOutOfRangeErrorCtor {\n    new (): ArgumentOutOfRangeError;\n}\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport declare const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/canReportError.d.ts"
    ],
    "content": "import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\n/**\n * Determines whether the ErrorObserver is closed or stopped or has a\n * destination that is closed or stopped - in which case errors will\n * need to be reported via a different mechanism.\n * @param observer the observer\n */\nexport declare function canReportError(observer: Subscriber<any> | Subject<any>): boolean;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/EmptyError.d.ts"
    ],
    "content": "export interface EmptyError extends Error {\n}\nexport interface EmptyErrorCtor {\n    new (): EmptyError;\n}\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport declare const EmptyError: EmptyErrorCtor;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/errorObject.d.ts"
    ],
    "content": "export declare const errorObject: any;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/hostReportError.d.ts"
    ],
    "content": "/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\nexport declare function hostReportError(err: any): void;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/identity.d.ts"
    ],
    "content": "export declare function identity<T>(x: T): T;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/Immediate.d.ts"
    ],
    "content": "/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport declare const Immediate: {\n    setImmediate(cb: () => void): number;\n    clearImmediate(handle: number): void;\n};\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport declare const TestTools: {\n    pending(): number;\n};\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isArray.d.ts"
    ],
    "content": "export declare const isArray: (arg: any) => arg is any[];\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isArrayLike.d.ts"
    ],
    "content": "export declare const isArrayLike: <T>(x: any) => x is ArrayLike<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isDate.d.ts"
    ],
    "content": "export declare function isDate(value: any): value is Date;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isFunction.d.ts"
    ],
    "content": "export declare function isFunction(x: any): x is Function;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isInteropObservable.d.ts"
    ],
    "content": "import { InteropObservable } from '../types';\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport declare function isInteropObservable(input: any): input is InteropObservable<any>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isIterable.d.ts"
    ],
    "content": "/** Identifies an input as being an Iterable */\nexport declare function isIterable(input: any): input is Iterable<any>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isNumeric.d.ts"
    ],
    "content": "export declare function isNumeric(val: any): val is number | string;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isObject.d.ts"
    ],
    "content": "export declare function isObject(x: any): x is Object;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isObservable.d.ts"
    ],
    "content": "import { Observable } from '../Observable';\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport declare function isObservable<T>(obj: any): obj is Observable<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isPromise.d.ts"
    ],
    "content": "/**\n * Tests to see if the object is an ES2015 (ES6) Promise\n * @see {@link https://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects}\n * @param value the object to test\n */\nexport declare function isPromise(value: any): value is PromiseLike<any>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/isScheduler.d.ts"
    ],
    "content": "import { SchedulerLike } from '../types';\nexport declare function isScheduler(value: any): value is SchedulerLike;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/noop.d.ts"
    ],
    "content": "export declare function noop(): void;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/not.d.ts"
    ],
    "content": "export declare function not(pred: Function, thisArg: any): Function;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/ObjectUnsubscribedError.d.ts"
    ],
    "content": "export interface ObjectUnsubscribedError extends Error {\n}\nexport interface ObjectUnsubscribedErrorCtor {\n    new (): ObjectUnsubscribedError;\n}\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport declare const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/pipe.d.ts"
    ],
    "content": "import { UnaryFunction } from '../types';\nexport declare function pipe<T>(): UnaryFunction<T, T>;\nexport declare function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport declare function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport declare function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport declare function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport declare function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport declare function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport declare function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport declare function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport declare function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;\nexport declare function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;\n/** @internal */\nexport declare function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/root.d.ts"
    ],
    "content": "declare const _root: any;\nexport { _root as root };\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/subscribeTo.d.ts"
    ],
    "content": "import { ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\nexport declare const subscribeTo: <T>(result: ObservableInput<T>) => (subscriber: Subscriber<T>) => void | Subscription;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/subscribeToArray.d.ts"
    ],
    "content": "import { Subscriber } from '../Subscriber';\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport declare const subscribeToArray: <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => void;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/subscribeToIterable.d.ts"
    ],
    "content": "import { Subscriber } from '../Subscriber';\nexport declare const subscribeToIterable: <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => Subscriber<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/subscribeToObservable.d.ts"
    ],
    "content": "import { Subscriber } from '../Subscriber';\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport declare const subscribeToObservable: <T>(obj: any) => (subscriber: Subscriber<T>) => any;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/subscribeToPromise.d.ts"
    ],
    "content": "import { Subscriber } from '../Subscriber';\nexport declare const subscribeToPromise: <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => Subscriber<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/subscribeToResult.d.ts"
    ],
    "content": "import { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nexport declare function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>, result: any, outerValue: undefined, outerIndex: undefined, innerSubscriber: InnerSubscriber<T, R>): Subscription | undefined;\nexport declare function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>, result: any, outerValue?: T, outerIndex?: number): Subscription | undefined;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/TimeoutError.d.ts"
    ],
    "content": "export interface TimeoutError extends Error {\n}\nexport interface TimeoutErrorCtor {\n    new (): TimeoutError;\n}\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link operators/timeout}\n *\n * @class TimeoutError\n */\nexport declare const TimeoutError: TimeoutErrorCtor;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/toSubscriber.d.ts"
    ],
    "content": "import { Subscriber } from '../Subscriber';\nimport { PartialObserver } from '../types';\nexport declare function toSubscriber<T>(nextOrObserver?: PartialObserver<T> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): Subscriber<T>;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/tryCatch.d.ts"
    ],
    "content": "export declare function tryCatch<T extends Function>(fn: T): T;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/internal/util/UnsubscriptionError.d.ts"
    ],
    "content": "export interface UnsubscriptionError extends Error {\n    readonly errors: any[];\n}\nexport interface UnsubscriptionErrorCtor {\n    new (errors: any[]): UnsubscriptionError;\n}\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport declare const UnsubscriptionError: UnsubscriptionErrorCtor;\n"
  },
  {
    "paths": [
      "node_modules/rxjs/node_modules/tslib/tslib.d.ts"
    ],
    "content": "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\nexport declare function __extends(d: Function, b: Function): void;\r\nexport declare function __assign(t: any, ...sources: any[]): any;\r\nexport declare function __rest(t: any, propertyNames: (string | symbol)[]): any;\r\nexport declare function __decorate(decorators: Function[], target: any, key?: string | symbol, desc?: any): any;\r\nexport declare function __param(paramIndex: number, decorator: Function): Function;\r\nexport declare function __metadata(metadataKey: any, metadataValue: any): Function;\r\nexport declare function __awaiter(thisArg: any, _arguments: any, P: Function, generator: Function): any;\r\nexport declare function __generator(thisArg: any, body: Function): any;\r\nexport declare function __exportStar(m: any, exports: any): void;\r\nexport declare function __values(o: any): any;\r\nexport declare function __read(o: any, n?: number): any[];\r\nexport declare function __spread(...args: any[][]): any[];\r\nexport declare function __spreadArrays(...args: any[][]): any[];\r\nexport declare function __await(v: any): any;\r\nexport declare function __asyncGenerator(thisArg: any, _arguments: any, generator: Function): any;\r\nexport declare function __asyncDelegator(o: any): any;\r\nexport declare function __asyncValues(o: any): any;\r\nexport declare function __makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray;\r\nexport declare function __importStar<T>(mod: T): T;\r\nexport declare function __importDefault<T>(mod: T): T | { default: T };\r\nexport declare function __classPrivateFieldGet<T extends object, V>(receiver: T, privateMap: { has(o: T): boolean, get(o: T): V | undefined }): V;\r\nexport declare function __classPrivateFieldSet<T extends object, V>(receiver: T, privateMap: { has(o: T): boolean, set(o: T, value: V): any }, value: V): V;\r\nexport declare function __createBinding(object: object, target: object, key: PropertyKey, objectKey?: PropertyKey): void;"
  },
  {
    "paths": [
      "node_modules/rxjs/Notification.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Notification';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Observable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Observable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/ArrayLikeObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/ArrayLikeObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/ArrayObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/ArrayObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/bindCallback.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/bindCallback';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/bindNodeCallback.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/bindNodeCallback';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/BoundCallbackObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/BoundCallbackObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/BoundNodeCallbackObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/BoundNodeCallbackObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/combineLatest.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/combineLatest';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/concat.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/concat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/ConnectableObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/ConnectableObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/defer.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/defer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/DeferObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/DeferObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/dom/ajax.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/dom/ajax';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/dom/AjaxObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/dom/AjaxObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/dom/webSocket.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/dom/webSocket';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/dom/WebSocketSubject.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/dom/WebSocketSubject';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/empty.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/empty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/EmptyObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/EmptyObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/ErrorObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/ErrorObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/forkJoin.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/forkJoin';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/ForkJoinObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/ForkJoinObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/from.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/from';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/fromArray.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/fromArray';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/fromEvent.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/fromEvent';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/FromEventObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/FromEventObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/fromEventPattern.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/fromEventPattern';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/FromEventPatternObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/FromEventPatternObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/fromIterable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/fromIterable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/FromObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/FromObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/fromPromise.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/fromPromise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/generate.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/generate';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/GenerateObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/GenerateObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/if.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/if';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/IfObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/IfObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/interval.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/interval';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/IntervalObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/IntervalObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/IteratorObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/IteratorObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/merge.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/merge';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/never.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/never';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/NeverObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/NeverObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/of.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/of';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/onErrorResumeNext.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/onErrorResumeNext';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/pairs.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/pairs';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/PairsObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/PairsObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/PromiseObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/PromiseObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/race.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/race';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/range.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/range';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/RangeObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/RangeObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/ScalarObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/ScalarObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/SubscribeOnObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/SubscribeOnObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/throw.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/throw';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/timer.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/timer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/TimerObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/TimerObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/using.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/using';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/UsingObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/UsingObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/observable/zip.d.ts"
    ],
    "content": "export * from 'rxjs-compat/observable/zip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Observer.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Observer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Operator.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Operator';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/audit.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/audit';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/auditTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/auditTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/buffer.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/buffer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/bufferCount.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/bufferCount';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/bufferTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/bufferTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/bufferToggle.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/bufferToggle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/bufferWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/bufferWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/catch.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/catch';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/combineAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/combineAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/combineLatest.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/combineLatest';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/concat.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/concat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/concatAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/concatAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/concatMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/concatMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/concatMapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/concatMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/count.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/count';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/debounce.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/debounce';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/debounceTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/debounceTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/defaultIfEmpty.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/defaultIfEmpty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/delay.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/delay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/delayWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/delayWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/dematerialize.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/dematerialize';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/distinct.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/distinct';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/distinctUntilChanged.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/distinctUntilChanged';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/distinctUntilKeyChanged.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/distinctUntilKeyChanged';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/do.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/do';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/elementAt.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/elementAt';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/every.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/every';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/exhaust.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/exhaust';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/exhaustMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/exhaustMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/expand.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/expand';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/filter.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/filter';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/finally.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/finally';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/find.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/find';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/findIndex.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/findIndex';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/first.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/first';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/groupBy.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/groupBy';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/ignoreElements.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/ignoreElements';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/isEmpty.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/isEmpty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/last.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/last';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/let.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/let';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/map.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/map';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/mapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/mapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/materialize.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/materialize';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/max.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/max';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/merge.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/merge';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/mergeAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/mergeAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/mergeMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/mergeMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/mergeMapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/mergeMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/mergeScan.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/mergeScan';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/min.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/min';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/multicast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/multicast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/observeOn.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/observeOn';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/onErrorResumeNext.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/onErrorResumeNext';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/pairwise.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/pairwise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/partition.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/partition';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/pluck.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/pluck';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/publish.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/publish';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/publishBehavior.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/publishBehavior';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/publishLast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/publishLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/publishReplay.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/publishReplay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/race.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/race';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/reduce.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/reduce';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/repeat.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/repeat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/repeatWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/repeatWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/retry.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/retry';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/retryWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/retryWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/sample.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/sample';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/sampleTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/sampleTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/scan.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/scan';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/sequenceEqual.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/sequenceEqual';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/share.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/share';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/shareReplay.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/shareReplay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/single.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/single';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/skip.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/skip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/skipLast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/skipLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/skipUntil.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/skipUntil';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/skipWhile.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/skipWhile';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/startWith.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/startWith';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/subscribeOn.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/subscribeOn';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/switch.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/switch';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/switchMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/switchMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/switchMapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/switchMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/take.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/take';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/takeLast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/takeLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/takeUntil.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/takeUntil';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/takeWhile.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/takeWhile';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/throttle.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/throttle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/throttleTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/throttleTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/timeInterval.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/timeInterval';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/timeout.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/timeout';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/timeoutWith.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/timeoutWith';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/timestamp.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/timestamp';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/toArray.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/toArray';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/toPromise.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/toPromise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/window.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/window';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/windowCount.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/windowCount';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/windowTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/windowTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/windowToggle.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/windowToggle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/windowWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/windowWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/withLatestFrom.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/withLatestFrom';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/zip.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/zip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operator/zipAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operator/zipAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/audit.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/audit';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/auditTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/auditTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/buffer.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/buffer';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/bufferCount.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/bufferCount';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/bufferTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/bufferTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/bufferToggle.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/bufferToggle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/bufferWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/bufferWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/catchError.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/catchError';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/combineAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/combineAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/combineLatest.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/combineLatest';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/concat.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/concat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/concatAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/concatAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/concatMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/concatMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/concatMapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/concatMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/count.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/count';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/debounce.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/debounce';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/debounceTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/debounceTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/defaultIfEmpty.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/defaultIfEmpty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/delay.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/delay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/delayWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/delayWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/dematerialize.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/dematerialize';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/distinct.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/distinct';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/distinctUntilChanged.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/distinctUntilChanged';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/distinctUntilKeyChanged.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/distinctUntilKeyChanged';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/elementAt.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/elementAt';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/every.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/every';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/exhaust.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/exhaust';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/exhaustMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/exhaustMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/expand.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/expand';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/filter.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/filter';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/finalize.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/finalize';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/find.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/find';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/findIndex.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/findIndex';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/first.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/first';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/groupBy.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/groupBy';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/ignoreElements.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/ignoreElements';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/index.d.ts",
      "node_modules/rxjs/operators/index.d.ts"
    ],
    "content": "export { audit } from '../internal/operators/audit';\nexport { auditTime } from '../internal/operators/auditTime';\nexport { buffer } from '../internal/operators/buffer';\nexport { bufferCount } from '../internal/operators/bufferCount';\nexport { bufferTime } from '../internal/operators/bufferTime';\nexport { bufferToggle } from '../internal/operators/bufferToggle';\nexport { bufferWhen } from '../internal/operators/bufferWhen';\nexport { catchError } from '../internal/operators/catchError';\nexport { combineAll } from '../internal/operators/combineAll';\nexport { combineLatest } from '../internal/operators/combineLatest';\nexport { concat } from '../internal/operators/concat';\nexport { concatAll } from '../internal/operators/concatAll';\nexport { concatMap } from '../internal/operators/concatMap';\nexport { concatMapTo } from '../internal/operators/concatMapTo';\nexport { count } from '../internal/operators/count';\nexport { debounce } from '../internal/operators/debounce';\nexport { debounceTime } from '../internal/operators/debounceTime';\nexport { defaultIfEmpty } from '../internal/operators/defaultIfEmpty';\nexport { delay } from '../internal/operators/delay';\nexport { delayWhen } from '../internal/operators/delayWhen';\nexport { dematerialize } from '../internal/operators/dematerialize';\nexport { distinct } from '../internal/operators/distinct';\nexport { distinctUntilChanged } from '../internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from '../internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from '../internal/operators/elementAt';\nexport { endWith } from '../internal/operators/endWith';\nexport { every } from '../internal/operators/every';\nexport { exhaust } from '../internal/operators/exhaust';\nexport { exhaustMap } from '../internal/operators/exhaustMap';\nexport { expand } from '../internal/operators/expand';\nexport { filter } from '../internal/operators/filter';\nexport { finalize } from '../internal/operators/finalize';\nexport { find } from '../internal/operators/find';\nexport { findIndex } from '../internal/operators/findIndex';\nexport { first } from '../internal/operators/first';\nexport { groupBy } from '../internal/operators/groupBy';\nexport { ignoreElements } from '../internal/operators/ignoreElements';\nexport { isEmpty } from '../internal/operators/isEmpty';\nexport { last } from '../internal/operators/last';\nexport { map } from '../internal/operators/map';\nexport { mapTo } from '../internal/operators/mapTo';\nexport { materialize } from '../internal/operators/materialize';\nexport { max } from '../internal/operators/max';\nexport { merge } from '../internal/operators/merge';\nexport { mergeAll } from '../internal/operators/mergeAll';\nexport { mergeMap, flatMap } from '../internal/operators/mergeMap';\nexport { mergeMapTo } from '../internal/operators/mergeMapTo';\nexport { mergeScan } from '../internal/operators/mergeScan';\nexport { min } from '../internal/operators/min';\nexport { multicast } from '../internal/operators/multicast';\nexport { observeOn } from '../internal/operators/observeOn';\nexport { onErrorResumeNext } from '../internal/operators/onErrorResumeNext';\nexport { pairwise } from '../internal/operators/pairwise';\nexport { partition } from '../internal/operators/partition';\nexport { pluck } from '../internal/operators/pluck';\nexport { publish } from '../internal/operators/publish';\nexport { publishBehavior } from '../internal/operators/publishBehavior';\nexport { publishLast } from '../internal/operators/publishLast';\nexport { publishReplay } from '../internal/operators/publishReplay';\nexport { race } from '../internal/operators/race';\nexport { reduce } from '../internal/operators/reduce';\nexport { repeat } from '../internal/operators/repeat';\nexport { repeatWhen } from '../internal/operators/repeatWhen';\nexport { retry } from '../internal/operators/retry';\nexport { retryWhen } from '../internal/operators/retryWhen';\nexport { refCount } from '../internal/operators/refCount';\nexport { sample } from '../internal/operators/sample';\nexport { sampleTime } from '../internal/operators/sampleTime';\nexport { scan } from '../internal/operators/scan';\nexport { sequenceEqual } from '../internal/operators/sequenceEqual';\nexport { share } from '../internal/operators/share';\nexport { shareReplay } from '../internal/operators/shareReplay';\nexport { single } from '../internal/operators/single';\nexport { skip } from '../internal/operators/skip';\nexport { skipLast } from '../internal/operators/skipLast';\nexport { skipUntil } from '../internal/operators/skipUntil';\nexport { skipWhile } from '../internal/operators/skipWhile';\nexport { startWith } from '../internal/operators/startWith';\nexport { subscribeOn } from '../internal/operators/subscribeOn';\nexport { switchAll } from '../internal/operators/switchAll';\nexport { switchMap } from '../internal/operators/switchMap';\nexport { switchMapTo } from '../internal/operators/switchMapTo';\nexport { take } from '../internal/operators/take';\nexport { takeLast } from '../internal/operators/takeLast';\nexport { takeUntil } from '../internal/operators/takeUntil';\nexport { takeWhile } from '../internal/operators/takeWhile';\nexport { tap } from '../internal/operators/tap';\nexport { throttle } from '../internal/operators/throttle';\nexport { throttleTime } from '../internal/operators/throttleTime';\nexport { throwIfEmpty } from '../internal/operators/throwIfEmpty';\nexport { timeInterval } from '../internal/operators/timeInterval';\nexport { timeout } from '../internal/operators/timeout';\nexport { timeoutWith } from '../internal/operators/timeoutWith';\nexport { timestamp } from '../internal/operators/timestamp';\nexport { toArray } from '../internal/operators/toArray';\nexport { window } from '../internal/operators/window';\nexport { windowCount } from '../internal/operators/windowCount';\nexport { windowTime } from '../internal/operators/windowTime';\nexport { windowToggle } from '../internal/operators/windowToggle';\nexport { windowWhen } from '../internal/operators/windowWhen';\nexport { withLatestFrom } from '../internal/operators/withLatestFrom';\nexport { zip } from '../internal/operators/zip';\nexport { zipAll } from '../internal/operators/zipAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/isEmpty.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/isEmpty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/last.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/last';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/map.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/map';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/mapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/mapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/materialize.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/materialize';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/max.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/max';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/merge.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/merge';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/mergeAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/mergeAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/mergeMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/mergeMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/mergeMapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/mergeMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/mergeScan.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/mergeScan';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/min.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/min';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/multicast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/multicast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/observeOn.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/observeOn';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/onErrorResumeNext.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/onErrorResumeNext';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/pairwise.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/pairwise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/partition.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/partition';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/pluck.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/pluck';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/publish.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/publish';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/publishBehavior.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/publishBehavior';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/publishLast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/publishLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/publishReplay.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/publishReplay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/race.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/race';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/reduce.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/reduce';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/refCount.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/refCount';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/repeat.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/repeat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/repeatWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/repeatWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/retry.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/retry';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/retryWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/retryWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/sample.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/sample';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/sampleTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/sampleTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/scan.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/scan';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/sequenceEqual.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/sequenceEqual';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/share.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/share';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/shareReplay.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/shareReplay';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/single.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/single';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/skip.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/skip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/skipLast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/skipLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/skipUntil.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/skipUntil';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/skipWhile.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/skipWhile';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/startWith.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/startWith';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/subscribeOn.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/subscribeOn';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/switchAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/switchAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/switchMap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/switchMap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/switchMapTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/switchMapTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/take.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/take';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/takeLast.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/takeLast';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/takeUntil.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/takeUntil';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/takeWhile.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/takeWhile';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/tap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/tap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/throttle.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/throttle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/throttleTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/throttleTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/throwIfEmpty.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/throwIfEmpty';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/timeInterval.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/timeInterval';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/timeout.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/timeout';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/timeoutWith.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/timeoutWith';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/timestamp.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/timestamp';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/toArray.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/toArray';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/window.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/window';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/windowCount.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/windowCount';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/windowTime.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/windowTime';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/windowToggle.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/windowToggle';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/windowWhen.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/windowWhen';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/withLatestFrom.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/withLatestFrom';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/zip.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/zip';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/operators/zipAll.d.ts"
    ],
    "content": "export * from 'rxjs-compat/operators/zipAll';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/OuterSubscriber.d.ts"
    ],
    "content": "export * from 'rxjs-compat/OuterSubscriber';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/ReplaySubject.d.ts"
    ],
    "content": "export * from 'rxjs-compat/ReplaySubject';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Rx.d.ts"
    ],
    "content": "export * from 'rxjs-compat';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Scheduler.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Scheduler';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/scheduler/animationFrame.d.ts"
    ],
    "content": "export * from 'rxjs-compat/scheduler/animationFrame';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/scheduler/asap.d.ts"
    ],
    "content": "export * from 'rxjs-compat/scheduler/asap';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/scheduler/async.d.ts"
    ],
    "content": "export * from 'rxjs-compat/scheduler/async';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/scheduler/queue.d.ts"
    ],
    "content": "export * from 'rxjs-compat/scheduler/queue';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Subject.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Subject';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/SubjectSubscription.d.ts"
    ],
    "content": "export * from 'rxjs-compat/SubjectSubscription';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Subscriber.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Subscriber';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/Subscription.d.ts"
    ],
    "content": "export * from 'rxjs-compat/Subscription';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/symbol/iterator.d.ts"
    ],
    "content": "export * from 'rxjs-compat/symbol/iterator';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/symbol/observable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/symbol/observable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/symbol/rxSubscriber.d.ts"
    ],
    "content": "export * from 'rxjs-compat/symbol/rxSubscriber';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/testing/index.d.ts",
      "node_modules/rxjs/testing/index.d.ts"
    ],
    "content": "export { TestScheduler } from '../internal/testing/TestScheduler';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/applyMixins.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/applyMixins';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/ArgumentOutOfRangeError.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/ArgumentOutOfRangeError';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/EmptyError.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/EmptyError';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/errorObject.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/errorObject';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/hostReportError.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/hostReportError';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/identity.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/identity';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/Immediate.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/Immediate';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isArray.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isArray';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isArrayLike.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isArrayLike';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isDate.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isDate';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isFunction.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isFunction';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isIterable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isIterable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isNumeric.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isNumeric';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isObject.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isObject';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isPromise.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isPromise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/isScheduler.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/isScheduler';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/noop.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/noop';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/not.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/not';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/ObjectUnsubscribedError.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/ObjectUnsubscribedError';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/pipe.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/pipe';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/root.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/root';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/subscribeTo.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/subscribeTo';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/subscribeToArray.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/subscribeToArray';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/subscribeToIterable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/subscribeToIterable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/subscribeToObservable.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/subscribeToObservable';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/subscribeToPromise.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/subscribeToPromise';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/subscribeToResult.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/subscribeToResult';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/TimeoutError.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/TimeoutError';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/toSubscriber.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/toSubscriber';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/tryCatch.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/tryCatch';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/util/UnsubscriptionError.d.ts"
    ],
    "content": "export * from 'rxjs-compat/util/UnsubscriptionError';\n"
  },
  {
    "paths": [
      "node_modules/rxjs/webSocket/index.d.ts",
      "node_modules/rxjs/webSocket/index.d.ts"
    ],
    "content": "export { webSocket as webSocket } from '../internal/observable/dom/webSocket';\nexport { WebSocketSubject, WebSocketSubjectConfig } from '../internal/observable/dom/WebSocketSubject';\n"
  }
]